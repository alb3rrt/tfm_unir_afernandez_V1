Binary extended formulations and sequential convexification

Manuel Aprile

Michele Conforti June 2, 2021

Marco Di Summa

arXiv:2106.00354v1 [math.OC] 1 Jun 2021

Abstract
A binarization of a bounded variable x is a linear formulation with variables x and additional binary variables y1, . . . , yk, so that integrality of x is implied by the integrality of y1, . . . , yk.
A binary extended formulation of a polyhedron P is obtained by adding to the original description of P binarizations of some of its variables. In the context of mixed-integer programming, imposing integrality on 0/1 variables rather than on general integer variables has interesting convergence properties and has been studied both from the theoretical and from the practical point of view.
We propose a notion of natural binarizations and binary extended formulations, encompassing all the ones studied in the literature. We give a simple characterization of the vertices of such formulations, which allows us to study their behavior with respect to sequential convexification. In particular, given a binary extended formulation and one of its variables x, we study a parameter that measures the progress made towards ensuring the integrality of x via application of sequential convexification. We formulate this parameter, which we call rank, as the solution of a set covering problem and express it exactly for the classical binarizations from the literature.

1 Introduction

A technique that has been widely investigated in combinatorial optimization and integer programming is to formulate a given problem in a higher-dimensional space, comprising the original, natural variables along with a number of additional variables. This general idea is motivated by the fact that these formulations, called extended formulations, may be easier to deal with, as they may have a small number of inequalities or may exhibit a structure that is not evident in the original space. (See, e.g., [4] for a survey on extended formulations.)
One way to obtain an extended formulation of a mixed-integer program is to reformulate each bounded integer variable by means of a set of binary variables, which are then relaxed to lie in the interval [0, 1]. In this case, the formulation is called a binary extended formulation. The use of binary variables is motivated both by theoretical and computational reasons, as we will discuss below.
The idea of using binary reformulations dates back at least to Glover [12], who proposed methods to linearize nonlinear conditions by means of binary variables. In the context of mixed-integer linear programming, different binarization techniques have been explored in the literature. We now mention some of the most relevant methods. Below we assume that x is an integer variable whose range of possible values is {0, . . . , k}.

· Sherali and Adams [17] suggested to model x by using k binary variables y1, . . . , yk as follows:

x=

k i=1

i

·

yi

with

k i=1

yi



1.

This

is

sometimes

referred

to

as

the

full

binarization.

· Assuming for the sake of simplicity that k = 2t - 1 for some integer t  0, Owen and Mehrotra

[14] proposed a reformulation with t binary variables of the form x =

t i=1

2i-1yi.

This is called

the compact or logarithmic binarization.

· Roy [15] suggested to write x =

k i=1

yi

with

y1



···



yk.

Following [10], we call this the

unary binarization.

In all the above examples, the integrality requirement on x can be relaxed, as it is implied by the integrality of y. When variables y are only required to be in the interval [0, 1], one obtains a polytope

1

P in the variables x and y with the following property: the projection of the set {(x, y)  P : yi  {0, 1}i} is the range of possible values of x, i.e., {0, . . . , k}. Furthermore, the rule used to model x by means of binary variables is independent of the constraints on the original x variables. A polytope of this type is called a binarization polytope, or simply a binarization, and a binary extended formulation of a polyhedron P can be obtained by adding to the description of P a binarization for each integer variable of P . (We postpone the formal definitions to Section 2.2.) We also remark that in the above binarizations x is linked to the y variables by means of a linear equation. In this situation, we will call the binarization affine. However, binarizations in general may not satisfy this property, and indeed most of our results apply to non-affine binarizations, as well.
Modelling with binary variables allows the use of canonical disjunctions of the form "yi = 0 or yi = 1" (where yi is a binary variable), which induce faces of the formulation. This property implies that, assuming that there are, say, d binary variables and all other variables are continuous (as is the case for a binary extended formulation), the integer hull can be obtained in d steps by taking the convex hull of the faces induced by yi = 0 and yi = 1, and iterating over all binary variables. (This is Balas' sequential convexification technique [1], which we review in Section 2.1). In contrast, general split disjunctions in the original space (i.e., disjunction of the form "ax   or ax   + 1" for some integer vector a and some integer number b) do not necessarily yield the integer hull in a finite number of steps. (See, e.g., [5] for more details on split disjunctions.)
From the practical point of view, binary mixed-integer problems tend to be easier to solve, compared to problems with general integer variables. However, there is a trade-off with the increase of computational effort due to the addition of many variables, and indeed, there are contrasting results on this point. For instance, Owen and Mehrotra [14] showed that, restricting sequential convexification to the binary variables of a single logarithmic binarization, one needs to convexify all such variables in order to reduce the range of the original integer variable by half: this suggests that using this type of binarization out-of-the-box in a branch-and-bound framework might result in larger trees than those one would obtain in the original space. On the other hand, Roy [15] proved that if one uses the unary binarization and generates suitable cuts that can be expressed in terms of the original variables, then the resulting cutting planes are in general stronger than those that one would produce directly in the original space. Bonami and Margot [3] showed a result in the same spirit, where only canonical disjunctions are applied.
Roy [15] gave a definition of binarization for the affine case. A generalization of this notion, that we also adopt in this paper, was given by Dash, Gu¨nlu¨k and Hildebrand [10]. They studied the behavior of binarizations with respect to the split closure, and showed that a class of binarizations called unimodular is optimal in this sense. Moreover, they showed that using appropriate binarizations can lead to smaller branch-and-bound trees, in contrast to what is suggested by [14].
The unimodular binarizations from [10], although optimal with respect to the split closure, have a large number of variables (exactly k if the range of the original variable is {0, . . . , k}). Dash et al. [10] suggest that it would be interesting to investigate the strength of binarizations with fewer variables.
The work described above motivates the question: how can we evaluate binarizations and determine which ones are "better"? In this paper we approach the question from an original perspective, centered around the technique of sequential convexification. We remark that the performance of sequential convexification on a binary extended formulation depends heavily on the polytope of interest, hence different choices of binarizations might be preferable for different polytopes: in spite of that, we offer a notion of rank that depends on a single binarization (and not on the original polytope) and models its behaviour with respect to sequential convexification.
Our contributions can be summarized as follows:
· In Section 2 we observe that the smallest number of disjunctions that remove a given set of fractional vertices is the solution of a set covering problem. We will build on this observation throughout the paper.
· In Section 3 we characterize the vertices of a binary extended formulation and their projections on the original space, provided the binarizations satisfy a "natural" assumption. This applies, in particular, to the three fundamental binarizations mentioned above.
2

· In Section 4 we define a notion of rank of a binarization that is related to the lift-and-project rank of a polytope (defined in Section 2.1). Informally, our rank models the problem of removing a set of fractional vertices of a binary extended binarization by performing the smallest number of disjunctions on the 0/1 variables of a fixed single binarization. We show that, under the aforementioned natural assumptions, our rank is the solution of a set covering problem that depends on the binarization only, and not on the rest of the binary extended formulation.
· In Section 4 we also provide explicit formulas for the rank of the three binarizations mentioned above, and we especially focus on the logarithmic binarization, which has the smallest possible number of variables: we show that it has minimum rank among all binarizations with the same "structure" (in particular, with the same number of variables).
We believe that our notion of rank leads to an educated guess on which binarizations yield better computational results, as it measures "partial progress" towards obtaining the mixed integer hull of the polytope of interest. This is motivated further in Section 5, where we review our results and propose further directions of research.
2 Sequential convexification and binarizations
2.1 Vertex interpretation of sequential convexification
We recall a fundamental result of Balas [1] on sequential convexification of a polytope contained in the unit cube, and give an elementary proof that will be useful throughout the paper.
Given a polytope Q, we denote with V (Q) the set of its vertices. If Q  [0, 1]h × Rn-h and we fix any variable xi with i  [h] (where we use the notation [h] := {1, . . . , h}), we define
Qxi := conv ({x  Q : xi = 0}  {x  Q : xi = 1}) .
We now give a "vertex" proof of the sequential convexification theorem of Balas [1].
Theorem 2.1 (Sequential convexification theorem of Balas). For every polytope Q  [0, 1]h × Rn-h, we have
conv{x  Q : xi  {0, 1} i  [h]} = (((Qx1 )x2 ) . . . )xh.
Proof. Since x1 = 0 defines a face of Q, say F0, we have V (F0) = {x  V (Q) : x1 = 0}. Therefore, if we let V1 be the set of vertices of Q with 0 < x1 < 1, then V (Qx1) = V (Q)\V1 = {x  V (Q) : x1  {0, 1}}. By iterating this argument, we obtain V ((((Qx1 )x2) . . . )xh ) = {x  V (Q) : xi  {0, 1} i  [h]}, and this proves the result.
While above theorem is stated for polytopes, it holds for a (possibly unbounded) polyhedron Q  [0, 1]h × Rn-h. Indeed, by intersecting Q with the orthogonal complement of its lineality space (so the resulting polyhedron contains vertices whenever Q is nonempty), and observing that the recession cone of Q is contained in {0}h × Rn-k, the above proof can be carried out in the same way. We also remark that Theorem 2.1 implies that the actual order of the sequence of convexifications is irrelevant.
Note that while Balas extended formulation for the convex hull of the union of polytopes provides an inequality description of Qx1 (and of (((Qx1)x2) . . . )xh) in an extended space (see [5, Section 4.9]), the inequality description of Qx1 in the original space may be very complicated with respect to the original description of the polytopes [8]. However, the above proof is based on the fact that a vertex description of conv{x  Q : xi  {0, 1} i  [h]} can be derived immediately from V (Q).
Let Q  [0, 1]h × Rn-h be a polytope. The lift-and-project rank lpr(Q) (with respect to variables x1, . . . , xh) is the minimum integer k such that there are variables xi1, . . . , xik , with i1, . . . , ik  [h], satisfying ((Qxi1 ) . . . )xik = conv{x  Q : xi  {0, 1} i  [h]}. (See, e.g., [5, Section 5.4])
Theorem 2.1 shows that lpr(Q)  h. Furthermore, one can derive a combinatorial interpretation of the lift-and-project rank as the solution of a minimum hitting set (or set covering) problem. Indeed, let
3

VF be the set of vertices in V (Q) containing at least one fractional component among x1, . . . , xh, and let F  2[h] be the family that contains, for each vertex in VF , the subset of indices of the fractional components of that vertex (where only components x1, . . . , xh are considered). Then lpr(Q) is exactly the minimum size of a hitting set of F, i.e., a minimum subset of [h] that intersects all the sets in F. Thus, if AQ denotes the |VF | × h 0/1-matrix whose rows are the incidence vectors of the members of F, we have the following. (We use 1 to denote the all-one vector of appropriate dimension.)
Observation 2.2. Let Q  [0, 1]h × Rn-h be a polytope. Then
lpr(Q) = min{1z : AQz  1, z  {0, 1}h}.
As it is customary, we refer to the integer program above as a set covering problem. Sequential convexification can be applied, in principle, also when x1, . . . , xh are not bounded between 0 and 1. Indeed, one can consider a canonical disjunction of the form "xi   or xi   + 1" for some   Z and update Q with conv({x  Q : xi  }  {x  Q : xi   + 1}). However, iterating this procedure does not always lead to conv{x  Q : xi  Z i  [h]}. For instance, if Q  R2 is defined as the convex hull of {(0, 0), (1.5, 1), (2, 2), (1, 1.5)}, one can see ([2, Theorem 2.4]) that the integer hull of Q cannot be obtained by applying a finite sequence of canonical split disjunctions.

2.2 Binarizations
Given a set S  {(x, y) : (x, y)  Rp × Rd}, we denote by x(S) the orthogonal projection of S on the x-space, i.e., x(S) = {x  Rp : (x, y)  S for some y  Rd}; y(S) is defined similarly.
A polytope B  {(x, y) : (x, y)  R × [0, 1]d} is a binarization of variable x in the range {0, . . . , k} (for some positive integer k) if

x({(x, y)  B : y  {0, 1}d}) = {0, . . . , k}.

(1)

This implies that d  log(k + 1). The following was observed in [10].

Observation 2.3. Let B  R × [0, 1]d be a binarization of variable x in the range {0, . . . , k}. Given y  {0, 1}d, there is at most one x such that (x, y)  B. If such x exists, then x  {0, . . . , k} and
(x, y)  V (B).

Proof. The first statement and the fact that x  {0, . . . , k} follow from (1), because if B contains (x1, y) and (x2, y) with x1 = x2, then B contains (x, y) with x  Z. To show the last statement,
assume that a point (x, y)  B with y  {0, 1}d is not a vertex of B. Then (x, y) is in the relative interior of a segment with endpoints (x1, y1) and (x2, y2) in B. Since y  {0, 1}d, y1 = y2 = y. Again, the above argument shows that this is possible only if x1 = x2 = x.

Given a polytope P  [0, k]p × Rn-p, with variables x1, . . . , xn, for every i  [p] let Bi  {(xi, yi) : (xi, yi)  R × [0, 1]d} be a binarization of xi. We denote the components of yi by yi1, . . . , yid. The
binary extended formulation Q of P with binarizations B1, . . . , Bp is

Q := {(x, y)  Rn × [0, 1]pd : x  P, (xi, yi)  Bi i  [p]}.

Notice that Q is an extended formulation of P , i.e., x(Q) = P . Since xi({(xi, yi)  Bi : yi  {0, 1}d}) = {0, . . . , k} for i  [p], we have that

{x  P : xi  {0, . . . , k} i  [p]} = x {(x, y)  Q : yi  {0, 1}d i  [p]} .

Thus the mixed-integer set in the x-space on the left-hand side is lifted to a mixed 0/1-set in an extended space.
The above observation, together with Theorem 2.1, implies that by applying sequential convexification to the y variables of Q one obtains the mixed integer hull of P (with respect to variables x1, . . . , xp). In particular, we have the following persistency property:

4

Observation 2.4. Given a polytope P  [0, k]p × Rn-p and a binary extended formulation Q of P with binarizations Bi  {(xi, yi) : (xi, yi)  R × [0, 1]d} for i  [p], consider a variable y¯i¯. If no point in V (Q) (equivalently, in x(V (Q))) satisfies  < x~i <  + 1 for some ~i  [p] and   Z, then no point in V (Qy¯i¯) (equivalently, in x(V (Qy¯i¯))) satisfies  < x~i <  + 1.
Proof. Since Qy¯i¯ is the convex hull of two faces of Q, we have that V (Qy¯i¯)  V (Q). It follows that x(V (Qy¯i¯))  x(V (Q)), and this proves the observation.
Indeed, the above holds for any hereditary property P, where "hereditary" means: "If S  V (Q) satisfies P and S  S, then S satisfies P". We stress that the convergence to the mixed integer hull of P implied by Observation 2.4 is not always possible in the original space, as the example at the end of Section 2.1 shows.
We remark that, since different variables xi can have different ranges and different binarizations, one can consider binary extended formulations where each binarization Bi has a different dimension di. For simplicity of notation, we stick to the case where di = d for each i  [p]. However, all our results, with straightforward modifications, hold in the general setting, as well.

2.3 Properties of binarizations

In this section we define several properties that a binarization can have, and some specific types of binarizations that have been used in the literature and are investigated further in this paper. Some of the properties below have been defined in [10].
In the following we assume that B  {(x, y) : (x, y)  R × [0, 1]d} is a binarization of x in the range {0, . . . , k}.
Definition 2.5. A binarization B is natural if x is integer for any vertex (x, y) of B.
In other words, a binarization B is natural if and only if x(V (B)) = {0, . . . , k}. Definition 2.6. A binarization B is integral if B = conv(B  (Z × {0, 1}d)).
It follows from the definition of binarization that the above condition is equivalent to B = conv(B (R × {0, 1}d)).
Definition 2.7. A binarization B is exact if for every x  {0, . . . , k} there exists exactly one y  {0, 1}d such that (x, y) in B.
Observation 2.8. Let B be an exact binarization. Then B is natural if and only if B is integral.
Proof. If B is integral, then B is obviously natural. For the converse, let (x, y) be a vertex of B, where B is exact and natural. As B is natural, x  Z. Since B is exact, y is unique and therefore y  {0, 1}d.

If B is a binarization which is exact and natural (or equivalently exact and integral), we say that B is perfect. Notice that if B is integral, then B is natural but may not be exact.

Definition 2.9. A binarization B is affine if x = f (y) for all (x, y)  B, where f : Rd  R is an affine function.

We recall some well-known binarizations that we have already mentioned in the introduction:

BU (d) = {(x, y)  R × [0, 1]d : x =

d i=1

yi,

1



y1



·

·

·



yd



0};

BF (d) = {(x, y)  R × [0, 1]d : x =

d i=1

i

·

yi,

d i=1

yi



1};

BL(d) = {(x, y)  R × [0, 1]d : x =

d i=1

2i-1yi

}.

BU (d) is known as the unary binarization; BF (d) is the full binarization; BL(d) is the logarithmic (or compact) binarization. Notice that in BU (d) and BF (d) the number of y variables d is also the upper bound of the range of the x variable (i.e., x  {0, . . . , d}), whereas in BL(d) the range of x is {0, . . . , 2d - 1}. Hence BL(d) uses a logarithmic number of variables with respect to the length of the

range of x and, as defined here, requires x to be a power of 2. The general case of an arbitrary range of x, also studied in [10], is treated in Section 4.4. We remark that BU (d), BF (d) and BL(d) are all

perfect binarizations (hence natural, integral and exact) and are all affine.

5

3 The vertices of a binary extended formulation
Let Q be a binary extended formulation of a polytope P  [0, k]p × Rn-p. We now describe the vertices of Q and their projections on the original space, provided that the associated binarizations are natural.
Given I  [p] and   {0, . . . , k}I , we define the subspace GI, := {x  Rn : xi = i i  I}.
Theorem 3.1. Let P  [0, k]p × Rn-p be a polytope and let Q  Rn × [0, 1]pd be a binary extended formulation of P with binarizations Bi  R × [0, 1]d for i  [p] that are natural. Then (x¯, y¯)  Rn × [0, 1]pd is a vertex of Q if and only if there exist a subspace GI, and a face F of P of dimension |I| such that:
i) F  GI, = {x¯};
ii) (x¯i, y¯i)  V (Bi) i  I;
iii) (x¯i, y¯i)  V (Bi  {xi = x¯i}) i  [p] \ I.
Proof. We work with the linear inequality description of Q given by some fixed linear inequality descriptions of P and Bi, for i  [p].
We first prove the "only if part". Given (x¯, y¯)  V (Q), define I~ = {i  [p] : x¯i  {0, . . . , k}}, and let F be the face of P of minimum dimension containing x¯. We will show that (x¯, y¯) satisfies i)­iii) by using F and GI, for an appropriate subset I of I~.
Let q be the dimension of F , and consider a basis B of Q defining (x¯, y¯) that contains n - q tight inequalities from the system defining P . Such a basis exists because we chose F of minimum dimension.
Notice that B contains at least d tight inequalities from the system defining each Bi for i  [p], as otherwise some variable yij of Bi would not be "fixed" by B. Furthermore, we claim that (x¯i, y¯i)  V (Bi  {xi = x¯i}) for each i  [p]: Indeed, consider a convex combination of points (x¯i, yi(1)), . . . , (x¯i, yi(t))  V (Bi  {xi = x¯i}) which is equal to (x¯i, y¯i). Then one can obtain (x¯, y¯) as a convex combination of points (x¯, y¯(1)), . . . , (x¯, y¯(t)) where each y¯(j) is equal to y(j) in coordinates yi, and to y¯ in all other coordinates. Hence, the fact that (x¯, y¯)  V (Q) proves our claim.
Moreover, for i / I~, B contains exactly d tight inequalities from the system defining Bi: indeed, it cannot contain d + 1 tight inequalities as, x¯i being fractional and Bi being natural, (x¯i, y¯i) cannot be a vertex of Bi. But then, since |B| = n + pd, there is a subset I  I~ of size q such that, for i  I, B contains d + 1 tight inequalities from the system defining Bi, i.e., (x¯i, y¯i)  V (Bi). This also implies that for every i  I the equation xi = x¯i is linearly independent from the equations defining F . Hence F  GI, = {x¯}, where i = x¯i for i  I. This proves that (x¯, y¯) satisfies i)­iii).
We now prove the "if" part. Let (x¯, y¯) satisfy i)­iii) for some F, I, . Notice that (x¯, y¯)  Q, and it satisfies at equality the following set B of inequalities from the system defining Q: n - |I| linearly independent inequalities defining F ; d + 1 linearly independent inequalities from each Bi with i  I; d linearly independent inequalities from each Bi with i  [p] \ I. In order to conclude that (x¯, y¯)  V (Q), it suffices to show that all these tight inequalities are linearly independent (implying that B is a basis). Now, since the Bi's have disjoint sets of variables, if B is not a basis then there is an equation among those defining F that is linearly dependent with some others. However notice that, since F  GI, = {x¯}, the system of equations defining F is equivalent to the system xi = x¯i for i  [p] \ I. Hence, if B is not a basis, there is i  [p] \ I such that the equation xi = x¯i is linearly dependent with the equations of B picked from Bi. But this contradicts the fact that (x¯i, y¯i)  V (Bi  {xi = x¯i}).
Theorem 3.2. Let P  [0, k]p × Rn-p be a polytope and let Q be a binary extended formulation of P with binarizations Bi  R × [0, 1]d for i  [p] that are natural. Then x¯  Rn is a point in x(V (Q)) if and only if there exist a subspace GI, and a face F of P of dimension |I| such that F  GI, = {x¯}.
6

Proof. The "only if"part follows from Theorem 3.1. Assume now F  GI, = {x¯}. For i  I, since x¯i  {0, . . . , k}, by Observation 2.3 there exists
y¯i  {0, 1}d such that (x¯i, y¯i)  V (Bi). For i  [p] \ I, x¯i can be obviously extended to a point in V (Bi  {xi = x¯i}). Therefore the "if" part also follows from Theorem 3.1.
Here are some consequences of the above theorems.
· The proof of the "if" parts in Theorems 3.1 and 3.2 does not use the fact that the binarizations are natural, hence these implications hold for any binary extended formulation. However, the assumption that the binarizations are natural is needed for the "only if" parts, as Remark 3.3 in Section 3.1 shows.
· Given a polytope P and a binary extended formulation Q of P as in Theorem 3.1, the set V (Q) (and its cardinality) is a function of the associated binarizations B1, . . . , Bp. However Theorem 3.2 implies that the projection of V (Q) on the x-space is independent of the binarizations, as long as they are natural.
· In particular, Theorem 3.2 implies that x(V (Q)) always contains V (P ) because given x¯  V (P ), one can choose I =  and F = {x¯}. Moreover, when p = n, x(V (Q)) also contains {x  P : xi  {0, . . . , k} i  [n]}. This is because given x¯  {x  P : xi  {0, . . . , k} one can choose F = P , I  [n] such that |I| = dim(P ) and P  GI, contains a single point (there must be such a subset I), and i = x¯i for all i  I.

3.1 An example

As a canonical disjunction on a binary variable is a split disjunction, the split rank of a polytope is less than or equal to the lift-and-project rank (we refer, e.g., to [5] for precise definitions).
While the split rank of a rational polyhedron is always finite when all variables are required to be integer, Cook, Kannan and Schrijver [9] provided a simple example showing that this is not always the case in the mixed-integer setting. Indeed, the split rank of the polyhedron

P = {(x1, x2, x3)  [0, 2]2 × R : hx1 + hx2 + x3  2h, x3  2hx1, x3  2hx2, x3  0}, (2)

where h > 0, is infinite if only x1 and x2 are required to be integer. It is also known that the split rank

of P is (log h) when all the variables are restricted to be integer [7]. Here we use the above example

to illustrate Theorems 3.1 and 3.2 on a binary extended formulation that uses natural binarizations,

and to demonstrate the convergence of sequential convexification.

We have V (P ) =

(0,

0,

0),

(2,

0,

0),

(0,

2,

0),

(

1 2

,

1 2

,

h)

.

We let p = d = 2 and apply the unary

binarization BU (2), which is natural: For i = 1, 2, let Bi = {(xi, yi1, yi2)  R × [0, 1]2 : xi =

yi1 + yi2, yi1  yi2}. Denoting by Q the corresponding binary extended formulation and applying

Theorem 3.2, we find that x(V (Q)) consists of the points that are the unique elements in sets of the form F  GI,, where F is a d-face of P , |I| = d, and   {0, 1, 2}I for some d  {0, 1, 2}. In

particular:

· for d = 0, we obtain the four vertices of P ;

· for d = 1, we obtain again the three integer vertices of P , along with the points (1, 0, 0), (0, 1, 0),

(1,

1, 0),

(1,

1 3

,

2 3

h),

(

1 3

,

1,

2 3

h);

· for d = 2, we obtain again the six integer points of P .

Thus we have

x(V (Q)) =

(0, 0, 0), (2, 0, 0), (0, 2, 0),

1 2

,

1 2

,

h

, (1, 0, 0), (0, 1, 0), (1, 1, 0),

1,

1 3

,

2 3

h

,

1 3

,

1,

2 3

h

.

See Figure 1.

7

(0, 2, 0)

(0, 1, 0)

(

1 3

,

1,

2h 3

)

(1, 1, 0)

(

1 2

,

1 2

,

h)

(1,

1 3

,

2h 3

)

(0, 0, 0)

(1, 0, 0)

(2, 0, 0)

Figure 1: A view of P from above: the points in x(V (Q)) are given by the vertices of P , and by the intersections of edges of P with the integer grid (represented by dashed lines).

V (Q) consists of the following points:
x1 x2 x3 y11 y12 y21 y22 v1 0 0 0 0 0 0 0 v2 2 0 0 1 1 0 0 v3 0 2 0 0 0 1 1 v4 1/2 1/2 h 1/2 0 1/2 0 v5 1/2 1/2 h 1/2 0 1/4 1/4 v6 1/2 1/2 h 1/4 1/4 1/2 0 v7 1/2 1/2 h 1/4 1/4 1/4 1/4 v8 1 0 0 1 0 0 0 v9 0 1 0 0 0 1 0 v10 1 1 0 1 0 1 0 v11 1 1 0 1/2 1/2 1 0 v12 1 1 0 1 0 1/2 1/2 v13 1 1/3 2h/3 1 0 1/3 0 v14 1 1/3 2h/3 1 0 1/6 1/6 v15 1/3 1 2h/3 1/3 0 1 0 v16 1/3 1 2h/3 1/6 1/6 1 0
If we use Observation 2.2, the set covering problem associated with the points in V (Q) that have some fractional yij variable is defined by the following matrix AQ:
y11 y12 y21 y22 v4 1 0 1 0 v5 1 0 1 1 v6 1 1 1 0 v7 1 1 1 1 v11 1 1 0 0 v12 0 0 1 1 v13 0 0 1 0 v14 0 0 1 1 v15 1 0 0 0 v16 1 1 0 0
Since the vector z = (1, 0, 1, 0) is an optimal solution to this set covering instance, we have lpr(Q) = 2. This implies that the polyhedron obtained after convexifying Q with respect to variables y11 and y21 projects down to conv{x  P : x1, x2  Z}.

8

Remark 3.3. We show that the assumption that the binarizations are natural made in Theorems

3.1 and 3.2 cannot be dropped. Let P be the polyhedron defined in (2), and let Bi = {(xi, yi1, yi2) 

R × [0, 1]2 : xi = yi1 + yi2, yi1  2yi2} for i = 1, 2. It is easy to check that these binarizations are

not natural. Denoting by Q the corresponding binary extended formulation, we have that x(V (Q))

contains,

for

instance,

the

points

(0,

3 2

,

0)

and

(

3 2

,

0,

0),

which

are

not

intersections

of

F

and

GI ,

for

any F , GI, as in Theorems 3.1 and 3.2.

4 The rank of a natural binarization

In this section we investigate the problem of eliminating certain types of fractional vertices of our binary extended formulation through sequential convexification of the y-variables of a single binarization B. This restriction will allow us to define a notion of rank that depends on B only, provided that B is natural.
Given a polytope Q  Rn, i  [n] and 1, . . . ,   Z, we say that Q satisfies property Pi 1,..., if every vertex x¯ of Q satisfies j  x¯i or x¯i  j + 1 for all j  []. When  = 1, we call the above property Pi . Below, we consider property Pi 1,..., of a binary extended formulation Q as defined in Section 2.2; we stress that, although the variables of Q are denoted by both x and y, the index i of the property is always relative to xi.
Definition 4.1. Given a polytope P  [0, k]p × Rn-p and a binary extended formulation Q of P , the rank of Pi 1,..., (where i  [p]) is the smallest integer t such that there are variables yij1, . . . yijt for which Pi 1,..., is satisfied by ((Qyij1 ) . . . )yijt = conv{(x, y)  Q : yij1, . . . , yijt  {0, 1}}). The rank of Pi 1,..., is taken to be 0 whenever Q itself satisfies the property.
Notice that, given a binary extended formulation Q of a polytope P , if ((Qyij1 ) . . . )yijt satisfies property Pi 1,...,, then x(((Qyij1 ) . . . )yijt ) satisfies the property. Furthermore, by Observation 2.4 the property remains satisfied as long as disjunctions on the 0/1 variables are used.

Observation 4.2. Given a polytope P  [0, k]p × Rn-p and a binary extended formulation Q of P , the rank of Pi 1,..., is the optimal value of the set covering instance min{1z : Az  1, z  {0, 1}d}, where the rows of A are the incidence vectors of the fractional components of y¯i for all (x¯, y¯)  V (Q) that violate Pi 1,..., .
Since Bi is a binarization, if (x¯, y¯)  V (Q) satisfies j < x¯i < j + 1 for some j  [], then y¯i  {0, 1}d. Therefore the above set covering instance is always feasible, as A has no all-zero row.
Hence the rank is well-defined.

Given a binary extended provided the binarization Bi

formulation Q of P  [0, k]p × Rn-p, we is natural. The main finding is that the

now study the rank of rank of Pi 1,..., is the

Pi 1,..., lift-and-

project rank of some polytope contained in Bi (Theorem 4.6).

In the following we write B(f ) to indicate {(x, y)  B : x = f } for any binarization B and any

(fractional) number f .

Lemma 4.3. Let B be a natural binarization,   {0, . . . , k - 1},  < f <  + 1. Then V (B(f ))
consists of one point (x~, y~) in the relative interior of each 1-dimensional face of B whose vertices (xu, yu) and (xv, yv) satisfy xu  , xv   + 1.

Proof. Since B is a natural binarization, we have x(V (B)) = {0, . . . , k}. Hence {(x, y)  V (B) : x = f } = . This shows that V (B(f )) consists of one point (x~, y~) in the relative interior of each
1-dimensional face of B that is intersected by the hyperplane defined by x = f . That is, whose vertices are (xu, yu) and (xv, yv) with xu   and xv   + 1.

Since, for a natural binarization B and a fractional number f , one has {(x, y)  B(f ) : y  {0, 1}d} = , the lift-and-project rank lpr(B(f )) with respect to variables y1, . . . , yd, as defined in Section 2.1, is the minimum number of y-variables whose convexification produces an empty polytope.

9

Observation 4.4. Let B be a binarization, let S be a set of 1-dimensional faces of B, and let V , V   B, each consisting of at least one point in the relative interior of each face of S. Then lpr(conv(V )) = lpr(conv(V )).
Proof. The set covering problems associated with lpr(conv(V )) and lpr(conv(V )), as defined in Observation 2.2, are the same up to duplication of identical rows of the constraint matrix.
Lemma 4.5. Given a natural binarization B, 1, . . . ,   Z, and j < fj < j + 1 for j  [], let S := j[] V (B(fj)). Then the minimum set of 1-dimensional faces of B whose relative interiors cover S coincides with the minimum set of 1-dimensional faces of B whose relative interiors cover V (conv(S)).
Proof. Note first that by Lemma 4.3, S is covered by the relative interiors of 1-dimensional faces of B, so the statement of the lemma is meaningful. Now the lemma is implied by the following observation:
Let S be a subset of points in the relative interiors of some 1-dimensional faces of a polytope P . Then conv(S) has at least one vertex (possibly two) in each 1-dimensional face of P that contains a point in S.
Theorem 4.6. Let P  [0, k]p × Rn-p be a polytope and let Q  Rn × [0, 1]pd be a binary extended formulation of P with binarizations Bi  R × [0, 1]d for i  [p] that are natural. Given 1, . . . ,   Z and i  [p], assume that for every j  [] there is a point (x¯j, y¯j)  V (Q) with j < x¯ji < j + 1. Then the rank of Pi 1,..., equals lpr(conv( j[] Bi(x¯ji ))).
Proof. Let V  := V (conv( j[] Bi(x¯ji ))). Clearly V   j[] V (Bi(x¯ji )). On the other hand, thanks to Lemma 4.5, for any j  [] and (xi, yi)  V (Bi(x¯ji )), there is a point (xi, yi)  V  such that, for h  [d], yih is fractional if and only if yih is.
Let A1 be the constraint matrix of the set covering problem relative to Pi 1,...,, as defined in Observation 4.2. Further, let A2 be the constraint matrix of the set covering problem relative to lpr(V ) (with respect to variables yi1, . . . , yid), as defined in Observation 2.2. We will show that A1 and A2 have the same set of rows (i.e., they are the same matrix up to repeating identical rows), concluding the proof.
First, let a  {0, 1}d be a row of A1. Then there is a vertex (x~, y~)  V (Q) that violates Pi 1,...,, such that the fractional coordinates of y~i correspond to the 1-entries of a. Let j  [] satisfy j < x~i < j + 1. Thanks to Theorem 3.1 (x~i, y~i) is a vertex of Bi(x~i), in particular it lies in the relative interior of a 1-dimensional face of Bi. But then there is a vertex of Bi(x¯ji ) (hence, there is a vertex of V ) that lies in the same 1-dimensional face, implying that a is also a row of A2.
On the other hand, let a  {0, 1}d be a row of A2. Then there are j  [] and a vertex (x¯ji , y^i) of Bi(x¯ji ) such that the fractional coordinates of y^i correspond to the ones of a. One can check, using Theorem 3.1 and the point (x¯j, y¯j)  V (Q) given by the hypotheses, that there is a vertex (x¯j, y~)  V (Q) such that y~i = y^i. This shows that a is a row of A1 as well.
We remark that, under the assumptions of the above theorem, the rank of Pi 1,..., only depends on Bi and 1, . . . , , and not on P or on the other binarizations of Q. We now give another description of the rank of Pi 1,..., that will be useful in the following.
Recall that the skeleton sk(P ) of a polytope P is the simple graph whose vertices are the vertices of P , where two vertices are adjacent in sk(P ) if and only if they are adjacent in P . Given the skeleton sk(B) of a natural binarization B  [0, k] × [0, 1]d and   {0, . . . , k - 1}, we say that edge ((xu, yu), (xv, yv)) is an -edge if xu   and xv   + 1, or viceversa. The indicator vector of edge ((xu, yu), (xv, yv)) is the vector t  {0, 1}d where tk = 0 if yku and ykv are either both 0 or both 1.
Definition 4.7. Given a natural binarization B  [0, k] × [0, 1]d, 1, . . . ,   {0, . . . , k - 1}, and x¯j such j < x¯j < j + 1 for j  [], we define the rank of B with respect to 1, . . . ,  as follows:
rkB(1, . . . , ) := lpr(conv( j[] B(x¯j))).
10

Observation 4.8. Given a natural binarization B  [0, k] × [0, 1]d and 1, . . . ,   {0, . . . , k - 1}, rkB(1, . . . , ) is the rank of Pi 1,..., with respect to any binary extended formulation satisfying the hypotheses of Theorem 4.6 whose associated i-th binarization is B.
Furthermore rkB(1, . . . , ) is the optimum value of the set covering problem in which the rows of the constraint matrix are the indicator vectors of the j-edges, j  [], of sk(B).
In the next subsections we will investigate the parameter rkB for different natural binarizations introduced in the literature.
We recall a result of Dash, Gu¨nluk and Hildebrand [10] that highlights the importance of property P with respect to general splits involving variables of a single binarization.
Theorem 4.9. (Proposition 6 in [10]) Given a binary extended formulation Q of a polytope P  [0, k]p × Rn-p with binarizations B1, . . . , Bp  R × [0, 1]d (not necessarily natural), let   Zd, 0  Z and i  [p]. Let Q0 := {(x, y)  Q : yi  0}, Q1 := {(x, y)  Q : yi  0 + 1}. Then there exists   {0, . . . , k - 1} such that
conv({(x, y)  Q : xi  })  {(x, y)  Q : xi   + 1})  conv(Q0  Q1).
(The original statement given in [10] is weaker. However their argument proves the above theorem.) This theorem indicates that split disjunctions in the extended space that involve y-variables of a single binarization are weaker than (canonical) split disjunctions in the x-space. On the other hand, the authors of [10] argue that a split disjunction that involves y-variables belonging to distinct binarizations may be more powerful than any split disjunction in the x-space.
4.1 The rank of the unary and full binarizations
We now examine rkB(1, . . . , ) for the unary and the full binarizations, as defined at the end of Section 2.3.
Binarizations BU (d) and BF (d) are d-dimensional polytopes with d + 1 vertices. Therefore they are simplices and the skeleton of these binarizations is a complete graph on d + 1 vertices.
Observation 4.10. The vertices of BU (d) are (i, y(i)) for i = 0, . . . , d, where y(i)  {0, 1}d has the first i components equal to 1 and the others to 0. The indicator vector t of edge ((i, y(i)), (j, y(j))), where i < j, has tk = 1 for i + 1  k  j and tk = 0 otherwise. Thus any matrix whose rows are indicator vectors of edges of the skeleton of BU (d) has the consecutive ones property and is therefore totally unimodular.
Lemma 4.11. Given pairwise distinct 1, . . . ,   {0, . . . , d - 1}, we have that
rkBU (d)(1, . . . , ) = .
Proof. By Observations 4.8 and 4.10, the vector z  {0, 1}d defined by z1+1 = · · · = z+1 = 1 and zk = 0 otherwise is an optimal solution to the set covering problem associated with rkBU (d)(1, . . . , ).

We now turn our attention to the full binarization. For i  [d], we denote by ei the canonical vector with the i-th component equal to one.

Observation 4.12. The vertices of BF (d) are (0, 0) and (i, ei) for all i  [d]. The indicator vector of edge ((0, 0), (i, ei)) is ei. The indicator vector of edge ((i, ei), (j, ej )), where i = j, is ei + ej.
Lemma 4.13. Given 1, . . . ,   {0, . . . , d - 1}, we have that

rkBF

(d) (1 ,

.

.

.

,

)

=

d

-

min
j[]

j .

Proof. Given   {0, . . . , d - 1}, the -edges are ((0, 0), (, e )) and ((, e), (, e )) where    and    + 1. Hence, by Observation 4.8, the optimal solution to the set covering problem associated with rkBF (d)(1, . . . , ) is the vector z defined by zk = 1 for k  minj[] j + 1, zk = 0 otherwise.

Note that Lemmas 4.11 and 4.13 show that rkBF (d)(1, . . . , )  rkBU (d)(1, . . . , ) for any choice of pairwise distinct 1, . . . ,   {0, . . . , d - 1}. Therefore the unary binarization is preferable,
according to this criterion.

11

4.2 Affine binarizations
The constraints of the set covering problem related to the rank of a natural binarization B, as defined in Observation 4.8, are associated with the edges of the skeleton of B. We remark that the skeleton of B is in general different from the skeleton of its projection y(B).
Observation 4.14. Let B be a binarization with variables (x, y)  [0, k] × [0, 1]d.
1. If |V (y(B))| = |V (B)| then y is a bijection between V (B) and V (y(B)).
2. If |V (y(B))| = |V (B)| and V  is the set of vertices of a face of y(B), then the preimage of V  under y is the set of vertices of a face of B.
3. If B is integral, then |V (B)| = |V (y(B))|.
4. If B is affine, then B and y(B) are isomorphic.
Proof. 1. trivially holds. Let F = conv(V ) be a face of y(B), where V   V (y(B)), and let ay   be an inequality that
is valid for y(B) and exposes F . Then ay   is valid for B and exposes precisely the preimage of F = conv(V ), which is therefore a face of B. By 1., the preimage of V  is a subset of V (B), and this proves 2.
If (x, y) is a vertex of B and B is an integral binarization, then y  {0, 1}d. Therefore y is also a vertex of y(B), as this set is contained in [0, 1]d. This proves 3.
If B is an affine binarization, there is an equation of the form x = ay +  satisfied by all points in B. This immediately implies 4.
Corollary 4.15. If B is an integral binarization, then sk(y(B)) is a subgraph of sk(B) on the same vertex set. If B is an affine binarization, then sk(B) and sk(y(B)) are isomorphic.
We say that a binarization B  R × [0, 1]d is a d-hypercube binarization, or simply a hypercube binarization, if y(V (B)) = {0, 1}d and x(V (B)) = {0, . . . , 2d - 1}, i.e., if the vertices of B are in one-to-one correspondence with the vertices of the d-hypercube, and each has a different x-component. We will use the fact that a hypercube binarization is perfect (hence natural, exact and integral, see Observation 2.8).
The logarithmic binarization BL(d) is a d-hypercube binarization with vertices (x, y), where x  {0, . . . , 2d - 1} and y = (x)2 is the reverse of the vector in {0, 1}d expressing x in base 2.
In the following, we will write BL instead of BL(d) when the dimension d is clear from the context.
Lemma 4.16. Up to permuting and complementing variables, the logarithmic binarization is the only hypercube binarization that is affine.
Proof. Let B be an affine hypercube binarization. Then there exist a  Rd and   R such that x = ay +  for every (x, y)  B. We first show that we may assume that  = 0. Indeed, consider the vertex (0, y0) of B. By complementing the variables such that yi0 = 1, we obtain y0 = 0, hence  = 0.
Since B is affine, by Observation 4.14, sk(B) is the d-hypercube. Vertices (ai, ei) show that a1, . . . , ad  1. Using x(V (B)) = {0, . . . , 2d - 1}, we now verify that {a1, . . . , ad} = {20, . . . , 2d-1}.
Let yi be such that (i, yi)  B. Notice that, for any j such that yji = 1, we have 0  a(yi - ej) = i - aj  i - 1. Now, we show that y2h  {e1, . . . , ed} for h = 0, . . . , d - 1 by induction on h. For h = 0, the claim is true as otherwise there are at least two j's with yj1 = 1, but only one value for a(y1 - ej) = 0. Now, let h > 0. By induction, and without loss of generality, we can assume that y20 = e1, . . . , y2h-1 = eh, implying that yi = (i)2 for i  2h - 1. Hence, we must have yj2h = 1 for at least one j > h. But, on the other hand, if there are two such indices j, then we reach a contradiction as before, as there would be two values i, i smaller than 2h but different from 0, . . . , 2h - 1; we argue similarly if there is another index j  h with yji = 1.
12

4.3 The rank of hypercube binarizations
In this section we show that, among hypercube binarizations, the logarithmic binarization BL minimizes rkB(1, . . . , ) for any choice of 1, . . . , . Given a hypercube binarization B, we let G(B) be the graph with vertex set V (B), where (xi, yi), (xj, yj) in V (B) are adjacent if and only if the 0/1 vectors yi and yj differ in exactly one component. Hence, G(B) is isomorphic to the d-dimensional hypercube graph.
By Observation 4.14 and Corollary 4.15, we have that G(B) = sk(y(B)) and G(B) is a subgraph of sk(B) having the same vertex set. If the binarization is a logarithmic binarization BL, then G(BL) = sk(BL) because sk(y(BL)) = sk(BL).
For   {0, . . . , 2d - 2} we let V := {(x, y)  V (B) : x  }, and for i  [d] we define V0i := {(x, y)  V (B) : yi = 0} and V1i := {(x, y)  V (B) : yi = 1}. We define an edge e of G(B) to be of type i if e  (V0i), and we write type(e) = i.
Observation 4.17. Given a d-hypercube binarization B and its hypercube graph G(B):

1. For   {0, . . . , 2d - 2}, the cut (V) consists of the -edges of G(B).
2. For i  [d], the cut (V0i) consists of the edges of G(B) whose indicator vector is ei.
3. The cuts (V0i), i  [d], partition the edges of G(B) into d perfect matchings.
We now argue that, given a hypercube binarization B and 1, . . . ,   {0, . . . , 2d - 2}, in order to compute rkB(1, . . . , ) one can restrict to the set covering problem related to G(B) instead of sk(B) (as in Observation 4.8). This allows us to draw conclusions on general (not necessarily affine) hypercube binarizations.

Lemma 4.18. Let B be a d-hypercube binarization, and G(B) be the corresponding graph. For 1, . . . ,   {0, . . . , 2d - 2}, we have

rkB(1, . . . , ) = {i : (V0i) 

 j=1

(Vj )

=

}

.

Proof. Let S := {i : (V0i) 

 j=1

(Vj )

=

}.

We will show that the incidence vector of S

is an

optimal solution of the set covering problem relative to rkB(1, . . . , ) (see Observation 4.8).

First, for j  [], consider e  (Vj ): it is an j-edge of sk(B) whose indicator vector is etype(e). This shows that S is contained in any solution of the aforementioned set covering problem.

On the other hand, we now show that S is a feasible solution of the set covering problem, concluding

the proof. In particular we show that, for any fixed j  [] and any j-edge of G(B) with extreme points (x1, y1), (x2, y2) and indicator vector t, there is an edge e  (Vj ) such that ttype(e)=1.
Consider any shortest path  in G(B) joining nodes (x1, y1), (x2, y2): it contains exactly one edge

of type i for each nonzero coordinate of t. Since we must have, without loss of generality, x1  j and x2  j + 1, there is an edge e of  with e  (Vj ).

Given a hypercube binarization B, its hypercube graph G(B) and 1, . . . ,   {0, . . . , 2d - 2},

we let fB(1, . . . , ) := |{i : (V0i) 

 j=1

(Vj

)

=

}|.

As |{i : (V0i) 

 j=1

(V(j

)

=

}|

=

d - fB(1, . . . , ), by Lemma 4.18 we have the following:

Corollary 4.19. Let B be a d-hypercube binarization, and G(B) be the corresponding graph. For 1, . . . ,   {0, . . . , 2d - 2}, we have

rkB(1, . . . , ) = d - fB(1, . . . , ).

Lemma 4.20. Given a hypercube binarization B, its hypercube graph G(B) and 1, . . . ,   {0, . . . , 2d- 2}, we have that 2fB(1,...,) divides j + 1 for every j  [].

Proof. Given a subset of vertices U of G(B), we let G[U ] be the subgraph of G(B) induced by U . Define q := fB(1, . . . , ) and let (V0i1), . . . , (V0iq ) be the cuts (and perfect matchings) that do not

13

intersect any (Vj ) for j  []. Then for j  [] and k  [q] the restriction of (V0ik ) to G[Vj ] is a

cut and a perfect matching of G[Vj ].

We proceed by induction on q. For q = 1 the lemma holds as, if G[Vj ] admits a perfect matching,

then |Vj | is even.

Assume q > 1 and let V0j = Vj V0iq and V1j = Vj V1iq : this is a partition of Vj into equal parts,

and since (V0j ) is a cut of G[Vj ], we have that edges of type i1, . . . , iq-1 induce a perfect matching

in

G[V0j ].

Then

by

induction

2q-1

divides

|V0j |

=

|Vj 2

|

,

and

thus

2q

divides

|Vj |

=

j

+ 1.

Lemma 4.21. Given the logarithmic binarization BL and   {0, . . . , 2d - 2}, we have that fBL() is the largest number of 1's that are not preceded by any 0 in ()2. Equivalently, fBL() is the largest t such that 2t divides  + 1.

Proof. We prove the first statement, as the second easily follows from the first. Consider the i-th bit of ()2. If it is 0, vertices (, ()2) and ( + 2i-1, ( + 2i-1)2) are adjacent in G(BL) and the corresponding edge is in (V0i)  (V).
If the i-th bit of ()2 is 1 and it is preceded by a 0 in position j < i, then vertices ( - 2i-1 + 2j-1, ( - 2i-1 + 2j-1)2) and ( + 2j-1, ( + 2j-1)2) are adjacent in G(BL) and the corresponding edge is in (V0i)  (V).
Finally, if the i-th bit of ()2 is 1 and it is not preceded by a 0, we claim that no -edge has type i, because if    and    + 1 have ()2 and ()2 different in a single position, that position
cannot be the i-th.

The following corollary, together with Corollary 4.19, gives an expression for the rank of the logarithmic binarization.
Corollary 4.22. Given the logarithmic binarization BL, its hypercube graph G(BL) and 1, . . . ,   {0, . . . , 2d - 2}, we have that fBL(1, . . . , ) = max{t : 2t divides j + 1 j  []}.
We are now ready for the main result of this subsection.

Theorem 4.23. Let B be a d-hypercube binarization, BL be the logarithmic binarization and let 1, . . . ,   {0, . . . , 2d - 2}. Then

rkB(1, . . . , )  rkBL (1, . . . , ).
Proof. By Corollary 4.19, rkB(1, . . . , ) = d-fB(1, . . . , ) and rkBL (1, . . . , ) = d-fBL (1, . . . , ). By Lemma 4.20 and Corollary 4.22, fBL (1, . . . , )  fB(1, . . . , ).
We conclude this subsection by comparing our result with Theorem 11 in [14]: Informally, that theorem states that, given a binary extended formulation Q and a variable x whose binarization is B = BL(d), convexifying all the y-variables of B but one is not enough to ensure integrality of x. A stronger result can be derived from our Corollary 4.22, as rkBL() = d for any even . Thanks to Theorem 4.23, one can extend this to all hypercube binarizations.

4.4 Truncated hypercube binarizations
For d  1 and 2d-1 < v  2d, the truncated logarithmic binarization B<Lv(d) is the convex hull of points (x, (x)2) for 0  x  v - 1 (where again (x)2 is the reversed d-bit string expressing x in base 2). Note that the assumption 2d-1 < v  2d is taken without loss of generality, and, if v = 2d, then B<Lv(d) = BL(d). The projection of B<Lv(d) on the y-space is called a d-dimensional truncated hypercube and is also known as a rev-lex polytope. As the latter is the convex hull of integral vectors ordered lexicographically, it belongs to a well-studied class of polytopes, see e.g. [11, 13, 6]. In particular a description of B<Lv(d) is obtained by adding to BL(d) at most d inequalities. We start with a couple of preliminary observations; the first follows from Corollary 4.15, the second is an easy check and the third is proved in [11].
Observation 4.24. Let B<Lv(d) be as defined above.

14

1. Graphs sk(B<Lv(d)) and sk(y(B<Lv(d))) are isomorphic. 2. B<Lv(d) is the convex hull of BL(d - 1) and (2d-1, ed) + B<Lv (d), where v = v - 2d-1 and d =
log(v). (Here we are abusing notation and embedding BL(d - 1) and B<Lv(d) in R × [0, 1]d.) 3. If two vertices of B<Lv(d) are adjacent vertices of BL(d), then they are adjacent in B<Lv(d) as
well.
Lemma 4.25. For any 2d-1 < v  2d and   {0, . . . , v - 2}, we have:
· if  < 2d-1, then rkB<Lv(d)() = rkBL(d)(); · if   2d-1, then rkB<Lv(d)() = 1 + rkB<Lv (d)( - 2d-1), where v = v - 2d-1 and d = log(v). Proof. Fix   {0, . . . , v - 2}, and let IL(, d) (resp. I<v(, d)) be the support of an optimal solution of the set covering problem related to rkBL(d)() (resp. rkB<Lv(d)()) as in Observation 4.8. Let Ui = {(x, y)  R × Rd : yd = i} for i = 0, 1. Notice that U0, U1 induce a partition of the vertices of BL(d) and of B<Lv(d): in particular, the points of U0 that are vertices of BL(d) and of B<Lv(d) are exactly the same, while the points of U1 that are vertices of B<Lv(d) are also vertices of BL(d).
· Let 0   < 2d-1. We show that I<v(, d) = IL(, d). First, notice that all the -edges of sk(BL(d)) are between U0 and U1, or between two nodes in U0, and that this is true for the -edges of sk(B<Lv(d)), as well.
­ We first deal with the -edges between U0 and U1. We claim that d  IL(, d)  I<v(, d). Indeed, we have that points (0, . . . , 0) and (2d-1, 0, . . . , 0, 1) are adjacent vertices of both BL(d) and B<Lv(d) (thanks to part 3 of Observation 4.24). The corresponding edge is an -edge whose indicator vector is ed, proving our claim.
­ Now, we focus on the -edges between pairs of vertices in U0. Since, by part 2 of Observation 4.24, U0 induces the same graph on both sk(BL(d)) and sk(B<Lv(d)),
I<v(, d) \ {d} = IL(, d) \ {d}.
This concludes the proof of the first case.
· Now, let 2d-1    v - 2. Then, all the -edges of sk(BL(d)) are between U0 and U1, or between two nodes in U1, and that this is true for the -edges of sk(B<Lv(d)), as well. ­ We claim that d  I<v(, d): indeed, consider vi = (xi, (xi)2)  B<Lv(d) for i = 1, 2 with x1 =  + 1 and x2 =  + 1 - 2d-1. Then v1, v2 are adjacent in B<Lv(d) (thanks to part 3 of Observation 4.24) and the corresponding edge is an -edge whose indicator vector is ed. ­ Now, we only need to deal with -edges between pair of vertices in U1. Thanks to part 2 of Observation 4.24, we have I<v(, d) \ {d} = I<v ( - 2d-1, d), which concludes the proof.
The following gives a direct way to compute the rank of B<Lv(d). We restrict to v < 2d, as B<L2d(d) = BL(d). Corollary 4.26. For any 2d-1 < v < 2d and   {0, . . . , v - 2}, let j  [d] be the largest index in which (v)2 is 1 and ()2 is 0 (notice that there must be at least one) and let s be the number of bits j > j where both (v)2 and ()2 are 1. Let ~ be the number such that (~)2 is obtained from ()2 by removing all bits j > j, and let d~ be the number of bits of (~)2. Then:
rkB<Lv(d)() = s + rkBL(d~)(~).
15

Proof. If  < 2d-1 then j as defined in the statement is d, hence ~ = , d~ = d, s = 0. The result then follows from the first part of Lemma 4.25.
If   2d-1, we have j < d. Let j1, . . . , js be the indices j > j where both (v)2 and ()2 are 1, with j =: j0 < j1 < · · · < js = d. We remark that for each index j with ji < j < ji+1 for some i  {0, . . . , s - 1}, we have that bit j of both (v)2 and ()2 is 0.
For i  {0, . . . , s}, we let vi be the number such that (vi)2 is obtained from (v)2 by removing the bits j > ji, and we define i similarly: note that vs = v, s = , and 0 = ~ as defined in the statement. Furthermore, vi = vi+1 - 2ji+1-1, i = i+1 - 2ji+1-1 for i  s - 1. Moreover, let di = log vi for i  {0, . . . , s}: again we have ds = d and d0 = d~ as defined in the statement.
Hence, applying the second part of Lemma 4.25 s times, we get:
rkB<Lv(d)() = 1 + rkB<Lvs-1 (ds-1)(s-1) = . . .
= s + rkB<Lv0 (d0)(0) = s + rkBL(d~)(~), where the last equation follows from the first part of Lemma 4.25.
Corollary 4.27. For any 2d-1 < v  2d and   {0, . . . , v - 2}, we have that
rkB<Lv(d)()  rkBL(d)().
Proof. We use the same notation as in Corollary 4.26, which states that rkB<Lv(d)() = s + rkBL(d~)(~). Consider the d-bit string ()2 and the d~-bit string (~)2 obtained from the former by removing all bits j > j: since the j-th bit of ()2 is 0, the two strings have the same number of 1's that are not preceded by any zero, i.e. by Lemma 4.21, fBL(d~)(~) = fBL(d)(). Moreover, we remark that s  d - d~. Applying again Lemma 4.21 and Corollary 4.19 we conclude that
rkB<Lv(d)()  d - d~+ rkBL(d~)(~) = d - fBL(d)() = rkBL(d)().
In light of the previous results, it is natural to ask whether the truncated logarithmic binarization is "best possible" in terms of rank among other binarizations with the same projection on the y-space, similarly as the complete logarithmic binarization is among all hypercube binarizations: however, the following example shows that the answer is in general negative. Consider the binarization B := {(x, y1, y2)  R × [0, 1]2 : x = -y1 + y2 + 1, y1 + y2  1}. Notice that B = conv{(1, 0, 0), (0, 1, 0), (2, 0, 1)}. We have rkB(0) = 1 (as both 0-edges have indicator vectors with z1 = 1), but rkB<L3(2)(0) = rkBL(2)(0) = 2. This shows that an analogue of Theorem 4.23 cannot be proved for the truncated binarization. Moreover, since B in the example is an affine binarization, also Lemma 4.16 cannot be extended in this context: however, we now show a slightly weaker version of it. A binarization B  R × [0, 1]d is linear if x = f (y) for all (x, y)  B, where f : Rd  R is a linear function.
Lemma 4.28. Up to permuting variables, the logarithmic truncated binarization is the only linear binarization whose projection on the y-space is a truncated hypercube.
Proof. Let 2d-1 < v < 2d for some d and let B be a linear binarization as in the statement. We would like to use the same argument as in the proof of Lemma 4.16. However, since that proof exploits the symmetry of the hypercube with respect to variable permutation, here we need an ad-hoc argument for variable xd.
Since B is linear, there exist a  Rd such that x = ay for every (x, y)  B. We have that x(V (B)) = {0, . . . , v - 1}. Moreover, vertices (ai, ei) show that a1, . . . , ad  1. For i  {0, . . . , v - 1}, let yi be such that (i, yi)  B, and Xi = {j  [d] : yji = 1}, so that i = ayi = a(Xi), where we write a(X) = jX aj for X  [d]. We have a(Xi) = a(Xi ) for any i = i in {0, . . . , v - 1}.
We first show that ad = 2d-1. Notice that there are v - ad numbers in {ad, . . . , v - 1} and v - 2d-1 vertices (x, y)  V (B) with yd = 1, for which x  ad: hence, ad  2d-1. Moreover, if the inequality is
16

strict, by the same counting argument we have that there is i  {ad, . . . , v - 1} with ydi = ydi-ad , i.e., d  Xi  Xi-ad . However, we have
a(Xi) - a(Xi-ad ) = ad = a(Xi \ Xi-ad ) = a(Xi-ad \ Xi) + ad.
But now, since d  Xi-ad we have Xi \ Xi-ad = (Xi-ad \ Xi)  {d}, hence d  Xi, a contradiction. Now one can show that {a1, . . . , ad-1} = {20, . . . , 2d-2} exactly as in the proof of Lemma 4.16,
concluding the proof.
In [10] it is shown that any affine binarization of a variable x can be turned into a linear binarization of x (with the same number of y-variables) through a unimodular transformation. This implies that affine and linear binarizations are equivalent in terms of split closure (see [10] for details). The example above, together with Lemma 4.28, shows that unimodular transformations do not preserve the rank, hence using specific non-linear or non-affine binarizations might be beneficial in terms of efficiency of the sequential convexification procedure.
5 Conclusion
Binary extended formulations featuring natural binarizations form a broad class that in our opinion deserves more attention. First, the vertices of such formulations admit a simple characterization (Theorem 3.1), that allows a deeper understanding of the performance of sequential convexification on such formulations; second, natural binarizations lend themselves to a notion of rank (Definition 4.7) that allows to compare them, as we have done for the classical binarizations from the literature.
Given the variety of (natural) binarizations one could come up with, it is natural to ask which binarizations are "better" than others with respect to a given criterion. This question was investigated in [10], which showed that certain binarizations with a large number of variables are optimal in terms of split closure. Our rank, stemming from a sequential convexification perspective, can be a valuable tool in investigating this question for binarizations with any number of variables.
In light of Lemmas 4.11, 4.13, one concludes that the unary binarization BU (d) is better than the full binarization BF (d) in terms of rank. We do not know whether BU (d) is optimal with respect to all binarizations that are isomorphic to a d-simplex. We leave this as our first open question.
Since the number of variables is an important factor for the efficiency of mixed-integer programming, it is interesting to focus on binarizations with the minimum number of variables, which is logarithmic in the length of the range of x. Hypercube binarizations are a prominent example of this, and the logarithmic binarization BL is optimal among them (Theorem 4.23). The rank function of BL is not comparable with the rank function of BU , but it is definitely larger than the latter when one restricts to a small number of values: rkBU () = 1 for any , while rkBL() can be as large as d depending on . This seems to suggest that there is a trade-off between the number of variables in a (natural) binarization and its rank.
The situation is less clear for the truncated logarithmic binarizations B<Lv. While the rank of B<Lv is at most the rank of BL (Corollary 4.27), it is not optimal: other isomorphic binarizations can have smaller rank (see the example at the end of Section 4.4). It is not clear whether B<Lv (or another binarization with the same number of variables) could be preferable to BL, which has a much simpler polyhedral structure. However it would be interesting to determine whether, for fixed d and v, there is a binarization that is optimal with respect to the rank among those isomorphic to B<Lv(d). This is our second open question.
Finally, we mention another research direction that is, as far as we know, still unexplored. Given a binary extended formulation Q of a polytope P , apply one round of the Sherali-Adams hierarchy [16] to the binary variables of Q: what can we say about the resulting extended formulation? We believe that the approach and the techniques developed in this paper will help answer this question and others in the same spirit.
17

Acknowledgments.
Manuel Aprile and Marco Di Summa are supported by a grant SID 2019 of the University of Padova.
References
[1] E. Balas. "Disjunctive programming: Properties of the convex hull of feasible points". In: Discrete Applied Mathematics 89.1 (1998), pp. 3­44.
[2] A. Basu, M. Conforti, M. Di Summa, and H. Jiang. "Complexity of branch-and-bound and cutting planes in mixed-integer optimization­II". In: arXiv preprint arXiv:2011.05474 (2020).
[3] P. Bonami and F. Margot. "Cut generation through binarization". In: Mathematical Programming 154.1 (2015), pp. 197­223.
[4] M. Conforti, G. Cornu´ejols, and G. Zambelli. "Extended formulations in combinatorial optimization". In: 4OR 8.1 (2010), pp. 1­48.
[5] M. Conforti, G. Cornu´ejols, and G. Zambelli. Integer programming. Vol. 271. Springer, 2014. [6] M. Conforti, M. De Santis, M. Di Summa, and F. Rinaldi. "Scanning integer points with lex-
inequalities: A finite cutting plane algorithm for integer programming with linear objective". In: 4OR (2020), pp. 1­18. [7] M. Conforti, A. Del Pia, M. Di Summa, Y. Faenza, and R. Grappe. "Reverse Chv´atal­Gomory rank". In: SIAM Journal on Discrete Mathematics 29.1 (2015), pp. 166­181. [8] M. Conforti, M. Di Summa, and Y. Faenza. "Balas formulation for the union of polytopes is optimal". In: Mathematical Programming 180.1 (2020), pp. 311­326. [9] W. J. Cook, R. Kannan, and A. Schrijver. "Chv´atal closures for mixed integer programming problems". In: Mathematical Programming 47 (1990), pp. 155­174. [10] S. Dash, O. Gu¨nlu¨k, and R. Hildebrand. "Binary extended formulations of polyhedral mixedinteger sets". In: Mathematical Programming 170.1 (2018), pp. 207­236. [11] R. Gillmann and V. Kaibel. "Revlex-initial 0/1-polytopes". In: Journal of Combinatorial Theory, Series A 113.5 (2006), pp. 799­821. [12] F. Glover. "Improved linear integer programming formulations of nonlinear integer problems". In: Management Science 22.4 (1975), pp. 455­460. [13] A. Gupte. "Convex hulls of superincreasing knapsacks and lexicographic orderings". In: Discrete Applied Mathematics 201 (2016), pp. 150­163. [14] J. H. Owen and S. Mehrotra. "On the value of binary expansions for general mixed-integer linear programs". In: Operations Research 50.5 (2002), pp. 810­819. [15] J.-S. Roy. ""Binarize and Project" to generate cuts for general mixed-integer programs". In: Algorithmic Operations Research 2.1 (2007). [16] H. D. Sherali and W. P. Adams. "A hierarchy of relaxations between the continuous and convex hull representations for zero-one programming problems". In: SIAM Journal on Discrete Mathematics 3.3 (1990), pp. 411­430. [17] H. D. Sherali and W. P. Adams. A reformulation-linearization technique for solving discrete and continuous nonconvex problems. Vol. 31. Springer Science & Business Media, 2013.
18

