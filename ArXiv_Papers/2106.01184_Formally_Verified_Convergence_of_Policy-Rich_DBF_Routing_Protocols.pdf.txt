1
Formally Verified Convergence of Policy-Rich DBF Routing Protocols
Matthew L. Daggitt, Timothy G. Griffin

arXiv:2106.01184v1 [cs.NI] 2 Jun 2021

Abstract--In this paper we present new general convergence results about the behaviour of Distributed Bellman-Ford (DBF) family of routing protocols, which includes distance-vector protocols (e.g. RIP) and path-vector protocols (e.g. BGP).
First, we propose a new algebraic model for abstract routing problems which has fewer primitives than previous models and can represent more expressive policy languages. The new model is also the first to allow concurrent reasoning about distance-vector and path-vector protocols.
Second, we explicitly demonstrate how DBF routing protocols are instances of a larger class of asynchronous iterative algorithms, for which there already exist powerful results about convergence. These results allow us to build upon conditions previously shown by Sobrinho to be sufficient and necessary for the convergence of path-vector protocols and generalise and strengthen them in various ways: we show that, with a minor modification, they also apply to distance-vector protocols; we prove they guarantee that the final routing solution reached is unique, thereby eliminating the possibility of anomalies such as BGP wedgies; we relax the model of asynchronous communication, showing that the results still hold if routing messages can be lost, reordered, and duplicated.
Thirdly, our model and our accompanying theoretical results have been fully formalised in the Agda theorem prover. The resulting library is a powerful tool for quickly prototyping and formally verifying new policy languages. As an example, we formally verify the correctness of a policy language with many of the features of BGP including communities, conditional policy, path-inflation and route filtering.
Index Terms--Vector routing protocols, Algebra, Convergence, Formal Verification, Agda.
I. INTRODUCTION

If we dig deeply into the classical theory underlying bestpath algorithms -- both synchronous [1], [2], and asynchronous [3] -- we find that it always assumes the following equation, or something equivalent, must hold:

f (best(r1, r2)) = best(f (r1), f (r2))

(1)

This property is referred to as distributivity. The left-hand side of the equation can be interpreted as a decision made by a router sending routes r1 and r2 while the right-hand side is a decision made by the neighbour receiving those routes. Assuming the equality holds, the classical theory proves that routing protocols arrive at globally optimal routes -- where every pair of routers use the best path between them.
By a policy-rich language we mean one in which distributivity does not hold. A clear example of how distributivity violations might arise in routing can be seen in the use of route maps which are functions (scripts) that take routes as input and return routes as output. For example, if g and h are route maps, then we might define another route map f as:

f (r) = if P (r) then g(r) else h(r),

(2)

where P is a predicate on routes (such as "does this route contain the BGP community 17?"). To see how easily distributivity can be violated, suppose that:

P (a)

= true,

P (b)

= false,

best(a, b)

= a,

best(g(a), h(b)) = h(b).

Then the left-hand side of Equation 1 is:

A. What is policy-rich routing?

f (best(a, b)) = f (a) = g(a),

This paper proves new, general results about the convergence of asynchronous routing protocols in the Distributed Bellman-Ford (DBF) family, which includes distance-vector (RIP-like) and path-vector (BGP-like) protocols. In particular, the results apply to what we call policy-rich protocols, and so we begin by informally explaining this terminology.
Suppose that a router participating in a DBF computation has a best route r to a destination d. If it then receives a route r for d from an immediate neighbour it will first apply some policy f associated with that neighbour and produce a candidate route f (r ). It will then compare r with f (r ) to determine which is best. Let us denote the outcome of this selection process as best(f (r ), r). A very simple example is the shortest-paths problem where r is just an integer representing distance, fw(r) = w + r for some weight w, and best(r, r ) = min(r, r ).

while the right-hand side becomes:
best(f (a), f (b)) = best(g(a), h(b)) = h(b)
For Eq 1 to hold we need g(a) = h(b), which may not be the case (indeed, if g(a) = h(b) were always true, then there would be no point in defining f !). Perhaps the most common example of such conditional policies is route filtering, where h(r) is equal to the invalid route.
A specialist schooled in the classical theory of path finding might be tempted to forbid the use of such "broken" policies when using the Bellman-Ford or Dijkstra algorithms. Yet, once again, practice has outstripped theory. The Border Gateway Protocol (BGP) [4] -- a key component of the Internet's infrastructure -- is a policy-rich routing protocol.
We argue that today's BGP is in fact broken since it is possible to write policies that can result in anomalous

2

behaviour such as non-convergence [5], [6] and multiple stable states [7]. The latter are problematic as the extra stable states are nearly always unintended and often violate the intent of policy writers. Leaving an unintended stable state requires manual intervention and, in the worst case, a high degree of coordination between competing networks. This phenomenon is colloquially referred to as a BGP wedgie.
Hence a pertinent question is how to tame the policy language of BGP-like protocols to ensure good behaviour? Of course we could mandate that all protocols must conform to Equation 1. However, we would then not be able to implement typical inter-domain policies that are based on commercial relationships [8], [9]. In addition, something as simple as shortest-path routing with route filtering would be banned.
Gao & Rexford [10] showed that the simple commercial relationships described in [8], [9], if universally followed, are enough to guarantee convergence. However their model is BGP-specific and gives us no guidance on how policyrich protocols should be constrained in general. Furthermore their conditions impose constraints on the topology of the network and therefore they require continuous verification as the topology changes.
Instead an alternative middle ground for generic policy-rich protocols has been achieved for both Dijkstra's algorithm [11] and the DBF family [12]. Rather than insisting on distributivity, we require that for all routes r and policies f we have:

r = best(r, f (r)).

(3)

In other words, applying policy to a route cannot produce a route that is more preferred. Although Equation 3 is sufficient for Dijkstra's Algorithm [11], it must be strengthened for DBF algorithms [12] to:

r = best(r, f (r))  r = f (r).

(4)

That is, applying policy to a route cannot produce a route that is more preferred and it cannot leave a route unchanged. We call policy languages that obey Equation 3 increasing and those that obey Equation 4 strictly increasing. Note that if policies g and h are strictly increasing, then the conditional policy f defined in Equation 2 is also strictly increasing. In other words, a strictly increasing policy language remains strictly increasing when route maps are introduced.
However, without distributivity we can no longer achieve globally optimal routes and so we must be content with locally optimal routes [11] ­ each router obtains the best routes possible given the best routes revealed by its neighbours.
It is natural to ask if the strictly increasing condition is too strong and prohibits desirable policies? Sobrinho [12] shows that it is the weakest possible property that guarantees a pathvector protocol always converges. This implies that if the policy language is not strictly increasing than there exists a network in which the protocol diverges.
Nonetheless, as we discuss in Section V, the policy language of BGP is not strictly increasing, and there is no known way of making it so without removing the ability of AS's to hide commercially sensitive information from each other. Therefore, the next natural question to ask is: given a nonstrictly increasing policy language, which networks does the

protocol converge over? Sobrinho shows that a network being free with respect to the policy language is a sufficient and necessary condition for a DBF protocol to converge over that network.
Subsequent to these foundational results, the algebraic approach has been extended to model other more complex methods of routing such as multi-path routing [13], [14], hierarchical routing [15], and quality of service routing [16].
B. Our contributions
1) Answers to big-picture questions: Given these prior results, the reader might be tempted to assume that the convergence of standard DBF routing protocols is a solved problem. However, this is far from the case. In this paper, we address the following open questions:
Q1) Sobrinho's proofs only guarantee that the protocols converge. Do they always converge to the same stable state? Answer: We prove that the answer is yes. From a theoretical perspective, this implies that the set of DBF protocols that converge and the set of DBF protocols that converge deterministically are the same. From a practical perspective, this implies that as long as a DBF protocol is guaranteed to converge then you don't have to worry about problems like BGP wedgies.
Q2) The proofs of Sobrinho and Gao-Rexford both assume TCP-like in-order, reliable communication between routers. Is this a fundamental requirement for convergence? Answer: We prove that the answer is no, by showing that the results still hold for a weaker, UDP-like model of communication in which route advertisements may be delayed, lost, reordered and duplicated. From a theoretical perspective, this provides strong evidence that the difficulty of solving a routing problem in a distributed environment is entirely independent of the communication model used. This is not the case in other distributed protocols, e.g. consensus protocols [17].
Q3) Sobrinho reasons about path-vector protocols. Do there exist corresponding results for distance-vector protocols? Answer: we show that they do. In particular, that distancevector protocols converge over strictly increasing algebras/free networks if the number of possible path-weights assigned to routes is finite. From a practical perspective this implies the feasibility of policy-rich distance-vector protocols, a relatively under-explored design space.
2) Improvements to the model: In addition to the new high-level results above, we also make several important contributions to the underlying mathematical model for DBF protocols. A more technical discussion of these contributions can be found in Section II-F.
M1) We propose a new algebraic structure for modelling policy languages which is both simpler and more-expressive than that of Sobrinho. In particular, it contains only 5 algebraic primitives instead of 8, and is capable of naturally modelling path-dependent policies such as route filtering and path-inflation.

3

M2) We identify that a DBF protocols are a single instance of a much broader class of asynchronous iterative algorithms, for which there exist prior models and convergence results. From a theoretical point of view, this allows us to cleanly abstract the underlying routing problem being solved from the distributed environment in which it is being solved. Practically, it greatly simplifies the proofs and allows us to prove asynchronous convergence purely by reasoning about the behaviour of the protocol in an entirely synchronous environment. In contrast, previous work [10], [12] has typically created their own custom model of message passing in an asynchronous environment and therefore have to directly reasoning about message timings and have avoided reasoning about unreliable communication.
M3) Thanks to this existing theory, we construct a mathematical model of an abstract DBF routing protocol that is the first to precisely describe the entire evolution of the protocol, including exact message timings, routers and links failing, routers and links being added, and routers being reset. As far as we aware, this is therefore the first fully provably correct executable model of an abstract DBF protocol. In contrast, previous proofs have focused on proving results about a snapshot of a single network configuration in which all routers, links and policies remain static.
3) Formal verification: In the past decade there has been a strong trend towards the verification of infrastructure-related software in areas as diverse as operating systems [18], compilers [19], [20] and networking [21], [22].
In line with this trend we have fully formalised all the results in this paper in the Agda theorem prover [23]. As Agda is capable of expressing both proofs and programs, and as our model is executable, this constitutes the first ever fully formalised, executable model of a general DBF protocol as far as we are aware. The advantages of this formalisation effort are as follows:
V1) It provides a much stronger guarantee of the correctness of our proofs. Reasoning about algorithms in distributed environments is notoriously tricky, and as Sobrinho himself says in [12], his proof of convergence is only "semi-formal". Having a computer check our proofs is a valuable and powerful assurance as to their correctness.
V2) The generality of our verified proofs means that they also function as a library that can be used by others to rapidly prototype, explore the behaviour of and formally verify the correctness of novel policy languages. This is a significant step towards reusable and modular formal verification of routing protocols. The library is freely available [24], and we hope that it will prove useful to the community.
V3) To demonstrate the utility of our library, we construct a model of a path-vector routing protocol that contains many of the features of BGP including local preferences, conditional policy, path inflation and route filtering. We formally verify in Agda that the policy language is strictly increasing, and therefore no matter what policies are used

the protocol will always converge deterministically to a single stable state given a sufficient period of stability. Such a protocol is therefore provably safe-by-design.
C. Road map
In Section II, we use an algebraic approach inspired by that of Sobrinho [12] and existing literature on asynchronous iterative algorithms [25], to construct an executable model of an abstract, fully asynchronous, distributed DBF routing protocol. This approach provides a clear, implementationindependent specification of the family of protocols which we can reason about. In Section III we discuss how our novel use of an existing theory of asynchronous iterative algorithms does much of the heavy lifting, and finish by applying using existing results from this field to prove our new results about distancevector and path-vector protocols. In Section IV we describe our Agda formalisation of these results, and in Section V we construct a safe-by-design algebra using the library.
D. Previous versions
Previous versions of this work have appeared before in conference proceedings [26] and in the thesis of the first author [27]. The many improvements in this paper over these prior versions are discussed in Section VII.
II. MODEL
In this section we construct a model of an arbitrary DBF routing protocol. For the reader's convenience, a glossary of all the notation used in this and later sections can be found in Appendix A.
A. Generality vs implementation details
In any mathematical model of a real-world system, there is a fundamental tension between capturing the most general form of the system and capturing every detail of the implementation. More implementation details can always be added to better model a particular system, at the cost of losing the ability to apply the work more generally.
In this paper we err on the side of generality. While we acknowledge that BGP is the dominant policy-rich path-vector protocol, the aim of our work is not only to inform how BGP policies may be constrained to provide better guarantees, but also to guide the design of future policy-rich protocols.
For example we do not explicitly model the hard-state nature of BGP. Instead we use a very general model of asynchronous computation which we believe can easily capture a hard-state protocol (this intuition is not fully formalised in this work). Had we explicitly modelled a hard-state protocol, it would prevent us from applying our work to soft-state protocols as well.
B. Paths
Prior to anything else, it is important to discuss exactly what is meant by a path in the context of a distributed, asynchronous routing protocol. Traditionally paths are defined with respect

4

to some graph G = (V, E). However because a network's topology changes over time, the path along which an entry in a router's routing table was generated may not correspond to a valid path in the current topology. Furthermore, and perhaps counter-intuitively, such a path may be formed from an amalgamation of paths from previous topologies, and therefore may not even have existed in any single past topology. Consequently, out of necessity, our notion of a path cannot be tied to the network's topology.
Therefore, we begin by defining V as the set of all valid router identifiers. An edge is an arbitrary pair of router identifiers, and therefore the set of edges is E = V × V. A path is a defined to be a sequence of contiguous edges. A cycle is a path which finishes at the same router it started at. A simple path is a path that doesn't contain any cycles. For our purposes, we also consider an additional simple path , which represents the absence of a path. We refer to the set of simple paths as P.
C. Routing algebras
In order to model all possible DBF protocols rather than one particular protocol, we first abstract over the routing problem being solved by representing it as a routing algebra.
Definition 1 (Routing algebra). A routing algebra is a tuple (S, , E, 0, ) where:
· S is the set of path-weights. A path-weight is the data that the routing protocol associates with each candidate path. For example in a shortest-path protocol the path-weights would be the lengths of the paths, e.g. N.
·  : S × S  S is the choice operator, which given two path-weights returns the preferred path-weight. In the introduction, this was informally referred to as "best". In a shortest-path protocol this would be the min operator.
· E : E  2SS is a map from an edge to the set of policy functions that may be used on that edge. Each policy is a function f : S  S, which when given a path-weight returns a new path-weight formed by extending the original path by the edge (i, j). For notational convenience we define the complete set of policies as E = (i,j)E Eij.
· 0  S is the path-weight of the trivial path from any router to itself. In a shortest-path protocol this is 0.
·   S is the invalid path-weight, representing the absence of a path.
which we assume to always have the following minimal properties: R1  is associative - the order doesn't matter when making
a sequence of choices between path-weights.
x, y, z  S : x  (y  z) = (x  y)  z
R2  is commutative - the order doesn't matter when choosing between two path-weights.
x, y  S : x  y = y  x
R3  is selective - choosing between two path-weights always returns one of the two path-weights.
x, y  S : x  y  {x, y}

S



E 0

Use

N min E+  0

shortest paths

N max E+ 0 

longest paths

N max Emin 0 

widest paths

{0, 1} max E× 0 1 most reliable paths

TABLE I EXAMPLES OF SOME SIMPLE ROUTING ALGEBRAS WHERE Eij = {fw(x) = w  x | w  S} FOR ARBITRARY OPERATOR 
E.G. Ei+j = {fw(x) = w + x | w  N}.

R4 0 is an annihilator for  - the trivial path-weight is more desirable than any other path-weight.

x  S : x  0 = 0 = 0  x

R5  is an identity for  - any path-weight is preferable to the invalid path-weight.

x  S : x   = x =   x

R6  is a fixed point for all policy functions - the extension of the invalid path-weight is also the invalid path-weight.
f  E : f () = 

Table I contains examples of simple routing algebras representing a variety of common routing problems. A much more complex routing algebra that is based off of BGP is discussed in detail in Section V.
Path-vector protocol are a subclass of DBF protocols which track the path along which a path-weight was generated. Routers then use this information to eliminate any pathweights that were generated via a cycle. It is well known that path-vector protocols have better convergence behaviour. To allow us to reason about such protocols we now define a subclass of routing algebras that can be used to model pathvector-specific behaviour.

Definition 2 (Path algebra). A path algebra is a routing algebra (S, , E, 0, ) equipped with an additional function path : S  P that obeys the following properties:
P1 A path-weight has the invalid path iff it is the invalid path-weight.

x  S : x =   path(x) = 

P2 The path of the trivial path-weight is the empty path.

x  S : x = 0  path(x) = [ ]

P3 Applying an edge's policy function to a path-weight simply extends the path-weight's path by that edge, unless it does not result in a non-simple path in which case it becomes the invalid path.

x  S, (i, j)  E, f  Eij :   
path(f (x)) = 
(i, j) :: path(x)

if i  path(x) if j = src(path(x)) otherwise

The function path : S  P allows us to extract the path along which the path-weight was generated without revealing

5

how the path is stored internally inside the path-weight. The advantages of this abstraction are discussed at the end of this section. Assumptions P1 ­ P3 ensure that the algebra's implementation is tracking the paths correctly. In P3 the first case i / path(x) ensures that path-weights generated along paths with cycles in them are eliminated. The second case j = src(path(x)) ensures that invalid routing announcements are also eliminated.
Note that assumption P3 is the primary reason that we require that each edge (i, j) comes with its own set of policy functions Eij in Definition 1. If instead we had only required the existence of a single set of policy functions (i.e. E) then we would be unable to express P3.

D. Synchronous DBF protocol
Now that we can model what problem our abstract DBF protocol is solving, we move on to modelling how it solves it. We start by defining a synchronous version of the protocol where update messages between routers are exchanged instantaneously and in parallel. Let V  V be the finite set of routers that will ever participate in the protocol and let n = |V |. We represent an instantaneous snapshot of the network topology by an n×n adjacency matrix A where Aij  Eij is the current policy function on the link from router i to router j. Note that in practice the policy function Aij may be the composition of the export policy of router j and the import policy of router i. The absence of a link from i to j is represented by the alwaysinvalid policy f  which is defined as x : f (x) .
The global state of the synchronous protocol can be entirely represented by the product of the state of each router's routing table. We therefore represent an individual state by a matrix X where row Xi is router i's routing table and so the element Xij is the path-weight of i's best current route to router j. We will use Sn to denote the set of routing table states (i.e. the set of vectors over S of length n), and Sn×n to denote the set of global states (i.e. the set of n × n matrices over S).
We define the sum of two matrices X and Y as:

(X  Y)ij

Xij  Yij

and the application of A to X as:

A(X)ij

Aik(Xkj )
k

In one synchronous round of a distributed Bellman-Ford computation every router in the network propagates its routing table its neighbours who then update their own tables accordingly. We model this operation as FA:

FA(X) A(X)  I

where I is the identity matrix:

0 if i = j

Iij

 otherwise

The nature of the underlying computation becomes clearer when expanding out the definition of a single element of FA(X):

FA(X)ij = A(X)ij  Iij

0 if i = j = Aik(Xkj)   if i = j
k

=

k Aik(Xkj )  0 if i = j

k Aik(Xkj )   if i = j

0

if i = j

=

(5)

k Aik(Xkj ) if i = j

Router i's new route to j is the best choice out of the extensions of the routes offered to it by each of its neighbours k.
We can now model the evolution of the synchronous version of protocol, , as repeated applications of FA.

Definition 3 (Synchronous state function). Given a network topology A and an initial state X, the state of the synchronous DBF protocol at time t is defined as:

t(X)

X

if t = 0

FA(t-1(X)) otherwise

E. Asynchronous DBF protocol
Although we have defined a synchronous model above, in reality DBF protocols are distributed and asynchronous. Update messages are dispatched at non-deterministic intervals and may be delayed, reordered, duplicated or even lost along the way. New routers and links may be added to the network, existing routers and links may fail, and routers may be rebooted and reset to their original state. Reasoning about the outcomes of such unpredictable events is known to be extremely challenging.
One advantage of first defining the synchronous model is that it highlights that the underlying algorithm is inherently iterative. Consequently, it is easy to recognise that a DBF protocol is simply a special instance of the family of dynamic asynchronous iterative algorithms. We can therefore use existing work [28], [25] that constructs mathematical model of such iterations. We now describe a specialisation of the model presented in [25] to DBF protocols.
The model assumes a discrete and linear notion of time, T, denoting the times of events of interest in the network (a routing table updating, a router failing etc.). Layered on top of time is the notion of epochs, E, which represent contiguous periods of time during which the network topology remains unchanged, i.e. no links or routers fail or are added and no policies are changed. Given this, we can now model a dynamic network, N , as a function from epochs to adjacency matrices where N e is the topology of the network during epoch e.
The non-deterministic evolution of the protocol is described by a schedule.
Definition 4 (Schedule). (Definition 9 in [25]) A schedule is a tuple of functions (, , , ) where:
·  : T  2V is the activation function, where (t) is the set of routers which update their routing table at time t.

6

Node i

Messages reordered Message lost

Message duplicated

Node j Time t 1 2 3 4 5 6 7 8 9 10 (t, i, j) 0 0 2 1 1 1 1 7 8 7
Fig. 1. Behaviour of the data flow function . Messages from router j to router i may be reordered, lost or even duplicated. The only constraint is that every message must arrive after it was sent. Reproduced from [25].

·  : T × V × V  T is the data flow function, where (t, i, j) is the time at which the route advertisements used by router i at time t was sent by router j.
·  : T  E is the epoch function, where (t) is the epoch at time t.
·  : E  2V is the participants function, where (e) is the subset of routers currently participating in the protocol during epoch e.
such that:
S1 information only travels forward in time

i, j, t : (t + 1, i, j)  t

S2 epochs increase monotonically

t1, t2 : t1  t2  (t1)  (t2)

This is a very weak model of asynchronous communication. As shown in Figure 1, nothing forbids the data flow function  from delaying, losing, reordering or duplicating messages. It also distinguishes between a router being a member of the network but not currently participating in the protocol. This allows us to model messages that continue to arrive from the previous epoch, e.g. router i can receive outdated route advertisements from router j even after router j has ceased to participate.
However, it does mean that we need to distinguish between the topology of network and the topology as seen by the active participants. In particular we need to enforce that information only flows between two participating routers.

Definition 5 (Participating topology). Given a network N , an epoch e and a set of participants p, we define Aep to be the
participating topology:

Aeijp =

Niej fij

if {i, j}  p otherwise

Given a schedule, for notational convenience we also define  : T  2V , the set of participants at time t, and At, the
current participating topology at time t, as:

(t) ((t) At A(t)(t)

Using this machinery it is now possible to define the full asynchronous state function, , in terms of the original iteration function FAt .

Definition 6 (Asynchronous state function). (Definition 10 from [25] with F t = FAt ,  = I) Given a dynamic network N , an initial state X, and a schedule (, , , ), the
state of the asynchronous DBF protocol at time t is defined
as:

Iij



itj (X)

=

Xij itj-1(X)



FAt (L)ij

if i / (t) else if t = 0 or i / (t - 1) else if i / (t) otherwise

where Lkj = (t,i,k)(X)kj .

This models the evolution of the protocol as follows. If a router is not currently participating then it adopts its nonparticipating state Iij. If a router has just begun to participate, either because t = 0 or because it was not participating at the previous time step, it adopts the initial state Xij. If the router is a continuing participant and is currently inactive then its state remains unchanged from that at the previous time step, itj-1(X). Otherwise, if it is currently active, it updates its state in accordance with router i's local view, L, of the global state as currently advertised by its neighbours. More concretely, Lkj is the last route advertisement for router j that router i received from its neighbour k.
Note that this is a straightforward generalisation of the synchronous model as we can immediately recover  from  by setting (t) = V , (t, i, j) = t-1, (t) = 0 and (t) = V i.e. there is a single epoch in which at each time step, every router is both participating and active and all messages only take a single time step to propagate.

F. Novel contributions
We now recap the main advantages of this new model over models proposed in previous work.
a) Simpler, more general algebraic structure: The algebraic structure we propose in Definition 1 is both more general and simpler than that proposed by Sobrinho [12], which in turn was inspired by the classical semiring approach [1], [29]. The main difference is in how we model path-weight extension. In semiring algebras it is modelled by a second binary operator  : S × S  S. However this is incapable of modelling modern routing policies such as those described in Sections I & V. Sobrinho generalised this binary operator by introducing labels L, signatures , an operator : L ×   

7

and a function g :   S mapping signatures to pathweights. However, by modelling extension policies as a set of functions, E, and as demonstrated in Section V, we retain the ability to model modern routing polices while reducing the size of the algebra from 8 primitives to 5 primitives.
b) Paths as part of the algebra: The second way in which the algebra is more general is that, by assigning each edge its own set of extension functions, we model the tracking of paths in path-vector protocols inside of the algebra itself. In contrast, Sobrinho [12] models the paths as part of the algorithm, i.e. in the equivalent definition of . This means that the paths along which the path-weights were generated are not provided as inputs to his  and E operators. Therefore they cannot alter or make decisions based on those paths. Consequently, unlike ours, Sobrinho's approach cannot model policies such as route filtering or path inflation in BGP.
c) Abstraction of paths: A third advantage of our new Definition 2 of a path algebra is that it only requires that the path function can extract a simple path from a pathweight, but does not force the protocol to reveal how paths are actually stored internally. This abstraction results in proofs that are far more robust to variations in how paths are stored internally by the protocol. For example, in Section V we show that our algebras can model BGP-like path inflation by simply adjusting the path function to strip out the inflated ASs, without having to adjust the proofs of convergence. In contrast, the model of path-vector protocols in Sobrinho [12] uses a concrete definition of paths, and therefore is incapable of modelling path inflation without altering all the proof of convergence.
d) Use of existing asynchronous theory: The additional complexity introduced by the more expressive dynamic asynchronous model , such as routers failing and rebooting, at first glance appears daunting. However, as we will discuss further in Section III, our use of the existing theory of dynamic iterative algorithms means that we have access to a range of powerful theorems that, impressively, are capable of totally abstracting away the asynchronicity of the system.
e) Executable model of the protocol: Sobrinho [12] only provides an abstract temporal model of individual events that occur during the operation of the protocol. In contrast, as far as we are aware, ours is the first fully formal and executable model of the full dynamic behaviour of an abstract DBF protocols in which routers and links can fail, join and reboot. This means that our model can be run and its behaviour observed, and that our proofs can be written in a style amenable to the formal verification discussed in Section IV.
III. CONVERGENCE RESULTS
A. Some useful concepts
Initially, we define some concepts that, although not required for constructing the model in Section II, are used in stating and reasoning about its convergence behaviour.
1) Ordering over path weights: Given any routing algebra (S, , E, 0, ), the choice operator  induces a preference order over path-weights as follows:

Definition 7 (Preference relation over path-weights ). A pathweight x is preferred to path-weight y, written x  y, if x is chosen over y:

x  y x < y

xy = x x  y  x = y.

As  is associative, commutative and selective, we have that  is a total order and that for all path-weights x we have 0  x  .

2) Assignments: In our model which router is using which path-weight is implicitly defined by the path-weight's location in the routing state (i.e. given a routing state X then the pathweight Xij is being used by router i). Nonetheless a more explicit notion of which router is using which path-weight is crucial for stating sufficient and necessary conditions for the convergence of the model over a given network. We shall refer to such a concept as an assignment.
Definition 8 (Assignment). An assignment (i, x) is a pair of a router i  V and a path-weight x  S. The set of assignments A V × S.

Note that an assignment is a generalisation of the notion of a couplet defined by Sobrinho [12]. Whereas a couplet stores the entire path along which the path-weight was generated, an assignment only stores the first router in the path. This generalisation is necessary as we seek to reason about distance-vector as well as path-vector protocols, and in the former case we do not have access to the full path.
Several binary relations may be defined over the set of assignments. The first is the lifting of the preference order over path-weights to assignments.
Definition 9 (Preference relation over assignments). An assignment a is preferred to assignment b, written a  b, if they have the same router and the path-weight of a is preferred to the path-weight of b:

(i, x)  (j, y) (i, x)  (j, y)

i = j  x  y i = j  x < y

Note that unlike  which is a total order over path-weights,  is only a partial order over assignments, as it can only
relate assignments to the same router. Intuitively, this makes sense as routers in a DBF protocol only compare paths that begin at themselves.

Definition 10 (Extension relation). An assignment a extends assignment b in the current topology A, written a A b, if the extension of the non-invalid path-weight of a across the relevant link is equal to the path-weight of b:

(j, y) A (i, x) Aij(y) = x  y = 
In the context of a path vector protocol, the axioms of a path algebra are sufficient to guarantee that if (j, y) A (i, x) then path(x) = (i, j) :: path(y).
Definition 11 (Threatens relation). An assignment a threatens assignment b in the current topology A, written a A b, if

8

the extension of the non-invalid path-weight of a across the relevant link is preferred to the path-weight of b:
(j, y) A (i, x) Aij(y)  x  y = 
Intuitively (j, y) A (i, x) means that after the next update router i may switch away from x and instead use a path-weight that is equal to or preferred to Aij(y). It is easy to see that if a A b then a A b.
3) Non-participating nodes: As seen in Definition 5, the constraint that non-participating routers do not advertise routes to or receive routes from other routers is enforced at the level of the adjacency matrix Aep and therefore the iteration function FAep . Consequently, after a single iteration the state of any non-participating router's routing table will always be the corresponding entry of the identity matrix, i.e. the trivial route to itself and invalid routes to all other routers in the network. In [25] such states are said to be accordant with the current set of participants.
Definition 12 (Accordant states). (Definition 15 from [25] with  = I) The set of routing states that are accordant with set of participants p, Spn×n, is defined as:
Spn×n {X  Sn×n | i, j : i / p  Xij = Iij }
B. Definition of convergence
Before proving convergence results about our model, we must first establish what does convergence even mean for a dynamic, asynchronous, iterative algorithm such as a DBF protocol? In this section, will build up a suitable definition by discussing in turn the complications introduced by each of these adjectives.
a) Iterative: The definition of convergence for a synchronous iterative algorithm is relatively simple. After a finite number of iterations, the algorithm must reach a stable state such that further iterations result in no further change. In terms of the synchronous model defined in Section II-D, this would translate to:
k  N : k  N : k  k  k(X) = k (X)
The resulting stable state X = k (X) is a fixed point for FA, as:
FA(X) = FA(k (X)) = k+1(X) = k (X) = X
From the perspective of a routing protocol, X being a fixed point is equivalent to the statement that in state X no router can improve its selected path-weights by unilaterally choosing to switch. Such a state can therefore be viewed as a locally optimal solution to the optimisation problem of finding the best consistent set of path choices in the current network topology. As will be discussed further in Section III-D, whether such a state is necessarily globally optimal depends on the properties of the routing algebra being used.

b) Asynchronous: At first glance, it appears relatively easy to adapt the above definition to a basic asynchronous model with only a single epoch: simply require that for every schedule the asynchronous iteration reaches a stable state. Unfortunately due to the asynchronous and distributed nature of the computation, and as discussed in Section II-E, our definition of a schedule does not assume reliable communication between routers. Consequently, in an arbitrary schedule a router may never activate or a pair of routers may never succeed in communicating. In such a schedule, it is clearly impossible for the protocol to converge to the desired stable state. Therefore, we need to restrict ourselves to only requiring that the protocol converges over reasonable schedules.
As long established in the asynchronous iterations literature [28], the right definition of "reasonable" is that the schedule contains pseudocycles. A pseudocycle is a period of time within an epoch such that for every participating router: all messages in flight to that router at the start of the pseudocycle are either dropped or arrive and, after this has occurred, the router performs at least one update. A formal definition of this concept is provided in Definition 13 in [25]. Informally, a pseudocycle can be thought of the asynchronous counterpart of a single synchronous iteration. Lemma 8 in [25] makes this intuition formal by proving that during a pseudocycle, the asynchronous model  makes at least as much progress towards the stable state as the synchronous model  would with a single synchronous iteration.
Another aspect that we must consider when moving from the synchronous to the asynchronous model is that of nondeterminism. As discussed in Section I-A, BGP suffers from non-deterministic convergence where the protocol may end up in multiple stable states, and which stable state is reached depends on the schedule and the initial state, rather than just the topology. This problem is known colloquially as a BGP wedgie [7]. Our definition of convergence should therefore require it to be deterministic, i.e. in each epoch only one stable state may be reached and that it is dependent only on the topology and the set of participants.
c) Dynamic: Finally, we now consider the full dynamic model with multiple epochs. In this scenario the network topology may change so frequently (i.e. the epochs may be so short), that the protocol never gets sufficient time to converge to a solution. Therefore we would like our definition of convergence to only require that the protocol will converge if given a sufficient period of stability. It is suggested in [25] that dynamic iterations should therefore be referred to as convergent rather than saying that they converge.
The final issue is that the protocol may only be convergent over some, rather than all, epochs and sets of participants. As shown by Sobrinho [12] and discussed further in Section III-D, DBF protocols only converge over network topologies that are free. Therefore the definition of convergent must be granular enough to express that the protocol is only convergent over a subset of epochs and sets of participants. A pair containing an epoch and a set of participants is referred to as a configuration. The set of all configurations C is therefore defined as:
C E × 2V

9

Taking all the above points into account, we therefore arrive at the following definition of what it means for our protocol to be convergent:
Definition 13 (Convergent). (Definition 14 from [25]) The DBF protocol is convergent over a set of configurations C  C iff:
1) for every configuration (e, p)  C there exists a fixed point Xep for FAep and a number of iterations kep.
2) for every initial state X, schedule (, , , ) and time t1 then if ((t1), (t1))  C and the time period [t1, t2] contains k(t1)(t1) pseudocycles then for every time t3 such that t3  t2 and (t2) = (t3) then t3 (X) = X(t1)(t1)
The essence of this definition is that for every valid configuration there exists a fixed point and a number of pseudocycles such that if, at an arbitrary point in time the configuration of the current epoch is in the set of valid configurations and the schedule contains that number of pseudocycles, then after those pseudocycles the protocol will have reach the fixed point and will remain in that fixed point until the end of the current epoch.
C. An existing convergence theorem
One of the most important advantages to using an established model of asynchronous iterations in Section II-E is that there already exist theorems describing sufficient conditions of such an iteration being convergent. The most powerful (and perhaps initially surprising) feature of these results is that the sufficient conditions only involve properties of the functions being iterated, FAep , rather than the full asynchronous iteration, . Consequently one can use them to prove that  is convergent without ever having to directly reason about the unreliable, asynchronous and dynamic nature of the underlying network, e.g. messages being lost or reordered, routers and links failing or being added.
In this paper, we will use the AMCO conditions from [25]. For a broader survey of the range of alternative sufficient conditions available see [28].
Definition 14 (AMCO, Definition 23 in [25]). The functions FAep are a set of asychronously metrically contracting operators (AMCO) over a set of configurations C if for every epoch e and set of participants p such that (e, p)  C then for all i  p there exists a distance function deip : Sn  Sn  N such that: D1 dei p is indiscernable
x, y : dei p(x, y) = 0  x = y
D2 dei p is bounded
n : x, y : dei p(x, y)  n
and if Dep(X, Y) = maxip dei p(Xi, Yi) then: D3 FAep is strictly contracting on orbits over Dep
X  Spn×n : FAep (X) = X  Dep(X, FAep (X) > Dep(FAep (X), (FAep )2(X))

D4 FAep is strictly contracting on fixed points over Dep:
X  Spn×n, X  Sn×n : FAep (X) = X  X = X  Dep(X, X) > Dep(X, FAep (X))
D5 FAep enforces accordancy:
X  Sn×n : FAep (X)  Spn×n
The properties required of an AMCO may seem complicated at first glance but each have clear interpretations. Firstly for every configuration in C there must exist a function deip which measures the distance between two routing table states (although it need not satisfy the formal definition of a metric). D1 requires that the distance between two states is zero iff the states are equal, and D2 that there exists a maximum distance. Distances over routing tables, deip, are then naturally lifted to distances over routing states Dep by calculating the maximum distance between the participating routing tables. D3 requires that the distance between the states after consecutive iterations strictly decreases, and D4 that if there exists a stable state then the distance to it strictly decreases after each iteration. Finally, D5 requires that applying the operator to an accordant state must always result in another accordant state.
Theorem 1. If FAep is a dynamic AMCO over a set of configurations C then  is convergent over C.
Proof. See Theorem 5 in [25] and the Agda proof [24].
Informally a synchronous version of the proof runs as follows: D3 require that each synchronous iteration moves the current state an increasingly smaller distance. As the distances are all bounded natural numbers by D2 then the distance must eventually reach zero, which by D1 means that one has reached a stable state. D4 then guarantees that this stable state is unique. With some non-trivial work, it is possible to lift this synchronous argument to an asynchronous argument because the distance function over routing states is decomposable into individual distance functions over routing tables.
The key point to take away is that by using this theorem in our later proofs, we reduce the problem of proving our model of the DBF protocol, , is convergent to merely constructing a suitable distance function dei p which interacts with FAep in the right way.
D. Types of routing algebras
In this section, we adapt the hierarchy of necessary and sufficient conditions for convergence established by Sobrinho [12] to our new simpler algebraic model1. The key insight of Sobrinho is that each of the routing algebra axioms in Definition 1 only reference either choice or extension, and that is the relationship between them that determines the convergence behaviour of the protocol.
1Our terminology differs slightly from that of Sobrinho as we use the traditional algebraic/order theoretic names for these conditions. In particular we use distributive instead of isotonic and increasing instead of monotonic. This is because the order theoretic notion of monotonicity, x  y  f (x)  f (y), is much more closely related to the notion of distributivity, f (x  y) = f (x)  f (y), than increasingness, x  f (x).

10

As discussed in Section I-A, the gold-standard are distribu- Lemma 2. If a path algebra (S, , E, 0, , path) is

tive algebras:

increasing then it is also strictly increasing.

Definition 15 (Distributive algebra). A routing algebra is distributive if:
f  E, x, y  S : f (x  y) = f (x)  f (y)
As was proven many times in the classic algebraic routing literature and, again by Sobrinho, then if the algebra is distributive then any stable state will necessarily be a globally optimal state in which every pair of routers is assigned the optimal path between them.
The next most desirable property for the algebra to have is to be increasing/strictly increasing:
Definition 16 (Increasing algebra). A routing algebra is increasing if:
f  E, x  S : x  f (x)
Definition 17 (Strictly increasing algebra). A routing algebra is strictly increasing if:
f  E, x  S : x =   x < f (x)
Sobrinho proved that the algebra being strictly increasing is a necessary and sufficient condition for a path-vector protocol to converge to some stable state in a given epoch. However, if the algebra is not distributive then that stable state will only be locally optimal rather than globally optimal, and some pairs of routers will end up using suboptimal paths.
Finally there is the freeness property over a particular network topology:
Definition 18 (Free network topology). A network topology A is free with respect to the routing algebra if there does not exist a cycle [(v1, v2), (v2, v3), ..., (vm, v1)] and a set of path-weights {x1, x2, . . . , xm} such that:
i : (vi-1, xi-1) A (vi, xi)
where i - 1 is calculated mod m.

Proof. Consider arbitrary i, j  V and f  Eij and x  S such that x = . We already have that x  f (x) as the algebra is increasing so it remains to show that x = f (x).
Suppose that f (x) = x. We then know that f (x) =  as x = . Likewise we know that path(x) =  as otherwise by Assumption P1 we would have x = . Therefore, by Assumption P3, we have that path(x) = path(f (x)) = (i, j) :: path(x) which is a contradiction. Therefore x = f (x) and we have the required result.
E. DBF convergence results
We now proceed to state our main convergence results, the proofs of which may be found in the appendices. We start by considering distance-vector protocols.
Theorem 2. If (S, , E, 0, ) is a routing algebra and S is finite then  is convergent over Cfree.
Proof. See Appendix B.
Theorem 2 says that for any distance-vector protocol with a finite set of path-weights then for any epoch and set of participating routers such that the network topology is free and given a sufficient period of stability in which the participating routers continue to activate and communicate, the protocol will always converge to the same stable state no matter the exact timing of messages and even in the presence of unreliable communication.
A more useful result for strictly increasing, finite algebras is then immediately obtainable which shows that such a distancevector protocol is always convergent.
Theorem 3. If (S, , E, 0, ) is a strictly increasing routing algebra and S is finite then  is always convergent.
Proof. As the algebra is strictly increasing then by Lemma 1 every configuration is free, and therefore we have the required result immediately by Theorem 2.

Intuitively a network is free if there does not exist a cycle where each router's current assignment can threaten the assignment of the previous router in the cycle. Sobrinho proved that the network topology being free with respect to the underlying algebra is a necessary and sufficient condition for a path-vector protocol to converge over that network, and that in the shortestpaths algebra this is equivalent to there being no negative weight cycles. Let Cfree be the set of configurations in which the participating topology is free, i.e.
Cfree = {(e, p)  C | Aep is free}
We now prove a couple of small lemmas showing some of the relationships between these properties.
Lemma 1. If a routing algebra is strictly increasing then every network topology is free.
Proof. See Theorem 2 & subsequent discussion in [12] or our Agda proof [24].

In practice the finiteness condition is restrictive and excludes many routing algebras of interest. For example even the shortest-path algebra uses the infinite set N as path weights. However recall that Theorems 2 & 3 guarantee that, given a sufficient period of stability, the protocol will reconverge even in the presence of messages from previous epochs. On the other hand shortest-path distance-vector protocols experience count-to-infinity problems when the state at the start of the epoch contains path-weights generated along paths that do not exist in the current topology. Finiteness is a sufficient condition to reduce count-to-infinity problems to merely count-toconvergence in distance-vector protocols. In the real world this is reflected in the design of RIP which artificially imposes a maximum hop count to ensure that S is finite.
A common approach to avoid the finiteness requirement (and count-to-convergence issues) is that of path-vector protocols which track the paths along which the path-weights are generated. Path-weights are then removed if their path contains a cycle.

11

Theorem 4. Given a path algebra (S, , E, 0, , path) then  is convergent over Cfree.
Proof. See Appendix C.
Again a more useful version of this proof for strictly increasing path algebras is immediately obtainable.
Theorem 5. Given an increasing path algebra (S, , E, 0, , path) then  is always convergent.
Proof. As the path algebra is increasing then by Lemma 2 it is also strictly increasing, and therefore by Lemma 1 every configuration is free. Hence we have the required result immediately by Theorem 4.
F. Novel contributions
We now recap the main contributions of these proofs over that of previous work.
a) Deterministic convergence: Sobrinho's proofs only guarantee that the protocol will converge, and nothing in his proof forbids the stable state reached depending on the state at the start of the epoch or the ordering of messages between routers during the epoch. In contrast our proofs guarantee that the protocol always converges to the same stable state, no matter the initial state or what the ordering of messages is. This therefore eliminates the possibility of phenomena such as BGP wedgies.
b) Unreliable communication: The definition of the dataflow function, , in Definition 4, Section II-E means that we only assume unreliable communication between routers. This is in contrast to previous proofs of convergence, for both general DBF protocols [12] and BGP in particular [10], that assume reliable communication. This means that our model and resulting proofs in later sections in theory apply to protocols built on-top of unreliable transport protocols such as UDP [30].
c) Extension to distance vector protocols: Theorems 2 & 3 apply to distance vector protocols, whereas Sobrinho's proofs only applied to path-vector protocols. In particular, this shows that convergence could still be guaranteed if complex conditional policies were added to distance-vector protocols like RIP.
IV. FORMALISATION IN AGDA
We have formalised every mathematical result in this paper, down to the most trivial lemma, in the Agda theorem prover. This includes the results about asynchronous iterative algorithms from [25]. As our proofs have been checked by a computer, we are far more confident in their correctness than usual. Even where we omit details or use standard informal mathematical reasoning to improve readability (e.g. Lemma 13 in Appendix C), the proofs are backed by mathematical arguments which are guaranteed to be fully rigorous.
Furthermore the act of formalisation itself was invaluable in creating and shaping these proofs. For example the unstructured way in which we initially laid out the pen-and-paper proof of Lemma 12 in Appendix C led us to overlook Case 2.3. Only when formalising the result, did we notice that this case

remained unproven. This in turn led us to presenting the proof in the much cleaner structure displayed in this paper.
The library of proofs is freely available [24] and is highly modular. To prototype a new policy language users need only define it as an algebra and prove that the algebra obeys the strictly increasing conditions in order to guarantee the resulting protocol is always convergent. Furthermore the protocol is then executable so that its dynamic behaviour can be observed for a given network and schedule. In Section V we give an outline of how to define such an algebra in Agda. We hope that the library's extensible nature means that it will be of use to the community when designing new policy languages.
V. A SAFE-BY-DESIGN ALGEBRA
We now present an example of how one could use our Agda library to develop a safe-by-design routing protocol. In particular, we explore the construction of a path-vector algebra that contains many of the features of BGP such as local preferences, community values [31] and conditional policies. These policies can perform operations such as path-filtering, path-inflation, modifying local preferences and communities. The conditions themselves are implemented using a simple language of predicates that includes the ability to inspect communities. The algebra is a generalisation of the Stratified Shortest Paths algebra [32].
It differs from the algebra underlying today's BGP in two crucial ways. Firstly, the implementation of the MED attribute violates the assumption that  is associative [33]. Secondly, BGP allows ASs to hide their local preferences and set them to arbitrary values upon importing routes from other ASs. This violates the assumption that the algebra is increasing.
Our algebra avoids these two issues by a) ignoring MED and b) having policies that only allow local preference to increase. For convenience, and to mirror the increasing terminology,
Note that we present our algebra only to give a practical example of how our theory can be used, and to show that "most" of the features of BGP are inherently safe. We are not presenting it as a practical solution to these two problems in real-world BGP. We discuss the open question of whether hidden information is compatible with increasing algebras in Section VI-B.
Path-weights in our protocol are defined as follows:
data PathWeight : Set where invalid : PathWeight valid : LocalPref  Communities  Path  PathWeight
i.e. there exists an invalid path-weight, and all other pathweights have a local preference, a set of communities and a path. The trivial path-weight, 0, is defined as:
0# : PathWeight 0# = valid (232-1)  []
where 232 - 1 is the highest possible local preference,  is the empty set of communities and [] is the empty path. The invalid path-weight, , is defined as:
# : PathWeight # = invalid

12

The choice operator, , is defined as:

__ : Op2 PathWeight

x

 y@(invalid)

=x

x@(invalid)  y

=y

x@(valid l cs p)  y@(valid m ds q) with compare l m

... | tri> l>m = x

... | tri< l<m = y

... | tri l=m with compare (length p) (length q)

... | tri< |p|<|q| = x

... | tri> |p|>|q| = y

... | tri |p|=|q| with p lex? q

...

| yes pq = x

...

| no qp = y

which operates as follows:
1) If either x or y is invalid return the other. 2) otherwise if the local pref of either x or y is strictly
greater than the other return that path-weight. 3) otherwise if the length of the path of either x or y is
strictly less than the other return that path-weight. 4) finally break ties by a lexicographic comparison of paths.
We will now construct the set of edge weights Eij. We start by defining a simple yet expressive language for conditions that can be used by our policy language to make decisions.

data Condition : Set where

_and_ : Condition  Condition  Condition

_or_ : Condition  Condition  Condition

not

: Condition  Condition

inPath : Node

 Condition

inComm : Community  Condition

hasPref : LocalPref  Condition

The semantics for these conditionals is defined as follows:

eval : Condition  PathWeight  Bool

eval (p and q) x

= eval p x  eval q x

eval (p or q) x

= eval p x  eval q x

eval (not p)

x

= not (eval p x)

eval (inComm c) (valid l cs p) = c ? cs

eval (inPath i) (valid l cs p) = i ? p

eval (hasPref v) (valid l cs p) = v =? l

eval _

invalid

= false

We next define the policy language as follows:

data Policy : Set1 where

reject

: Policy

decrPrefBy : N  Policy

addComm : Community  Policy

delComm : Community  Policy

inflate

: N  Policy

_;_

: Policy  Policy  Policy

if_then_ : Condition  Policy  Policy

The semantics of each type of policy are defined by the function that applies policies to path-weights:

apply : Policy  PathWeight  PathWeight

apply p

invalid

= invalid

apply reject

x

= invalid

apply (decrPrefBy v) (valid l cs p) = valid (l - v) cs p

apply (addComm c) (valid l cs p) = valid l (add c cs) p

apply (delComm c) (valid l cs p) = valid l (remove c cs) p

apply (inflate n)

(valid l cs p) = valid l cs (inflate p n)

apply (p ; q)

x

= apply q (apply p x)

apply (if c then p) x

= if (eval c x)

then (apply p x) else x

where the inflate function prepends n copies of the path's source on the front of the path. Note that since the policy language provides no way of increasing a path-weight's local preference or decrease the length of its path, it is not possible to define a non-increasing policy.
We define the set of edge weight functions Eij for each edge (i, j) as:

data Extension {n} (i j : Node n) : Set1 where ext : Policy  E i j

and the application of an extension function is defined as:

_ _ : Extension i j  PathWeight  PathWeight

(ext pol) invalid

= invalid

(ext pol) (valid l cs p) with (i , j) ? p | i ? p

... | no _ | _

= invalid

... | yes _ | yes _ = invalid

... | yes ijp | no ip = apply pol (valid l cs ((i , j) :: p))

where (i , j) ? p tests if the edge (i, j) is a valid extension of path p (i.e. if j = src(p)), and i /? p tests whether or not i already exists in p (i.e. if the resulting path would loop).
The path function from path-weights to simple paths required by a path algebra can be defined as:

path : PathWeight  Path

path invalid

=

path (valid _ _ p) = deflate p

where deflate strips from the path any consecutive duplicate routers that might have been introduced by inflate. The reader might have noted at this point that all our proofs in this paper work over simple paths, yet this algebra internally stores non-simple paths. However this apparent contradiction is resolved by observing that, as was discussed in Section II-F, the definition of a path algebra only requires that we can extract a simple path from a path-weight, rather than requiring that the path-weight stores a simple path. This demonstrates the power of the path algebra abstraction.
Taken together, the above definitions ensure that the algebra

(PathWeight, , Extension, 0#, #, path)

satisfies all the requirements of an increasing path algebra as defined in Section II-C. For formal proofs of these properties see the Agda formalisation [24].
Our implementation of Theorem 5 in Agda guarantees that a protocol based on this algebra converges from any state to a unique solution even in the presence of message loss, reordering and duplication, i.e. it is impossible to write policies that interfere with convergence.

13

There are many other features of BGP that are safely increasing but, for space reasons, are not included in this model. For example hierarchical AS paths are possible to add with minor tweaks to the path function and the policy language.
VI. OPEN QUESTIONS
A. Rate of convergence of path-vector protocols
One aspect of convergence that this paper does not address is how long it takes for convergence to occur. Consider a network of n routers. It has long been known that pathvector protocols with distributive, strictly increasing policies require (n) time to converge in the worst-case [1], [2]. However, it was only recently proved that non-distributive, strictly increasing path-vector protocols require (n2) time to converge in the worst-case [34]. Meanwhile, a tight bound for the time required for the worst-case convergence of pathvector protocols in free networks is still not known however. Current results have it lying between (n2) and O(n!).
Another question of interest is that it appears that not all non-distributive, strictly increasing algebras require (n2) iterations (e.g. the shortest-widest-paths algebra). We suspect that a careful analysis of policy language features might be able to tease apart distinct classes with respect to worst-case convergence time.
B. Hidden information
Unlike in (external) BGP, in the algebra described in Section V the local preference attribute is not deleted when exporting a route. This raises a more general issue for routing protocols that allow information to be hidden. It is an open question as to whether it is possible to have increasing algebras with hidden information without requiring global coordination.
Ensuring increasing policies in today's BGP may require communicating lost information with some other mechanism such as community values. Of course only the relative ranking of local preference values assigned within an AS matter. For example one AS might use a local preference of 100 for its most preferred routes, while another could use 2000. In this context can we ensure increasing policies using only bilateral agreements between neighbouring networks or does it truly require global coordination? If the latter, then a political rather than a technical solution is required.

VII. PREVIOUS VERSIONS OF THIS WORK A previous version of this work has appeared before in conference proceedings [26]. This version makes the following new contributions, listed in order of appearance: 1) in this version, the set of policy functions E in a rout-
ing algebra in Definition 1 are parameterised by edges, which allows us to define a path algebra in Definition 2 without having it depend on A, the current topology of the network. Although an apparently minor change, this makes the path algebras significantly easier to work with. 2) in this version we use the new dynamic model of asynchronous iterations from [25] rather than the static model from [28] which only captures the dynamics of a single epoch. This is not only a more accurate model as it can capture messages from non-participating nodes from previous epochs, but it also results in the model being fully executable. 3) as a consequence of the previous point, in this version we therefore use the dynamic AMCO convergence results from [25] instead of the static ultra-metric convergence results from Gurney [37] used in the previous version. 4) in the previous version we only proved results about strictly increasing algebras (Theorems 3 & 5), whereas in this version we include results about free networks (Theorems 2 & 4). With the exception of Theorems 2 & 4, much of this work appears in Chapters 4 & 5 in the PhD thesis of the first author [27].
VIII. ACKNOWLEDGEMENTS Matthew L. Daggitt was supported by an EPSRC Doctoral Train- ing grant and the ESPRC AISEC grant.
Dr Matthew L. Daggitt received his PhD degree in computer science from the University of Cambridge in 2018 and is currently working as a post-doc at Heriot-Watt University, Scotland. His main interests lie in the formal analysis and verification of complex systems, such as networking protocols and machine learning algorithms.

C. Verification of data-center policies
BGP is widely used today to implement (private) connectivity within and between data-centers [35]. In such an environment the network architects have total control of the global topology and therefore hidden information is not an issue. Yet even here we have witnessed the use of conditional policies, combined with filtering and the manipulation of local preference on routes. Perhaps tools such as Propane [36] could be extended to either ensure that all policies are strictly increasing, or at the very least provide warnings when they are not?

Timothy G Griffin received his B.S. degree in mathematics from the University of Wisconsin, Madison, in 1979, and M.S. and his Ph.D. degrees in computer science from Cornell University, Ithaca, NY, in 1985 and 1988, respectively. Previous experience includes teaching at UNICAMP in Brazil and more than a dozen years in industry at Bell Laboratories, AT&T Research, and Intel Labs. He joined the Computer Lab at the University of Cambridge in 2005.

14

REFERENCES
[1] M. Gondran and M. Minoux, Graphs, dioids and semirings: new models and algorithms. Springer Science & Business Media, 2008, vol. 41.
[2] J. S. Baras and G. Theodorakopoulos, "Path problems in networks," Synthesis Lectures on Communication Networks, vol. 3, no. 1, pp. 1­77, 2010.
[3] D. P. Bertsekas, R. G. Gallager, and P. Humblet, Data networks. Prentice-Hall International New Jersey, 1992, vol. 2.
[4] Y. Rekhter, T. Li, and S. Hares, "A border gateway protocol 4 (BGP-4)," RFC 4271, 2006. [Online]. Available: http://www.ietf.org/rfc/rfc4271.txt
[5] D. McPherson, V. Gill, D. Walton, and A. Retana, "Border gateway protocol (BGP) persistent route oscillation condition," RFC 3345, 2002. [Online]. Available: http://www.ietf.org/rfc/rfc3345.txt
[6] K. Varadhan, R. Govindan, and D. Estrin, "Persistent route oscillations in inter-domain routing," Computer networks, vol. 32, no. 1, pp. 1­16, 2000.
[7] T. G. Griffin and G. Huston, "BGP wedgies," RFC 4264, 2005. [Online]. Available: http://www.ietf.org/rfc/rfc4264.txt
[8] G. Huston, "Interconnection, peering and settlements: Part I," Internet Protocol Journal (Cisco), vol. 2, no. 1, June 1999.
[9] ----, "Interconnection, peering and settlements: Part II," Internet Protocol Journal (Cisco), vol. 2, no. 2, June 1999.
[10] L. Gao and J. Rexford, "Stable internet routing without global coordination," IEEE/ACM Transactions on Networking (TON), vol. 9, no. 6, pp. 681­692, 2001.
[11] J. L. Sobrinho and T. G. Griffin, "Routing in equilibrium," Mathematical Theory of Networks and System, 2010.
[12] J. L. Sobrinho, "An algebraic theory of dynamic network routing," IEEE/ACM Transactions on Networking (TON), vol. 13, no. 5, pp. 1160­ 1173, 2005.
[13] C.-K. Chau, "Policy-based routing with non-strict preferences," in Proceedings of the 2006 conference on Applications, technologies, architectures, and protocols for computer communications, 2006, pp. 387­398.
[14] J. L. Sobrinho and M. A. Ferreira, "Routing on multiple optimality criteria," in Proceedings of the Annual conference of the ACM Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication, 2020, pp. 211­225.
[15] A. J. Gurney and T. G. Griffin, "Lexicographic products in metarouting," in 2007 IEEE International Conference on Network Protocols. IEEE, 2007, pp. 113­122.
[16] H. Geng, X. Shi, X. Yin, Z. Wang, and S. Yin, "Algebra and algorithms for multipath QoS routing in link state networks," Journal of Communications and Networks, vol. 19, no. 2, pp. 189­200, 2017.
[17] M. J. Fischer, N. A. Lynch, and M. S. Paterson, "Impossibility of distributed consensus with one faulty process," Journal of the ACM (JACM), vol. 32, no. 2, pp. 374­382, 1985.
[18] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and S. Winwood, "seL4: Formal verification of an OS kernel," in Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles (SOSP), 2009.
[19] R. Kumar, M. O. Myreen, M. Norrish, and S. Owens, "CakeML: A Verified Implementation of ML," in POPL, 2014.
[20] X. Leroy, "Formal verification of a realistic compiler," Commun. ACM, vol. 52, no. 7, pp. 107­115, 2009.
[21] A. Guha, M. Reitblatt, and N. Foster, "Machine-verified network controllers," in PLDI, 2013.
[22] A. Zaostrovnykh, S. Pirelli, L. Pedrosa, K. Argyraki, and G. Candea, "A formally verified NAT," in SIGCOMM, 2017.
[23] U. Norell, "Dependently typed programming in Agda," in Proceedings of the 4th International Workshop on Types in Language Design and Implementation, 2009.
[24] M. L. Daggitt, R. Zmigrod, L. v. d. Stoep, and T. G. Griffin, "Agda routing library," 2021. [Online]. Available: https://github.com/ MatthewDaggitt/agda-routing/tree/ton2021
[25] M. L. Daggitt and T. G. Griffin, "Dynamic asynchronous iterations," 2020.
[26] M. L. Daggitt, A. J. Gurney, and T. G. Griffin, "Asynchronous convergence of policy-rich distributed bellman-ford routing protocols," in Proceedings of the 2018 Conference of the ACM Special Interest Group on Data Communication, 2018, pp. 103­116.

[27] M. L. Daggitt, "An algebraic perspective on the convergence of vector-based routing protocols," Ph.D. dissertation, University of Cambridge, 2019. [Online]. Available: https://www.repository.cam.ac. uk/handle/1810/292067
[28] A. Üresin and M. Dubois, "Parallel asynchronous algorithms for discrete data," Journal of the ACM (JACM), vol. 37, no. 3, pp. 588­606, 1990.
[29] B. A. Carré, "An algebra for network routing problems," IMA Journal of Applied Mathematics, vol. 7, no. 3, pp. 273­294, 1971.
[30] J. Postel, "User datagram protocol," RFC 768, 1980. [31] R. Chandra, P. Traina, and T. Li, "BGP communities attribute," RFC
1997, 1996. [Online]. Available: http://www.ietf.org/rfc/rfc1997.txt [32] T. G. Griffin, "Exploring the stratified shortest-paths problem,"
Networking Science, vol. 1, no. 1, pp. 2­14, Mar 2012. [Online]. Available: https://doi.org/10.1007/s13119-011-0003-6 [33] T. G. Griffin and G. Wilfong, "Analysis of the MED oscillation problem in bgp," in Network Protocols, 2002. Proceedings. 10th IEEE International Conference on. IEEE, 2002, pp. 90­99. [34] M. L. Daggitt and T. G. Griffin, "Rate of convergence of increasing pathvector routing protocols," in 2018 IEEE 26th International Conference on Network Protocols (ICNP). IEEE, 2018, pp. 335­345. [35] P. Lahiri, G. Chen, P. Lapukhov, E. Nkposong, D. Maltz, R. Toomey, and L. Yuan, "Building scalable data centers: BGP is the better IGP!" presentation, 2012. [36] R. Beckett, R. Mahajan, T. Millstein, J. Padhye, and D. Walker, "Don't mind the gap: Bridging network-wide objectives and device-level configurations," in Proceedings of the 2016 ACM SIGCOMM Conference, 2016. [37] A. J. T. Gurney, "Asynchronous iterations in ultrametric spaces," Tech. Rep., 2017. [Online]. Available: https://arxiv.org/abs/1701.07434

15

APPENDIX A NOTATIONAL GLOSSARY

Notation
V E P  i j k p
S  Eij E 0  path f  < x, y, z f
V Sn Sn×n A I FA  x, y X, Y X
T
E N      Aep  Spn×n C Cf ree t e p
A 
A
A
a, b, c
<ep hep rdDieeieppp

Meaning
Set of all node labels Set of all edges Set of all simple paths The invalid path Arbitrary origin node Arbitrary destination node Arbitrary neighbour node Arbitrary path
Set of path-weights Choice operator over path-weights Set of policy functions for edge (i, j) Set of all policy functions Trivial path-weight Invalid path-weight Function from path-weights to paths The constantly invalid policy Total order over path-weights Strict total order over path-weights Arbitrary path-weights Arbitrary policy function
Set of labels of nodes that participate Set of routing tables (n vectors over S) Set of states (n × n matrices over S) Arbitrary adjacency matrix Identity matrix A single sync. iteration with topology A Synchronous state function Arbitrary routing tables Arbitrary routing states Arbitrary stable state
The set of times of events of interest The set of epochs An arbitrary network Schedule activation function Schedule data flow function Schedule epoch function Schedule participants function Participants function Participation adjacency matrix Asynchronous state function Set of accordant states Set of all configurations Set of free configurations Arbitrary time Arbitrary epoch Arbitrary set of participants
Set of assignments Strict partial order over assignments Extended by relation over assignments Threatens relation over assignments Arbitrary assignments
Dislodging order over assignments Height function over assignments Distance function over path-weights Distance function over routing table states Distance function over routing states

Defined in
Section II-B Section II-B Section II-B Section II-B N/A N/A N/A N/A
Definition 1 Definition 1 Definition 1 Definition 1 Definition 1 Definition 1 Definition 2 Section II-D Definition 7 Definition 7 N/A N/A
Section II-D Section II-D Section II-D Section II-D Section II-D Section II-D Definition 3 N/A N/A N/A
Section II-E Section II-E Section II-E Definition 4 Definition 4 Definition 4 Definition 4 Section II-E Definition 5 Definition 6 Definition 12 Section III-B Section III-D N/A N/A N/A
Definition 8 Definition 9 Definition 10 Definition 11 N/A
Appendix B Appendix B Appendix B Appendix B Appendix B

16

APPENDIX B PROOF OF THEOREM 2 - DISTANCE VECTOR PROTOCOLS
This appendix contains the proof that distance-vector protocols over a finite routing algebra are convergent whenever the network topology is free.
Assume that we have a finite routing algebra (S, , E, 0, ) and some network N . We will prove that asynchronous model of the protocol  is convergent whenever the network topology Aep is free, by showing that the set of synchronous iterations FAep is an AMCO over Cfree. The required result then follows by Theorem 1.

A. Constructing the distance functions
Consider an arbitrary configuration consisting of an epoch e and set of participants p such that the participation topology Aep is free. To fulfil the AMCO conditions, for each router i we must construct a suitable distance functions, deip, that can be used to compare the different states of its routing
table. Intuitively, our notion of distance will be based upon the ability of the router i's current entries of dislodging entries in
other router's routing tables. We now describe the formal construction of such a distance
function. Note that for notational convenience, whenever we
refer to a concept that depends an adjacency matrix we will use ep as a shorthand for Aep. For example we will write F ep instead of FAep and ep instead of Aep .

1) Dislodgement order over assignments: To begin with we construct a strict partial order <ep over the set of assignments,

which we will call the dislodgement order. The key idea for

this is adapted from Sobrinho's notion of a couplet digraph

which we generalise to an assignment digraph. The vertices

of this digraph are the set of assignments A. There is an

edge from assignment a to assignment b in the digraph if,

in the current topology, either the latter is an extension of the former (i.e. a ep b), or the former is strictly preferred to the latter (i.e. a  b). Then a <ep b if there exists a path from
assignment a to assignment b in this digraph.

Mathematically this relation is the transitive closure of the union of the ep and  relations:

a <e1p b a <emp+1 b a <ep b

a ep b  a  b c : a <e1p c  c <emp b m : a <emp b

Intuitively, a <ep b describes a chain of events triggered by

a router choosing to use assignment a that would eventually

cause another router to remove assignment b from its routing

table, i.e. a can eventually cause b to be dislodged. In particular, each ep link represents an extension event and

each  link represents a choice event. The crucial properties of this relation are as follows:

O1 <ep is irreflexive - An assignment cannot dislodge itself.

a  A : a ep a

O2 <ep is transitive - If assignment a can dislodge b and b can dislodge c then a can dislodge c.

a, b, c  A : a <ep b  b <ep c  a <ep c

O3 <ep respects ep - If assignment a is extended by assignment b then a can dislodge b.
a, b  A : a ep b  a <ep b
O4 <ep respects < - If assignment a is strictly preferred to assignment b then a can dislodge b.
a, b  A : a  b  a <ep b
Properties O2, O3 and O4 are immediate from the definition of <ep. In contrast O1, the proof of irreflexivity, is non-trivial and uses the assumption that Aep is free. However, modulo the differences in the algebraic structures and the change from couplets to assignments, the proof is identical to that of Lemma 1 in the appendix of [12]. Readers interested in a proof using our algebraic model may consult our accompanying Agda code.

2) Height of assignments: As both S and V are finite, the set of assignments A is also finite. Therefore all upwards closed subsets under the relation <ep must also be finite. Consequently the height of an assignment can be defined as the number of assignments it is capable of dislodging:
hep(a) |{b  A | a <ep b}|
The crucial properties of hep are as follows: H1 If a is extended by b then the height of b is strictly less
than the height of a:
a, b  A : a ep b  hep(b) < hep(a)
H2 If a is strictly preferred to b then the height of b is strictly less than the height of a:
a, b  A : a  b  hep(b) < hep(a)
H3 There exists a maximum height:
H  N : a  A : hep(a)  H
H1 and H2 trivially follow from properties O1, O2, O3 and O4. H3 follows from the fact that A is finite.

3) Distance between path-weights: For each router i we can now construct a distance function riep : S × S  N between
path-weights as follows:

riep(x, y)

0

if x = y

1 + max(h(i, x), h(i, y)) otherwise

By this definition the distance between a pair of non-equal path-weights is proportional to the maximum number of assignments that are dislodgeable when router i chooses to use either x or y. Intuitively this is a reasonable measure of distance as if you have two alternative assignments then, from a convergence perspective, the seriousness of the disagreement between them is directly proportional to the number of resulting changes in the rest of the network when adopting one over the other.

17

4) Distance between routing tables: For each router i, the distance between a pair of routing table states that it may adopt is defined to be the maximum of the pairwise distances between their entries:

dei p(x, y)

max
jV

riep(xj , yj )

If the two routing tables are identical then they will have zero
distance between them, otherwise the distance is equal to the
maximum number of assignments that are dislodgeable by i
choosing to use a route that x and y disagree on. This is the distance function deip required by the AMCO conditions in Definition 14.

5) Distance between routing states: As required by the AMCO conditions, the distance function over routing states is defined as follows:

Dep(X, Y)

max
ip

dei p(Xi, Yi)

Again Dep measures the distance between states X and Y. If all the elements of X and Y are equal then there is zero distance between them, otherwise the distance is equal to the maximum number of assignments that are dislodgeable by any participating router i choosing a route that X and Y disagree on.

B. Properties of the distance functions

We must conditions.

now It is

show that clear that

ddeieipp

and Dep is always

satisfy the AMCO less than or equal

to H + 1 by can be shown

Hth3atarniedp/tdheiapt/Ddeiepp(xfo,rym)

= an

0 iff x = y. In fact it ultrametric space over

S/Sn/Sn×n but showing this is not necessary for the AMCO

conditions. Therefore it remains to show that F ep is both strictly

contracting over orbits and strictly contracting over any fixed point. In fact, in this particular case F ep can be shown to be

strictly contracting:

X =p Y  Dep(F ep(X), F ep(Y)) < Dep(X, Y)

which implies it is strictly contracting over both orbits and any fixed points.
However, instead of proving this result directly, we will first separate out a couple of smaller lemmas which we will later reuse in Appendix C in the proof of convergence for pathvector protocols.

Lemma 3. After an iteration, any router i's path-weight to itself is always the trivial path-weight:

i, X : F ep(X)ii = 0
Proof. F ep(X)ii = Iii by Equation 5 in Section II-D and Iii = 0 by definition of I.
Lemma 4. For each destination, the maximum distance between all entries of two routing states must strictly decrease after a single synchronous iteration:

X, Y, i, j, v > 0 : (k : rkep(Xkj , Ykj )  v)  riep(F ep(X)ij , F ep(Y)ij ) < v

Proof. Assume

k : rkep(Xkj , Ykj )  v

(6)

Case 1: F ep(X)ij = F ep(Y)ij

Then the required inequality is immediate as:

riep(F ep(X)ij, F ep(Y)ij) = 0 (by Case 1 and def. of riep)

<v

(by v > 0)

Case 2: F ep(X)ij = F ep(Y)ij

Without loss of generality assume that F ep(X)ij is a more desirable path-weight than F ep(Y)ij and therefore:

F ep(X)ij < F ep(Y)ij

(7)

Case 2.1: i = j

A router's path-weight to itself is always the trivial path-weight by Lemma 3 and so if i = j then F ep(X)ij = 0 = F ep(Y)ij
which contradicts the assumption of Case 2.

Case 2.2: i = j

Consequently by Equation 5 in Section II-D:

F ep(X)ij =

Aeikp(Xkj )

k

and so as  is selective there must exist a router k such that:

F ep(X)ij = Aeikp(Xkj )

(8)

If Xkj =  then F ep(X)ij =  which contradicts (7) and

therefore:

Xkj = 

(9)

It cannot be the case that Xkj = Ykj as otherwise it would be possible to prove the following:

F ep(X)ij = Aeikp(Xkj ) = Aeikp(Ykj )



Aeikp(Ykj )

k

= F ep(Y)ij

(by (8)) (by Xkj = Ykj ) (by def. of )
(by Case 2.2 & Equation 5)

which again contradicts (7) and so:

Xkj = Ykj

(10)

The required inequality can now be proved as follows:

riep(F ep(X)ij , F ep(Y)ij ))

= 1 + max(hep(i, F ep(X)ij), hep(i, F ep(Y)ij))

= 1 + hep(i, F ep(X)ij )

(by def. of riep & Case 2) (by H2 & (7))

< 1 + hep(k, Xkj)

(by H1 & (8))

 1 + max(hep(k, Xkj), hep(k, Ykj)) (by def. of max)

= rkep(Xkj , Ykj )

(by def. of rkep and (10))

v

(by (6))

18

We can now use Lemma 4 to prove that F ep is strictly contracting.

Lemma 5. The operator F ep is strictly contracting w.r.t. Dep over Spn×n.
X, Y  Spn×n : X =p Y  Dep(F ep(X), F ep(Y)) < Dep(X, Y)

Proof. Consider states X, Y  Spn×n such that X = Y. As:

Dep(F ep(X), F ep(Y)) = max
ip,jV

riep(F ep(X)ij , F ep(Y)ij )

it suffices to show for all routers i  p and j  V that

riep(F ep(X)ij , F ep(Y)ij ) < Dep(X, Y)

This can be achieved by applying Lemma 4 where
v = Dep(X, Y). However in order to apply the lemma we
must first check that 0 < Dep(X, Y) and that for all routers k then rkep(Xkj , Ykj )  Dep(X, Y).
The former holds as X = Y and X, Y  Spn×n so there must exist entries in participating routers in X and Y which

are a non-zero distance apart. To show that the latter holds

consider whether or not k is participating. If k  p then the required inequality holds simply from the definition of Dep.

Otherwise if k / p then as X and Y are accordant with p

then Xkj = Ykj =  and the inequality holds trivially as rkep(Xkj , Ykj ) = 0.

Finally all the pieces to show that the set of functions F ep are

an AMCO over Cfree have now been assembled. In particular:

D1:

x, y : dei p(x, y) = 0  x = y Immediate from the definition of

dei p

and

riep.

D2: n : x, y : dei p(x, y)  n

The height of assignments is bounded above by H and

hence every distance is bounded above 1 + H. D3: F ep is strictly contracting on orbits over Dep
Immediate by applying Lemma 5 to X and F ep(X). D4: F ep is strictly contracting on fixed points over Dep
Immediate by applying Lemma 5 to X and X. D5: X : F ep(X)  Spn×n.
Immediate by the definition of F ep as Aep discards the

state of all non-participating routers.

As F ep is an AMCO over Cfree then Theorem 1 we have that

 is convergent over (S, , E, 0, ) whenever the network

topology is free.

19

APPENDIX C PROOF OF THEOREM 4 - PATH-VECTOR PROTOCOLS
As discussed in Section III-E, the requirement that S, the set of path-weights, is finite proves very restrictive in practice. One principled approach to avoiding this requirement is that of path-vector protocols which track and remove path-weights generated along looping paths, as encoded by the path algebra axioms in Definition 2. This turns out to be sufficient to guarantee that eventually the protocol will always reach a finite subset of consistent path-weights from which it will then converge. As with distance vector protocols, we will use this to construct a suitable set of distance functions riep that fulfil the AMCO conditions.

A. Consistent path-weights
We now formally define the notion of a path-weight being consistent with the current network topology. Consider an arbitrary path algebra (S, , E, 0, , path).

Definition 19 (Weight of a path). The weightA : P  S, which calculates the weight of a path p with respect to the current network topology A, is defined as:

weightA(p)

  
0
Aij (weightA (q))

if p =  if p = [ ] if p = (i, j) :: q

Definition 20. A path-weight x is consistent with respect to the topology A iff it is equal to the current weight of the path along which it was generated. The set of consistent routes and the set of consistent routing states are therefore defined to be:

CA {x  S | weightA(path(x)) = x} CAn×n {X  Sn×n | i, j : Xij  CA}
The following lemmas show that consistency is preserved by the routing operations.

Lemma 6. Choice preserves consistency:

x, y  CA : x  y  CA

Proof. Immediate from axiom R3 that  is selective.

Lemma 7. Extension preserves consistency:

i, j  V, x  CA : Aij(x)  CA

Proof. Consider a path-weight x  CA being extended along an arbitrary edge (i, j). By axiom P3 in the definition of a path algebra there are two cases. Case 1: path(Aij(x)) = 
Then the required result follows:

weightA (path(Aij (x))) = weightA() = = Aij(x)

(by Case 1) (by def. of weightA) (by axiom P1 and Case 1)

Case 2: path(Aij(x)) = (i, j) :: path(x)

Then we have the required result as follows:

weightA (path(Aij (x))) = weightA((i, j) :: path(x)) = Aij(weightA(path(x)) = Aij(x)

(by Case 2) (by def. of weightA)
(by x  CA)

Lemma 8. A single synchronous iteration preserves consistency:
X  CAn×n : FA(X)  CAn×n
Proof. This is an immediate from Lemmas 6 & 7 as every operation in FA preserves consistency.
One consequence of Lemma 8 is that applying an update never spontaneously introduces new inconsistent path-weights into the routing state. Therefore the only way inconsistent pathweights can be introduced into the routing state is by the network topology changing (consequently beginning a new epoch).
Lemma 9. CA is finite.
Proof. By Definition 20 every consistent path-weight is associated with at least one simple path in the current network topology. The set of consistent path-weights, CA, is therefore equal to:
CA = {weightA(p) | p  P }
where P is the set of simple paths in topology A. As P is finite, so too is CA.
As in the previous section, in order to prove that  is convergent in epochs where then network topology is free. it is necessary to find a quantity that always decreases when applying FA. The key insight is that because the set of consistent path-weights is finite and consistency is preserved by iteration, it is therefore possible to reuse the distance functions defined in Section B when calculating the distance between two consistent states. In particular, FA remains strictly contracting over this distance function with respect to the set of consistent states. The remaining problem is to find a quantity that decreases when applying FA to a routing state that contains inconsistent path-weights.
The solution is to consider the lengths of the inconsistent paths in the state. In particular the length of the shortest inconsistent path, s(X) in the state X must strictly increase after a single iteration. This is because the contraposition of Lemma 8 implies that the shortest inconsistent path-weight in FA(X) must be an extension of some inconsistent path-weight in X. By P3 the paths of the two path-weights must be of the form (i, j) :: p and p respectively, and by definition of s(X) we have that s(X)  |p|. Hence s(X)  |p| < |(i, j) :: p| = s(FA(X)).
One simple consequence of is that, in the absence of further topology changes, eventually all inconsistent path-weights must be flushed from the state. This follows as if the length of the path of the shortest inconsistent path-weight continues to increase then eventually all inconsistent path-weights must be

20

Distance vector

hei p

=

Path vector

heCpi

heIp

riep

=

rCepi

rIep

riep

2) Inconsistent distance function: The inconsistent height can be used to define the inconsistent distance function rIep : S × S  N as follows:
rIep(x, y) max(heIp(x), heIp(y))
This will always be used to compare pairs of path-weights in which at least one is inconsistent. Therefore the inconsistent distance between two path-weights is proportional to the length of the shortest inconsistent path. Note this definition does not contain a check for equality as in practice it will never be used to compare two equal path-weights.

dei p

dei p

Dep

Dep

Fig. 2. The construction of the distance functions in the convergence proofs.

of at least length n. Hence their path will necessarily contain a loop and therefore they will be flushed from the routing state as a consequence of assumption P3. Therefore after n applications of FA the state must be consistent.
Consequently "n - s(X)" provides the required strictly decreasing quantity for inconsistent states. The two separate strictly decreasing quantities, the length of the shortest inconsistent path and the height of the consistent routes, can then be combined to form a unified strictly decreasing distance function over both inconsistent and consistent path-weights. Figure 2 shows how all the distance functions fit together.

B. Constructing the distance functions
Consider an arbitrary configuration consisting of an epoch e and set of participants p such that the participation topology Aep is free. Note that once again for notational convenience, whenever we refer to a concept that depends an adjacency matrix we will use ep as a shorthand for Aep. For example we will write F ep instead of FAep and Cep instead of CAep .
1) Inconsistent height of path-weights: With the above discussion in mind, the inconsistent height of a path-weight heIp : S  N is defined as:

3) Consistent distance function: As discussed, the set of
path-weights consistent with the current network topology
is finite and consistency is closed over the routing algebra operations. Therefore (Cep, , E, 0, ) forms a finite routing algebra and consequently the previous metric riep from Section B may be used to compare consistent path-weights. This will be renamed to rCepi : CAep × CAep  N. The maximum such consistent distance H will also be renamed to HC.

4) Distance between path-weights: Given both the con-
sistent and inconsistent distance functions, then the overall distance function over path-weights riep : S×S  N is defined as:



0

riep(x,

y)

=

 rCepi(x,

y)

1 + HC + rIep(x, y)

if x = y if x = y  {x, y}  Cep if x = y  {x, y} Cep

If the two path-weights are equal then the distance between them is zero. If the two path-weights are not equal but both ctihnoesntmseia.sdtOe. ntTht hetrehweqnisueranCeaptitityilsea1usst+eodHnetoCisciosimnacpdoudntesedistthteoentrdIeaispnt(daxn,rcyIee)pbtieostwulaesteeednr ensure that the required strictly contracting properties hold. In particular the fact that the distance between inconsistent path-weights is always greater than the distance between consistent path-weights guarantees that the distance is still strictly decreasing when the last inconsistent path-weight is flushed from the routing state.

5) Distance function over routing tables: As before, the distance function over routing tables can now be defined as:

dei p(x, y)

=

max
jV

riep(xj , yj )

heIp(x)

0

if x  Cep

1 + (n - |path(x)|) otherwise

where n is the number of routers in the network. All consistent path-weights have the minimum height 0, and the maximum height is n + 1 as the path function only returns simple paths. To explicitly highlight the parallels with the previous section, this maximum height will be called HI . Therefore for all pathweights x then the following relationships hold:
0  heIp(x)  n + 1 = HI

The distance between two routing tables is therefore propor-
tional to the length of the shortest inconsistent path-weight,
or, if no such path-weight exists, the desirability of the best consistent path-weight. This is the distance function deip required by the AMCO conditions in Definition 14.

6) Distance function over states: Finally, as required by the
AMCO conditions, the distance function over routing states, Dep, is defined as follows:

Dep(X, Y)

=

max
ip

dei p(Xi, Yi)

21

C. Properties of the distance functions

As in the proof for distance-vector protocols, we will now

show that F ep above 1 + HC

is an AMCO. It + HI and that

is obvious dei p(x, y)

that =0

dei p iff

is x

bounded = y. As

in Appendix B, it is unnecessary but possible to show that

riep/dei p/Dep form an ultrametric space over S/Sn/Sn×n. However, unlike Appendix B, the iteration F ep is not strictly

contracting with respect to Dep. Therefore it is is necessary

to prove that F ep is both strictly contracting on orbits and

strictly contracting on fixed points separately. As before, we

first prove a couple of useful auxiliary lemmas.

Lemma 10. If any routing table entry is inconsistent, then there must have an inconsistent routing table entry in the previous state with the same destination which has changed since the last state:
X, i, j : F ep(X)ij / CA  k : Xkj / CA  Xkj = F ep(X)kj
Proof. As the path-weight F ep(X)ij is inconsistent, by Lemma 8 it must be an extension of some inconsistent pathweight in X. Therefore there exists a router l such that F ep(X)ij = Aeilp(Xlj) and Xlj is inconsistent.
If Xlj = F ep(X)lj then l is the required router. Otherwise if Xlj = F ep(X)lj then F ep(X)lj is inconsistent. Therefore the entire argument can be repeated with F ep(X)lj. However as F ep(X)ij = Aeijp(Xlj ) = Aeijp(F ep(X)lj ) the path of F ep(X)lj must be strictly shorter than the path of F ep(X)ij. The length of the path cannot decrease indefinitely and therefore this argument must eventually terminate.

The next lemma corresponds to Lemma 4 in the proof of convergence for distance-vector protocols.

Lemma 11. For each destination, the maximum distance between all entries of three consecutive routing states must strictly decrease:

X, i, j, v > 0 : (k : rkep(Xkj, F ep(X)kj)  v)  riep(F ep(X)ij , (F ep)2(X)ij ) < v

Proof. Assume

k : rkep(Xkj , F ep(X)kj )  v

(11)

Case 1: F ep(X)ij = (F ep)2(X)ij

Then the inequality is immediate as:

riep(F ep(X)ij , (F ep)2(X)ij ) = 0 (by Case 1 & def riep)

<v

(by lemma ass.)

Case 2: F ep(X)ij = (F ep)2(X)ij and F ep(X)ij and (F ep)2(X)ij are both consistent.
Case 2.1: X is consistent
If X is consistent then F ep(X) must also be consistent and so all path-weights involved are consistent. As the topology is cycle-free then the required inequality is therefore immediate from Lemma 4 in Appendix B.

Case 2.2: X is inconsistent

If X is inconsistent then there must exist routers k and l such that

Xkl / Cep

(12)

Xkl = F ep(X)kl

(13)

To see why, consider whether F ep(X) is consistent. If F ep(X) is consistent then any inconsistent entry in X will suffice. If F ep(X) is inconsistent, then there exists an inconsistent entry F ep(X)ml in which case the required k may be obtained from Lemma 10.
The required inequality then follows as:

riep(F ep(X)ij , (F ep)2(X)ij ) = rCepi(F ep(X)ij , (F ep)2(X)ij ) < HC + rIepk(Xkl, F ep(X)kl) = rkep(Xkl, F ep(X)kl)
v

(by Case 2 & def riep) (by rCepk  HC )
(by def riep, (12) & (13))
(by (11))

Case 3: F ep(X)ij = (F ep)2(X)ij and F ep(X)ij or (F ep)2(X)ij is inconsistent.
As either F ep(X) or (F ep)2(X) is inconsistent then by Lemma 7 we have that X must be inconsistent as well. Let Xkl be the inconsistent path-weight with the shortest path in X. As all inconsistent path-weights in F ep(X) and (F ep)2(X) are an extension of inconsistent path-weights in X, the path of Xkl must be shorter than the paths of all inconsistent pathweights in F ep(X) and (F ep)2(X) and so

max(heIp(F ep(X)ij ), heIp((F ep)2(X)ij )) < heIp(Xkl) (14) Xkl = F ep(X)kl (15)

The inequality then follows as:

riep(F ep(X)ij , (F ep)2(X)ij )

= HC + rIep(F ep(X)ij , (F ep)2(X)ij ) (by Case 3 & def riep)

< HC + 1 + heIp(Xkl)

(by (14))

 HC + 1 + max(heIp(Xkl), heIp(F ep(X)kl)) (by def max)

= rkep(Xkl, F ep(X)kl)

(by def rkep, (12) & (15))

v

(by (11))

Hence the required inequality holds in all cases.

The required strictly contracting on orbits property can now be proved using the above lemma. Lemma 12. F ep is strictly contracting on orbits over Dep. Proof. Consider an arbitrary state X  Spn×n. Then it must be shown that if X = F ep(X) then:
Dp(F ep(X), (F ep)2(X)) < Dp(X, F ep(X))

As

Dep(F ep(X), (F ep)2(X))

=

max
ip,jV

riep(F ep(X)ij , (F ep)2(X)ij )

22

it suffices to show for all routers i  p and j  V that
riep(F ep(X)ij , (F ep)2(X)ij ) < Dep(X, F ep(X))
This can be proved by applying Lemma 11 where v = Dep(X, F ep(X)). However to apply the lemma it must be verified that 0 < Dp(X, F ep(X)) and that for all routers k then rkep(Xkj , F ep(X)kj )  Dep(X, F ep(X)).
The former holds as X is accordant and X = F ep(X) and so there must exist entries for participating routers in X and F ep(X) which are a non-zero distance apart. To show that the latter holds consider whether or not router k is participating. If k  p then the required inequality holds simply from the definition of Dep. If k / p then, as X and F ep(X) are accordant, Xkj =  = F ep(X)kj and therefore the inequality holds trivially as rkep(Xkj, F ep(X)kj) = 0.
Lemma 13. F ep is strictly contracting on fixed points over Dep.
Proof. The proof has the same structure as Lemmas 11 & 12. The only major difference is that some of the cases in the corresponding version of Lemma 11 are redundant as the fixed point X is guaranteed to be consistent. This must be the case, as if X was inconsistent then applying F ep would increase the length of the shortest inconsistent path. Interested readers can find the remaining details in the Agda formalisation [24].

Finally all the pieces to show that the set of functions F ep are an AMCO over Cfree have now been assembled. In particular:

(DU1)

x, y : dei p(x, y) = 0  x = y Immediate from the definition of

dei p

and

riep.

(DU2)

dei p is bounded The maximum distance

riep,

and

therefore

dei p,

can

return is 1 + HC + HI .

(DU3) F ep is strictly contracting on orbits over Dep

Proved in Lemma 12. (DU4) F ep is strictly contracting on fixed points over Dep

Proved in Lemma 13. (DU5) X : F ep(X)  Spn×n.
Immediate by the definition of F ep.

As F ep is an AMCO over Cfree then by Theorem 1 we have

that  is convergent over (S, , E, 0, , path) whenever

the network topology is free.

