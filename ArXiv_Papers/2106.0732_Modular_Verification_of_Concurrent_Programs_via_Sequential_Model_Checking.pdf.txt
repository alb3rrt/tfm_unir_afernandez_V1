arXiv:2106.00732v1 [cs.PL] 1 Jun 2021

Modular Verification of Concurrent Programs via Sequential Model Checking
Dan Rasin1, Orna Grumberg1, and Sharon Shoham2
1 Technion ­ Israel Institute of Technology 2 Tel-Aviv University
Abstract. This work utilizes the plethora of work on verification of sequential programs for the purpose of verifying concurrent programs. We reduce the verification of a concurrent program to a series of verification tasks of sequential programs. Our approach is modular in the sense that each sequential verification task roughly corresponds to the verification of a single thread, with some additional information about the environment in which it operates. Information regarding the environment is gathered during the run of the algorithm, by need. While our approach is general, it specializes on concurrent programs where the threads are structured hierarchically. The idea is to exploit the hierarchy in order to minimize the amount of information that needs to be transferred between threads. To that end, we verify one of the threads, considered "main", as a sequential program. Its verification process initiates queries to its "environment" (which may contain multiple threads). Those queries are answered by sequential verification, if the environment consists of a single thread, or, otherwise, by applying the same hierarchical algorithm on the environment. Our technique is fully automatic, and allows us to use any off-the-shelf sequential model checker. We implemented our technique in a tool called CoMuS and evaluated it against established tools for concurrent verification. Our experiments show that it works particularly well on hierarchically structured programs.
1 Introduction
Verification of concurrent programs is known to be extremely hard. On top of the challenges inherent in verifying sequential programs, it adds the need to consider a high (typically unbounded) number of thread interleavings. An appealing direction is to exploit the modular structure of such programs in verification. Usually, however, a property of the whole system cannot be partitioned into a set of properties that are local to the individual threads. Thus, some knowledge about the interaction of a thread with its environment is required.
In this work we develop a new approach, which utilizes the plethora of work on verification of sequential programs for the purpose of modularly verifying the safety of concurrent programs. Our technique automatically reduces the verification of a concurrent program to a series of verification tasks of sequential programs. This allows us to benefit from any past, as well as future, progress in sequential verification.
Our approach is modular in the sense that each sequential verification task roughly corresponds to the verification of a single thread, with some additional information

2
about the environment in which it operates. This information is automatically and lazily discovered during the run of the algorithm, when needed.
While our approach is general, it specializes on concurrent programs where the threads are structured hierarchically as it takes a hierarchical view of the program. Namely, for the purpose of verification, one of the threads, tM , is considered "main", and all other threads are considered its "environment". The idea is to exploit the hierarchy in order to minimize the amount of information that needs to be transferred between the verification tasks of different threads.
We first analyze tM using sequential verification, where, for soundness, all interferences from the environment are abstracted (over-approximated) by a function env move, which is called by tM whenever a context switch should be considered. Initially, env move havocs all shared variables; it is gradually refined during the run of the algorithm. When the sequential model checker discovers a violation of safety in tM , it also returns a path leading to the violation. The path may include calls to env move, in which case the violation may be spurious (due to the over-approximation). Therefore, the algorithm initiates queries to the environment of tM whose goal is to check whether certain interferences, as observed on the violating path, are feasible. Whenever an interference turns out to be infeasible, the env move function is refined to exclude it. Eventually, env move becomes precise enough to enable full verification of the desired property on the augmented tM . Alternatively, it can reveal a real counterexample in tM .
The queries are checked on the environment (that may consist of multiple threads) in the same modular manner. Thus we obtain a hierarchical modular verification. Along the algorithm, each thread learns about the next threads in the hierarchy, and is provided with assumptions from former threads in the hierarchy to guide its learning. When the program has a hierarchical structure that is aligned with the verification process, this makes the assumptions simpler and speeds up verification.
Our technique is fully automatic and performs unbounded verification, i.e., it can both find bugs and prove safety in concurrent programs even with unbounded executions (e.g., due to loops), as long as the number of threads is fixed. It works on the level of program code and generates standard sequential programs in its intermediate checks. This allows us to use any off-the-shelf sequential model-checker. In particular, we can handle concurrent programs with an infinite state-space, provided that the sequential model checker supports such programs (as is the case in our implementation).
We implemented our technique in a prototype called Concurrent to Multiple Sequential (CoMuS) and evaluated it against established tools for unbounded verification of concurrent C programs. We use SeaHorn [18] to model check sequential programs.
Our experiments show that the approach works particularly well on programs in which the threads are arranged as a chain, t1, t2, . . . , tk, where thread ti depends only on its immediate successor ti+1 in the chain. This induces a natural hierarchical structure in which t1 is the main thread with environment t2, . . . , tk; thread t2 is the main thread in the environment, and so on. This structure often occurs in concurrent implementations of dynamic programming algorithms.
To summarize, the main contributions of our work are as follows:

3
­ We present a new modular verification approach that reduces the verification of a concurrent program to a series of verification tasks of sequential programs. Any off-the-shelf model checker for sequential programs can thus be used.
­ Our approach takes a hierarchical view of the program, where each thread learns about the next threads in the hierarchy, and is provided with assumptions from former threads to guide its learning.
­ The needed information on a thread's environment is gathered in the code, automatically and lazily, during the run of the algorithm.
­ We implemented our approach and showed that as the number of threads grows, it outperforms existing tools on programs that have a hierarchical structure, such as concurrent implementations of dynamic programming algorithms.
1.1 Related Work
The idea of code transformation to a sequential program appeared in [32,33,24]. However, these works translate the concurrent program to a single nondeterministic sequential program. In contrast, our technique exploits the modular structure of the program.
In the rest of this section, we address unbounded modular techniques for proving safety properties of concurrent programs. Other techniques use bounded model checking, where the bound can address different parameters, such as the number of context switches [19,33], write operations [32] or loop iterations [29,1,35].
The work most closely related to ours is [16,17]. Their technique uses predicate abstraction of both states and environment transitions (similar to our env move), as part of an automatic modular verification framework. The technique also iteratively refines this abstraction by checking possible witnesses of errors. However, they treat all threads symmetrically, whereas our approach exploits a hierarchical view of the program. In addition, [16,17] explore abstract single threads using reachability trees, which are inherent to their technique. We, on the other hand, represent threads (augmented with some environment information) as stand-alone C programs. Thus, we can use any offthe-shelf model checker to address the "sequential part" of the verification problem.
The works in [9,20,12] suggest to apply rely-guarantee reasoning for concurrent (or asynchronous) programs, while the different sections of the program can be verified sequentially. However, their technique requires human effort to specify the rely-guarantee conditions, whereas our approach is completely automatic.
[10] suggests a modular algorithm with rely-guarantee reasoning and automatic condition inference. [21] formalizes the algorithm in the framework of abstract interpretation. However, their algorithm requires finite state systems, and its inferred conditions only refer to changes in global variables. Hence, they fail to prove properties where local variables are necessary for the proof. In our approach, reasoning about local variables is allowed, when we learn that they are necessary for verification. Such variables are then turned into global variables, but their behavior is abstracted, preserving modularity. [6] also tackles the incompetence of modular proofs by exposing local variables as global, according to counterexamples. However, their approach uses BDDs and suits finite state systems. Similar to [16], they treat threads symmetrically. Our approach is applicable to infinite state systems and uses a guided search to derive cross-thread information.

4
Our queries resemble queries in learning-based compositional verification [5,25], which are also answered by a model checker. Our hierarchical recursive approach resembles the n-way decomposition handled in [25]. However, these works represent programs, assumptions and specification as LTSs, and although extended to deal with shared memory in [31] these algorithms are suitable for finite state systems.
Several works such as [11,14,34,28], tackle the interleaving explosion problem by performing a thread interleaving reduction. [34] combines partial order reduction [13] with the impact algorithm [22], whereas [28] identifies reducible blocks for compositional verification. These approaches are complementary to ours, as our first step is performing an interleaving reduction (to identify cut-points for env move calls).
2 Preliminaries
Sequential Programs. A sequential program P is defined by a control flow graph whose nodes are a set of program locations L (also called labels), and whose edges E are a subset of L × L. The program has an initial label, denoted linit  L. Each node l is associated with a command c  cmds, denoted cmd(l), which can be an assignment or an if command, as well as havoc, assume and assert (explained below). Intuitively, we think of standard C programs (that may contain loops as well), which can be trivially compiled to such control flow graphs. The program may also include non-recursive functions, which will be handled by inlining.
The program is defined over a set of variables V . Conditions in the program are quantifier-free first-order-logic formulas over V . A special variable pc  V , ranging over L, indicates the program location. A state s of P is a pair (l, ) where l  L is the value of pc and  is a valuation of V . Variables may have unbounded domains, resulting in a potentially infinite state-space. We also assume the existence of a special error state, denoted = (l , ). We denote by l(s) and (s) the first and second components (resp.) of a state s = (l, ). Given an initialization formula init over V , the set of initial states consists of all states (linit, ) where  |= init.
For s = (l, ), let cmd(s) = cmd(l). We denote next(s) = {s | s can be obtained from s using cmd(s)}. This set is defined according to the command. In particular, s  next(s) implies that (l(s), l(s ))  E. The definition of next(s) for assignments and if commands is standard. A v=havoc() command assigns a non-deterministic value to the variable v. An assume(b) command is used to disregard any computation in which the condition b does not hold. Formally, if s = (l, ) and cmd(s)=assume(b), then  b  next(s) = {(l , )} where l = l is the unique label such that (l, l )  E, and  b  next(s) = . An assert(b) command is defined similarly, except that it moves to the error state if b is violated.
A computation  of P is a sequence  = s0 - s1 - . . . - sn for some n  0 s.t. for every two adjacent states si, si+1: si+1  next(si).  is an initial computation in P if it starts from an initial state.  is a reachable computation in P if there exists an initial computation  for which  is the suffix. The path of a computation (l0, 0) - . . . - (ln, n) is the sequence of program locations l0, . . . , ln.
Preconditions and Postconditions. Given a condition q over V and an edge e = (l, l ), a precondition of q w.r.t. e, denoted pre(e, q), is any condition p such that for every

5
state s, if (s) p and l(s) = l then there exists s  next(s) s.t. (s ) q and l(s ) = l 3. A precondition extends to a path  = l0, . . . , ln in the natural way. The weakest precondition of q w.r.t. e (resp., ) is implied by any other precondition, and can be computed in the standard way [8]. We denote it wp(e, q) (resp., wp(, q)).
A postcondition of p w.r.t e = (l, l ), denoted post(e, p), is any condition q such that if (s) p, l(s) = l then for every s  next(s), if l(s ) = l then (s ) q. Postconditions can also be extended to paths  = l0, . . . , ln. We use post(, p) to denote a postcondition of condition p w.r.t. path .

Concurrent Programs A concurrent program P consists of multiple threads t1, . . . , tm,

where each thread ti has the same syntax as a sequential program over a set of vari-

ables Vi and a program location variable pci. The threads communicate through shared

variables, meaning that generally Vi, Vj are not disjoint for i = j. A variable is written

by ti if it appears on the left hand side of any assignment in ti. A variable v is shared

between two threads ti, tj if v  Vi  Vj. A variable v  Vi is a local variable of ti

if v  Vj for every j = i. Let V =

m i=1

Vi

.

A

state

of

P

is

a

pair

(l, ),

where



is a valuation of V and l = (l1, . . . , lm) where li is the value of pci. We also assume

one common error state . Given an initialization formula init over V , the set of initial states consists of all states (linit, ) where  init and liinit is the initial label of ti.

The execution of a concurrent program is interleaving, meaning that exactly one

thread performs a command at each step, and the next thread to execute is chosen non-

deterministically. We consider a sequentially consistent semantics in which the effect

of a single command on the memory is immediate. For s = (l, ), let cmd(s, ti) denote

the command of thread ti at label li. We denote next(s, ti) = {s | s can be obtained

from s after ti performs cmd(s, ti)}. A computation  of the concurrent program P is a sequence s0 -t1 s1 -t2 . . . -tn sn s.t. for every two adjacent states si, si+1: si+1  next(si, ti+1). We say that  is a computation of thread t in P if tj = t for
every 1  j  n. We define initial and reachable computations as in the sequential

case, but w.r.t. computations of the concurrent program.

We support synchronization operations by modeling them with atomic control commands. For example, Lock(lock) is modeled by atomic execution of assume(lock = false); lock = true. Since our technique models context switches by explicit calls to env move, we are able to prevent context switches between these commands.

Safety. A computation of a (sequential or concurrent) program is violating if it ends in the error state . The computation is safe otherwise. A (sequential or concurrent) program is safe if it has no initial violating computations. In the case of a sequential program, we refer to the path of a violating computation as a violating path.
A Sequential Model Checker is a tool which receives a sequential program as input, and checks whether the program is safe. If it is, it returns "SAFE". Otherwise, it returns a counterexample in the form of a violating path.
3 Note that our definition of a precondition does not require all the successors to satisfy q.

6
3 Our Methodology
In this section we describe our methodology for verifying safety properties of concurrent programs, given via assertions. The main idea is to use a sequential model checker in order to verify the concurrent program. Our approach handles any (fixed) number of threads. However, for simplicity, we describe our approach for a concurrent program with two threads. The extension to any number of threads can be found in [30].
In the sequel, we fix a concurrent program P with two threads. We refer to one as the main thread (tM ) and to the other as the environment thread (tE), with variables VM and VE and program location variables pcM and pcE, respectively. VM and VE might intersect. Let V = VM  VE. Given a state s = (l, ), we denote by lM (s) and lE(s) the values of pcM and pcE, respectively. For simplicity, we assume that safety of P is specified by assertions in tM (this is not a real restriction of our method).
Our algorithm generates and maintains a sequential program for each thread. Let PM and PE be the two sequential programs, with variables VM  VM and VE  VE. Each sequential program might include variables of the other thread as well, together with additional auxiliary variables not in V . Our approach is asymmetric, meaning that PM and PE have different roles in the algorithm. PM is based on the code of tM , and uses a designated function, env move, to abstract computations of tE. PE is based on the code of tE, and is constructed in order to answer specific queries for information required by PM , specified via assumptions and assertions. The algorithm iteratively applies model checking to each of these programs separately. In each iteration, the code of PM is gradually modified, as the algorithm learns new information about the environment, and the code of PE is adapted to answer the query of interest.
In Sec. 4, we first describe the way our algorithm operates on PM . During the analysis of PM , information about the environment is retrieved using environment queries: Intuitively, an environment query receives two conditions,  and , and checks whether there exists a reachable computation of tE in P from  to . The idea is to perform specific guided queries in tE, to search for computations that might "help" tM to reach a violation. If such a computation exists, the environment query returns a formula , which ensures that all states satisfying it can reach  using tE only. We also require that  and  overlap. In order to ensure the reachability of , the formula  might need to address local variables of tE, as well as pcE. These variables will then be added to PM , and may be used for the input of future environment queries. If no such computation of the environment exists, the environment query returns  = FALSE. Sec. 5 describes how our algorithm answers environment queries. The formal definition follows.
Definition 1 (Environment Query) An environment query ReachE(, ) receives conditions  and  over V  {pcE}, and returns a formula  over V  {pcE} such that:
1. If there exists a computation of tE in P that is (1) reachable in P , (2) starts from a state s s.t. s  and (3) ends in a state s s.t. s , then     FALSE.
2. If   FALSE then     FALSE and for every state s s.t. s , there exists a computation (not necessarily reachable) of tE in P from s to some s s.t. s .
Multiple threads. The key ingredients used by our technique are (i) an env move function that is used in PM to overapproximate finite computations (of any length) of tE

7

Algorithm 1 Algorithm MainThreadCheck

1: procedure MAINTHREADCHECK(tM , tE , init)

2: PM = add env move calls in tM and initialize env move()

3: while a violating path exists in PM do // using sequential MC

4:

Let  = l0, . . . , ln+1 be a path violating assert(b).

5:

if there are no env moves in  then return "Real Violation"

6:

let lk be the label of the last env move call in 

7:

let start = l0, . . . , lk and end = lk+1, . . . , ln

8:

 = wp(end, ¬b)

// see (1) in Sec. 4.3

9:

 = post(start, init)

// see (2) in Sec. 4.3

10:

Let  = ReachE(, ) // environment query for tE (see Sec. 5)

11:

if  is FALSE then

12:

Let ( ,  ) = GenE(, )

// see (4) in Sec. 4.3.

13:

PM = RefineEnvMove(PM ,  ,  ) // see (4) in Sec. 4.3

14:

else // see (5) in Sec. 4.3

15:

Add assert(¬) in PM at new label l right before lk

16: return "Program is Safe".

(see Sec. 4), and (ii) a try start function that is used in PE to overapproximate initial computations of P in order to let PE simulate non-initial computations of tE that follow them (see Sec. 5). When P has more than two threads, the environment of tM consists of multiple threads, hence environment queries are evaluated by a recursive application of the same approach. Since the computations we consider in the environment are not necessarily initial, the main thread of the environment should now include both the env move function and the try start function. For more details see [30].
4 Analyzing the Main thread
In this section we describe our algorithm for analyzing the main thread of P for the purpose of proving P safe or unsafe (Algorithm 1). Algorithm 1 maintains a sequential program, PM , over VM  VM , which represents the composition of tM with an abstraction of tE. The algorithm changes the code of PM iteratively, by adding new assumptions and assertions, as it learns new information about the environment.
The abstraction of tE is achieved by introducing a new function, env move. Context switches from tM to tE are modeled explicitly by calls to env move. The body of env move changes during the run of Algorithm 1. However, it always has the property that it over-approximates the set of finite (possibly of length zero) computations of tE in P that are reachable in P . This is formalized as follows:
Definition 2 (Overapproximation) For a state sm of PM (over VM ) s.t. l(sm) is the beginning or the end of env move, we say that sm matches a state s of P (over V ) if (1) sm and s agree on VM  V , i.e. (sm)|V = (s)|VM , where |U is the projection of  to the variables appearing in U , and (2) if pcE  VM , then (sm)(pcE) = lE(s).
We say that env move overapproximates the computations of tE in P if for every reachable computation  = s -tE . . . -tE s of tE in P (possibly of length 0), and for

8

1 bool claim0 = false , claim1 = false ; 2 bool cs1 = false , cs0 = false ; 3 int turn ;

4 void t0 () {

5

while ( true ) {

6

claim0 = true ;

7

turn = 1;

8

w h i l e ( c l a i m 1 && t u r n ! = 0 ) { }

9

cs0 = true ;

10

/ / CRITICAL SECTION

11

assert(!cs1) ;

12

cs0 = false ;

13

claim0 = false ;

}}

14 v o i d t 1 ( ) {

15

while ( true ) {

16

claim1 = true ;

17

turn = 0;

18

w h i l e ( c l a i m 0 && t u r n ! = 1 ) { }

19

cs1 = true ;

20

/ / CRITICAL SECTION

21

cs1 = false ;

22

claim1 = false ;

}}

Fig. 1. Peterson's mutual exclusion algorithm for two threads t0 and t1.

every state sm s.t. l(sm) is the beginning of env move and sm matches s, there exists a computation m = sm  · · ·  sm of PM s.t. (1) m is a complete execution of env move, i.e., l(sm) is the end of env move and for every other state sm in m, l(sm) is a label within env move, and (2) sm matches s .
The code of PM always consists of the original code of tM , the body of the env move function (which contains assumptions about the environment), calls to env move that are added at initialization, and new assertions that are added during the algorithm. VM always consists of VM , possibly pcE, some variables of VE (that are gradually added by need), and some additional auxiliary variables needed for the algorithm (see (4) in Sec. 4.3).
4.1 Initialization
Algorithm 1 starts by constructing the initial version of PM , based on the code of tM . To do so, it adds explicit calls to env move at every location where a context switch needs to be considered in tM . The latter set of locations is determined by an interleaving reduction analysis, which identifies a set of locations, called cut-points, such that the original program is safe if and only if all the computations in which context-switches occur only at cut-points are safe.
In addition, the algorithm constructs the initial env move function which havocs every shared variable of tE and tM that is written by tE. This function will gradually be refined to represent the environment in a more precise way.
Example 3 We use Peterson's algorithm [26] for mutual exclusion, presented in Fig. 1, as a running example. The algorithm contains a busy-wait loop in both threads, where a thread leaves that loop and enters its critical section only after the turn variable indicates that it is its turn to enter, or the other thread gave up on its claim to enter the critical section. In order to specify the safety property (mutual exclusion), we use additional variables cs0, cs1 which indicate that t0 and t1 (resp.) are in their critical sections. The safety property is that ¬cs0  ¬cs1 always holds. It is specified by the assert(!cs1) command in t0 between lines 9 and 12, where cs0 is true
Assume that t0 was chosen as the main thread and t1 as the environment thread. We generate a sequential program P0, based on the code of t0: we add env moves

9
at every cut point, as determined by our interleaving reduction mechanism. The initial env move only havocs all variables of P0 that are written by t1, i.e., claim1, turn, cs1 (see Fig. 4).
4.2 Iteration of the MainThreadCheck Algorithm
Each iteration of Algorithm 1 starts by applying a sequential model checker to check whether there exists a violating path (that may involve calls to env move) in PM (line 3). If not, we conclude that the concurrent program is safe (line 16), as the env move function over-approximates the computations of the environment. If an assertion violation is detected in PM , the model checker returns a counterexample in the form of a violating path. If there are no env move calls in the path (line 5), it means that the path represents a genuine violation obtained by a computation of the original main thread, and hence the program is unsafe.
Otherwise, the violation relies on environment moves, and as such it might be spurious. We therefore analyze this counterexample as described in Sec. 4.3. The purpose of the analysis is to check whether tE indeed enables the environment transitions used along the path. If so, we find "promises of error" for the violated assertion at earlier stages along the path and add them as new assertions in PM . Intuitively speaking, a "promise of error" is a property ensuring that tE can make a sequence of steps that will allow tM to violate its assertion. Such a property may depend on both threads, and hence it is defined over V  {pcE} (pcM is given implicitly by the location of the assertion in PM ). Formally, we have the following definition:
Definition 4 Let ,  be formulas over V  {pcE} and let l, l be labels of tM . We say that (l, ) is a promise of (l ,  ) if for every state s of P s.t. lM (s) = l and s  there exists a computation in P starting from s to a state s s.t. lM (s ) = l and s  .
If (l, ) is a promise of (l , ¬b) and l has an assert(b) command, then we say that (l, ) is a promise of error.
Note that the definition is transitive. Specifically, if (l, ) is a promise of (l ,  ) and (l ,  ) is a promise of error, then (l, ) is also a promise of error.
Outcome. Each iteration of Algorithm 1 ends with one of these three scenarios: 1. The algorithm terminates having found a genuine counterexample for P (line 5). 2. The obtained counterexample is found to be spurious since an execution of env move
along the path is proved to be infeasible. The counterexample is eliminated by refining the env move function (line 13, also see item (4) in the next section). 3. Spuriousness of the counterexample remains undetermined, but a new promise of error is generated before the last env move call in the violating path. We augment PM with a new assertion, representing this promise of error (line 15).
4.3 Analyzing a potentially spurious violating path
Let  = l0, . . . , ln+1 be a violating path of PM , returned by the sequential model checker in an iteration of Algorithm 1, which is potentially spurious in P , i.e., contains

10

(a)

(b)

Fig. 2. (a) If ReachE(, ) = FALSE, we search for more general  and  which restrict the environment transition; (b) If ReachE(, ) =  = FALSE, then we know that  leads to  and that    = FALSE.

1 void P0 ( ) {

2

assert ((! cs1 ) || claim1 ) ;

3

env move () ;

4

while ( true ) {

5

claim0 = true ;

6

assert ((! cs1 ) || claim1 ) ;

7

env move () ;

8

turn = 1;

9

assert ((! cs1 ) ||

( c l a i m 1 && t u r n ! = 0 ) ) ;

10

...

11

}}

Fig. 3. The sequential program P0 after a few iterations of Algorithm 1.

1 void env move () {

2

bool claim1 copy = claim1 ;

3

int turn copy = turn ;

4

bool cs1 copy = cs1 ;

5

claim1 = havoc bool ();

6

turn = havoc int ();

7

cs1 = havoc bool ();

8

if (true) { assume(!cs1 || claim1) ; } }

Fig. 4. The env move function of P0: initially (without highlighted lines); and after one refinement (with highlighted lines).

at least one env move call. Since  is violating, ln+1 = l and cmd(ln) =assert(b) for some condition b. Let lk, for some 0  k  (n - 1), be the location of the last env move in . We perform the following steps, illustrated by Fig. 2:
(1) Computing condition after the environment step: We compute (backwards) the weakest precondition of ¬b w.r.t. the path end = lk+1, . . . , ln to obtain  = wp(end, ¬b) (line 8). Recall that ¬b is necessarily reachable from  along end in PM .
(2) Computing condition before the environment step: We compute (forward) a postcondition  = post(start, init) starting from init for the path start = l0, . . . , lk (line 9). To ensure progress, we make sure that if start ends with a suffix of asserts then   c for every assert(c) command that appears in this suffix (e.g., by conjoining  with c). Recall that  necessarily holds after executing start in PM from init.
(3) Environment query: We compute  = ReachE(, ) (line 10).
Example 5 Fig. 3 presents a prefix of PM after a few iterations of the algorithm, before the first refinement of env move (i.e., PM still uses the initial env move function). The previous iterations found new promises of error, and augmented PM with new assertions. Consider the initial conditions from Fig. 1, i.e., init [claim0 =

11
claim1 = cs1 = cs0 = false]. Assume that our sequential model checker found the violation given by the next path: 2, 3, 4, 5, 6, 7, 8, 9, .
To check whether the last env move call in line 7 represents a real computation of t1, we compute the weakest precondition of the condition ¬b cs1  (¬claim1  turn = 0), taken from the violated assertion in line 9, w.r.t. the path end = 8, 9. The result is  = wp(end, ¬b) = (cs1  ¬claim1). The computation of  = post(start, ) for the path start = 2, 3, 4, 5, 6 yields  = (¬cs0claim0(¬cs1 claim1)). We then generate an environment query ReachE(, ).
(4) Refining the env move function: If  = FALSE (line 11) it means that there is no reachable computation of tE in P from a state s s.t. s |=  to a state s s.t. s |= . We apply a generalization procedure GenE(, ) that returns  ,  s.t.    ,    and still ReachE( ,  ) = FALSE (line 12). To do so, GenE iteratively replaces  and/or  with  ,  s.t.    ,    and rechecks ReachE( ,  ). For example, if  contains a subformula of the form 12 that appears positively, we attempt to replace it by 1 or 2 to obtain  .4 We then refine env move to eliminate the environment transition from  to  (line 13). Fig. 2(a) illustrates this step.
The refinement is done by introducing in env move, after the variables are havocked, the command (if ( (W old)) assume(¬ )), where W old are the values of the variables before they are havocked in env move (these values are copied by env move to allow evaluating  on the values of the variables before env move is called). The command blocks all computations of env move from  to  . Since such computations were proven by the environment query to be infeasible in tE, we are ensured that env move remains an overapproximation of the computations of tE.
Example 6 The call to ReachE(, ) in Example 5 results in  = FALSE. Hence, we apply generalization. We obtain two formulas  = T RU E,  =  which indeed satisfy    ,    and ReachE( ,  ) = FALSE. This means that when tE is called with  = T RU E, then no computation of tE reaches a state satisfying  = cs1  ¬claim1. Fig. 4 presents the env move function before and after the refinement step based on ( ,  ) takes place. The refinement step adds the highlighted line to the initial env move function. This line has the constraint if (true) assume(!cs1 || claim1), derived from the observation above.
(5) Adding assertions: If  = FALSE, then for every state satisfying  there is a computation of tE in P to a state satisfying . Since  = wp(end, ¬b), it is guaranteed that this computation can be extended (in tM ) along the path end, which does not use any environment moves, to reach a state s that violates the assertion assert(b). This is illustrated in Fig. 2(b). We therefore conclude that if  is satisfied before the env move at label lk, a genuine violation can be reached, making (l^k, ) a promise of error, where l^k denotes the label in tM that corresponds to lk (the label reached after executing the env move called at label lk). Therefore, we add a new assertion assert(¬) right before lk (line 15). In addition, if  includes a variable v that is not in VM (e.g., pcE), then v is added to VM , its declaration (and initialization, if exists) is added to PM , and env move is extended to havoc v as well (if it is written by tE).
4 More information about the generalization appears in the optimizations section in [30].

12
5 Answering Environment Queries
Recall that an environment query ReachE(, ) checks whether there exists a reachable computation  of tE in P from a state s |=  to a state s |= . This computation may involve any finite number of steps of tE, executed without interference of tM .
If     FALSE, we simply return , which represents a computation of length zero. Otherwise, we wish to apply a sequential model checker on tE in order to reveal such computations, or conclude there are none. However, the computation  may not be initial, while our sequential model checker can only search for violating paths starting from an initial state. Hence we construct a modified sequential program PE, based on the code of tE, which also represents (over-approximates) non-initial, but reachable, computations  of tE in P . For that, we add in PE calls to a new function, try start, which models the runs of tM until the start of . The calls to try start are added in all cut-points computed by an interleaving reduction (similar to the one applied to tM ).
The try start function. The try start function is responsible for non-deterministically setting the start point of , where context switches to tM are no longer allowed. This is done by setting a new start variable to true (provided that its value is not yet true). We refer to the latter call as the activation try start. As long as start is false (i.e., prior to the activation call), try start havocs the variables written by tM . When start is set to true, we add an assume() command after the havoc commands as this is the state chosen to start the computation. To handle the case where pcE appears in , try start receives the original location (in tE) in which it is called as a parameter, and updates the explicit pcE variable. Whenever start is already true, try start immediately exits, ensuring that  indeed only uses transitions of tE.
In PE, we also add assertions of the form assert(!start || ¬) after every call to try start. Hence, a violating path, if found, reaches start  , i.e., it captures a computation in which  was satisfied (when start was set to true), and reached .
Returning Result. If a violating path is not found, we return ReachE(, ) = FALSE. If a violating path m0, . . . , mn+1 is found, let mk be the label of the activation try start for some 0  k  (n-1). Let E be the projection of mk+1, . . . , mn-1 to tE. We compute the weakest precondition of  w.r.t. the path E and obtain  = wp(E, ). The computed  satisfies the desired requirement: For every state s of P s.t. s wp(E, ), there exists a computation  of tE starting from s which follows the path E and reaches a state s satisfying . Note that  might not be reachable, as in the prefix we used an abstraction of tM . That means that ReachE(, ) is not "exact" and may return  = FALSE when there is no reachable computations as required. However, it satisfies the requirements of Def. 1, which is sufficient for soundness and progress. The intuition is that checking the reachability of  is done by the main thread.
For an example demonstrating how an environment query is answered see [30].
6 Soundness and Progress
Our algorithm for verifying the concurrent program P terminates when either (i) all the assertions in PM are proven safe (i.e., neither the original error nor all the new promises

13
of error can be reached in PM ), in which case Algorithm 1 returns "Program is Safe". (ii) a violation of some assertion in PM , which indicates either the original error or a promise of error, is reached without any env move calls, in which case Algorithm 1 returns "Real Violation". The following theorem summarizes its soundness5.
Theorem 1. If Algorithm 1 returns "Safe" then the concurrent program P has no violating computation; If it returns "Real violation" then P has a violating computation.
The proof of the first claim shows that our algorithm maintains the overapproximation property of env move (see Def. 2), from which the claim follows immediately. In the proof of the second claim, we show that the properties of an environment query (see Def. 1) and of promises of errors (Def. 4) are satisfied.
While termination is not guaranteed for programs over infinite domains, the algorithm is ensured to make progress in the following sense. Each iteration either refines env move (step (4) in Sec. 4.3), making it more precise w.r.t. the real environment, or generates new promises of errors at earlier stages along the violating path (step (5) in Sec. 4.3). In the former case, the set of pairs of states (s, s ) represented by the start and end states of computations of env move is strictly decreasing ­ this set overapproximates the set of pairs of states (s, s ) for which tE has a reachable computation from state s to state s (see Def. 2). In the latter case, the set of states known to lead to a real violation of safety is strictly increasing. In both cases, the other set remains unchanged.
When the domain of all variables is finite, these two sets are bounded, hence the algorithm is guaranteed to terminate.
7 Experimental Results and Conclusion
Setup. We implemented our algorithm in a prototype tool called CoMuS. The implementation is written in Python 3.5, uses pycparser [2] for parsing and transforming C programs, uses SeaHorn [18] for sequential model checking, and uses Z3 [7] to check logical implications for some optimizations. A description of the optimizations can be found in [30]. CoMuS currently supports only a subset of the syntax of C (see Sec. 2). It does not perform alias analysis and hence has limited pointers support. It also does not support dynamic thread creations, although we support any fixed number of threads.
We compare CoMuS with Threader [27], VVT [15] and UL-CSeq [23], the last two being the top scoring model checkers on the concurrency benchmark among sound unbounded tools in SVCOMP'16 and SVCOMP'17 (resp.). On the concurrency benchmark, VVT was 4th overall in SVCOMP'16, and UL-CSeq was 8th overall in SVCOMP'17 6. Threader performs modular verification, abstracts each thread separately and uses an interference abstraction for each pair of threads. UL-CSeq performs a reduction to a single non-deterministic sequential program. We used it in its default mode,
5 Full proofs appear in https://tinyurl.com/comusfull. 6 The same benchmark was used for unbounded sound tools and tools which perform unsound
bounded reductions. Bounded tools are typically ranked higher. Our method is unbounded and is able to provide proofs, hence we find the selected tools more suitable for comparison.

14
with CPAChecker [3] as a backend. VVT combines bounded model checking for bug finding with an IC3 [4] based method for full verification.
We ran the experiments on a x86-64 Linux machine, running Ubuntu 16.04 (Xenial) using Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz with 8GB of RAM.
Experiments. We evaluated the tools using three experiments. One compares the four tools on concurrent programs with a clear hierarchy. The second compares syntactically similar programs with and without hierarchal structure to evaluate the effect of the structure on the verification time. The last one looked at general concurrent programs.
Hierarchically structured programs. For the first experiment, we used three concurrent dynamic-programming algorithms: Sum-Matrix, Pascal-Triangle and Longest-IncreasingSubsequence. The Sum-Matrix programs receive a matrix A as input. For every pair of indexes (i, j), it computes the sum of all elements A[k, l], where k  i and l  j. In their concurrent version, each thread is responsible for the computation of a single row. The Pascal-Triangle programs compute all the binomial coefficients up to a given bound. Each thread computes one row of the triangle, where each element in the row depends on two results of the previous row. The Longest-Increasing-Subsequence programs receive an array, and compute for each index i, the length of the longest increasing subsequence that ends at index i. Each thread is responsible for computing the result for a given index of the array, depending on the result of all prefixes. Both these and the matrix programs are infinite state, as the elements of the array (resp. the matrix) are unbounded inputs.
These algorithms have a natural definition for any finite number of threads. Typically, the verification becomes harder as the number of threads increases. For evaluation, we used programs with an increasing number of threads, and check the influence of the number on the different tools. For each instance, we use both a safe and an unsafe version. Both versions differ from each other either only by a change of specification, or by a slight modification that introduces a bug.
The chosen programs have two meaningful characteristics: (i) They exhibit nontrivial concurrency. This means that each thread performs a series of computations, and it can advance when the data for each computation is ready, without waiting for the threads it depends on to complete. Consider the Sum-Matrix problem as an example. Assume thread ti needs to compute the result at some location (i, j), and that each row is computed backwards (from the last cell to the first). The computation exploits the results of thread ti+1. Thread ti needs to wait for thread ti+1 to compute the result for location (i + 1, j). However, ti does not wait for ti+1 to terminate, as it can compute the cell (i, j), while ti+1 continues to compute (i + 1, j - 1). (ii) Their data flow graph has a clear chain structure. That is, the threads can be ordered in a chain hierarchy, and each thread only requires information computed by its immediate successor.
Fig. 5 summarizes the results for these programs. The timeout was set to 3600 seconds. The code of the programs is available at tinyurl.com/comusatva18. We include in the table also our running example, the Peterson algorithm.
The results demonstrate a clear advantage for CoMuS for verification (i.e., for safe programs) as the number of threads increases. This can be attributed to the chain structure that lets CoMuS minimize the amount of information transferred between threads.

15
Fig. 5. Run times [secs] for all four tools for verifying concurrent dynamic programs algorithms.
For falsification, CoMuS is outperformed by VVT's bounded method. However, it still performs significantly better than the two other tools when the number of threads grows.
Hierarchical vs. non-hierarchical programs. The programs used for this evaluation are variants of the "fib bench" examples of the SV-COMP concurrency benchmark. We compare programs in which the data flow graph has a ring topology, vs. programs in which it has a chain topology. For the ring case, consider a program with threads t0, . . . , tn-1 and variables v0, . . . , vn-1. Each thread ti runs in a loop, and iteratively performs vi+=v(i+1(mod n)). The checked property is that v0 does not surpass an upper bound. The chain case is identical except that for the last thread, tn-1, we break the chain and perform vn-1+=1 instead of vn-1+=v0. Fig. 6 presents the results of this comparison. All the programs in the table are safe and with two loop iterations. The timeout was set to 1200 seconds.
For the ring case, all tools fail to verify programs with  4 threads. Threader presents similar results for both ring and chain topologies. VVT benefits from the less dependent chain topology, but still timeouts on > 3 threads. CoMuS, on the other hand, is designed to exploit hierarchy, and benefits significantly from the chain topology, where it verifies all instances. UL-CSeq is excluded from the table as it times-out on the "fib bench" examples (both in our experiments and in the SV-COMP results).
The reason for CoMus's different runtime on the chain and ring variants is that for programs that have no clear hierarchy (as in the ring programs), the conditions passed to the environment queries must include information relevant to the caller thread; a manual inspection shows that they typically become more complex. As similar phenomenon happens if the verification order used by CoMuS is not aligned with the hierarchy of the program. For example, switching the verification order of the last two threads in the long th3 safe example, increases the verification time from 10 to 25 seconds.
General concurrent programs. We also evaluated the tools on a partial subset of the SV-COMP concurrency benchmark, whose code is supported by CoMuS. Typically, on these runs CoMuS was outperformed by the other tools. We conclude that even

16
Fig. 6. Run times [secs] for fib bench programs with ring topology vs. chain topology.
though our method can be applied to programs without a clear hierarchical structure, it is particularly beneficial for programs in which the hierarchy is inherent.
Conclusion. In this work we develop an automatic, modular and hierarchical method for proving or disproving safety of concurrent programs by exploiting model checking for sequential programs. The method can handle infinite-state programs. It is sound and unbounded. We implemented our approach in a prototype tool called CoMuS, which compares favorably with top scoring model checkers on a particular class of problems, as previously characterized. In the future we intend to exploit internal information gathered by the sequential model checker (e.g., SeaHorn) to further speedup our results. We would also like to examine how to apply our approach to other hierarchies (e.g., trees).
Acknowledgement. This publication is part of a project that has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No [759102-SVIS]). The research was partially supported by Len Blavatnik and the Blavatnik Family foundation, the Blavatnik Interdisciplinary Cyber Research Center, Tel Aviv University, and the United States-Israel Binational Science Foundation (BSF) grants No. 2016260 and 2012259.
References
1. J. Alglave, D. Kroening, and M. Tautschnig. Partial orders for efficient Bounded Model Checking of concurrent software. In Computer Aided Verification (CAV), 2013.
2. E. Bendersky. https://github.com/eliben/pycparser. 3. D. Beyer and M. E. Keremoglu. CPAchecker: A tool for configurable software verification.
In Computer Aided Verification (CAV), pages 184­190, 2011. 4. A. R. Bradley. SAT-based model checking without unrolling. In VMCAI, 2011. 5. J. M. Cobleigh, D. Giannakopoulou, and C. S. Pasareanu. Learning assumptions for compo-
sitional verification. In TACAS, pages 331­346, 2003. 6. A. Cohen and K. S. Namjoshi. Local proofs for global safety properties. In CAV, 2007. 7. L. De Moura and N. Bjørner. Z3: An efficient SMT solver. TACAS, 2008. 8. E. W. Dijkstra. A Discipline of Programming. Prentice-Hall, 1976. 9. C. Flanagan, S. N. Freund, and S. Qadeer. Thread-modular verification for shared-memory
programs. In ESOP, 2002. 10. C. Flanagan and S. Qadeer. Thread-modular model checking. In SPIN, 2003.

17
11. C. Flanagan and S. Qadeer. Transactions for software model checking. Electr. Notes Theor. Comput. Sci., 89(3):518­539, 2003.
12. I. Gavran, F. Niksic, A. Kanade, R. Majumdar, and V. Vafeiadis. Rely/guarantee reasoning for asynchronous programs. In CONCUR, 2015.
13. P. Godefroid. Partial-Order Methods for the Verification of Concurrent Systems - An Approach to the State-Explosion Problem, volume 1032 of LNCS. Springer, 1996.
14. G. Gueta, C. Flanagan, E. Yahav, and M. Sagiv. Cartesian partial-order reduction. SPIN'07. 15. H. Gu¨nther, A. Laarman, and G. Weissenbacher. Vienna verification tool: IC3 for parallel
software - (competition contribution). In TACAS, 2016. 16. A. Gupta, C. Popeea, and A. Rybalchenko. Predicate abstraction and refinement for verifying
multi-threaded programs. In POPL, 2011. 17. A. Gupta, C. Popeea, and A. Rybalchenko. Threader: A constraint-based verifier for multi-
threaded programs. In Computer Aided Verification (CAV), pages 412­417, 2011. 18. A. Gurfinkel, T. Kahsai, A. Komuravelli, and J. A. Navas. The seahorn verification frame-
work. In Computer Aided Verification (CAV), pages 343­361, 2015. 19. A. Lal and T. W. Reps. Reducing concurrent analysis under a context bound to sequential
analysis. In Computer Aided Verification (CAV), pages 37­51, 2008. 20. K. R. M. Leino and P. Mu¨ller. A basis for verifying multi-threaded programs. In ESOP'09. 21. A. Malkis, A. Podelski, and A. Rybalchenko. Thread-modular verification is cartesian ab-
stract interpretation. In Theoretical Aspects of Computing - ICTAC, pages 183­197, 2006. 22. K. L. McMillan. Lazy abstraction with interpolants. In CAV, 2006. 23. T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato. Unbounded lazy-CSeq: A lazy sequen-
tialization tool for C programs with unbounded context switches - (competition contribution). In TACAS, pages 461­463, 2015. 24. T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato. Lazy sequentialization for the safety verification of unbounded concurrent programs. In ATVA, 2016. 25. C. S. Pasareanu, D. Giannakopoulou, M. G. Bobaru, J. M. Cobleigh, and H. Barringer. Learning to divide and conquer: applying the L* algorithm to automate assume-guarantee reasoning. Formal Methods in System Design, 32(3):175­205, 2008. 26. G. L. Peterson. Myths about the mutual exclusion problem. Inf. Process. Lett., 12(3):115­ 116, 1981. 27. C. Popeea and A. Rybalchenko. Threader: A verifier for multi-threaded programs - (competition contribution). In TACAS, pages 633­636, 2013. 28. C. Popeea, A. Rybalchenko, and A. Wilhelm. Reduction for compositional verification of multi-threaded programs. In FMCAD, pages 187­194, 2014. 29. I. Rabinovitz and O. Grumberg. Bounded model checking of concurrent programs. CAV'05. 30. D. Rasin. Modular verification of concurrent programs via sequential model checking. M.Sc. thesis, Technion -- Israel Institute of Technology, 2018. 31. N. Sinha and E. M. Clarke. SAT-based compositional verification using lazy learning. In CAV, pages 39­54, 2007. 32. E. Tomasco, O. Inverso, B. Fischer, S. La Torre, and G. Parlato. Verifying concurrent programs by memory unwinding. In TACAS, 2015. 33. E. Tomasco, T. L. Nguyen, O. Inverso, B. Fischer, S. La Torre, and G. Parlato. Lazy sequentialization for TSO and PSO via shared memory abstractions. In FMCAD, 2016. 34. B. Wachter, D. Kroening, and J. Ouaknine. Verifying multi-threaded software with impact. In Formal Methods in Computer-Aided Design, FMCAD, pages 210­217, 2013. 35. M. Zheng, J. G. Edenhofner, Z. Luo, M. J. Gerrard, M. S. Rogers, M. B. Dwyer, and S. F. Siegel. CIVL: applying a general concurrency verification framework to c/pthreads programs (competition contribution). In TACAS, pages 908­911, 2016.

