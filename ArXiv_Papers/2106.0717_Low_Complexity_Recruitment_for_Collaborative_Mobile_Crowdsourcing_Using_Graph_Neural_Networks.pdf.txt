Low Complexity Recruitment for Collaborative Mobile Crowdsourcing Using Graph Neural Networks
Aymen Hamrouni, Student Member, IEEE, Hakim Ghazzai, Senior Member, IEEE, Turki Alelyani, Member, IEEE, and Yehia Massoud, Fellow, IEEE

arXiv:2106.00717v1 [cs.LG] 1 Jun 2021

Abstract-- Collaborative Mobile crowdsourcing (CMCS) allows entities, e.g., local authorities or individuals, to hire a team of workers from the crowd of connected people, to execute complex tasks. In this paper, we investigate two different CMCS recruitment strategies allowing task requesters to form teams of socially connected and skilled workers: i) a platform-based strategy where the platform exploits its own knowledge about the workers to form a team and ii) a leader-based strategy where the platform designates a group leader that recruits its own suitable team given its own knowledge about its Social Network (SN) neighbors. We first formulate the recruitment as an Integer Linear Program (ILP) that optimally forms teams according to four fuzzy-logic-based criteria: level of expertise, social relationship strength, recruitment cost, and recruiter's confidence level. To cope with NP-hardness, we design a novel low-complexity CMCS recruitment approach relying on Graph Neural Networks (GNNs), specifically graph embedding and clustering techniques, to shrink the workers' search space and afterwards, exploiting a meta-heuristic genetic algorithm to select appropriate workers. Simulation results applied on a real-world dataset illustrate the performance of both proposed CMCS recruitment approaches. It is shown that our proposed low-complexity GNN-based recruitment algorithm achieves close performances to those of the baseline ILP with significant computational time saving and ability to operate on large-scale mobile crowdsourcing platforms. It is also shown that compared to the leader-based strategy, the platform-based strategy recruits a more skilled team but with lower SN relationships and higher cost.
Index Terms--Crowdsourcing, Internet-of-things, recruitment, embedding, graph neural network.
I. INTRODUCTION
Mobile Crowdsourcing (MCS) is the act of outsourcing sensing tasks traditionally performed by employees or contractors to an undefined large group of dynamic Internet population or cyber community through an open or targeted call. It harnesses the power of built-in sensors in mobile devices (e.g., smartphones, tablets, and smart devices) and allows Internetof-things (IoT) devices to establish relationships, communicate, and cooperate together to complete specific sensing and
A part of this work has been accepted for publication in the proceedings of IEEE Technology & Engineering Management Conference, Novi, MI, USA, June. 2020 [1].
Aymen Hamrouni, Hakim Ghazzai, and Yehia Massoud are with the School of Systems and Enterprises, Stevens Institute of Technology, Hoboken, NJ, USA. (E­mails: {ahamroun, hghazzai, ymassoud}@stevens.edu). Turki Alelyani is with the College of Computer Science and Information Systems, Najran University, Najran, Saudi Arabia, (E­mail: tnalelyani@nu.edu.sa).

data collection tasks without requiring pre-deployed dedicated infrastructure [2], [3].
In the traditional MCS architecture [4], three main components are identified: task requesters, task workers, and the Platform as a Service (PaaS) hosting the main framework. The task requester, acting as a human possessing a smartphone or an IoT device (e.g., ground or aerial autonomous vehicle), provides its task description and criteria to the PaaS server requesting a certain service, e.g., covering an ongoing event by taking pictures [5]. The cloud platform then uses these requirements to match suitable workers and provides them with the task information. For this paradigm, the selected workers are asked to achieve what is necessary independently of each other and the final result is combined from their partial results to produce the overall outcome. The quality of the returned result, which is deduced from each worker's partial result, depends heavily on the characteristics of the recruited workers. To this end, most of the MCS research focused on hiring professional workers for each task such that they can complete the tasks' successfully and provide desired results [6], [7].
Nevertheless, in many other MCS applications, the set of tasks, also called projects, are very complex and the success of their completion depends not only on the expertise of their selected workers but also on how efficiently these workers can work together as a team. This could be, for example, the case of a MCS framework that helps build a virtual search party of smartphone users to find lost items, pets, or persons, as well as returning them. This team-based MCS paradigm is referred to as Collaborative MCS (CMCS) [8]. The enlisted workers are divided into convenient groups, using specific criteria required by the requester, and are asked to collaborate for the search by providing up-to-the minute reports about any updates. If the collaboration somehow fails for one reason or another, the job cannot be achieved successfully. Therefore, besides providing the required skills, the successful completion of the project is very sensitive to the way team members collaborate and communicate.
In this paper, we develop a team recruitment framework for large-scale CMCS systems. The objective is to recruit the most suitable workers that will collaborate and complete a CMCS project while considering various workers' and tasks' constraints and attributes. The proposed CMCS recruitment framework uses fuzzy logic for both the workers' skills and Social Network (SN) relations connecting the different

2

workers registered in the CMCS platform. For an appropriate matching, it aims to maximize a multi-objective function enclosing four key recruitment metrics: select skilled workers that meet the project requirements, select socially connected team, reduce the total recruitment cost, and ensure a high confidence level of the team selection process.
Two recruitment strategies are investigated: The first one is a platform-based strategy in which the CMCS platform itself is responsible for forming the entire team based on its knowledge about the workers' SN and their attributes (e.g., profile, history, experience, previous performance, reliability). The second one is a leader-based strategy in which the cloud platform selects a worker as a leader to which it delegates the team formation procedure. The chosen leader recruits team members based on its knowledge about other workers in its SN vicinity (e.g., social incentive mechanism, man-toman, friendship). For both strategies, we model the CMCS recruitment problem as an Integer Linear Program (ILP) with the aim to recruit optimal teams. However, this comes at the expense of a very high computational complexity. Therefore, and in order to promote instantaneous real-time recruitment in large-scale CMCS platforms, we propose a low-complexity recruitment approach that relies on Graph Neural Networks (GNNs) [9], [10] to learn unsupervised representations of the workers' relational structure and attributes by using graph embedding techniques as a way to reduce the complexity due to the problem's dimensionality [11]. Afterwards, for the resulting reduced search space, a modified meta-heuristic algorithm, namely the Genetic Algorithm (GA), is employed to form teams that match the CMCS project requirements.
In layman's terms, the main contributions of this paper are summarized as follows: · Formulate an ILP optimization problem that optimally solves the CMCS recruitment problem using two recruitment strategies: i) platform-based recruitment strategy that exploits the knowledge of the platform towards workers and recruits suitable team members and ii) a leader-based recruitment strategy that uses the knowledge of an appointed leader by the platform to recruit the rest of the team. · Design a low-complexity GNN-based algorithm that maps workers' attributes and representations from their SN graph into a 2-D format then clusters workers based their attributes and computes locally an approximation GA to form teams.
Simulation results on the Facebook SN dataset illustrate the performance of the CMCS framework for selected scenarios and show that our proposed CMCS recruitment algorithm for specific embedding parameters achieves close results to the baseline ILP with significant computational time saving. It is also shown that the proposed approach outperforms existing algorithms in terms of team recruitment and computational speed. Further experimental results show a performance tradeoff between the two virtual team grouping strategies when varying the members SN edge degrees. Compared to the leader-based strategy, the platform-based strategy recruits a more skilled team but with lower SN relationships and higher cost.
The remainder of this paper is organized as follows. Related work is reviewed in Section II. The system model is presented

in Section III. The ILP formulation for solving the CMCS recruitment problem is introduced in Section IV. Section V presents the proposed low-complexity CMCS recruitment algorithm based on Graph Embedding techniques. Experiments and simulation results are discussed in Section VI. Finally, the paper is concluded in Section VII.
II. RELATED WORK
Over the last decade, many MCS-based applications have been emerging. Zheng et al. [12] examined user skills using Knowledge Base (KB), e.g., Wikipedia and Freebase, to detect the domain of tasks and workers. Gong et al. [13] discussed privacy issues when recommending tasks to workers. In this context, the authors of [14] have proposed a joint Bayesian learning and graph optimization framework achieving privacypreserving and fast convergence over a heterogeneous and sparse IoT graph without assumptions on the prior knowledge of the data distribution across the nodes. Yan et al. [15] proposed an algorithm to enhance High Definition (HD) and Ultra High Definition (UHD) video services for mobile users through MCS participants that download and transmit video segments. Hamrouni et al. [6] proposed a photo-based MCS architecture that monitors the quality of the photos submitted by reporters to cover ongoing events. Alabduljabbar et al. [7] studied a dynamic approach that exploits task-quality ontology to select the most suitable quality control mechanism for a given task based on its type. Ben Said et al. [16] proposed an algorithm to determine the best public transport journey plan offering based on the quality of service of available WiFi mobile crowdsourced WiFi coverage along the journey.
In the MCS applications, the requester posts tasks and recruits workers to complete them independently of each other [17]. Due to the temporal and spatial constraints of the tasks and background knowledge of different workers, not everyone is qualified to execute a specific task. Therefore, selecting the appropriate worker from a pool of candidates is important as it can directly affect the quality of the final result of the MCS task [18]. Estrada et al. [19] proposed a MCS recruitment algorithm that implements a multi-objective task allocation algorithm based on Particle Swarm Optimization (PSO) while handling incoming sensing tasks in the server side and at the end-user side and avoiding delaying or declining the sensing requests due to unforeseen user context. Guo et al. [20] reviewed the state of research in many types of task allocation such as multiple task allocation, low-cost task allocation, etc. They discussed the recruitment issues in realworld deployment but proposed solutions in a small-scale problem. Gao et al. [21] proposed a Learning-based Credible Participant Recruitment Strategy (LC-PRS) to maximize the platform and participants' profits at the same time via MCS participation. Yu et al. [22] proposed a dynamic utility task allocation algorithm that estimates the ability of workers to execute tasks and then maximizes the overall utility. Xing et al. [23] proposed an intelligent multi-attribute crowdsourcing task assignment approach. This approach solves the stability of the crowdsourcing transaction and adopts the game theory to maximize the satisfaction of both sides during the task assignment. Yu et al. [24] developed an approach to recruit

3

CMCS Assignment Unit
Projects Submission

Fetch Available Workers

Set of recruited teams
An edge represents a
direct connection between workers in the social network.
Fig. 1: Recruitment system model in the CMCS Framework displaying samples of team workers and their respective teams.
suitable workers using three metrics: worker's ability, task module complexity, and worker's active time. Wang et al. [25] proposed to hire MCS workers by leveraging the influence of information propagation on the social networks. Other studies have focused on the optimization of spatial task assignment. For instance, Zhou et al. [26] proposed a secure and efficient spatial task matching framework that utilizes multi-user searchable encryption and secure index technique. Abdullah et al. [27] introduced the use of Bayesian Network in modelling and selecting optimal workers and used k-medoids partitioning technique for tasks clustering and scheduling. Wang et al. [28] put the SMCS into another prospective by formulating it as the Walrasian equilibrium where the optimum solution is researched to maximize the social welfare of mobile crowdsourcing systems. Hamrouni et al. [29] proposed a heuristic SMCS recruitment approach allowing the achievement of sub-optimal matching and recruitment solution by iteratively solving a weighted bipartite graph problem.
On the other hand, as a teamwork-based paradigm, CMCS aims to form groups of workers, often with diverse and complementary skills, that will work together to complete complex tasks [30], [31]. Fewer studies have begun to address the need to consider recruiting a team of workers in MCS [32]­[34]. Some approaches, such as [35], focused on dividing complex tasks into flows of simple sub-tasks and allocating these subtasks to a team of workers. These approaches have focused only on the expertise of recruited team members and did not consider the interaction within members. Other approaches limited their focus on team formation in SNs and proposed a solution to hire teams with good social relationships indifferent of the members' levels of expertise [36]­[38]. The authors in [39] have shed the light on the CMCS paradigm by providing a detailed CMCS taxonomy and investigating the challenges in designing CMC tasks.
Most of the existing studies have investigated traditional MCS platforms and offered solutions designed for simple MCS tasks. The ones that are designed for CMCS platforms are focused on either the workers' social network or their attributes and skills. To the best of our knowledge, this work is the first one that tackles the recruitment process for complex projects within CMCS systems while relying on both the workers' attributes and social network. It is also the first that proposes a machine learning approach, specifically a GNN-

Database

TABLE I: Notations and Descriptions

Notations

Descriptions

P Sp W
Cwi ,k
Cw Swi ,k
Sw,k S^w Ewi ,k Uwi

Set of projects in the framework, P = {1, . . . , |P|} A set representing the skills that project p requires
Set of all workers in the framework, W = {1, . . . , |W|}
Cost, seen by recruiter i, demanded by worker w when providing skill k
A set representing the cost for each skill provided by worker w Skill level, seen by recruiter i, provided by worker w contributing with skill k Real skill set value provided by worker w
when contributing with skill k A set representing the noised skills
values for worker w Efficiency of worker w recruited by i contributing with skill k
Confidence level of recruiter i towards worker w

based algorithm, for recruiting skilled and socially connected teams while taking into account the team compensation cost and the confidence level of the recruitment decision.

III. CMCS SYSTEM MODEL
In this section, we start by presenting the different components of the CMCS system. Afterwards, we introduce the SN model and the recruitment utility that the task manager aims to optimize during the CMCS assignment process.
A typical CMCS framework interacts with two main actors: project/task requesters and task workers. The entire platform workflow is divided into a four-stage process: 1) a task initiation stage in which requesters define and submit their projects' requirements to the platform, 2) a task announcement phase during which the platform uses these requirements in order to select suitable teams and notify them about the project, 3) a task execution stage during which the selected team members collaborate and communicate together to collect and submit requested data, and 4) a response handover stage where the results of the team members are combined and delivered to the project requesters.
In this paper, we focus on the second stage where the CMCS platform target is to recruit suitable and convenient team for the assigned project. In Fig. 1, we illustrate a highlevel workflow of the recruitment process in CMCS platform. The CMCS assignment unit server uses both the project's (e.g., required skills) and worker's attributes (e.g., level of expertise, availability), to determine a suitable matching. As we can notice, the server consults its database where information about the registered workers and their related SN graph exists. The objective of the server is to form teams that match the project requirement accordingly. Note that the proposed platform is recruiting a team of workers where each of its member contributes with a different skill. However, we may notice that workers with the same profession are in the same team. This is because we assume that each worker is an expert in his/her primary profession but also have some levels of expertise in other ones. Next, we present the characteristics and attributes of the different CMCS actors. For clarity, we provide the main notations used throughout the paper in Table I.

4

A. Project Model
The overall set of projects published in the platform is denoted by P where P = {1, . . . , . . . , |P|}. Each task p  P is denoted with a list of attributes. For simplification purposes, let {Idp, T itp, Desp, Sp} be the list of attributes of task p that are defined as follows: · Idp: represents the project's unique identifier. · T itp and Desp: represent the task title and the text description of the task (e.g., a task can be described as "Please contact your teammates in order to help in the ongoing fire in the nearby mall"). · Sp: This attribute represents the skills or the features that a task needs. Given a set S = {1, . . . , |S|} of all S possible skills in the system, we define the logical skill quantity for a project p by Qp(k), k  S where Qp(k) = 1 if the skill k is required by project p and Qp(k) = 0, otherwise. Hence, the skills set required by the project Sp = {k  S/Qp(k) = 1}. In the case of the previous mentioned project example, Sp can be a binary vector with all zeros except the skills referring to a doctor, a nurse, a fireman, an IT engineer, a mechanical engineer, and photographer.
B. Worker Model
A worker is a platform user which offers its services to the system to complete CMCS projects. We denote the set of workers in the platform by W = {1, . . . , |W|}. Arriving workers express their readiness to collaborate in projects and provide their restraints to the CMCS platform. Each worker w  W is characterized by a list of attributes. For simplification purposes, let {idw, entw, levw, Cw, S^w} be that list where its elements are explained as follows: · idw: this term represents the worker's unique identifier. · entw and levw: these attributes are the entering and leaving time of the worker to the system, respectively. · Cw: this term refers to the reward that the worker is seeking. To execute a project with skill k, a worker w may request a certain cost denoted by Cwk. Therefore, Cw = {Cw1, . . . , Cw|S|} · S^w: Each worker w  W has a degree of expertise in skill k  S denoted by Swk where 0  Swk  1. The term Swk represents the actual expertise value of skill k that worker w has and it is interpreted as follows: Swk  1 means that the worker w is an expert in skill k. Otherwise, Swk  0. We assume that a recruiter i, which can be a worker as well as the platform itself, does not perfectly know the degree of the skill k of each worker. Instead, it knows an estimated value, referred to as a fuzzy skill set, expressed as follows: S^wi k = Swk + S~wi , where S~wi is a skill error made by the recruiter i given its knowledge about worker w. The parameter S~w is a noise modeled as a probability distribution with a variance Uw that reflects the confidence level of the recruiter i towards worker w. Let S^w = {S^w1, . . . , S^w|S|} be the set of skills provided by worker w. We suppose that each recruited worker can only contribute with one required skill. Consequently, for a project p having as a skill set Sp, the number of team members must be |Sp|. This approach uses the fuzzy logic in which the truth values of variables may be any real number between 0 and 1 both inclusive. It is employed to handle the concept of partial

truth, where the truth value may range between completely true and completely false.

C. Social Network Model

The subscribed workers in the platform form a SN modeled

as an undirected weighted graph G(W, E). Every vertex of G

corresponds to a worker w  W while the set of edges E

represents the SN relationships between the workers. Initially,

we only consider the edges connecting a pairwise of workers

that can directly communicate and collaborate and we asso-

ciate the value 1 to their weights. Then, the edges between

the remaining pairwise of vertices, e.g., (w, w ), which are

not directly connected are given a weight computed using the shortest number of hops, denoted by nhwowps, needed for
one of the pairwise vertices to reach the other. Hence, the

graph G is converted into a complete graph where all vertices

are directly connected and the values of the edges' weights

indicate the social relationships levels between each pair of

workers. The real values on each edge between two workers

w and w

are given as: Rww

=

. 1
1+nhops

In

a

way

similar

ww

to S~wi and due to the fact that social networks do not capture

nor reflect complete information about relationships between

the workers, we introduce uncertainty in the social network

relations. Furthermore, if a worker "A" is directly connected

to two other workers, "B" and "C". The social network will

naturally attribute the same value to the links between workers

"A" and "B" and workers "A" and "C". However, in practice,

this could not be the case since worker "A" can have a stronger

relationship with worker "B" than worker "C". Other factors

that introduce uncertainty towards the connections in the social

network can also include, and not limited to, fake profiles or

false links. Therefore, we assume that a recruiter i, which can

be a worker as well as the platform itself, does not perfectly

know the real relationship between workers. Instead, it knows

an estimated value, referred to as: R^ww

= Rww

+

(R~w i +R~w i 2

),

where R~wi and R~wi represent relationships error made by

the recruiter i given its knowledge about workers w and w ,

respectively. The noise R~wi is modeled as a probability distribution with
a variance Uwi that reflects the confidence level of recruiter
i towards worker w. If an isolated sub-graph exists, then the

weights connecting a node of this sub-graph to other external

vertices is a pure noise (i.e., nhops  ).

D. Recruitment Utility Model

In the CMCS system, it is important to establish an effective

criterion to guarantee an appropriate recruitment decision. The

latter should guarantee a certain correlation between the team

members and the projects as well as between the team mem-

bers themselves such that the formed team matches the project

requirements. We define this correlation as the efficiency of

workers to perform tasks. The efficiency of worker w to

contribute with skill k and chosen by a recruiter i is modeled as

a Pareto multi-objective function and is expressed as follows:

Ewi ,k

=

1

S^wi ,k S¯

-

2

Uwi U¯

-

3

Cw,k C¯

+

|T

4 |-1

R^ww R¯

.

w T \ {w}

(1)

5

The efficiency of the worker is measured by its skill level as

seen by the recruiter, the confidence level of the recruiter, the

requester cost to execute the task, and its social relation level

with other team members. In (1), T denotes the set of hired workers in the formed team. The quantities X¯ are introduced

for normalization purposes so that the four key metrics have

the same order of magnitude in the efficiency expression. The

weights t, with t  {1, 2, 3, 4} and

4 t=1

t

=

1,

indicate

the

recruiter's recruitment strategy. For example, situations where

the project requester only cares about its task being completed

by the workers having the highest skills (i.e., 1 = 1, and 2, 3, 4 are set to 0). If the recruiter is looking for a reduced cost-effective team, a higher value of 3 is recommended.

The variable vww indicates that all the positive 2-tuple combinations of the chosen team members. Its value can be computed using the following expression:

vww =

xiwk 

xiw k,  (w, w )  W × W,

iI kSp

iI kSp

(2)

where the symbol () represents the logical operator AND.

For the leader-based approach, we introduce an endogenous

binary variable presented as follows:

yi = 1, if worker i is selected as a team leader, 0, otherwise,

i  W.

IV. OPTIMAL RECRUITMENT PROBLEM FORMULATION
In this section, we propose a formulation to the CMCS recruitment problem using two possible recruitment strategies depending on the nature of the recruiter: the platform itself or a leader delegated by the platform. Let I be the set of possible team recruiters, which can be defined as follows:
I = {0}, if the recruiter is the platform, W, if the recruiter is a worker.
We propose to model the recruitment problem as an Integer Linear Program. In the following, we define the different decision variables and the necessary constraints that ensure suitable matching of the defined tasks to the appropriate set of workers. Afterwards, we present the objective function that we seek to maximize, which is based on the correlation function defined in (1).

B. Recruitment Problem Constraints

1) Common Constraints: In the following, we present all the common constraints for both recruitment approaches. · Skill Participation Constraints: The following constraint forces each worker, if selected, to provide at most one skill for the project p:

xiwk  1,  w  W.

(3)

iI kSp

· Social Network Constraints: These constraints address

the SN of the workers within the team. The following one

eliminates the case of counting a worker w to be its own co-

worker if hired within the team:

vww = 0,  w  W,

(4)

while the following one forces the symmetric relations be-

tween vertices in the undirected graph G(W, E) of workers'

SNs:

vw w = vww ,  (w, w )  W × W.

(5)

A. Decision Variables

In order to assign to the recruiter the chosen workers for

a project p and decide the skill sk that he/she will contribute

with, we introduce a binary decision variable xiwk defined as

follows:



1, if recruiter i selects worker w to contribute



xiwk =

in project p with skill k,

0, otherwise,

 (i, w)  I × W,  k  Sp.
Depending on the recruitment strategy, the index i can take either the value of {0} for the platform-based approach or any value in W for the leader-based approach. For the latter approach, the optimizer decides which worker in W will be assigned as a leader. Hence, it will determine the leader and the recruited team based on the knowledge and SN of the leader.

2) Platform-based Approach Constraints: This constraint targets the platform-based approach: · Capacity Constraints: The following constraint ensures that each of the workers within the hired team contributes with a required skill defined by the project.

xiwk = Q(sk),  k  Sp,

(6)

iI wW
3) Leader-based Approach Constraints: These constraints

target the leader-based approach.

· Capacity Constraints: The following constraint ensures that

each of the workers within the hired team contributes with a

required skill defined by the project.

xiwk - Q(sk)  M (1 - yi),  i  W, (7a)
kSp wW

xiwk - Q(sk)  M (yi - 1),  i  W, (7b)
kSp wW

Another binary decision variable vww is introduced to con-

xiwk  M yi,  i  W,

(7c)

sider the social relationships between the project teammates.

wW kSp

This variable is presented as follows:

1, if workers w and w are hired within the project,

xiwk  -M yi,  i  W,

(7d)

vww =

wW kSp

0, otherwise,

Constraints (7a), (7b), (7c), and (7d) are the result of the

 (w, w )  W × W.

big-M method to guarantee that the team leader recruits a

6

Start

Clean Digestible format

Feature Vectors

Similar Workers in Communities

Set of candidate workers

Data Cleaning and Preparation

Embedding

Clustering

PostProcessing

Worker Selection

1 (+)

2 (+)

Social Network graph (, )

Workers' Skills

3 (+) Recruited Teams

Workers'

and Projects'

End

attributes

Fig. 2: High-level flowchart illustrating the inputs/outputs of each phase of the proposed CMCS recruitment algorithm.

team with workers having the required skills. The term M represents the upper bound of wW kSp xiwk. Notice that the constraints presented in (6) and (7) have analogous goal
but they are adapted for each strategy. · Leader Participation Constraints: The following con-
straint ensures that the chosen leader contributes with a
required skill defined by the project.

xiik = 1,  i  W.

(8)

kSp

· Leader Uniqueness Constraints: To guarantee the

uniqueness of the leader, we include the following constraint:

yi = 1 .

(9)

iW

C. Optimization Problem

The objective of this paper is to hire the most suitable team to complete a CMCS project p. To this end, we introduce

a general team formation optimization problem for both ap-

proaches, and we define it as follows:

(P): maximize
xiwk {0,1}
vww {0,1}

xiwk
iI wW kSp

1

S^wi ,k S¯

-

2

Uji U¯

-

3

Cw,k C¯

+

4 |Sp| -

1

jW

w

W

vww

Rww R¯

,

subject to:

(xiwk + xiw k)  2 × vww ,  (w, w )  W × W,
iI kSp
(10a)

vww 

(xiwk + xiw k) - 1,  (w, w )  W × W,

iI kSp

(10b)

(3) - (5),

(6)

if i = 0,

(7) - (9) if i = 0.

The value of vww is computed using a product of the decision variables xijk. Therefore, we use the standard linearization technique and replace vww given in (2) with the
constraints (10a) and (10b).

The optimization problem in (P) is formulated as an ILP and the solution can be optimally obtained using off-the-shelf

software such as Gurobi or CPLEX integrating the branch and bound algorithm or simplex method. Also, note that there are cases where the problem is infeasible, for example when the number of workers |W| is less than the number of skills |Sp|. However, in CMCS platforms, this case is unlikely to occur since, by definition, in large-scale IoT systems, the value of |W| |Sp|.
Since the ILP solution is proven to be computationally expensive to obtain, we introduce, in the following section, a low-complexity heuristic approach that uses graph embedding techniques and GA to ensure an effective team recruitment.
V. PROPOSED TEAM RECRUITMENT ALGORITHM
In this section, we present the architecture of the proposed CMCS team recruitment algorithm composed of five components/phases as depicted in Fig. 2. The algorithm starts with a data cleaning and preparation phase that generates a digestible format to be fed to the GNN-embedder. The latter converts the workers' graph into numerical feature vectors representing the social relations and attributes of each worker. Afterwards, a clustering algorithm is executed to determine communities of similar workers and hence, reduce the search space for the following recruitment phase. Finally, a GA-based algorithm is run to determine a team of skilled and socially connected workers from the obtained set of candidate workers, i.e., maximizing the objective function of (P).
A. Phase I: Data Cleaning and Preparation
Initially, we assume that the CMCS platform possesses a database that contains the list of the IoT users registered to the system along with their recorded attributes that we have discussed earlier in Section III. Moreover, the platform has a partial knowledge about their social relations with their peers. This knowledge depends on the offline data that are disclosed by the users or based on their experience and activity in the platform. In order to submit a task to the platform, the request needs to submit all the information required so that the platform can determine the suitable team. Before starting the recruitment phase, we propose to perform a data cleansing process on the workers' SN dataset. This phase ensures that all the unknown or missing relationships are found and eliminated. Also, we perform the conversion of the graph G(W, E) to a fully connected graph while respecting the defined model earlier. In other words, we associate the value R^ww between each pair of workers (w, w ).

7

v

u

Graph

Neural



q

Networks

r



t

s
Original network
Fig. 3: Visualization of the embedding process where the original 3D network is transformed into an embedding space with 2-D vectors by the means of an encoding function EN C().

B. Phase II: Network Embedding
Afterwards, we proceed with a network embedding phase. Network embedding is a technique that converts the 3D structure of the graph and embeds it into a lower dimensional continuous latent space (i.e., numerical representation of the graph vertices) [9], [40]. Since vector operations are often simpler and faster than the equivalent graph operations, graph embedding leverages the data-science tool sets by learning a mapping from a 3D network to a 2D compressed representation space while preserving relevant network properties.
As recent work has shown, there are various ways to go about embedding graphs, each with a different level of granularity [41], [42]. The embedding can be performed on the on the node level [43] or on the entire graph [44]. In node embedding, each vertex (node) is encoded with its vector representation. This approach is used if the objective is to perform visualization or prediction on the vertex level, e.g., visualization of vertices in the 2D plane or prediction of new connections based on vertex similarities. By definition, the nodes close to each other in the graph, relying on specific measure, must be close to each other in the embedding space, using that same me sure. Deepwalk [45] by Perozzi et al. was the first approach that tackled the node embedding group. It uses random walks to produce embeddings. However, this technique has several limitations, including the disregard of the neighborhood of the embedded node. Node2vec [43] approach by Grover et al. surpasses this issue by proposing a different walking technique between nodes. It has parameters P , and Q. Parameter Q defines how probable it is that the random walk would discover the undiscovered part of the graph, while parameter P defines how probable it is that the random walk would return to the previous node. Graph embedding, on the other hand, is a technique that transforms the whole graph is into a single vector [46]. This approach is used to perform predictions at the graph level or compare and visualize entire graphs, e.g., comparing chemical structures. Methods that tackled this group are Graph2vec [44] which are based on the idea of the doc2vec approach and rely on node2vec.
It is worth to note that there is another important distinction between the embedding techniques. There is a transductive embedding which is a low-dimension vector representation derived for each node making it impossible to find the vector representation for a new node. In data science terms, the algorithm cannot perform prediction based on unknown data. Transductive methods are principally based on matrix factor-

ization techniques and random walks. This approach is simple and is able to generate embeddings with fewer nodes. The inductive embedding on the other hand is more consistent with the common training/prediction model that we are used to find in most machine learning techniques. It requires labeled data in order to train the target function.

In our proposed approach, we are interested in extracting information from the workers' network structure and from each of their devices in a simple fast way. Therefore, we focus on the transductive node embedding. There are two groups of embedding in the social network graph: 1) the first one is a featureless node embedder using single layer GNNs, aka, shallow embedders and 2) the second one is an attributed graph embedder using unsupervised multi-layer GNNs. In the first group, the embedding captures only the social network graph topology, vertex-to-vertex relationship, and sometimes other relevant information about graphs, subgraphs, and vertices. The second group, however, is also able to capture the nodes' characteristics and features while including them in the resultant output embedding vectors. The key difference between these two groups lies in the definition of the encoding function mapping the social network graph to the embedding space. As Fig. 3 illustrates, this function, referred to as EN C(), is responsible from outputting the node u's embedding vector value Zu from the original network. Depending on which embedding group (i.e., single layer GNNs or unsupervised multi-layer GNNs), the function EN C() must be carefully defined in order for the resultant vector value Zu to include either the social network vertex-to-vertex relationship or both vertex-to-vertex relationship and the devices' features.

For the first group, this mapping function represents a simple encoder that captures only the workers' social relationships, which can be written as follows [47]:

EN C(u) = zu = Z × eu,

(11)

where Z is the output matrix with dimension d×|V| containing the embedding values of the nodes V and eu is an indicator vector that has all values set to zero except in one column, set to one, indicating the presence state of node u.

For the second group, and because of its complexity and

need to capture the nodes' attributes, the encoder is in the form

of unsupervised multi-layer neural networks [48]. The encoder

no longer only takes the node's relations as input but also its

attributes. As Fig. 4 shows, the encoder is a computational

graph with multiple encoding layers. The first layer (i.e., layer

0) takes as input vector Xu,0, which also involves the attributes of the node u. The encoding for node u is accomplished using

Xu,0 and all the directly connected nodes in a set N (u), which, in the example of Fig. 4, are nodes q, r, and v for node u.

The final layer, in Fig. 4, Layer 2, captures the embedding of

the nodes. The neural layers corresponding to layer k for a

node u are defined as hku and can be written as follows:





hku =

 Wk

hka-1 |N (u)|

+

Bkhku-1 ,

aN (u)

k  {1, · · · , K} (12)
The initial 0-th layer embedding h0u are equal to the node features xu and the optimized embedding zu are equal to

8

(2 ) = 2   ,, ,1 + 2  ,1

u  ,2

(2 )

v 

v ,1

r ,1

q ,1

u ,1

u

ur

,0

uqt

s ,0 ,0

,0 ,0 ,0 ,0

vr q

,0 ,0

,0

Fig. 4: Illustration of the graph neural network embedding two nodes u and v using their attribute vector xu,0 and xv,0.

the final layer embedding hKu . The  function represents the non-linearity (e.g., relu) and Wk and Bk represent the

trainable weight matrices that will be adjusted with the loss

function. The term

hka-1 aN (u) |N (u)|

represents

the

average

of neighbors's previous layer embedding. A more simplified

vector format is written as follows:

H(l+1) =  H(l)W(l) + A~ H(l)B(l) ,

(13)

where A~

=

D-

1 2

AD-

1 2

and

H(k)

=

h(1k)T , . . . , h(mk)T

T
,

where D is the diagonal matrix, A is the social relationship

adjacency matrix and m represents the number of embeddings

in layer k.

After defining the appropriate encoders for the single layer GNN and unsupervised multi-layer GNN, we need to define two similarity functions [48] that specify how the nodes characteristics in the vector space map to nodes' characteristics in the original network. The first similarity function, denoted by S, compares the nodes in the original graph, while the second function compares the embedding vectors. The similarity between tow nodes u and v in the embedding space is simple and can be defined as zv zu, the dot product between the vectors. The goal is to find a function S where the embedding zu and zv of the nodes u and v can be optimized in a way such that:

S(u, v)  zv zu.

(14)

In the literature, there have been some studies [49], [50] focusing on multiple approaches using different similarity functions. Some functions include a basic adjacency matrix, multi-hop network similarity matrix, or a random walk similarity [51]­[53]. For the shallow encoding, we rely on the random walk technique. The nodes similarity in the social network graph is computed based on the probability that two nodes u and v co-occur on a random walk over the network. Moreover, the probability of visiting node v on a random walk starting from node u using some random walk strategy R describes the similarity between the two nodes. We choose this particle similarity function because it incorporates both local and higher-order neighborhood information and does not need to consider all node pairs when training; it only needs to

consider pairs that co-occur on random walks. The difference between this similarity, also known as Loss, is the function that will be optimized, and it is written as follows:

L=

- log (P (v | zu)) ,

(15)

uV vNR(u)

where NR(u) describes the multiset of nodes visited on random walks starting from node u and P (v | zu) represent

the likelihood of random walk co-occurrences between the

node v and embedding of node u computed using Softmax

as follows:

P (v | zu) =

exp zu zv

.

nV exp (zu zn)

(16)

This term represents the predicted probability of u and v

co-occuring on random walk. The overall loss function that

needed to be minimized is:

L=

- log

uV vNR(u)

exp zu zv

, (17)

nV exp (zu zn)

where the first sum is over all nodes u in the social network,

the second sum is over all nodes v seen on random walks

starting from u using a strategy R. Optimizing random walk

embeddings means finding zu that minimizes L. The unsuper-

vised multi-layer GNN approach takes advantage of the same

loss functions with a stochastic gradient descendent. In this

paper, we utilize the same loss function defined in (17) for

the single-layer GNN.

In our proposed approach, we utilize both the featureless

node embedders and the attributed graph embedders. As shown

in Fig. 2, for the featureless node embedder, we have only one

input (i.e., input1 only) and we employ the Graph Embedding

with Self Clustering (GEMSEC) [54]). For the attributed graph

embedder, we have two inputs (i.e., input1 and input2)

and we employ the Attributed Social Network Embedding

(ASNE) [55]). The GEMSEC provides a limited knowledge

about the workers. It only embeds their social relationships

and allows later clustering workers accordingly. However, the

ASNE embedder provides a better knowledge about the whole

system by including the workers' social relations as well as

their skills so that the obtained clusters will regroup workers

that are socially connected and share similar expertise. This

comes at the cost of a higher implementation complexity as it

requires large and diverse dataset.

The output of this phase is |W| feature vectors that are

forwarded to the clustering phase. The embedding is done in

order to turn the network graph into a set of numerical feature

vectors that can be handled by machine learning models.

C. Phase III: Clustering
Once the vector representation for each node in the SN graph is determined, we proceed with a dimensional reduction algorithm (e.g., T-SNE or PCA) in order to reduce the number of variables of the data by extracting most important ones from a large pool. This phase alleviates the clustering problem, speeds up the computation process, and presents a visualization method in the 2-dimensional space for the clusters. After that, an unsupervised machine learning technique can be utilized to group the workers with common features and attributes into clusters or communities. If the GEMSEC is

9

-Social Network graph (, ) -Set of workers'
attributes.
GA initial parameters (,,,
etc)
New population (combination)

-Platform's confidence level 
-Project  skill requirement 

Start

Generate initial
population

Generate  list of candidate solutions, each solution is a binary string having a length M × 
Evaluate population using fitness function

End
No?
Condition

Selection Crossover Mutation

Iteration++

Elitize

Select parents based on their
scores

Is this the highest value so
far?

Condition:
1) Iteration < 
2) Fitness function improvement

Yes?

Re-Evaluate population using fitness
function

Yes?

Record solution

No?

Discard

Fig. 5: Flowchart illustrating the worker selection mechanism (Phase V) of the proposed CMCS recruitment algorithm.

used in the embedding phase, the workers that are socially connected with be grouped in the same clusters. These workers may have different skills. We define this method as the "Edgeonly Embedding". However, if the ASNE is employed, then the workers sharing strong social relations and similar skills will be labeled in a common cluster. We identify this method as the "Edge-Attribute Embedding".
There are several possible machine learning approaches for clustering. The most known ones are Affinity Propagation, Agglomerative Clustering, DBSCAN, K-Means, OPTICS, Spectral Clustering, and Mixture of Gaussians [56]. As shown in Fig. 2, the inputs to this phase are feature vectors that the clustering algorithm will be performed on. The outputs are the resulting communities, which will be used as a small search space for the GA-based recruitment algorithm.

D. Phase IV: Data Post-processing

Given the obtained groups of similar workers, a cluster

selection algorithm is executed during a data post-processing

phase to output a set of candidate workers by determining the

appropriate clusters that should be forwarded to the recruit-

ment phase. The objective of the post-processing phase is to

determine the most appropriate cluster, or clusters, that the

recruitment algorithm of the following phase should focus on.

For the Edge-only embedding, our solution is to assign to

each cluster a "score" that reflects the degree of appropriate-

ness. This score is computed based on the average efficiency of

workers (equation (1)) belonging to each cluster. It takes into

account the skills that are required by the project's cluster Sp, average uncertainty level of the recruiter i, average requested

reward of the workers, and average SN strength. Hence, the

most appropriate cluster is chosen as follows:

c = arg max

Ewi ,k , i,

c=1,...,C¯ wCc kSp |Cc|

(18)

where Cc is the cluster c obtained from the clustering phase and C¯ is the total number of clusters. Next, the best cluster c

is selected for the next phase.

For the Edge-Attribute embedding, the clusters are grouping

workers having similar skills. Hence, the data pre-processing

phase aims to determine the most suitable |Sp|, i.e., each

cluster representing a particular skill. To this end, it assigns

to each of the clusters a skill score, which is computed as the

average skill level of all members of the cluster as known by

the recruiter i. A skill kc is assigned to cluster c as the most representative one using the following formula:

kc

=

arg max
kSp

wCc

S^wi ,k |Cc|

,

i,

c = 1, . . . , C¯,

(19)

In this way, the recruitment algorithm of the following phase

will consider only the obtained |Sp| clusters and, from which,

will select at most one worker.

E. Phase V: Worker Selection
For the worker selection phase, we propose to employ a lowcomplexity approach based on GA [57] that will be applied on the list of workers obtained from the data post-processing phase. The GA algorithm solves the CMCS recruitment problem formulated in (P) but on a much smaller search space compared to the ILP. Indeed, this algorithm is proposed as an alternative to the NP-hard optimal ILP approach because of its low overhead and running time. GAs simulate the process of natural selection which means those species who can adapt to changes in their environment are able to survive and reproduce and go to next generation. In GA, each generation consists of a population of individuals and each individual represents a point in the search space and a possible solution.
Once we determine the most appropriate shortlisted set of candidate workers after the post-processing phase, the GA-based worker selection algorithm starts the process of matching workers and forming the appropriate team for the project of interest. The GA's solving workflow is illustrated in Fig. 5 and can be briefly summarized as follows: At first, an initial generation of genes is created. This generation can be a string of digit values where each digit reflects a certain status. This generation evolves using: i) the selection operator

10

which is mainly giving preference to the individuals with good fitness scores and allows them to pass their genes to the successive generations, ii) the crossover operator which represents mating between individuals, and hence, two individuals are selected using selection operator and crossover sites are chosen randomly, and finally iii) The mutation operator which inserts random genes in offspring to maintain the diversity in population to avoid the premature convergence. This process is repeated until a pre-defined condition is met. As shown in Fig. 5, this condition can be, for example, the number of iterations reaching a threshold value nI or when there is no improvement in the fitness function. In the case of looping a local optimum, we apply a restart operation which restarts the whole process with new initial generation. We choose to perform elitism after each generation to ensure that the best individual remains in the next generation. In the case of platform-based scheme, the genes population represents the series of workers' skill attributes. In fact, each worker is represented by an S-digit binary values where S represents the possible skills in the platform. For example, if |S| = 4, and |W| = 3 then "100000100001" represents the genes series of three workers, where the first worker contributes with the first listed skill in the platform, the second worker contributes with the third skill in the platform, and the third worker contributes with the last listed skill in the platform.
We should note that when generating the initial population, the default GA generates random strings. However, in our case, we tune this process and setup a specific generation technique that is able to enhance the performances of the GA. In fact, since all the feasible solutions are strings with length N × M having only |Sp| set of ones, we opt to modify the random generation to produce strings with length N × M containing |Sp| set of ones and (N × M - |Sp|) set of zeros. In this way, the algorithm initially starts with a feasible solution and the search space is narrowed down, consequently boosting the GA performances and convergence speed. However, this comes at the expense of increasing the likelihood of getting stuck in local maxima/minima. In order to overcome this and avoid being trapped a local optimum, we have introduced the restarting technique to completely re-initiate the GA algorithm each time the algorithm detects a premature convergence.
Also, in the case of multiple project assignments, the string of genes is no longer binary but rather integer with values taking place between 0 and |P|. In the case of the leader-based scheme, we could add a series of bits with length |W | + 1 at the beginning of the gene string stating the recruiter. We also should reduce for this specific string the frequency of mutation and crossover since any change on this particular series of bits is sensible as it changes the recruiter.
VI. EXPERIMENTS AND EVALUATION
In this section, we investigate the performances of the proposed CMCS recruitment approaches. At first, we start by presenting the used dataset and environmental setup. Then, we conduct experiments to show the differences between the leader-based and platform-based recruitment strategies using the ILP method. Next, we analyze the behavior of the proposed GNN approach by investigating the embedding and clustering

Fig. 6: The SN graph extracted from the real-world Facebook dataset.

Number of nodes

Job type

Job: Category 1 Job: Category 2 Job: Category 3 Job: Category 4 Job: Category 5 Job: Category 6 Job: Category 7 Job: Category 8 Job: Category 9 Job: Category 10 Job: Category 11 Job: Category 12 Job: Category 13 Job: Category 14 Job: Category 15 Job: Category 16 Job: Category 17 Job: Category 18 Job: Category 19 Job: Category 20 Job: Category 21 Job: Category 22 Job: Category 23 Job: Category 24

Fig. 7: Histogram illustrating the Job type distribution in the Dataset.

0.6

Skill: Category 1

Skill: Category 2

Skill: Category 3

0.5

Skill: Category 4

Skill: Category 5

Skill: Category 6

0.4

Skill: Category 7

Skill: Category 8

0.3

Skill: Category 9 Skill: Category 10

0.2

Skill Value

0.1

0 0 1427 325 145 99

5 3356 14 224 489 1154 77 887 543 4000 532 66 32 221 468 521
Node Id

Fig. 8: Samples from the dataset showing the skill values for certain workers. A work can have multiple skills at the same time but with different levels.

performances to, finally, close the loop by comparing the performances of the GNN recruitment method with the ones of the ILP. We should note that all the simulations to evaluate the performances of the proposed GNN-based approach were done on the entire large-scale dataset presented in the following section. However, whenever the ILP was involved (either when analyzing the performances of the two recruitment schemes or when validating the performances of the proposed GNN-based approach), we had to shrink the huge initial pool of workers to a small-scale dataset because of its high computational complexity.

A. Dataset and Environmental Setup
Because there are no available real-world datasets that can be directly used to simulate CMCS applications, we had to fine-tune our own dataset while inspiring from the most suited available ones in order to fairly perform the evaluation.

Team Skill Level (avg) Uncertainty Level (avg) Allocated Budget (avg) Relationship Rate (avg)

|W| =  |W| = 

Leader-based Platform-based

|W| =  |W| = 

Leader-based Platform-based

|W| =  |W| = 

Leader-based Platform-based

11
|W| =  |W| =  Leader-based Platform-based

SN Edge Degree (avg)

SN Edge Degree (avg)

SN Edge Degree (avg)

SN Edge Degree (avg)

Fig. 9: Efficiency criteria vs. SN edge degree for the leader-based and the platform-based recruitment strategies with |Sp| = 5 for values of |W| set to 14 and 28. (a) Average skills level, (b) average recruiter's uncertainty level of the recruited team, (c) average cost per worker, and (d) social relationship rate.

Our created dataset is partially synthetic and exploits the "ego-Facebook" [58], a real dataset from Facebook collected from 4039 survey participants and containing 88234 edges, to simulate the workers' social network. The "ego-Facebook" is initially an ego-centered dataset that contains lists of 'circles' (i.e., 'friends lists') from Facebook. This can be seen in Fig. 6 where the users' circles appear like communities. The dataset originally includes the nodes' edges and their corresponding features (i.e., profile attributes). Examples of these features are the Facebook id, job type, work experience, sign-up date, and birthday. Because of the privacy concerns, all the data has been anonymized and the feature's interpretation has been obscured and replaced with anonymized data. For instance, if a feature "Area-of-Expertise" has a category "Computer Systems", the "ego-Facebook" dataset would simply contain "Area-of-Expertise=anonymized category 1". A histogram illustrating the job feature with multiple categories is shown in Fig. 7. Since the data has been obscured, we choose to manually label each of the categories such that they are related to CMCS applications (e.g., WorkCategory1 is turned to "doctor", workCategory is turned to "salesman", etc.). To calculate and assign the workers' skills levels and demanded cost, we extract and join some of the features that we find appropriate to CMCS applications such as current job, previous job, work domain, and work start date and join them in a while introducing our own fuzzy-logic values. Moreover, we use the Facebook users' current field of work (e.g., IT, medical, business, etc.) and their education background (e.g., high school, university, school) along with their availability (e.g., retired, full-time, unemployed) to estimate the degree of skills and demanded cost of each worker. For example, users with a medical field of work and have a full-time availability are more qualified to achieve a project that requires high medical skills than a nurse with high school background and part time availability. Furthermore, if a certain CMCS project demands skilled workers in the medical field and the platform contains profiles of users which have 'doctor, nurse, etc.', it is only natural for a node with a category "doctor" to be more skilled than the other two categories. For the reward attribute, we introduce some randomness to reflect the human demand noise. We also introduce another randomness where we assign to every node some degrees of skill level in the fields out of its main specialty. This can be seen in Fig. 8 where a worker that has a domain of expertise in IT (e.g., category 1) can have little background in the medical field (e.g., category 4),

Fig. 10: An example of the selected teams using both recruitment strategies for an SN graph where |W| = 14 and |Sp| = 4. The selected team members are green and red for the leader-based and the platform-based approaches, respectively. For the former approach, the team leader is contoured in bold.

therefore, we choose to attribute a low value of skills for all

the workers in their non-domains of expertise. As such, we do

for the rewards.

To sum up, our resultant dataset contains 88234 real world

relationships between 4039 ego-centered Facebook users. We

took the Facebook circles, their ego center, and the edges

and built the SN relationship graph. Then, we used Dijkstra

shortest path algorithm in order to turn the graph into a fully

connected one where the edges are inversely proportional to

the number of hops between the users. This way, we can

quickly estimate the distance between users without having to

compute it every time in the algorithm. For each of the users,

we estimated their attributes, i.e., their skill and reward, using

the real features contained in the Facebook dataset. These two

attributes are fuzzy-logic based as discussed in III-B and they

are computed using the users' history of job field, experience,

education, working period, and availability.

The values of i in the objective function of (P) are chosen

uniformly

(i.e.,

i

=

1 4

,

i).

In

our

experiments,

all

algorithms

are implemented in a Python 3.6 environment and run on a 32

socket Intel(R) Xeon (R) E5-2698 v3 @2.30GHz CPU with

72G of RAM. To solve the ILP problems, we use the python

API of academical CPLEX. For the first embedding approach

(i.e., using GEMSEC), we set the number of node embedding

dimension to 23, the random walk length to 80, the number

of walks from source to 5, the downsampling distortion to

0.75. For the second approach (i.e., using ASNE), we set the

number of feature embedding dimension to 48, the size of

the gradient to 64, and the number of training epochs to 10.

For the following sections, we refer to |W| as the number

12

of workers selected randomly from the pool of 4039 workers available in the dataset.
For the platform-based approach, the knowledge level about the workers' skills and the workers' relationships are proportionally modeled to their history in the platform (i.e., workers with more history in the platform has lower uncertainty levels). On the other hand, the uncertainty levels of potential leaders i towards workers w for the leader-based recruitment strategy regarding the workers relationships are proportional and increase with the number of hops between the team leader and other workers. For both approaches, the error is modeled as a zero-mean normal distribution  N (0, 0.32).
B. ILP Recruitment: Comparison between Platform-based Strategy and Leader-based Strategy
In Fig. 9, we perform a Monte Carlo simulation where 1, 000 realizations of different parameter settings are generated. We evaluate the average four metrics of the selected teams: skills efficiency Fig. 9(a), recruiter confidence Fig. 9(b), team cost Fig. 9(c), and social relationships Fig. 9(d). Due to the high complexity of the ILP approach, we randomly pick a small subset |W| from the entire dataset with different edge density levels from the graph G(W, E). This simulation is run on |W| = 14 and |W| = 28 and the value of |Sp| is set to 5.
The result of this simulation for |W| = 14 shows that, for the leader-based approach, the performances for all metrics get higher with the increase of the edge density. For instance, the uncertainly level on the selected team skill decreases and tends to zero when the edge density reaches one. This can be explained by the fact that, by increasing the edge density of the graph, the number of hops between the leader and any worker in G(W, E) decreases. Moreover, the number of directly connected workers increases until the resultant graph is fully connected (i.e., everyone knows everyone). Also, the team skills level, budget allocation, and relationships rate increase when increasing the edge density because the team leader will have more workers connected to it and consequently more vast choices in its vicinity. When increasing the edge density, the relationships rate within the team increases because team members are more likely to have more connections. However, the performances of the platform-based approach, except the relationships rate, remains basically invariant while varying the edge density. We notice a growth in the relationships rate and a slight decrease in all the other metrics. This can be explained by the fact that the platform is basing its recruitment decision on the workers' history and any changes of the edges density in G(W, E) will only affect the relationships term in the objective function. Notice that, for the leader-based approach, the recruited team skills level exceeds the one of the platform-based approach when the SN network becomes nearly fully connected. These observation remains valid for |W| = 28. In fact, the effect of expanding the network while maintaining the number of required team members enhanced slightly the performance of both recruitment strategies by increasing the team skill level and decreasing the recruiter uncertainty. We notice that, for the leader-based approach, the team skill level curve has a higher slop and converge faster than when |W| = 14.

Fig. 11: 2-D representation showing the result of the T-SNE and GEMSEC for embedding and self-clustering where colors represent workers belonging to the same cluster. The legend indicates the color and index of each cluster.
Fig. 12: 2-D representation showing the result of the T-SNE using the GEMSEC for embedding and self-clustering where colors represent the dominant skills of each worker. The legend indicates the color and index of each possible skill.
Fig. 13: Result of Edge-Attribute embedding using the T-SNE, ASNE for embedding, and GEMSEC for clustering where colors represent workers belonging to the same cluster. The legend indicates the color and index of each cluster.
In Fig. 10, we present an example of the recruited teams using both recruitment strategies for |W| = 14, |Sp| = 4. The figure shows that the leader-based approach recruits a congregated team (workers are close to each other in the SN) while the platform-based approach recruits a team relatively scattered but with higher skills. C. Graph Embedding and Clustering Performances
Before comparing the results of the ILP and the proposed low-complexity algorithms, we propose to analyze the per-

13

TABLE II: Statistics showing the clustering efficiency of the two embedding/clustering algorithms: Phase I to Phase III

Modularity Number of clusters
Avg number of users per cluster Max number of users per cluster Min number of users per cluster

Edge-only Embedding
0.632 25 160
421
253

Edge-Attribute Embedding 0.314 36 111
197
6

formance of the employed graph embedding techniques and clustering algorithms with the studied dataset (i.e., Phase I till Phase III of the proposed recruitment approach). After performing the node embedding on the SN graph using GEMSEC, we obtain a 23-D vector. We run T-SNE as the dimensionality reduction algorithm to speed up the computations. Next, we use the output of the T-SNE as input to clustering component in the GEMSEC. The final output of this process is illustrated in Fig. 11 and Fig. 12. As we can notice, in Fig. 11, we color the nodes with different colors where each color represents the cluster color. In Fig. 12, we color the same nodes but this time, the color reflects the skill type of each worker/node. As it is showing, each cluster represents a community that have multiple workers with diversified skills. The clustering effect is illustrated using the SN graph as showing in Fig. 11 and Fig. 12. Note that this approach serves also as a community detection technique.
After performing the Edge-Attribute embedding on the SN graph and their attributes (namely skill level and cost), we obtain also a 48-D feature vector. We also run the dimensionality reduction algorithm (T-SNE) then perform clustering using GEMSEC. The final output of this process is illustrated in Fig. 13. As we can see, in Fig. 13, we color the nodes with different colors where each color represents the cluster color. This type of embedding has made it possible to cluster nodes based on their attributes and SN degree. In each of these cluster, the nodes are practically similar in term of attributes, and they are close in the SN graph. Therefore, each cluster represents an expertise. Some metrics highlighting the difference between the two clustering approaches have been computed and included in Table II. As it is shown, the modularity using the edge-only embedding is higher than the modularity of the edge-attribute embedding. This can be explained by the fact that the first approach uses the node's edges only to compute the clusters and therefore, the resultant clusters contain nodes that are more close in the SN.
Note that, for dimensionality reduction, we could have used the famous PCA. However, PCA is a linear algorithm and therefore it will not be able to interpret the complex polynomial relationship between features in the SN while tSNE is made to capture exactly that. Also, PCA and t-SNE are not mutually exclusive. When dealing with highly dimensional data where t-SNE simply does not scale. We may use PCA first to reduce the dimensionality of the data and then, taking the top principal components, we apply t-SNE for visualization.

Edge-only Embedding GA

0.7

Edge-Attribute Embedding GA

ILP

0.6

0.5

0.4

0.3

0.2

0.1

Value

Skill (avg)

Skill

Edge Degree Edge

Uncertainty

(avg) Uncertainty

(avg)

(avg)

Reward

Objective

(avg) Function (avg)

Fig. 14: Performances of the proposed CMCS recruitment approaches using |W| = 14. The Edge-only embedding and Edge-Attribute embedding GA-based algorithms versus the optimal ILP.

D. Proposed Algorithm Performance Analysis
In this subsection, we evaluate the performances of the proposed algorithm against the optimal ILP. For simplification purposes, and because extensive evaluations were conducted between the two recruitment strategies using the ILP, the proposed CMCS recruitment algorithm was only implemented for the platform-based scheme. However, theoretically, the results remain valid even for the leader-based scheme. For the performances analysis, we run a Monte-Carlo simulation where 1, 000 realizations of different project settings are generated for the Facebook dataset. For the GA, we define Nb as the base population size, Ni as the number of iterations, Rc as the rate of crossover, and Rm as the rate of mutation. we set Nb = 1000, Ni = 500, Nc = 0.4 and Nm = 0.8. The choice of these values was carefully picked based on several conducted trials. From the initial 4039 pool of workers in the dataset, we pick at each realization only |W| = 14 workers. This is done to ensure fairness comparison between the performances of the ILP and the proposed approach as the ILP has an exponential running time and consequently, it fails to converge in a reasonable time for higher values of |W| . Furthermore, the ILP was run on 14 pool of workers. However, for our proposed solution, and by the means of the means of the embedding and clustering techniques, this initial pool of workers is reduced to only the best potential candidates that are estimated to have the best performances and the GA is run on the resultant shrunk pool. We evaluate the performances of the ILP, a GA algorithm based on Edge-only embedding, and a GA based on Edge-Attribute embedding using the recruitment key metrics: skills, skills uncertainty, edge degree, edge uncertainty, and the reward. For each of the 1, 000 simulation, we pick random |W| workers from the total available 4039 that satisfies the following constraints: i) for the edge-only embedding, |W| must result in at least |Sp| clusters, ii) for the edge-attribute embedding, |W| must result at least in one cluster containing at least |Sp| nodes. If the selected W workers validate these conditions, we proceed and perform the worker selection phase. As Fig. 14 illustrates, we notice that the performances of the proposed CMCS recruitment algorithm for the attributed embedding achieves better results than the Edge-only embedding with close performances to the optimal ILP.
In order to evaluate the time complexity of the CMCS

14

Running Time (s)


ILP
. 

. 

. 
Edge-Attribute Embedding GA


Edge-only Embedding GA

Running Time (s)

12

Stochastic Approach

10

8

Edge-Attribute

6

Embedding PSO

4

ILP
Edge-Attribute Embedding GA

5

6

7

8

9

10

11

12

Number of Workers

Fig. 15: Running time in seconds for the Edge-only embedding and Edge-Attribute embedding GA-based algorithms and the optimal ILP.

0.8

0.7

0.6 0.5

Value

0.4

0.3

0.2

0.1

Skill (avg)

Skill

Edge Degree Edge

Uncertainty (avg) Uncertainty

(avg)

(avg)

Reward Objective (avg) Function (avg)

Fig. 16: Performances of the proposed CMCS recruitment approaches using |W| = 1800. The Edge-Attribute embedding GA-based algorithm versus the Edge-Attribute embedding PSO-based algorithm and CMCS Stochastic approach.

algorithms: the proposed low-complexity CMCS recruitment approach along with the optimal algorithm, we perform a running time simulation during which we vary the number of available workers in the platform and compute the running time needed for the three algorithms to converge. As Fig. 15 shows, we notice that the optimal approach has the highest running time among the three algorithms and that the time complexity gap increases while increasing the number of available workers. Also, the optimal ILP has an exponential running time because the running time increases exponentially with the size of the input (i.e., number of workers). However, we note that the time complexity of the proposed CMCS recruitment approach with the two embedding variation is polynomial. The GA algorithm based on Edge-Attribute embedding has a slightly higher running time than the Edge-only Embedding GA.
In another experiment, we increase the pool of initial workers to |W| = 1800 and evaluate the performances of the proposed Edge-Attribute Embedding GA with two other CMCS recruitment algorithms. The first is similar to the proposed approach but instead of using GA, we employ the PSO algorithm. We refer to this algorithm as "Edge-Attribute Embedding PSO". Hence, the workers of the network undergo an attribute embedding and clustering to shrink the pool of workers before running the PSO algorithm. The second approach, identified as the "Stochastic approach", is a probabilistic technique that uses the optimal stopping strategies. It is based on the odds algorithm [59], [60]. The purpose of this Monte-Carlo simulation is to evaluate the recruitment

2 1500 1550

1600 1650 1700 1750
Number of Workers

1800

Fig. 17: Running time in seconds for the Edge-Attribute embedding GA-based algorithm, the Edge-Attribute embedding PSO-based algorithm, and CMCS Stochastic approach.

key metrics: skills, skills uncertainty, edge degree, edge uncertainty, and the reward for each of these three algorithms for a large-scale network. As performed previously in Fig. 14, for each of the 1, 000 simulations, we pick random |W| = 1800 workers from the total available 4039. We notice that the EdgeAttribute Embedding PSO achieves, in certain key metrics, higher performances than the Edge-Attribute Embedding GA. However, the highest overall objective function, describing the efficiency of the recruited team was realized by the EdgeAttribute Embedding GA. The Stochastic approach performs poorly compared to the other two algorithms. This might be due to the fact that it operates on the entire |W| = 1800 workers and does not undergo search space reduction. We also perform time complexity analysis for these three algorithms while varying the number of workers between 1500 and 1800. As shown in Fig. 17, the Edge-Attribute embedding GA algorithm has a slight lower running time than the EdgeAttribute embedding PSO. The stochastic approach yields an elevated running time surpassing 10s per simulation.

VII. CONCLUSION AND FUTURE WORK
In this paper, we proposed a Collaborative Mobile Crowdsourcing (CMCS) recruitment approach in large-scale IoT networks. The objective is to form a skilled and socially connected team that matches the project requirements submitted to the platform by a task requester. We first formulated the CMCS team formation problem as an Integer Linear Program (ILP) that optimally recruit workers and form teams that satisfy the required project skills while being socially connected. We also proposed two recruitment strategies. The first proposed strategy is a platform-based approach which exploits the platform knowledge to form the team. The second one is a leader-based approach that designates one of the workers as a leader of the team and based on its knowledge about their SN neighbors the team is recruited.
Due to the high computational complexity of the ILP, we proposed a low-complexity heuristic recruitment approach that uses the network embedding/clustering techniques and rely on the genetic algorithm as a solver. This model proves to have lower overhead with close performances to the optimal ILP. Results of the effectiveness and efficiency of the proposed heuristic CMCS recruitment algorithm have been verified via

15

experiments on the Facebook dataset. It is shown that the proposed graph neural network based approach is able to shrink the search space of the CMCS dataset into small clusters of workers sharing common skills and/or social relations, which allow its easy application on large-scale CMCS platforms.
Based on the findings of this paper, our future work will treat the privacy concerns that workers could encounter when revealing their social interactions. Also, we will consider an adaptive feedback recruitment mechanism assuring submission quality control where the quality of the responses and collaborative behaviors among teams are assessed. Furthermore, we will enhance the learning component in our proposed approach, in terms of convergence speed and accuracy, by incorporating Bayesian learning in the embedding optimization and harnessing the power of inductive learning to avoid repeating the mapping process when new nodes are added to the social IoT network.
REFERENCES
[1] A. Hamrouni, H. Ghazzai, T. Alelyani, and Y. Massoud, "Optimal team recruitment strategies for collaborative mobile crowdsourcing systems," in 2020 IEEE Technology Engineering Management Conference (TEMSCON), Novi, MI, 2020, pp. 1­6.
[2] A. T. Abraha and B. Wang, "Hierarchical indoor localization from crowdsourced samples," IEEE Sensors Letters, vol. 4, no. 7, pp. 1­4, 2020.
[3] Y. Hu and R. Zhang, "A spatiotemporal approach for secure crowdsourced radio environment map construction," IEEE/ACM Transactions on Networking, vol. 28, no. 4, pp. 1790­1803, 2020.
[4] S. R. Pandey, N. H. Tran, M. Bennis, Y. K. Tun, A. Manzoor, and C. S. Hong, "A crowdsourcing framework for on-device federated learning," IEEE Transactions on Wireless Communications, vol. 19, no. 5, pp. 3241­3256, 2020.
[5] A. Hamrouni, H. Ghazzai, M. Frikha, and Y. Massoud, "A spatial mobile crowdsourcing framework for event reporting," IEEE Transactions on Computational Social Systems, vol. 7, no. 2, pp. 477­491, Apr. 2020.
[6] ----, "A photo-based mobile crowdsourcing framework for event reporting," in 2019 IEEE 62nd International Midwest Symposium on Circuits and Systems (MWSCAS), Aug 2019, pp. 198­202.
[7] R. Alabduljabbar and H. Al-Dossari, "A dynamic selection approach for quality control mechanisms in crowdsourcing," IEEE Access, vol. 7, pp. 38 644­38 656, 2019.
[8] Y. Ren, W. Liu, T. Wang, X. Li, N. N. Xiong, and A. Liu, "A collaboration platform for effective task and data reporter selection in crowdsourcing network," IEEE Access, vol. 7, pp. 19 238­19 257, 2019.
[9] H. Cai, V. W. Zheng, and K. C. Chang, "A comprehensive survey of graph embedding: Problems, techniques, and applications," IEEE Transactions on Knowledge and Data Engineering, vol. 30, no. 9, pp. 1616­1637, 2018.
[10] F. Scarselli, M. Gori, A. C. Tsoi, M. Hagenbuchner, and G. Monfardini, "Computational capabilities of graph neural networks," IEEE Transactions on Neural Networks, vol. 20, no. 1, pp. 81­102, 2009.
[11] A. Khanfor, A. Nammouchi, H. Ghazzai, Y. Yang, M. R. Haider, and Y. Massoud, "Graph neural networks-based clustering for social internet of things," in 2020 IEEE 63rd International Midwest Symposium on Circuits and Systems (MWSCAS), 2020, pp. 1056­1059.
[12] Y. Zheng, G. Li, and R. Cheng, "Docs: A domain-aware crowdsourcing system using knowledge bases," Proc. VLDB Endow., vol. 10, no. 4, pp. 361­372, Nov. 2016.
[13] Y. Gong, L. Wei, Y. Guo, C. Zhang, and Y. Fang, "Optimal task recommendation for mobile crowdsourcing with privacy control," IEEE Internet Things J., Oct 2016.
[14] T. Alshammari, S. Samarakoon, A. Elgabli, and M. Bennis, "Baygo: Joint bayesian learning and information-aware graph optimization," CoRR, vol. abs/2011.04345, 2020. [Online]. Available: https://arxiv.org/ abs/2011.04345
[15] C. Yan, Y. Chen, F. Wang, Y. Wen, S. Fu, and W. Huang, "A multiobjective video crowdsourcing method in mobile environment," IEEE Access, vol. 7, pp. 133 787­133 798, 2019.

[16] A. Ben Said and A. Erradi, "A probabilistic approach for maximizing travel journey wifi coverage using mobile crowdsourced services," IEEE Access, vol. 7, pp. 82 297­82 307, 2019.
[17] G. Lee, B. Moon, and M. Park, "Crowdsourcing-based learning data collection for real-time sensor error correction in indoor environments," IEEE Access, vol. 8, pp. 127 353­127 367, 2020.
[18] L. Wang, Z. Yu, D. Zhang, B. Guo, and C. H. Liu, "Heterogeneous multi-task assignment in mobile crowdsensing using spatiotemporal correlation," IEEE Transactions on Mobile Computing, vol. 18, no. 1, pp. 84­97, Jan 2019.
[19] R. Estrada, R. Mizouni, H. Otrok, A. Ouali, and J. Bentahar, "A crowdsensing framework for allocation of time-constrained and location-based tasks," IEEE Transactions on Services Computing, vol. 13, no. 5, pp. 769­785, 2020.
[20] B. Guo, Y. Liu, L. Wang, V. O. K. Li, J. C. K. Lam, and Z. Yu, "Task allocation in spatial crowdsourcing: Current state and future directions," IEEE Internet of Things Journal, June 2018.
[21] H. Gao, Y. Xiao, H. Yan, Y. Tian, D. Wang, and W. Wang, "A learning-based credible participant recruitment strategy for mobile crowd sensing," IEEE Internet of Things Journal, vol. 7, no. 6, pp. 5302­5314, 2020.
[22] D. Yu, Y. Wang, and Z. Zhou, "Software crowdsourcing task allocation algorithm based on dynamic utility," IEEE Access, vol. 7, pp. 33 094­ 33 106, 2019.
[23] Y. Xing, L. Wang, Z. Li, and Y. Zhan, "Multi-attribute crowdsourcing task assignment with stability and satisfactory," IEEE Access, vol. 7, pp. 133 351­133 361, 2019.
[24] D. Yu, Z. Zhou, and Y. Wang, "Crowdsourcing software task assignment method for collaborative development," IEEE Access, vol. 7, pp. 35 743­ 35 754, 2019.
[25] J. Wang, F. Wang, Y. Wang, D. Zhang, L. Wang, and Z. Qiu, "Socialnetwork-assisted worker recruitment in mobile crowd sensing," IEEE Transactions on Mobile Computing, vol. 18, no. 7, pp. 1661­1673, 2019.
[26] F. Zhou, J. Li, Y. Lin, J. Wei, and V. K. A. Sandor, "A secure and efficient task matching scheme for spatial crowdsourcing," IEEE Access, vol. 8, pp. 155 819­155 831, 2020.
[27] N. A. Abdullah, M. M. Rahman, M. M. Rahman, and K. I. Ghauth, "A framework for optimal worker selection in spatial crowdsourcing using bayesian network," IEEE Access, vol. 8, pp. 120 218­120 233, 2020.
[28] Y. Wang, Z. Cai, Z. Zhan, B. Zhao, X. Tong, and L. Qi, "Walrasian equilibrium-based multiobjective optimization for task allocation in mobile crowdsourcing," IEEE Transactions on Computational Social Systems, vol. 7, no. 4, pp. 1033­1046, 2020.
[29] A. Hamrouni, H. Ghazzai, and Y. Massoud, "Many-to-many recruitment and scheduling in spatial mobile crowdsourcing," IEEE Access, vol. 8, pp. 48 707­48 719, 2020.
[30] A. Lakhani, A. Gupta, and K. Chandrasekaran, "Intellisearch: A search engine based on big data analytics integrated with crowdsourcing and category-based search," in 2015 International Conference on Circuits, Power and Computing Technologies [ICCPCT-2015], March 2015, pp. 1­6.
[31] S. Murali, V. Krishnapriya, and A. Thomas, "Crowdsourcing for disaster relief: A multi-platform model," in 2016 IEEE Distributed Computing, VLSI, Electrical Circuits and Robotics (DISCOVER), Aug 2016, pp. 264­268.
[32] W. Wang, Z. He, P. Shi, W. Wu, Y. Jiang, B. An, Z. Hao, and B. Chen, "Strategic social team crowdsourcing: Forming a team of truthful workers for crowdsourcing in social networks," IEEE Transactions on Mobile Computing, vol. 18, no. 6, pp. 1419­1432, 2019.
[33] Q. Liu, T. Luo, R. Tang, and S. Bressan, "An efficient and truthful pricing mechanism for team formation in crowdsourcing markets," in 2015 IEEE International Conference on Communications (ICC), June 2015, pp. 567­572.
[34] I. Dissanayake, J. Zhang, and B. Gu, "Virtual team performance in crowdsourcing contest: A social network perspective," in 2015 48th Hawaii International Conference on System Sciences, Jan 2015, pp. 4894­4897.
[35] H. Jiang and S. Matsubara, "Efficient task decomposition in crowdsourcing," in PRIMA 2014: Principles and Practice of Multi-Agent Systems, H. K. Dam, J. Pitt, Y. Xu, G. Governatori, and T. Ito, Eds. Cham: Springer International Publishing, 2014.
[36] J. Flores-Parra, M. Castan~o´n-Puga, R. D. Evans, R. Rosales-Cisneros, and C. Gaxiola-Pacheco, "Towards team formation using belbin role types and a social networks analysis approach," in 2018 IEEE Technology and Engineering Management Conference (TEMSCON), June 2018, pp. 1­6.

16

[37] A. Anagnostopoulos, L. Becchetti, C. Castillo, A. Gionis, and S. Leonardi, "Online team formation in social networks." International Conference on World Wide Web (WWW'12), Lyon, France, Apr. 2012.
[38] M. Kargar and A. An, "Discovering top-k teams of experts with/without a leader in social networks," in ACM Int. Conf. Inf. Knowl. Manag., ser. CIKM '11, New York, NY, USA, 2011.
[39] A. Hamrouni, H. Ghazzai, T. Alelyani, and Y. Massoud, "Towards collaborative mobile crowdsourcing," IEEE Internet of Things Magazine, 2021. [Online]. Available: https://arxiv.org/abs/2104.05626
[40] Q. Wang, Z. Mao, B. Wang, and L. Guo, "Knowledge graph embedding: A survey of approaches and applications," IEEE Transactions on Knowledge and Data Engineering, vol. 29, no. 12, pp. 2724­2743, 2017.
[41] Y. Zhu, Y. Xu, F. Yu, S. Wu, and L. Wang, "Cagnn: Cluster-aware graph neural networks for unsupervised graph representation learning," 2020.
[42] A. Hamdi, D. Y. Kim, and F. D. Salim, "flexgrid2vec: Learning efficient visual representations vectors," 2020.
[43] A. Grover and J. Leskovec, "node2vec: Scalable feature learning for networks," 2016.
[44] A. Narayanan, M. Chandramohan, R. Venkatesan, L. Chen, Y. Liu, and S. Jaiswal, "graph2vec: Learning distributed representations of graphs," 2017.
[45] B. Perozzi, R. Al-Rfou, and S. Skiena, "Deepwalk: Online learning of social representations," CoRR, vol. abs/1403.6652, 2014. [Online]. Available: http://arxiv.org/abs/1403.6652
[46] J. Yang, J. You, and X. Wan, "Graph embedding via graph summarization," IEEE Access, vol. 9, pp. 45 163­45 174, 2021.
[47] W. L. Hamilton, R. Ying, and J. Leskovec, "Representation learning on graphs: Methods and applications," 2018.
[48] J. Zhou, G. Cui, S. Hu, Z. Zhang, C. Yang, Z. Liu, L. Wang, C. Li, and M. Sun, "Graph neural networks: A review of methods and applications," 2021.
[49] Z. Wu, S. Pan, F. Chen, G. Long, C. Zhang, and P. S. Yu, "A comprehensive survey on graph neural networks," IEEE Transactions on Neural Networks and Learning Systems, vol. 32, no. 1, p. 4­24, Jan 2021. [Online]. Available: http://dx.doi.org/10.1109/TNNLS.2020. 2978386
[50] J. Shao, Y. Mao, and J. Zhang, "Learning task-oriented communication for edge inference: An information bottleneck approach," 2021.
[51] Z. Zhang, P. Cui, and W. Zhu, "Deep learning on graphs: A survey," IEEE Transactions on Knowledge and Data Engineering, pp. 1­1, 2020.
[52] S. Georgousis, M. P. Kenning, and X. Xie, "Graph deep learning: State of the art and challenges," IEEE Access, vol. 9, pp. 22 106­22 140, 2021.
[53] W. Dou, W. Zhang, Z. Weng, and Z. Xia, "Graph embedding framework based on adversarial and random walk regularization," IEEE Access, vol. 9, pp. 1454­1464, 2021.
[54] B. Rozemberczki, R. Davies, R. Sarkar, and C. Sutton, "Gemsec: Graph embedding with self clustering," 2018.
[55] L. Liao, X. He, H. Zhang, and T. Chua, "Attributed social network embedding," IEEE Transactions on Knowledge and Data Engineering, vol. 30, no. 12, pp. 2257­2270, 2018.
[56] J. Zhang, X. Hong, S. Guan, X. Zhao, H. Xin, and N. Xue, "Maximum gaussian mixture model for classification," in 2016 8th International Conference on Information Technology in Medicine and Education (ITME), 2016, pp. 587­591.
[57] B. Guo, Y. Liu, W. Wu, Z. Yu, and Q. Han, "Activecrowd: A framework for optimized multitask allocation in mobile crowdsensing systems," IEEE Transactions on Human-Machine Systems, vol. 47, no. 3, pp. 392­ 403, 2017.
[58] J. Leskovec and J. J. Mcauley, "Learning to discover social circles in ego networks," in Advances in Neural Information Processing Systems 25, F. Pereira, C. J. C. Burges, L. Bottou, and K. Q. Weinberger, Eds. Curran Associates, Inc., 2012, pp. 539­547.
[59] B. Blamey, F. Wrede, J. Karlsson, A. Hellander, and S. Toor, "Adapting the secretary hiring problem for optimal hot-cold tier placement under top-k workloads," in 2019 19th IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing (CCGRID), 2019, pp. 576­583.
[60] A. Hamrouni, H. Ghazzai, T. Alelyani, and Y. Massoud, "A stochastic team formation approach for collaborative mobile crowdsourcing," in 2019 31st International Conference on Microelectronics (ICM), 2019, pp. 66­69.

AYMEN HAMROUNI (Student Member, IEEE) received the Diplome d'Ingenieur degree (with summa cum laude) in Telecommunication engineering from the Ecole Superieure des Communications de Tunis (SUP'COM), Tunis, Tunisia, in 2019. In 2019, he was a Research Assistant with the Stevens Institute of Technology, Hoboken, NJ, USA. He is currently a Research Scholar with the School of Systems and Enterprises, Stevens Institute of Technology. His research interests include the intersection of mobile crowdsourcing, applied machine learning, optimization, social network analysis, mathematical modeling, graph theory, and the Internet-of-Things.
HAKIM GHAZZAI (Senior Member, IEEE) received the Ph.D. degree in electrical engineering from KAUST, Saudi Arabia, in 2015, and the Diplome d'Ingenieur (Hons.) in telecommunication engineering and the master's degree in high-rate transmission systems from the Ecole Superieure des Communications de Tunis (SUP'COM), Tunis, Tunisia, in 2010 and 2011, respectively. He was a Visiting Researcher with Karlstad University, Sweden, and a Research Scientist with the Qatar Mobility Innovations Center (QMIC), Doha, Qatar, from 2015 to 2018. He is on the Editorial Board of the IEEE Communications Letters, the IEEE Open Journal of the Communications Society, and Frontiers in Communications and Networks. He has authored over 130 articles in peerreviewed journals and conferences. He is currently a Research Scientist with the Stevens Institute of Technology, Hoboken, NJ, USA. His general research interests are on the areas of wireless networks, UAVs, the Internet of Things, intelligent transportation systems, and optimization.
TURKI ALELYANI (Member, IEEE) received his Ph.D. in Software Engineering from Stevens Institute of Technology, New Jersey, United States. Prior to that, he received his master degree in Computer Science from Stevens as well. Dr. Alelyani's research studies Socio-Technical Systems Design in order to overcome some of the challenges in motivation, engagement, coordination and collaboration. His research is applied into different domains including engineering design, Software Engineering, and social computing. He approaches this research by conducting empirical studies which involve using statistical analysis, machine learning, and experimental design.
YEHIA MASSOUD (Fellow Member, IEEE) received the Ph.D. degree in electrical engineering and computer science from the Massachusetts Institute of Technology, Cambridge, MA, USA. He is currently the Dean of the School of Systems and Enterprises, Stevens University of Science and Technology, Hoboken, NJ, USA. He has authored over 325 articles in peer-reviewed journals and conferences. He is a Fellow of the IEEE and has served as a Distinguished Lecturer by the IEEE Circuits and Systems Society and as an elected member of the IEEE Nanotechnology Council. He was selected as one of ten MIT Alumni Featured by MIT's Electrical Engineering and Computer Science department in 2012. He was a recipient of the Rising Star of Texas Medal, in 2007, the National Science Foundation CAREER Award, in 2005, the DAC Fellowship, in 2005, the Synopsys Special Recognition Engineering Award, in 2000, several best paper award nominations. Dr. Massoud has held several academic and industrial positions, including a member of the technical staff with the Advanced Technology Group, Synopsys, Inc., CA, USA, a tenured faculty with the Departments of Electrical and Computer Engineering and Computer Science, Rice University, Houston, USA, the W. R. Bunn Head of the Department of Electrical and Computer Engineering at UAB, Birmingham, USA, and the Head of the Department of Electrical and Computer Engineering, Worcester Polytechnic Institute, USA. Massoud has served as the editor of Mixed-Signal Letters--The Americas and also as an associate editor of IEEE Transactions on Very Large Scale Integration Systems and IEEE Transactions on Circuits and Systems I.

