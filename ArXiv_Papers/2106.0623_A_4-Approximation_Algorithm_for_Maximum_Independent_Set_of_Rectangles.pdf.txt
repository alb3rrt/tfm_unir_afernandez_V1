arXiv:2106.00623v1 [cs.CG] 1 Jun 2021

A 4-Approximation Algorithm for Maximum Independent Set of Rectangles
Waldo Gálvez1, Arindam Khan2, Mathieu Mari3, Tobias Mömke4, Madhusudhan Reddy5, and Andreas Wiese6
1Technical University of Munich, Germany. galvez@in.tum.de 2Indian Institute of Science, Bengaluru, India. arindamkhan@iisc.ac.in
3University of Warsaw, Poland. mathieu.mari@ens.fr 4University of Augsburg, Germany. moemke@informatik.uni-augsburg.de 5Indian Institute of Technology, Kharagpur, India. pmsreddifeb18@gmail.com
6Universidad de Chile, Chile. awiese@dii.uchile.cl
June 2, 2021
Abstract
We study the Maximum Independent Set of Rectangles (MISR) problem, where we are given a set of axis-parallel rectangles in the plane and the goal is to select a subset of non-overlapping rectangles of maximum cardinality. In a recent breakthrough, Mitchell [28] obtained the first constant-factor approximation algorithm for MISR. His algorithm achieves an approximation ratio of 10 and it is based on a dynamic program that intuitively recursively partitions the input plane into special polygons called corner-clipped rectangles (CCRs).
In this paper, we present a 4-approximation algorithm for MISR which is based on a similar recursive partitioning scheme. However, we use a more general class of polygons--polygons that are horizontally or vertically convex--which allows us to provide an arguably simpler analysis and already improve the approximation ratio. Using a new fractional charging argument and fork-fences to guide the partitions, we improve the approximation ratio even more to 4. We hope that our ideas will lead to further progress towards a PTAS for MISR.
1 Introduction
Maximum Independent Set of Rectangles (MISR) is a fundamental and well-studied problem in computational geometry, combinatorial optimization, and approximation algorithms. In MISR, we are given a set R of n possibly overlapping axis-parallel rectangles in the plane. We are looking for a subset R  R of maximum cardinality such that the rectangles in R are pairwise disjoint. MISR finds numerous applications in practice, e.g., map labelings [21, 12], data mining [15], resource allocation [26], etc.
The problem is an important special case of the Maximum Independent Set problem in graphs, which in general is NP-hard to approximate within n1- for any constant  > 0 [20]. However, for MISR much better approximation ratios are possible, e.g., there are multiple simple O(log n)-approximation algorithms [6, 32, 25]. It had been a long-standing open problem to find an O(1)-approximation algorithm for MISR. One possible approach for this is to compute an optimal solution to the canonical LP-relaxation of MISR
Supported by the European Research Council, Grant Agreement No. 691672, project APEG. Partially supported by the DFG Grant 439522729 (Heisenberg-Grant)
1

and round it. This approach was used by Chalermsook and Chuzhoy in order to obtain an O(log log n)approximation [7]. The LP is conjectured to have an integrality gap of O(1) which is a long-standing open problem by itself, and which has interesting connections to graph theory [5, 7]. On the other hand, it seems likely that MISR admits even a PTAS, given that it admits a QPTAS [2], and in particular one with a running time of only n(log log n/)O(1) [10].
Recently, in a breakthrough result, Mitchell presented a 10-approximation [28] and consequently solved the aforementioned long-standing open problem. Instead of rounding the LP, he employs a recursive partitioning of the plane into a special type of rectilinear polygons called corner-clipped rectangles (CCRs). Given a CCR, he recursively subdivides it into at most five smaller CCRs until he obtains CCRs which intuitively contain at most one rectangle from the optimal solution OPT each. At the end, he outputs the rectangles contained in these final CCRs plus some carefully chosen rectangles from OPT that are intersected by this recursive cuts. With a dynamic program, he computes the recursive partition that yields the largest number of output rectangles, which in particular "remembers" in each step O(1) rectangles that were intersected by some previous cuts. In a structural theorem he shows that there exists a set of at least |OPT|/10 rectangles which can be output by such a recursive partitioning, leading to the approximation ratio of 10. The structural theorem is proved using an exhaustive case analysis for defining the subdivision of a given CCR, with sixty cases in total.
Mitchell's result yields several interesting open questions, most notably whether one can improve the approximation ratio and whether one can give a simpler analysis which does not rely on a large case distinction. In this paper, we answer both questions in the affirmative.
1.1 Our Contribution
In this paper, we present a polynomial time 4-approximation algorithm for MISR. Similar to the result by Mitchell [28], we use a recursive decomposition of the plane into a constant number of axis-parallel polygons with constant complexity. Instead of requiring each arising polygon to be a CCR like in [28], we require them only to be horizontally (or vertically) convex (see Figure 1), i.e., if two points in the polygon lie on the same horizontal (vertical) line, then any point between them is also contained in the polygon. Hence, this class of polygons is larger than CCRs. However, it allows us to provide a simpler analysis.
In particular, when we define the subdivisions of a given polygon, there are only few different cases that we need to distinguish. Also, w.l.o.g. each resulting cut contains only one line segment which might cut and hence delete rectangles from OPT, while the other line segments do not cut through rectangles in OPT. In contrast, in [28] there can be two line segments of the former type which yields a higher approximation ratio and a more complicated analysis. In order to improve the approximation ratio even more, we introduce fork-fences in the plane which emerge from edges of the given polygon and which have the shape of a fork, see Figure 7. Like the horizontal fences in [28], they protect some of the rectangles in OPT from being deleted, since we do not allow ourselves to cut through them. However, due to their more elaborate shape, they protect more rectangles in OPT and they protect them better. Also, they allow us to use a simpler dynamic program that does not need to remember rectangles that were intersected by previous cuts, but which instead only partition the plane recursively. Finally, we introduce a fractional charging argument for the intersected rectangles from OPT which allows us to improve the approximation ratio even more.
Theorem 1. There is a polynomial-time 4-approximation algorithm for maximum independent set for a set of axis-aligned rectangles in the plane.
1.2 Other related work
For simple geometric objects such as disks, squares and fat objects, polynomial-time approximation schemes (PTAS) are known for the corresponding setting of Independent Set [13, 8]. In the weighted case of MISR, called maximum weighted independent set of rectangles (MWISR), each rectangle has an associated weight and the goal is to select a maximum weight independent set. Recently an O(log log n)-approximation [7] has been obtained, improving the previous O(log n/ log log n)-approximation [8]. Furthermore, Marx [27]
2

showed that MISR is W[1]-hard, ruling out an EPTAS for the problem. Grandoni et al. [18] presented a parameterized approximation scheme for the problem.
MIS has been extensively studied for many other variants. Fox and Pach [14] have given an napproximation for maximum independent set of line segments. In fact, their result extends to the independent set of intersection graphs of k-intersecting curves (where each pair of curves has at most k points in common).
There are many other related important geometric optimization problems, such as geometric set cover [30], geometric hitting set [31], 2-D bin packing [3], strip packing [22], 2-D knapsack [17, 16], unsplittable flow on a path [19], storage allocation problem [29], etc. We refer the readers to [9] for a literature survey.
MISR also has interesting connections with end-to-end cuts (called guillotine cuts [33], also known as binary space partitions [11]). Due to its practical relevance in cutting industry, guillotine cuts are well-studied for packing problems [4, 23]. It has been conjectured [1] that, given a set of n axis-parallel rectangles, (n) rectangles can be separated using a sequence of guillotine cuts. If true, this will imply an O(n5)-time simple O(1)-approximation algorithm for MISR. The connection has also been extended to the weighted case which implies that if we can guarantee that a constant fraction of weight can be separated using a sequence of guillotine cuts, we obtain a O(n5)-time simple O(1)-approximation algorithm for MWISR [24].
2 Dynamic program
We assume that we are given the set R = {R1, . . . , Rn} with n axis-parallel rectangles in the plane such that each rectangle Ri  R is specified by its two opposite corners (x(i1), yi(1))  N2 and (x(i2), yi(2))  N2, with x(i1) < x(i2) and yi(1) < yi(2), so that Ri := {(x, y)  R2 | x(i1) < x < x(i2)  yi(1) < y < yi(2)} (i.e., the rectangles are open sets). By some standard preprocessing, we can assume that, for each rectangle Ri  R, we have that x(i1), x(i2), yi(1), yi(2)  {0, ..., 2n - 1} [2]. In particular, all input rectangles are contained in the square S := [0, 2n - 1] × [0, 2n - 1]. We will also assume that there is no pair of rectangles Rp, Rq  R such that Rp  Rq (if that is the case, we can safely replace Rq by Rp in any feasible solution containing Rq).
Our algorithm is a geometric dynamic program (similar as in [2, 10, 28]) which, intuitively, recursively subdivides S into smaller polygons until each polygon contains only one rectangle from the optimal solution OPT. For each of the latter polygons, it selects one input rectangle that is contained in the polygon, and finally outputs the set of all rectangles that are selected in this way. During the recursion, we ensure that each arising polygon has only O(1) edges which are all axis-parallel with integral coordinates, and the polygon is horizontally convex or vertically convex (formally defined below, see Figure 1 for examples). This ensures that there are only nO(1) possible polygons of this type, which allows us to define a dynamic program that computes the best recursive partition of S in time nO(1). Note that the line segments defining the recursive subdivision of S might intersect rectangles from OPT and those will not be included in our solution.
Our dynamic program has a parameter k  N. It has a dynamic programming table with one cell for each polygon P  S with at most k axis-parallel edges, such that the endpoints of each edge have integral coordinates and P is horizontally or vertically convex.
Definition 2. A polygon P is horizontally (resp. vertically) convex if for any two points x, y  P lying on the same horizontal (resp. vertical) line , the line segment connecting x and y is contained in P .
Note that a rectangle P is both horizontally and vertically convex, and this holds in particular for S. Denote by P(k) := P the set of polygons corresponding to the DP-cells. For each P  P, the dynamic program computes a solution DP(P )  R consisting of rectangles from R contained in P . For computing these solutions, we order the polygons P according to any partial order  in which, for each P, P  P with P P , it holds that P  P . We consider the polygons in P in this order so as to compute their respective solutions DP(P ). Consider a polygon P  P. If P does not contain any rectangle from R then we define DP(P ) :=  and stop. Similarly, if P contains only one rectangle R  R then we define DP(P ) := {R} and stop. Otherwise, suppose that P is horizontally convex. Then, the DP tries all subdivisions of P into at most three horizontally convex polygons P1, P2, P3  P, looks up their corresponding (already computed)
3

Figure 1: On the left a horizontally convex polygon. On the middle, a vertically convex polygon. On the right, an axis-parallel polygon that is neither horizontally nor vertically convex.
solutions, and defines their union DP(P1)  DP(P2)  DP(P3) as a candidate solution for P . If P is vertically convex then we do the same operation with all subdivisions of P into at most three vertically convex polygons P1, P2, P3  P and define DP(P1)  DP(P2)  DP(P3) as a candidate solution for P . Note that if P is horizontally and vertically convex, we do both operations. Finally, we define DP(P ) to be the candidate solution with largest cardinality. At the very end, we output DP(S).
Lemma 3. Parameterized by k  N, the running time of the dynamic program is O(n5k/2).
Proof. Polygons associated to the cells of the dynamic program are axis-parallel, have at most k edges, and each vertex has integral coordinates in [0, . . . , 2n - 1] × [0, . . . , 2n - 1]. Thus, the number of cells is O(nk). For each cell, the algorithm enumerates all possible partitions of the corresponding polygon P  P(k) into two or three polygons P1, P2, P3 in P(k). Such a partition can be characterized by two sequences  and  of line segments whose union corresponds to edges of Pi (with i = 1, 2, 3) that are contained in the interior of P . Since each Pi has at most k edges and each such edge is shared by two polygons Pi, the total number of line segments in    is at most 3k/2. Thus, the running time to process each DP cell is O(n3k/2). This gives an overall running time of O(n5k/2).
In order to analyze the DP, we introduce the concept of k-recursive partitions. Intuitively, the solution computed by the DP corresponds to a recursive partition of S into polygons in P, in which each arising polygon P is further subdivided into at most three polygons P1, P2 and P3, or instead we select one rectangle R  P and do not partition P further. This can be modeled as a tree as given in the following definition.
Definition 4. A k-recursive partition for a set R  R consists of a rooted tree with vertices V such that
· for each node v  V there is a corresponding polygon Pv  P(k),
· each internal node v has at most three children Cv  V such that Pv =  v Cv Pv ,
· for each leaf v  V , Pv contains at most one rectangle in R .
· for each rectangle R  R , there exists a leaf v  V such that R  Pv and R  Pv =  for each leaf v with v = v.
Along this work we will usually assume that Pr = S, where r  V is the root node of the tree. Note that the rectangles in R are pairwise disjoint due to the last property. Also, for each internal node v, the polygons of its children are disjoint.
Lemma 5. Given an input set of rectangles R, if there exists a k-recursive partition for a set R  R, then on input R our dynamic program computes a solution R~  R with |R~|  |R |.
Proof. We will prove the statement by induction on the height of the tree. If the tree has height 1, it means that |R | is constant and each node aside from the root contains either a unique or no rectangle from R . For each polygon in one of the leaves we can define a feasible partition into a constant number of polygons
4

from P by circumventing the corresponding rectangle from R and extending its horizontal boundary until touching the boundary of the polygon. This sequence of polygons represents a feasible partition that our Dynamic Program considers, meaning that the returned solution will have size at least |R | as the polygons containing the rectangles from R will be leaves containing a unique rectangle.
Following the inductive proof, we can recourse the argument on each subtree rooted at a child of the root. Again the subdivision into polygons induced by the recursive partition for R is a feasible candidate that our Dynamic Program considers, leading to a returned solution of size at least |R |.

In the following sections, we will prove the following.

Lemma 6. For an arbitrary input set of rectangles R, there exists a 34-recursive partition for some set

R

 R with |R | 

1 4

|OPT|.

This yields our main theorem restated below.

Theorem 1. There is a polynomial-time 4-approximation algorithm for maximum independent set for a set of axis-aligned rectangles in the plane.

3 Recursive cutting sequence
In this section our goal is to prove Lemma 6. Consider an optimal solution OPT. Like in [28], we first extend each rectangle R  OPT in order to make it maximally large in each dimension. Formally, we consider the rectangles in OPT in an arbitrary order. For each R  OPT, we replace R by a (possibly) larger rectangle R such that R  R  S and if we enlarged R further by changing any one of its four coordinates, then we would intersect some rectangle in OPT, or it would no longer be true that R  S. Denote by OPT the resulting solution.
Lemma 7. For every k  N, if there is a k-recursive partition for a set R  OPT , then there is also a k-recursive partition for a set R~  OPT with |R | = |R~|.
Proof. Let T be a k-recursive partition for a set R  OPT , and consider R~  OPT to be the set of original rectangles that were maximally expanded so as to obtain R . In particular |R | = |R~|. Since each rectangle R  R~ is contained in a unique rectangle R  R , we conclude that T is also a k-recursive partition for R~ .
Our goal is now to prove that there always exists a k-recursive partition for a subset R  OPT of large enough size.
As Mitchell [28], we define nesting relationships for the rectangles in OPT (see Figure 2). Consider a rectangle R  OPT . Note that each of its four edges must intersect the edge of some other rectangle R  OPT or some edge of S. We say that R is vertically nested if its top edge or its bottom edge is contained in the interior of an edge of some other rectangle R  OPT or in the interior of an edge of S. Similarly, we say that R is horizontally nested if its left edge or its right edge is contained in the interior of an edge of some other rectangle R  OPT or in the interior of an edge of S.
Proposition 8 (Mitchell [28]). A rectangle R  OPT cannot be vertically and horizontally nested; however, it is possible for R to be neither vertically nor horizontally nested.
Proof. For a contradiction, assume that a rectangle R  OPT is vertically and horizontally nested. W.l.o.g. we can assume that its top edge is contained in the interior of an edge of a rectangle R  OPT and its left edge is contained in the interior of an edge of a rectangle R  OPT . Let c = (x, y) be the coordinates of the top-left corner of R. Since c lies in the interior of the bottom edge of R and coordinates of rectangles in OPT are integral, we deduce that the point c = (x - 1/2, y + 1/2) must lie in the interior of R . An analogous argumentation indicates that c is also contained in the interior of R . This is a contradiction with the fact that rectangles in OPT are disjoint.

5

Figure 2: Example of maximal rectangles OPT . Red rectangles are nested horizontally. Blue ones are nested vertically. Gray rectangles are neither nested vertically nor horizontally. White areas are not covered by any rectangle in OPT .

We assume w.l.o.g. that at most half of the rectangles in OPT are not nested horizontally (which will

lose a factor of 2 in our approximation ratio). Assuming this, the polygons in our recursive partition will all

be horizontally convex. We will ensure that our solution will contain at least half of the rectangles that are

not nested horizontally; however, it might also contain rectangles that are nested horizontally.

We first prove in Section 3.1 a weaker result (but with a simpler proof) which shows that there exists a

26-recursive partition for a set R



R

with

|R

|



1 6

|OPT|.

Then, in Section 3.2 we will prove Lemma 6.

For this, we will show how to extend this partitioning strategy developed in section 3.1 to more complicated

fences, which will allow us to provide a better bound on the size of the solution R .

3.1 A recursive partition for a 6-approximate set

We want to prove that there is a 26-recursive partition for a set R

 OPT

with

|R

|



1 6

|OPT

|.

In order

to describe this recursive partition, we initialize the corresponding tree T with the root r and define that

Pr := S is the polygon corresponding to r. We define now a recursive procedure that takes as input a so

far unprocessed vertex v of the tree, corresponding to some polygon P = Pv. It either partitions P further

(hence adding children to v) or assigns a rectangle R  OPT to v and does not add children to v. We denote

by OPT (P )  OPT the subset of rectangles of OPT that are contained in P . If OPT (P ) = , then we

simply delete v from T . If |OPT (P )| = 1 then we add the single rectangle in OPT (P ) to R , assign it to

v, and do not process v further.

Assume now that |OPT (P )| > 1. We classify the vertical edges of P as left vertical edges and right

vertical edges (see Figure 3).

Definition 9. For a vertical edge e of a horizontally convex polygon P , we say that e is left vertical if its interior contains a point p = (px, py) such that there exists a value  > 0 for which (px + , py)  P , and right vertical, otherwise.

For each point p with integral coordinates on a left vertical edge of P , we define a line fence emerging from p, see Figure 4. If there is a point p  P such that (i) p and p have the same y-coordinate, (ii) the horizontal line segment connecting p and p intersects1 no rectangle of OPT (P ) and (iii) p is contained in the interior of the left side of a rectangle R  OPT (P ), or the top right corner or the bottom right corner of a rectangle R  OPT (P ), then we create a line fence that consists of the horizontal line segment from p to p . Notice that if p is contained in the interior of a left edge of a rectangle in OPT (P ), then p = p and the fence emerging from p consists only of a single point. We call p the endpoint of the fence emerging from

1since rectangles are open sets, when we say that a line segment intersects a rectangle, we mean that it contains some point of its interior. In particular a line segment that contains the edge of a rectangle R does not intersect R.

6

Figure 3: The left vertical edges (blue) and the right veritical edges (red) of a horizontally convex polygon.
Figure 4: Some line fences (red) emerging from the boundary of P (blue). Shaded rectangles are the rectangles in OPT that intersect the boundary of P . White spaces indicate points that are not covered by rectangles of OPT contained in P . Darker gray rectangles correspond to rectangles in OPT (P ) that are protected by some line fence. p. We define line fences emerging at points of right vertical edges of P in a symmetric manner. Denote by F (P ) the set of all fences created in this way.
When we partition P , we will cut P along line segments such that (i) no horizontal line segment intersects a rectangle in OPT (P ) and (ii) no vertical line segment crosses a line fence in F (P ). Therefore, the line fences intuitively protect some rectangles in OPT (P ) from being intersected by line segments defined in future iterations of the partition. This motivates the following definition. Definition 10. Given a horizontally convex polygon P , we say that a rectangle R  OPT (P ) is protected in P if there exists a line fence f  F (P ) such that the top edge or the bottom edge of R is contained in f .
We will ensure that a protected rectangle will not be intersected when we cut P , and the line fences in F (P ) will help us to ensure this. We apply the following lemma to P . Lemma 11 (Line-partitioning Lemma). Given a horizontally convex (resp. vertically convex) polygon P  P(26), such that P contains at least two rectangles from OPT , there exists a set C of line segments with integral coordinates such that:
(1) C is composed of at most 8 horizontal or vertical line segments that are all contained in P . 7

(2) P \ C has two or three connected components, and each of them is a horizontally (resp. vertically) convex polygon in P(26).
(3) There is a vertical (resp. horizontal) line segment of C that intersects all the rectangles in OPT (P ) that are intersected by C.
(4) does not intersect any rectangle that is protected in P .
We introduce an (unprocessed) child vertex of v corresponding to each connected component of P \ C which completes the processing of P .
We apply the above procedure recursively to each unprocessed vertex v of the tree until there are no more unprocessed vertices. Let T denote the tree obtained at the end, and let R denote the set of all rectangles that we assigned to some leaf during the recursion.
Lemma 12. The tree T and the set R satisfy the following properties.
(i) For each node v  T , the horizontal edges of Pv do not intersect any rectangle in OPT .
(ii) T is a 26-recursive partition for R .
(iii) If a rectangle R  OPT is protected in Pv for some node v  T , then
· it is protected in Pv for each descendant v of v, · RR.
Proof. The first and second properties follow from the definition of the fences and Lemma 11. The third property follows from the fact that if f is a line fence in F (Pv) then, f  Pv is a line fence of F (Pv ).
3.1.1 Analysis
We want to prove now that |R |  |OPT|/6. Consider an internal node v of the tree and let v be the corresponding line segment due to Lemma 11, defined above for partitioning Pv. We define a charging scheme for the rectangles in OPT that are intersected by v and are not nested horizontally. For any such rectangle R, we will identify two rectangles RL and RR in OPT (Pv) such that RL lies on the left of R and RR lies on the right of R, and assign a charge of 1/2 to each of them, thus to a total charge of 1. More precisely, we will assign each of these charges to some corner of RL and RR, respectively, and ensure that in the overall process each corner of each rectangle is charged at most once. Thus, each rectangle receives a total charge of 2. Furthermore, if a rectangle receives a charge (to one of its corners), then it will be protected by the fences for the rest of the partitioning process.
The key difference to the algorithm of Mitchell [28] is that, in our algorithm, each application of Lemma 11 yields a single line segment that might intersect rectangles from OPT . In the respective routine in [28] there can be two such line segments, and a consequence is that for each intersected rectangle R  OPT there might be only one other rectangle from OPT to charge, rather than two. Furthermore, our proof of Lemma 11 is arguably simpler.
The charging scheme. We now explain how to distribute the charge from rectangles that are intersected by v (and are thus not in R ).
Definition 13. We say that a rectangle R  OPT sees the corner c of a rectangle R  OPT on its right if
(i) c is the top-left corner or the bottom-left corner of R ,
(ii) there is a horizontal line segment h that connects a point p on the right edge of R with c and h does not intersect any rectangle in OPT , and
8

Figure 5: Green marks indicate the corners of the rectangles in OPT that are seen by the central darkgray rectangle.
(iii) if p is the bottom-right (resp. top-right) corner of R then we also require that c is the bottom-left (resp. top-left) corner of R .
We define the corners seen by R  OPT on its left in a symmetric manner. See Figure 5. It is easy to see that if a rectangle R is horizontally nested, then there is at least one side (left of right) on which R does not see any corner. On the other hand, if R is not horizontally nested, then on its left it sees at least one corner of a rectangle in OPT (P ), and similarly on its right. Intuitively, we will later charge R to these rectangles in OPT (P ).
Lemma 14. Let P be a horizontally convex polygon, and let R be a rectangle in OPT (P ) that is not protected in P and not horizontally nested. Then, R sees at least one corner of a rectangle in OPT (P ) on its left, and at least one corner of another rectangle in OPT (P ) on its right.
Proof. Let R be a rectangle in OPT (P ) that is not nested horizontally. We prove that R sees a corner on its right, or is protected. The left case is exactly symmetrical. Consider the horizontal line segment h that connects its top-right corner to a right vertical edge e of P . If h does not intersect any rectangle in OPT (P ), then R must be protected by a fence that emerges from a point in e , i.e., R is protected in P . Otherwise, let R  OPT (P ) denote the rectangle intersected by h, or that has its top side intersected by h, that is the closest to R. We now use the fact that R is not nested horizontally to prove that R sees a corner of R .
Let yb and yt denote the y-coordinates of the bottom and top edge of R and let yb and yt denote the y-coordinates of the bottom and top edge of R . Additionally, let xr denote the x-coordinate of the right edge of R and let xl denote the x-coordinate of the left edge of R . We know that xr  xl. We now treat all the possible cases.
1. If yt = yt then, by definition of R , we obtain directly that R sees the top-left corner of R 2.
2. Otherwise, we have yb < yt < yt.
a. If xr = xl then necessarily we have that yb  yb since we assumed that R was not horizontally nested. In this case, it is clear that R sees the bottom-left corner of R .
b. Otherwise, we have xr < xl, and then either yb < yb or yb  yb. i. We show that yb < yb cannot happen. Indeed, assume that yb < yb and consider the rectangular area W with bottom-left corner (xr, yb) and top-right corner (xl, yt). In particular, the right edge of R is the left edge of W . Since rectangles in OPT are maximally large in
2in this case, one can prove that we must also have xr = xl.
9

each dimension, W must intersect some rectangle in OPT . By maximality again, there must be a rectangle R  OPT that intersects h within W , or that has its top side contained in h within W . If R is contained in P , then we get a contradiction with the definition of R . Otherwise, if R is not contained in P , then either R is intersected by the boundary of P , and by Lemma 12(i), it must be intersected by a vertical edge of P , or R must be contained in the complement of P . In both cases, the horizontal rightwards ray from the top-right corner of R must reach the boundary of P before reaching the left edge of R . This is a contradiction with the definition of R . ii. If yb  yb then we prove that R sees the bottom-left corner of R . As in the previous case, consider the rectangular area W with bottom-left corner (xr, yb) and top-right corner (xl, yt). If R does not see the bottom-left corner of R , then there must be a rectangle in OPT that intersects W . By maximality, this implies that there exists a rectangle R that intersects h or that has its top side contained in h. By the same argumentation as before we obtain a contradiction with the definition of R .
For every node v  T and every rectangle R  OPT (Pv) not nested horizontally that is intersected by v, we assign a (fractional) charge of 1/2 to a corner of a rectangle in OPT (Pv) that R sees on its left, and a charge of 1/2 to a corner of a rectangle in OPT (Pv) that R sees on its right.
We prove now that if some rectangle R  OPT is charged at some point, then R  R . The reason is that when R is charged due to a vertical line segment v, then in the subsequent subproblems (i.e., corresponding to the children of v) R will be protected.
Lemma 15. If a rectangle R  OPT receives a charge to at least one of its corner, then R  R .
Proof. Suppose that R receives a charge from a rectangle R during the partitioning of Pv, for some v  T . In particular, R sees a corner c of R . W.l.o.g. we assume that R is on the right of R, and c is the top-left corner of R (the case where c is the bottom-left corner is identical). Consider v  T to be the child of v such that Pv contains R . We show that R is protected in Pv . By Lemma 12(iii), this will imply that R  R . The vertical line segment v that intersected R is a vertical edge of Pv . Since R sees c, the horizontal leftwards ray from c does not intersect any rectangle in OPT (Pv ) and reaches a left vertical edge of Pv , say on a point p. Then, the horizontal edge of R that contains c is contained in the line fence of F (Pv ) emerging from p, i.e., R is protected in Pv .
10

In the next lemma, we show that each corner of a rectangle R  R can be charged at most once. Hence, each rectangle receives a total fractional charge of at most 2.
Lemma 16. Each corner of a rectangle in R is charged at most once.
Proof. Let c be a corner of a rectangle R  R . W.l.o.g. we assume that c lies on the left side of R . We also assume that c is the top-left corner of R (the case when c is the bottom-left corner is identical). For a contradiction, assume that c is charged at least twice. Then, there are two rectangles R1  OPT (Pv1 ) and R2  OPT (Pv2 ), for some nodes v1, v2  T , such that c receives charges from R1 during the partitioning of Pv1 and also receives charge from R2 during the partitioning of Pv2 . In particular, both R1 and R2 see c, and R  Pv2  Pv1 . We have Pv2  Pv1 or Pv1  Pv2 . W.l.o.g. we assume that Pv2  Pv1 . In particular, both R1 and R2 are contained in Pv1 .
First, if v1 = v2, then R1 and R2 are both intersected by the same vertical line segment v1 (Lemma 11, property (3)). In particular, the top edge of R2 is below the bottom edge of R1, or the contrary. Since both R1 and R2 see c, the leftwards horizontal ray h from c intersect the right edges of both R1 and R2. These two facts together indicate that h intersect the bottom edge of R1 and the top edge of R2, or the contrary. This brings a contradiction with the third condition of Definition 13.
Otherwise, we have that v2 is a descendant of v1. We show that the contradiction comes here from the fact that R2 must be protected in Pv2 . Since c was charged from R1 during the partitioning of Pv1 , the argumentation in the proof of Lemma 15 indicates that c is contained in a line fence f emerging from a right vertical side of Pv2 . In particular, since R2 is contained in Pv2 and sees c, it must be that the top edge (or the bottom edge) of R2 is contained in f ; otherwise we would get a contradiction with the assumption that fences in Pv2 do not penetrate any rectangle in OPT (Pv2 ). This implies that R2 must be protected in Pv2 . Thus, by property (4) of Lemma 11, R2 cannot be intersected during the partitioning of Pv2 , and R does not receive any charge from R2.
Hence, each rectangle in R needs to pay for at most two other rectangles that are not nested horizontally and that were intersected, which loses a factor 3. We lose another factor 2 since we assumed that at most half of the rectangles in OPT are not nested horizontally. This yields a factor of 6 overall.
Lemma 17. We have |R |  |OPT|/6.
Proof. We can write OPT = OPTh  R  L, where OPTh are the rectangles in OPT that are nested horizontally and L are the rectangles in OPT not nested horizontally that are intersected by v, for some node v  T . Notice that L  R = . Since a rectangle has 4 corners, we know from Lemma 16 that each rectangle in R receives a charge of at most 2. Then, by Lemma 15, no corners of rectangles in L are charged. Thus, |L|  2|R |. By our initial assumption that at most half of the rectangles in OPT are nested horizontally, it holds that |L| + |R |  |OPT |/2. Thus, |R |  |OPT |/6 = |OPT|/6.
3.1.2 Proof of the Line-partitioning Lemma
Now we prove Lemma 11 which is crucial in obtaining the previously described 6-approximation.
Lemma 11 (Line-partitioning Lemma). Given a horizontally convex (resp. vertically convex) polygon P  P(26), such that P contains at least two rectangles from OPT , there exists a set C of line segments with integral coordinates such that:
(1) C is composed of at most 8 horizontal or vertical line segments that are all contained in P .
(2) P \ C has two or three connected components, and each of them is a horizontally (resp. vertically) convex polygon in P(26).
(3) There is a vertical (resp. horizontal) line segment of C that intersects all the rectangles in OPT (P ) that are intersected by C.
(4) does not intersect any rectangle that is protected in P .
11

We only prove the lemma when P is a horizontally convex polygon in P(26); the case when P is vertically convex is symmetrical. First, if P admits a guillotine cut, i.e., if there exists a horizontal or vertical line segment C that cuts P into two connected components without intersecting any rectangle of OPT (P ), it is easy to check that C satisfies the claimed properties. Thus, from now on, we assume that there is no such guillotine cut. We first explain how to construct C using the line fences, and then we prove that this set satisfies the desired properties from Lemma 11.
Claim 18. If a horizontally convex piece P does not admit a guillotine cut, then each point on the horizontal edges of P lies on some line fence.
Proof. First, let us prove this for all horizontal edges eh that are not the top-most or the bottom-most edges of the piece P . Since we know that there are no guillotine cuts and the piece is horizontally convex, the horizontal ray from one of the endpoints p or pr of eh into the interior of P must hit the interior of some vertical edge of a rectangle R  OPT (P ) at some point p . This implies that each of the line segments p p and prp are line fences. Since p pr is contained in either of these fences, all the points on eh belong to some line fence. In order to prove that every point of the top edge belongs to some line fence, observe that there exists some rectangle R whose top edge is contained in the top edge of the piece thanks to the assumption that there are no guillotine cuts. This implies that the line segment joining the left endpoint of the top edge of the piece and the top-right corner of the rectangle, and the line segment joining the right endpoint of the top edge of the piece and the top-left corner of the rectangle are line fences by definition. Since the union of these two fences covers the entire top edge of the piece, it follows that every point on the top edge of a piece belong to some fence. A similar argument for bottom edge completes the proof.
Construction of the cut C. We define left and right vertical edges of P as before and let L(P ) and R(P ) denote the set of the left and right vertical edges of P , respectively. Assume w.l.o.g. that |L(P )|  |R(P )|. Let e1, ..., es denote the left vertical edges of P , ordered from top to bottom. Consider the edges EM := {e s/3 +1, ..., e 2s/3 }, which are essentially the edges in the middle third of e1, ..., es. See Figure 6. Let f  F (P ) be a line fence in F (P ) emerging from a point p on an edge in EM such that, among all such fences, its endpoint p is the furthest to the right. We now identify two additional fences in F (P ) that will be used to partition P . Let qb be the farthest point on the upwards vertical ray from p such that the line joining qb and p does not intersect any rectangle in OPT (P ) protected by some line fence g  F (P ). Eventually, we may have qb = p . From the definition, we know that qb is in the interior of the bottom edge of some protected rectangle Rt  OPT (P ) protected by some line fence g  F (P ), or on line fence g itself.
Symmetrically, we define q^t to be the farthest point on the downwards vertical ray from p such that the line joining q^t and p does not intersect any rectangles in OP T (P ) protected by some line fence g^  F (P ). Eventually, we may have q^t = p . Again, q^t is in the interior of the top edge of some protected rectangle Rb  OPT (P ) protected by some line fence g^  F (P ), or on line fence g^ itself.
It is important to note that qbq^t is a vertical line of length strictly greater than zero because p is always on one of the vertical edges of some rectangle in OPT (P ).
Whenever Rt or Rb exists, let us refer to the top, bottom, left, right edges of Rt and Rb as tt, bt, lt, rt and tb, bb, lb, rb, respectively. When Rt or Rb does not exist, the corresponding edges will be equal to the empty set. This allows us to think of the case when the ray from p hits a fence as if it hit an edge of a protected rectangle of height zero.
We now use the fences f, g and g^ to define a set C of at most 8 vertical and horizontal line segments that partition P into two or three connected components. See Figure 6. Let p, q and q^ denote the points of the boundary of P from which f, g and g^ are emerging, respectively. We distinguish the following cases:
1. [qbq^t intersects with the interior of P ]
a. [q is on a right vertical edge and (qbp intersects the interior or Rt exists)] Let be the vertical line segment from p and qb. We define C as the sequence of line segments in f  btrtg that connects p to q.
12

b. [q^ is on a right vertical edge and (q^tp intersects the interior or Rb exists)] Let be the vertical line segment from p and q^t. Similarly, we define C as the sequence of line segments in f   tb  rb  g^ that connects p to q^.
c. [Both q and q^ are on left vertical edges] Here, we define to be the vertical line segment with endpoints qb and q^t. Let C be the sequence of line segments in g  lt  bt   tb  lb  g^ that connects q to q^. We define C := C  f . Remark. Note that we did not explicitly mention the case when qbp lies completely on the boundary of P , q is on a right vertical edge, Rt =  and q^ is on the left vertical edge (and the corresponding symmetric case). However, both these cases are covered in (1c) using the fact that, whenever qbp is on the boundary, Rt =  and qbq^t intersecting with the interior implies that qb is on the top edge and, in particular, either qb = p and both lie in the interior of top edge, or qb is at the left corner of the top edge and p is at the lower endpoint in the vertical edge containing qb. If qb were not on the top edge, we would be able to argue that either qbq is a guillotine cut, or pp is a guillotine cut, or qbqt lies on the boundary, which would contradict our assumption. This implies that q can be assumed to be on the left as well as right. Assuming it is on the left, it falls under case (1c).
2. [qbq^t lies completely on the boundary of P ] This implies that the vertical line segment qbq^t is contained in one of the vertical edges of piece P because qbq^t is a vertical line segment of non-zero length. If we assume that it is a left vertical edge, then we should have p = p . As there are no guillotine cuts and by the definitions of qb and q^t, there must exist some rectangle R  OPT whose left edge is contained in the same vertical edge that p belongs to. The line segment joining the top left corner with the top right corner is a fence on the same vertical edge as p and is longer than f , which contradicts the choice of f . If qbq^t is a right vertical edge, it implies that pp basically connects one point on the left vertical edge and the right vertical edge. Since we assumed that there are no guillotine cuts in piece P , the edge pp has to coincide with the top edge or the bottom edge of the piece P . Let us assume that it coincides with the top edge and define the cut accordingly. The definition of the line fences and the choice of f implies that 1 + s/3 = 1, i.e., s  2. Hence, the total number of vertical sides of the piece is at most 4 and the point p is the top right vertex of some rectangle R  OPT (P ). Define the cut C as the sequence of line segments joining p to the bottom right corner of R that does not include the point p . Note that whenever this case happens the number of vertical sides of the piece after the cut is at most 5. So we will not include this case from now on whenever we do an analysis to prove the resulting piece has less than 13 vertical edges.
Remark. In case (1c), cutting along C is sufficient in almost all cases. The additional cut along f guarantees that the left pieces will have at most 13 vertical sides. For instance, in the case where |L(P )| = 12, |R(P )| = 1, and q and q^ are respectively on the first and last left vertical edge, without the additional cut along f , we would obtain a left piece with 15 vertical sides.
Observation 19. No two vertical segments of the cut C have a non-zero length intersection of their horizontal projections (i.e. their projections onto the y-axis do not overlap)
Properties of C. We now prove that C satisfies the properties of Lemma 11. Property (1) is easy to check: C is formed by at most three line fences and two pairs of edges of two rectangles, plus one vertical line segment , thus for a total of 8 line segments. Property (3) is also easy to check since, by construction, neither the line segments of the line fences nor the edges of the two rectangles intersect rectangles from OPT (P ). Properties (2) and (4) are proved in Claim 20 and Claim 21, respectively.
Claim 20. The set P \ C has two or three connected components and each of them is a horizontally convex polygon contained in P(26).
Proof. Suppose for a contradiction that P \ C has only one connected component. Since C is a sequence of line segments within P that connects two different points of its boundary, C must be contained in the
13

Figure 6: Different cases for the partitioning of a polygon. The blue area indicates the left vertical edges that are in EM . The set of lines C used to cut the polygon is shown in blue.
boundary of P . However, in our construction of C, we defined the cut so that at least one vertical line segment of C is strictly in the interior of P (this is true in case 2 too as there is more than one rectangle in the piece). Thus, P \ C has at least two connected components. In all cases except (1c), cut C basically connects two points on its boundary hence P \ C has exactly two connected components. Similarly, in case (1c), cut C also divides P into exactly two connected components and the cut along f divides one of these pieces into two more pieces which proves that P \ C has at most three connected components.
It is clear that each of these components has axis-parallel edges. We now prove that each connected component is horizontally convex. For a contradiction, suppose that there is a connected component P of P \ C that is not horizontally convex. Since we assumed that P is horizontally convex, there must be two points x and x in P with the same y-coordinate such that the horizontal line segment between x and x crosses two vertical segments of C. From Observation 19, we know that no two vertical segments of the cut C have a non-zero intersection hence leading to a contradiction.
It remains to show that the number of vertical edges of each connected component of P \ C is at most 13. For case 2, the maximum number of vertical edges is at most 5. So, we focus only on case 1. Recall that e1, . . . , es denote the left vertical edges of P ordered from top to bottom. Let e1, . . . , es denote the right vertical edges of P ordered from top to bottom. We know that s  s and s + s  13. In particular, we have s  6. In cases (1a) and (1b), C starts on a left vertical edge ei for some s/3 + 1  i  2s/3 and ends on a right vertical edge ej with 1  j  s . C contains at most two vertical line segments. Thus, each connected component has a number of vertical sides upper bounded by
2s/3 + s + 2 = 2(s + s )/3 + s /3 + 2  2 · 13/3 + 6/3 + 2 = 13.
For case (1c), assume that q and q^ are respectively on edges ei and ej. By the choice of f as the fence anchored on some left vertical edge of EM with the rightmost endpoints among all such fences, we deduce
14

that g and g^ are not emerging from an edge in EM , i.e., j  2s/3 + 1 and i  s/3 . Then, the connected component on the right has at most s + s - ( 2s/3 - s/3 ) + 3 = s + 2 s/3 + 3  13 vertical edges. The two other components have each at most 2s/3 + 3  2 · 12/3 + 3 = 11 vertical edges. This concludes the proof of Claim 20.
Claim 21. does not intersect any protected rectangle.
Proof. It follows from the definition of qb and q^t that there cannot be any protected rectangle intersected by the vertical line segment joining qb and q^t. Since in all the subcases of case (1) we define to be a subset of the vertical segment connecting qb and q^t, the claim follows.

3.2 A recursive partition for a 4-approximate set

In this section we define a 34-recursive partition of a set R

with

|R |



1 4

OPT.

The difference with

Section 3.1 is that we use more complicated fences, called fork fences, that protect more rectangles and

intuitively protect them better. Thanks to this fact, we will be able to ensure that for each rectangle in

R at most two of its corners are charged (with a charge of 1/2 each), which yields a total charge of 1 per

rectangle and an approximation ratio of 4.

3.2.1 Fork fences
Given a horizontally convex polygon P and a point p with integral coordinates on a left vertical edge of P , we define a set of fork fences emerging from p, see Figure 7. Each such fence contains up to four lines segments and is constrained not to intersect any rectangle in OPT (P ). For each point p  P such that
· p and p have the same y-coordinate,
· the horizontal line segment connecting p and p intersects no rectangle of OPT (P ) and
· p is contained in the left edge of a rectangle R  OPT (P ) (possibly p is a top-left or bottom-left corner),
we build a new fork fence f emerging from p that is composed of the horizontal line segment connecting p and p , the left edge of R, the top edge of R and the bottom edge of R. If p lies in the interior of the left edge of R, we say that f is maximal. We call the top-right corner (resp. bottom-right corner) of R the top endpoint of f (resp. the bottom endpoint of f ). The sequence of line segments of f connecting p with the top end-point of R is called the top of f , and denoted by ft. Similarly, the bottom of f (denoted fb) refers to the set of line segments of f that connect p with the bottom endpoint of f . Notice that it may happen that p = p (e.g., for the orange fork fence in Figure 7). We say that the rectangle R is protected by f .
We define fork fences emerging at points of right vertical edges of P in a symmetric manner. Denote by F +(P ) the set of all fences created in this way. Let us assume that all fences in F (P ) also exist along with fences in F +(P ). We consider this assumption only to deal with some boundary cases with ease. For line fences, both the bottom and top of the fence are identical to the fence itself.
Definition 22. Given a horizontally convex polygon P , we say that a rectangle R  OPT is fork-protected in P if it is protected by a fork fence in F +(P ), i.e., if there exists a fork fence f  F +(P ) such that the top edge of R is contained in the top of f and if its bottom edge is contained in the bottom of f .
Notice that if a rectangle R is protected in P by a line fence in F (P ), then there is also a fork fence in F +(P ) that fork-protects R. However, our fork fences protect strictly more rectangles, namely those that are protected by maximal fork fences (e.g., the rectangle R in Figure 7). On the other hand, note that if the top or bottom edge of a rectangle R is included in some fork fence f , then f does not necessarily fork-protect R.

15

Figure 7: Some fork fences emerging from the boundary of P (blue). Shaded rectangles are the rectangles in OPT that intersect the boundary of P . White spaces indicate points that are not covered by rectangles of OPT contained in P . The fork fence f emerging from p is maximal. Its top part ft is highlighted by a thicker line. Darker gray indicates the rectangles in OPT (P ) that are protected by some fork fences. For clarity, we have a represented only three fork fences. The yellow fork fence is not maximal.
3.2.2 Recursive partitioning
Like in Section 3.1, in order to describe our recursive partition, we initialize the corresponding tree T with the root r and define that Pr := S is the polygon corresponding to r. Suppose that we are given a so far unprocessed vertex v of the tree, corresponding to some polygon P = Pv. If OPT (P ) = , then we simply delete v from T . If |OPT (P )| = 1 then we add the single rectangle in OPT (P ) to R , assign it to v, and do not process v further.
Assume now that |OPT (P )| > 1. We apply the following lemma to P .
Lemma 23. (Fork-partitioning Lemma) Given a horizontally convex (resp. vertically convex) polygon P in P(34), such that P contains at least two rectangles from OPT , there exists a set C of line segments with integral coordinates such that:
(1) C is composed of at most 10 horizontal and vertical line segments that are contained in P .
(2) P \C has two or three connected components, and each of them is a horizontally convex (resp. vertically convex) polygon in P(34).
(3) The set of rectangles in OPT (P ) that are intersected by C are all intersected by the same vertical (resp. horizontal) line segment of C.
(4) does not intersect any rectangle that is fork-protected in P .
We introduce an (unprocessed) child vertex of v corresponding to each connected component of P \ C which completes the processing of P .
We apply this procedure recursively to each vertex v of the tree. Let T denote the tree obtained at the end, and let R denote the set of all rectangles that we assigned to some leaf during the recursion. As in Section 3.1, we have the following properties.
16

Lemma 24. The tree T and the set R have the following properties.
(i) For each node v  T , the horizontal edges of Pv do not intersect any rectangle in OPT .
(ii) T is a 34-recursive partition for R .
(iii) If a rectangle R  OPT is fork-protected in Pv for some node v  T , then
· it is fork-protected in Pv for each descendant v of v, · RR.
Proof. The first and the second properties follow from Lemma 23. The third property simply follows from the fact that if f is a fork fence of F +(Pv), then f  Pv is a fork fence of F +(Pv ).
3.2.3 Analysis
In this section we show that |R |  |OPT|/4. We use a similar charging scheme as in Section 3.1. Consider an internal node v of the tree and let v be the corresponding line segment defined above for
partitioning Pv. Let R be a rectangle in Pv that is intersected by v and that is not nested horizontally. By Lemma 23 we know that R is not fork-protected in Pv and, in particular, it is not protected (by a line fence) in Pv. Thus, Lemma 14 implies that R sees two corners of two rectangles in OPT (Pv), one on its left and one on its right. We assign to each of these corners a charge of 1/2, which yields a total charge of 1. The following lemma can be proven similarly as Lemmas 15 and 16.
Lemma 25. If a corner of a rectangle R  OPT is charged then R  R . Also, for each rectangle R  R , each of its corners can be charged at most once.
Proof. Using the same argumentation as in the proof of Lemma 15, we obtain that if a corner of a rectangle R  OPT(Pv) is charged for some v  T , then it will be protected by line fences for the child v of v such that R  Pv . Notice that, like Lemma 12(i), Lemma 24(i) ensures that the horizontal edges of Pv do not intersect rectangles in OPT . Then, since R is protected in Pv , it is also fork-protected in Pv , which implies by Lemma 24(iii) that R  R .
Using the same argumentation as in the proof of Lemma 16, we now obtain that a corner can be charged at most once. Again the argumentation is identical since, in both partitioning process, no horizontal edge intersects rectangles in OPT .
Due to the fork fences, we can further prove that for each rectangle R  R at most two of its corners can be charged. More precisely, if one of its left corners is charged then the right corner on the horizontal edge containing this left corner is not charged, and vice versa. This yields a total charge of at most 1 for R .
Lemma 26. If a corner c of a rectangle R  R is charged, then the other corner of R that has the same y-coordinate cannot be charged.
Proof. Let R  OPT be a rectangle that receives a charge from a rectangle R during the partitioning of Pv for some node v  T . There is a corner c of R such that R sees c. Let c denote the other corner of R with the same y-coordinate, and we assume w.l.o.g. that c is on the left of c .
Since c can only be charged from a rectangle on its right, and all rectangles intersected during the partitioning of Pv are intersected by the vertical v that lies on the left of c, we conclude that c cannot be charged by a rectangle intersected by v.
Now, let v  T be the child of v such that R  Pv  Pv. We prove that the rectangle R  Pv that sees c is fork-protected in Pv , if such a rectangle R exists (if such a rectangle does not exist, then it is clear that c cannot be charged). Then, by Lemma 24(iii), we conclude that R  R .
First, like in the proof of Lemma 15, the horizontal leftwards ray from c must reach the boundary of Pv without intersecting any rectangle in OPT (Pv ). Let h be the horizontal line segment that connects c, with a point p on a left vertical edge of Pv . We know that h does not intersect any rectangle in OPT (Pv ).
17

Then, since R sees c (on its left), there exists a point p on the left edge of R such that p and c have the same y-coordinate, and the horizontal line segment h between p and c does not intersect any rectangle in OPT (Pv ). Now, the horizontal line segment between p and p is the union of h, the top edge (or bottom edge) of R and h . Then, since it does not intersect any rectangle in OPT , by construction of the fork fences, there exists a fork fence in F +(Pv ) emerging from p that protects R . See Figure 8. This concludes the proof of the lemma.
Figure 8: Proof of Lemma 26.
Lemma 27. It holds that |R |  OPT/4. Proof. We can write OPT = OPTh  R  L where OPTh are the rectangles in OPT that are nested horizontally and L are the rectangles in OPT not nested horizontally that are intersected by v, for some node v  T . Notice that L  R = . Since a rectangle has 4 corners, we know from Lemma 16 and Lemma 26 that each rectangle in R receives a charge of at most one. Then, by Lemma 15, no corners of rectangles in L are charged. Thus, |L|  |R |. By our initial assumption that at most half of the rectangles in OPT are nested horizontally, we know |L| + |R |  |OPT |/2. Thus, |R |  |OPT |/4 = |OPT|/4.
This completes the proof of Lemma 6. Remark. One can modify the dynamic program of Section 2, so that it considers only cuts that are used in the Fork-partitioning Lemma. Since such cuts comprise at most 10 line segments, each DP cell can be processed in time O(n10), which implies an overall running time of O(n44).
3.2.4 Proof of the Fork-partitioning Lemma In this section, we prove Lemma 23 restated below. Lemma 23. (Fork-partitioning Lemma) Given a horizontally convex (resp. vertically convex) polygon P in P(34), such that P contains at least two rectangles from OPT , there exists a set C of line segments with integral coordinates such that:
(1) C is composed of at most 10 horizontal and vertical line segments that are contained in P . (2) P \C has two or three connected components, and each of them is a horizontally convex (resp. vertically
convex) polygon in P(34). (3) The set of rectangles in OPT (P ) that are intersected by C are all intersected by the same vertical
(resp. horizontal) line segment of C. (4) does not intersect any rectangle that is fork-protected in P .
18

We only prove the lemma when P is a horizontally convex polygon in P(34); the case when P is vertically convex is symmetrical. First, if P admits a guillotine cut, i.e. if there exists a horizontal or vertical line segment C that cuts P into two connected components without intersecting any rectangle of OPT , it is easy to check that C satisfies the claimed properties. Thus, from now on, we assume that there is no such guillotine cut. We first explain how to construct C using the fork fences, and then we prove that this set satisfies the expected properties of Lemma 23.
Claim 28. Assuming that a piece P admits no guillotine cuts and |OPT (P )| > 1, we can say that for any fork fence f  F +(P ), either its top part or its bottom part has to intersect the interior of P .
Proof. For the sake of a contradiction, assume that there exists a fork fence f  F +(P ) such that both its top part ft and it bottom part fb lie on the boundary of P . Since the line segment joining the top endpoint pt and bottom endpoint pb of f is a line segment connecting two points on the boundary of P , we can say that is a guillotine cut unless it is on the boundary. Since f  forms a closed region with each point on the boundary, this region has to be the whole boundary. This contradicts our assumption that there is more than one rectangle in the piece since there can be exactly one rectangle in the region f  .
Construction of the cut C. We define left and right vertical edges of P as before and let L(P ) and R(P ) denote the set of the left and right vertical edges of P , respectively. Assume w.l.o.g. that |L(P )|  |R(P )|. Let e1, ..., es denote the left vertical edges of P , ordered from top to bottom. Consider the edges EM := {e s/3 +1, ..., e 2s/3 } which are essentially the edges in the middle third of e1, ..., es. See Figure 10. Let f  F +(P ) be a fork fence in F +(P ) emerging from a point p of an edge in EM , such that among all such fences, its endpoints pt and pb are the furthest to the right3.
We now identify two additional fences in F +(P )  F (P ) that will be used to partition P . Let qb be the lowest point on the upwards vertical ray from pt such that qb is contained in the bottom of a some fork fence or line fence g  F +(P )  F (P ). Eventually, we may have qb = pt. Also, if qb is contained in the bottom of several fences, we can choose any of them.
Claim 29. Such a point qb exists. Furthermore, the vertical line segment joining pt and qb is contained in P . Finally, if there exists a point qt  \ {qb} such that qt is contained in the top of g , for some g  F +(P ), then qt is a corner of the rectangle of OPT (P ) protected by g .
Symmetrically, we define q^t to be the highest point on the downwards vertical ray from pb such that q^t is contained in the top of some fork fence or line fence g^  F +(P )  F (P ). Eventually, we may have q^t = pb. Similarly as in Claim 29, we can prove that such a point q^t exists; the vertical line segment ^ joining pb and q^t is contained in P , and if there exists a point qb  ^\ {q^t} such that q is contained in the bottom of some fork fence g  F +(P ), then qb is a corner of the rectangle of OPT (P ) protected by g .
Proof of Claim 29. Since each point on any horizontal edge of P is covered by the bottom and the top of some fence in F +(P )  F (P ), we get that the vertical upwards ray from pt must reach the bottom of a fence before crossing the boundary of P . This implies that qb exists and is contained in P .
Now assume for a contradiction that there exists a point q  \ {qb} such that qt is in the top of some fork fence g  F +(P ) and qt is not a corner of the rectangle R  OPT (P ) protected by g .
First, if qt is not on the boundary of R then it must lie in the first horizontal line segment of f . This would imply that qt is also contained in the bottom of g , which brings a contradiction with the definition of qb.
Thus, qt must be contained in the interior of the top side of R . Since both endpoints of g have the same x-coordinate, the vertical line containing pt and qt must reach the bottom edge of R , say at a point qb. Observe that then qb is contained in the bottom of g . Thus, by definition of qb, the point qb must lie below pt. See Figure 9. Now, we know that the vertical line segment joining qt and qb is contained in the interior of R . This is a contradiction with the fact that pt is the top-right corner of a rectangle R  OPT and rectangles of OPT are disjoint.
3Notice that the top and the bottom endpoints of a fork fence have the same x-coordinate.
19

Figure 9: On the left, a case that cannot happen in the proof of Claim 29. If the vertical line segment between pt and qb contains a point qt contained in the top part of a fork fence g , then qt must be either the top-left corner of R (top-right figure), or the top-right corner of R (bottom-right figure).
We now use the fences f, g and g^ to define a set C of at most 10 vertical and horizontal line segments that partition P into two or three connected components. See Figure 10. Let p, q and q^ denote the points of the boundary of P from which f, g and g^ are respectively emerging. We distinguish three cases:
case 1: q is on a right vertical edge and ft  ptqb  gb intersects with the interior of P . Let be the vertical line segment from pt and qb. We define C as the sequence of line segments in ft   gb that connects p to q. Assuming that the cut does not subdivide the piece into more than one non-empty subpieces, it implies that C has to be on the boundary. Since C connects two points p, q on the left and right vertical edges of P respectively, we can say that C has to contain either the top most edge or the bottom most edge of P . If C contains the bottom edge, since the points in C have non-decreasing height as we go from left to right, we can say that pp is part of the bottom edge, which implies that fb is also part of the boundary since it lies below or at the same height as pp . We have a contradiction due to Claim 28 as we deduced that ft  fb is on the boundary. If C contains the top edge, we can say that g is a line fence on the top edge of the piece because assuming it to be a fork fence would lead to a similar contradiction as the previous statement. Since g is a line fence on the top edge of the piece, we can deduce that ft   gb lies on the boundary, contradicting our assumption.
case 2: q^ is on a right vertical edge and fb  pbq^t  g^t intersects with the interior of P . Let be the vertical line segment from pb to q^t. The cut C must subdivide the piece into more than one nonempty subpieces using the same argument as the above case. Similarly, we define C as the sequence of line segments in fb   g^t that connects p to q^.
case 3: Both q and q^ are on left vertical edges. Here, we define to be the vertical line segment with endpoints qb and q^t. Let C be the sequence of line segments in g   g^ that connects q to q^. We define C := C  ft if ft intersects the interior of P . Otherwise, we define C := C  fb. Since ft or fb must intersect the interior of P due to Claim 28, the cut C always subdivides the piece into more than one non-empty subpieces.
Remark 1. Note that we did not explicitly mention the case when q is on the right, ft  ptqb  gb is on the boundary and q^ is on the left vertical edge; and the other symmetric case. However, both these cases are covered in case (3) using the fact that, whenever ft  ptqb  gb is on the boundary and q is on the right, we can say that g is a line fence on the top edge using the same argument as in case (1). This implies that q can be assumed to be on the left as well as right. Assuming it is on the left, it falls under case (3).
20

Remark 2. In case 3, cutting along C is sufficient in almost all cases. The additional cut along ft guarantees that the left pieces will have at most 17 vertical edges. For instance, in the case where |L(P )| = 16, |R(P )| = 1 and q and q^ are respectively on the first and last left vertical edge, then without the additional cut along ft we would obtain a left piece with 19 vertical sides.
Figure 10: Different cases for the partitioning of a polygon. The green area indicates the left vertical edges that are in EM . The set of lines C used to cut the polygon is shown in blue.
Properties of C. We now prove that C satisfies the properties of Lemma 23. Property (1) is easy to check: C is formed by at most three fork fences that contain each 3 line segments plus one vertical line segment , thus for a total of 10 line segments. Property (3) is also easy to check since, by construction, the line segments of the fences do not intersect any rectangle in OPT (P ). We now prove properties (2) and (4). Claim 30. (2) The set P \ C has two or three connected components and each of them is a horizontally convex polygon contained in P(34). Proof. As already discussed before, we know that there are at least two connected components in P \ C. It is also not difficult to see that the number of connected components is at most three and it can only happen in case (3) (the proof is similar as in Claim 20). It is clear that each of these components has axis-parallel edges. We now prove that each connected component is horizontally convex. For a contradiction, suppose that there is a connected component P of P \ C that is not horizontally convex. Since we assumed that P is horizontally convex, there must be two points x and x in P with the same y-coordinate such that the horizontal line segment between x and x crosses two vertical segments of C. From Claim 29, we deduce that the respective vertical line segments of f, g and g^, the vertical line segments between pt and qb and the vertical line segment between pb and q^t have pairwise disjoint projections on the y-axis. This brings a contradiction in cases 1 and 2. In case 3, the unique pair of vertical segments of C that have non-disjoint projections on the y-axis consists of the vertical line segment of f and . But in this case, if the horizontal line segment between x and x crosses , then x and x must be in different connected components.
It remains to show that the number of vertical edges of each connected component of P \ C is at most 17. Recall that e1, . . . , es denote the left vertical edges of P ordered from top to bottom. Let also e1, . . . , es denote the right vertical edges of P ordered from top to bottom. We know that s  s and s + s  17. In particular, we have s  8. In cases 1 and 2, C starts on a left vertical edge ei for some s/3 +1  i  2s/3 and ends on a right vertical edge ej with 1  j  s . C contains at most three vertical line segments. Thus, each connected component has a number of vertical sides upper bounded by
2s/3 + s + 3 = 2(s + s )/3 + s /3 + 3  2 · 17/3 + 8/3 + 3 = 17.
21

For case 3, assume that q and q^ are respectively on edges ei and ej. By the choice of f as the fence anchored on some left vertical edge of EM with the rightmost endpoints among all such fences, we deduce that g and g^ are not emerging from an edge in EM , i.e., j  2s/3 + 1 and i  s/3 . Then, the connected component on the right has at most s + s - ( 2s/3 - s/3 ) + 3 = s + 2 s/3 + 3  17 vertical edges. The two other components have each at most 2s/3 + 3  2 · 16/3 + 3 = 14 vertical edges. This concludes the proof of Claim 30.
Claim 31. (4) does not intersect any protected rectangle.
Proof. For a contradiction, suppose that a rectangle R  OPT is intersected by and is protected by a fence g  F +(P ). In case 3, remark that the fraction of between pt and pb is the right side of the rectangle in OPT protected by f so R must be intersected either by the fraction of between pt and qb or by the fraction of between pb and q^t. By symmetry, it is enough to consider only the first case. If the vertical line segment from pt to qb intersects R then reaches the bottom edge of R at a point qb that is contained in the bottom of g . Since qb lies strictly below qb, this brings a contradiction with the choice of qb. Thus, no rectangle intersected by is protected.
References
[1] Fidaa Abed, Parinya Chalermsook, José R. Correa, Andreas Karrenbauer, Pablo Pérez-Lantero, José A. Soto, and Andreas Wiese. On guillotine cutting sequences. In Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques (APPROX/RANDOM), volume 40, pages 1­ 19. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2015. doi:10.4230/LIPIcs.APPROX-RANDOM. 2015.1.
[2] Anna Adamaszek, Sariel Har-Peled, and Andreas Wiese. Approximation schemes for independent set and sparse subsets of polygons. J. ACM, 66(4):29:1­29:40, 2019. doi:10.1145/3326122.
[3] Nikhil Bansal and Arindam Khan. Improved approximation algorithm for two-dimensional bin packing. In Proceedings of the Twenty-Fifth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 13­25. SIAM, 2014. doi:10.1137/1.9781611973402.2.
[4] Nikhil Bansal, Andrea Lodi, and Maxim Sviridenko. A tale of two dimensional bin packing. In 46th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pages 657­666. IEEE Computer Society, 2005. doi:10.1109/SFCS.2005.10.
[5] Parinya Chalermsook. Coloring and maximum independent set of rectangles. 6845:123­134, 2011. doi:10.1007/978-3-642-22935-0\_11.
[6] Parinya Chalermsook and Julia Chuzhoy. Maximum independent set of rectangles. In Proceedings of the Twentieth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 892­901. SIAM, 2009. URL: http://dl.acm.org/citation.cfm?id=1496770.1496867.
[7] Parinya Chalermsook and Bartosz Walczak. Coloring and maximum weight independent set of rectangles. In Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 860­868. SIAM, 2021. doi:10.1137/1.9781611976465.54.
[8] Timothy M. Chan and Sariel Har-Peled. Approximation algorithms for maximum independent set of pseudo-disks. Discret. Comput. Geom., 48(2):373­392, 2012. doi:10.1007/s00454-012-9417-5.
[9] Henrik I. Christensen, Arindam Khan, Sebastian Pokutta, and Prasad Tetali. Approximation and online algorithms for multidimensional bin packing: A survey. Comput. Sci. Rev., 24:63­79, 2017. doi:10.1016/j.cosrev.2016.12.001.
22

[10] Julia Chuzhoy and Alina Ene. On approximating maximum independent set of rectangles. In IEEE 57th Annual Symposium on Foundations of Computer Science (FOCS), pages 820­829. IEEE Computer Society, 2016. doi:10.1109/FOCS.2016.92.
[11] Mark de Berg, Otfried Cheong, Marc J. van Kreveld, and Mark H. Overmars. Computational geometry: algorithms and applications, 3rd edition. Springer, 2008. URL: https://www.worldcat.org/oclc/ 227584184.
[12] Jeffrey S. Doerschler and Herbert Freeman. A rule-based system for dense-map name placement. Commun. ACM, 35(1):68­79, 1992. doi:10.1145/129617.129620.
[13] Thomas Erlebach, Klaus Jansen, and Eike Seidel. Polynomial-time approximation schemes for geometric intersection graphs. SIAM J. Comput., 34(6):1302­1323, 2005. doi:10.1137/S0097539702402676.
[14] Jacob Fox and János Pach. Computing the independence number of intersection graphs. In Proceedings of the Twenty-Second Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 1161­ 1165. SIAM, 2011. doi:10.1137/1.9781611973082.87.
[15] Takeshi Fukuda, Yasuhiko Morimoto, Shinichi Morishita, and Takeshi Tokuyama. Data mining using two-dimensional optimized accociation rules: Scheme, algorithms, and visualization. pages 13­23, 1996. doi:10.1145/233269.233313.
[16] Waldo Gálvez, Fabrizio Grandoni, Sandy Heydrich, Salvatore Ingala, Arindam Khan, and Andreas Wiese. Approximating geometric knapsack via l-packings. In 58th IEEE Annual Symposium on Foundations of Computer Science (FOCS), pages 260­271. IEEE Computer Society, 2017. doi: 10.1109/FOCS.2017.32.
[17] Waldo Gálvez, Fabrizio Grandoni, Arindam Khan, Diego Ramirez-Romero, and Andreas Wiese. Improved approximation algorithms for 2-dimensional knapsack: Packing into multiple l-shapes, spirals and more. In To appear in SoCG, 2021.
[18] Fabrizio Grandoni, Stefan Kratsch, and Andreas Wiese. Parameterized approximation schemes for independent set of rectangles and geometric knapsack. In 27th Annual European Symposium on Algorithms (ESA), volume 144, pages 53:1­53:16. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2019. doi:10.4230/LIPIcs.ESA.2019.53.
[19] Fabrizio Grandoni, Tobias Mömke, Andreas Wiese, and Hang Zhou. A (5/3 + )-approximation for unsplittable flow on a path: placing small tasks into boxes. In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing (STOC), pages 607­619. ACM, 2018. doi:10.1145/ 3188745.3188894.
[20] Johan Håstad. Clique is hard to approximate within n1-. Acta Mathematica, 182(1):105­142, 1999. doi:10.1007/BF02392825.
[21] Jan-Henrik Haunert and Tobias Hermes. Labeling circular focus regions based on a tractable case of maximum weight independent set of rectangles. In Proceedings of the 2nd ACM International Workshop on Interacting with Maps, MapInteract (SIGSPATIAL), pages 15­21. ACM, 2014. doi: 10.1145/2677068.2677069.
[22] Klaus Jansen and Malin Rau. Closing the gap for pseudo-polynomial strip packing. In 27th Annual European Symposium on Algorithms (ESA), volume 144, pages 62:1­62:14. Schloss Dagstuhl - LeibnizZentrum für Informatik, 2019. doi:10.4230/LIPIcs.ESA.2019.62.
[23] Arindam Khan, Arnab Maiti, Amatya Sharma, and Andreas Wiese. On guillotine separable packings for the two-dimensional geometric knapsack problem. In To appear in SoCG, 2021.
23

[24] Arindam Khan and Madhusudhan Reddy Pittu. On guillotine separability of squares and rectangles. In Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques (APPROX/RANDOM), volume 176, pages 47:1­47:22. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020. doi:10.4230/LIPIcs.APPROX/RANDOM.2020.47.
[25] Sanjeev Khanna, S. Muthukrishnan, and Mike Paterson. On approximating rectangle tiling and packing. In Proceedings of the Ninth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 384­393. ACM/SIAM, 1998. URL: http://dl.acm.org/citation.cfm?id=314613.314768.
[26] Liane Lewin-Eytan, Joseph Naor, and Ariel Orda. Routing and admission control in networks with advance reservations. In 5th International Workshop on Approximation Algorithms for Combinatorial Optimization (APPROX), volume 2462, pages 215­228. Springer, 2002. doi:10.1007/3-540-45753-4\ _19.
[27] Dániel Marx. Efficient approximation schemes for geometric problems? In 13th Annual European Symposium on Algorithms (ESA), volume 3669, pages 448­459. Springer, 2005. doi:10.1007/11561071\_41.
[28] Joseph S. B. Mitchell. Approximating maximum independent set for rectangles in the plane. CoRR, abs/2101.00326, 2021. URL: https://arxiv.org/abs/2101.00326.
[29] Tobias Mömke and Andreas Wiese. Breaking the barrier of 2 for the storage allocation problem. In 47th International Colloquium on Automata, Languages, and Programming (ICALP), volume 168, pages 86:1­86:19. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020. doi:10.4230/LIPIcs.ICALP. 2020.86.
[30] Nabil H. Mustafa, Rajiv Raman, and Saurabh Ray. Settling the apx-hardness status for geometric set cover. In 55th IEEE Annual Symposium on Foundations of Computer Science (FOCS), pages 541­550. IEEE Computer Society, 2014. doi:10.1109/FOCS.2014.64.
[31] Nabil H. Mustafa and Saurabh Ray. Improved results on geometric hitting set problems. Discret. Comput. Geom., 44(4):883­895, 2010. doi:10.1007/s00454-010-9285-9.
[32] Frank Nielsen. Fast stabbing of boxes in high dimensions. Theor. Comput. Sci., 246(1-2):53­72, 2000. doi:10.1016/S0304-3975(98)00336-3.
[33] János Pach and Gábor Tardos. Cutting glass. volume 24, pages 481­496, 2000. doi:10.1007/ s004540010050.
24

