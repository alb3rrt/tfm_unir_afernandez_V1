arXiv:2106.01053v1 [cs.CR] 2 Jun 2021

The Seventh International Olympiad in Cryptography NSUCRYPTO: problems and solutions
A. Gorodilova1, N. Tokareva1,2, S. Agievich3, C. Carlet4, V. Idrisova1, K. Kalgin1,5, D. Kolegov6, A. Kutsenko1,5, N. Mouha7, M. Pudovkina8, A. Udovenko9
1Sobolev Institute of Mathematics, Novosibirsk, Russia 2Laboratory of Cryptography JetBrains Research, Novosibirsk, Russia
3Belarusian State University, Minsk, Belarus 4University of Paris 8, Paris, France
5Novosibirsk State University, Novosibirsk, Russia 6Tomsk State University, Tomsk, Russia
7National Institute of Standards and Technology, Gaithersburg, United States 8Bauman Moscow State Technical University, Moscow, Russia 9CryptoExperts, Paris, France
E-mail: nsucrypto@nsu.ru
Abstract. The International Olympiad in Cryptography NSUCRYPTO is the unique olympiad containing scientific mathematical problems for professionals, school and university students from any country. Its aim is to involve young researchers in solving curious and tough scientific problems of modern cryptography. In 2020, it was held for the seventh time. Prizes and diplomas were awarded to 84 participants in the first round and 49 teams in the second round from 32 countries. In this paper, problems and their solutions of NSUCRYPTO'2020 are presented. We consider problems related to attacks on ciphers and hash functions, protocols, permutations, primality tests, etc. We discuss several open problems on JPEG encoding, Miller -- Rabin primality test, special bases in the vector space, AES-GCM. The problem of a modified Miller -- Rabin primality test was solved during the Olympiad. The problem for finding special bases was partially solved. Keywords. cryptography, ciphers, hash functions, CPA game, permutations, orthomorphisms, bases, AES, primality tests, steganography, Olympiad, NSUCRYPTO.
The work of the second and sixth authors was supported by Mathematical Center in Akademgorodok under agreement No. 075-15-2019-1613 with the Ministry of Science and Higher Education of the Russian Federation and Laboratory of Cryptography JetBrains Research. The work of the first, fifth and eighth authors was supported by Russian Foundation for Basic Research (project no. 20-31-70043).
1

Introduction
NSUCRYPTO (Non-Stop University Crypto) is the International Olympiad in Cryptography that was held for the seventh time in 2020. The Olympiad program committee includes specialists from Belgium, France, the Netherlands, the USA, Norway, India, Luxembourg, Belarus', Kazakhstan, and Russia. Interest in the Olympiad around the world becomes more significant. In 2020, there were 775 participants from more than 50 countries; and 14 countries took part for the first time. Summing the results, 84 participants in the first round and 49 teams in the second round from 32 countries were awarded with prizes and honorable diplomas. The list of the winners can be found at the official website of the Olympiad [9].
Let us shortly formulate the format of the Olympiad. When registering to the Olympiad, each participant chooses his/her category: "school students" (for junior researchers: pupils and high school students), "university students" (for participants who are currently studying at universities) and "professionals" (for participants who have already completed education or just want to be in the restriction-free category). The Olympiad consists of two independent the Internet rounds. The first round is individual (duration 4 hours 30 minutes, two sections: A is for "school students", B is for "university students" and "professionals"). The second round is a team one (duration 1 week, common to all participants).
A distinctive feature of the Olympiad is that some unsolved problems at the intersection of mathematics and cryptography are offered to the participants as well as problems with known solutions. During the Olympiad, one of such open problems, "Miller -- Rabin revisited" (see section 2.5), was solved completely. For another one problem, "Bases" (see section 2.13), a partial solution was proposed. All the open problems stated during the Olympiad history can be found here [10]. What is more important for us that some researchers were trying to find solutions after the Olympiad was over. In the recent paper [7], a complete solution was found for the problem "Orthogonal arrays" (2018). A partial solution for the problem "A secret sharing" (2014) was proposed in [3]. We invite everybody who has ideas on how to solve the problems to send your solutions to us!
The paper is organized as follows. We start with problem structure of the Olympiad in section 1. Then we present formulations of all the problems stated during the Olympiad and give their detailed solutions in section 2.
Mathematical problems and their solutions of the previous International Olympiads in cryptography NSUCRYPTO from 2014 to 2019 can be found in [2], [1], [8], [4], [5], and [6] respectively.
Figure 1: NSUCRYPTO logo and winners
2

1 Problem structure of the Olympiad
There were 14 problems stated during the Olympiad, some of them were included in both rounds (Tables 1, 2). Section A of the first round consisted of six problems, whereas the section B contained seven problems. The second round was composed of ten problems. Four problems included unsolved questions (awarded special prizes from the Program Committee).

Table 1: Problems of the first round

N Problem title

Max score

1 2020

4

2 POLY

4

3 A secret house

4

4 RGB

4

5 Miller -- Rabin revisited (Q1)

4

6 Mysterious event

4

N Problem title

Max score

1 2020

4

2 A secret house

4

3 Miller -- Rabin revisited 4 + add. sc. for open pr.

4 RGB

4

5 Mysterious event

4

6 CPA game

6

7 Collisions (Q1)

4

Section A

Section B

Table 2: Problems of the second round

N Problem title

Maximum score

1 POLY

4

2 Stairs-Box

7

3 Hidden RSA

6

4 Orthomorphisms

12

5 JPEG Encoding

Unlimited (open problem)

6 Miller -- Rabin revisited 4 + add. sc. for open pr.

7 CPA game

6

8 Collisions

8

9 Bases

Unlimited (open problem)

10 AES-GCM

10 + add. sc. for open pr.

2 Problems and their solutions
In this section, we formulate all the problems of NSUCRYPTO'2020 and present their detailed solutions paying attention to solutions proposed by the participants.
2.1 Problem "2020"
2.1.1 Formulation
A cipher machine WINSTON can transform a binary sequence in the following way. A sequence S is given, a cipher machine can add to S or remove from S any subsequence of the form 11, 101, 1001, 10 . . . 01. Also, it can add to S or remove from S any number of zeros.
When special agent Smith entered the room there were two identical WINSTON machines. He was curious to encrypt number 2020 and he tried to encrypt the number in it's binary form. The first cipher machine returned the binary form of number 1984, the second one returned the binary form of number 2021. Smith understood that one of the machines is broken. How did he know that?

3

2.1.2 Solution
By removing subsequences of the form 10...01 and 0...0, the parity of ones in the binary representation cannot be changed. The given numbers have the following binary representations:
2020  11111100100  7 ones 2021  11111100101  8 ones 1984  11111000000  5 ones Hence, it is impossible to obtain 2021 from the input 2020. Hence, the second machine must be broken.
2.2 Problem "POLY"
2.2.1 Formulation
During a job interview, Bob was proposed to think up a small cryptosystem that operates with integers. Bob invented and implemented a complex algorithm POLY that can be represented mathematically as a polynomial. Namely, if x is a plaintext, then ciphertext y is equal to p(x), where p is a polynomial with integer coefficients.
Bob's employer decided to test it. At first, he encrypted the number 20 and obtained the number 7. Secondly, he encrypted the number 15 and obtained the number 5. After that he said to Bob that there was a mistake in the implementation of the algorithm and did not hire him. What was wrong?
2.2.2 Solution Let p(x) = c0 + c1x + . . . + cnxn. Then p(a) - p(b) = c1(a - b) + . . . + cn(an - bn), where a, b are some integers. Since (ak - bk) is divided by (a - b), we have that p(a) - p(b) is divided by (a - b). By condition, we have p(20) = 7 and p(15) = 5, but 5 does not divide 2. Hence, there is a mistake in the implementation.
2.3 Problem "A secret house"
2.3.1 Formulation
You can see a secret house in Fig. 2(a). Looking on it, could you understand what should be shown inside the frame left blank in Fig. 2(b)?

(a)

(b)

Figure 2: A secret house

2.3.2 Solution
Looking on the house, one can see that the number in a window is equal to "5 minus the number of shadows" inside the window. Hence, we can guess that the task is to calculate 340231 (mod 5). Since 34 = 1 (mod 5), then 340231 (mod 5) = 34·10057+3 (mod 5) = 33 mod 5 = 4. Hence, there should be one shadow inside the frame.
4

2.4 Problem "RGB"
2.4.1 Formulation Victor is studying the Moctod search server. Inside its software, he found two integer variables a and b that change their values when special search queries "RED", "GREEN" and "BLUE" are processed. More precisely, the pair (a, b) is changed to (a + 18b, 18a - b) when processing the query "RED", to (17a + 6b, -6a + 17b) when processing "GREEN", and to (-10a - 15b, 15a - 10b) when processing "BLUE". When any of a or b reaches a multiple of 324, it resets to 0. Whenever (a, b) = (0, 0), the server crashes.
On the server startup, the variables (a, b) are set to (20, 20). Prove that the server will never crash with these initial values, regardless of the search queries processed.
2.4.2 Solution The number 325 is the first natural number that can be written as sums of squares in three different ways (up to permutation of terms):
325 = 12 + 182 = 62 + 172 = 102 + 152.
Keeping this in mind, if (A, B) is the result of changing (a, b) with some query, then
A2 + B2 = 325(a2 + b2)  a2 + b2 (mod 324).
Thus, the number (a2 + b2) mod 324 does not change for any chain of queries (in order words, it is an invariant). Since initially (202 + 202) mod 324 = 152 = 0, the server will never crash.
2.5 Problem "Miller -- Rabin revisited"
2.5.1 Formulation Bob decided to improve the famous Miller -- Rabin primality test and invented his test given in Algorithm 1. The odd number n being tested is represented in the form n - 1 = 2k3 m, where m is not divisible by 2 or 3.
Algorithm 1 Bob's primality test 1. Take a random a  {2, . . . , n - 2}. 2. Put a  am mod n. If a = 1, return "PROBABLY PRIME". 3. For i = 0, 1, . . . , - 1 do the following steps: (a) b  a2 mod n; (b) if a + b + 1 is divisible by n, return "PROBABLY PRIME"; (c) a  ab mod n. 4. For i = 0, 1, . . . , k - 1 repeat: (a) if a + 1 is divisible by n, return "PROBABLY PRIME"; (b) a  a2 mod n. 5. Return "COMPOSITE".
Q1 Prove that Algorithm 1 does not fail, that is, not return "COMPOSITE", for a prime n.
5

Q2 Bonus problem (extra scores, a special prize!)
A composite integer n may be classified as "PROBABLY PRIME" by a mistake. It is known that for the usual Miller -- Rabin test the error probability is less than 1/4. Can this estimation be improved when we are switching to Algorithm 1?
Remark. The expression a  am mod n means that a takes a new value that is equal to the remainder of dividing am by n.

2.5.2 Solution

Let us prove that Algorithm 1 does not fail (Q1). If n is prime, then by Fermat's Little Theorem n divides

an-1 - 1 = a2k3lm - 1 = (a2k-13lm - 1)(a2k-13lm + 1) = . . . =

k-1

k-1

= (a3lm - 1)

a2i3lm + 1 = ((a3l-1m)3 - 1)

a2i3lm + 1 =

i=0

i=0

k-1

= (a3l-1m - 1)((a3l-1m)2 + a3l-1m + 1)

a2i3lm + 1 = . . . =

i=0

l-1

k-1

= (am - 1)

(a3jm)2 + a3jm + 1

a2i3lm + 1 .

j=0

i=0

A prime number n must divide one of the parentheses in the last expression. The required statement follows from this.
The answer for the question Q2 is "the estimation is not improved". Let us prove this. In the original Miller -- Rabin test, instead of steps 2 and 3, the following step is performed:
23. a  a3lm mod n. If a = 1, return "PROBABLY PRIME".

In other words, the following congruence relation is checked:

a3lm  1 (mod n).

(1)

If (1) is satisfied, then A = a3l-1m is the cube root of 1 modulo n:

A3 - 1  0 (mod n)  (A - 1)(A2 + A + 1)  0 (mod n).

In this case, either A  1 (mod n), i.e.

a3l-1m  1 (mod n),

(2)

or A2 + A  -1 (mod n). Both cases are analyzed in Bob's test. In the first case, the congruence relation (2) is analyzed in the same way as (1).
Thus, the answer "PROBABLY PRIME" in Miller -- Rabin test is returned if and only if the same answer is returned in Bob's test. Bob's test has an advantage over Miller -- Rabin test. It is more efficient since the correctness of (1) can be obtained earlier.
The question Q2 was correctly solved by 10 participants and teams. They are Artur Puzio (Poland), Leo Boitel (France), Geng Wang (China), Gabor P. Nagy (Hungary), the team of MirceaCostin Preoteasa, Gabriel Tulba-Lecu, Ioan Dragomir (Romania), the team of Albert Smith, Ethan Tan, Guowen Zhang (Australia), the team of Sergey Bystrevskii, Maksim Starodubov, Evgeny Mikhalchuk (Russia), the team of Mohammad Akbarizadeh, Reza Kaboli, Sajjad Bagheri (Iran), the team of Jeremy Jean, Hugues Randriam (France), Irina Slonkina (Russia).

6

2.6 Problem "Mysterious event"
2.6.1 Formulation
Mr. Bob is the editor in-chief of a well known magazine. He has many interests and activities in addition to work: meetings with bright people of politics and art, dancing, fishing, and even stenography and linguistics.
Every week, the magazine publishes a hard Sudoku on the last page. Mr. Bob likes this game too! So, it is a pleasure for him to personally analyze all solutions from the readers. He sits down in his office with a cup of coffee and looks through all the PNG-files with photos of solutions.
But suddenly Mr. Bob disappeared. The last solution he could see on his monitor was that in Fig. 3 (here is a link to it, if you are interested in).
But what happened? Where is Mr. Bob?

Figure 3: Sudoku

2.6.2 Solution
As Mr. Bob likes stenography and the format of the given file is png, one can try to find message hidden in Fig. 3 using steganography tools, for example [14]. It reveals the message "They know that you are a spy! Get back to the center right now." So, Mr.Bob is in the center.

2.7 Problem "CPA game"
2.7.1 Formulation
Suppose we have a system for the encryption of binary messages. The system has the following characteristics:
· Every message is divided into blocks of length n that are called plaintexts (it is supposed that the length of messages is divisible by n).
· The system employs a block cipher with the encryption function E in cipher block chaining (CBC) mode (see the picture below). A block, an initialization vector IV and a key lengths are equal to n. The result of encryption of the message is a concatenation of IV and the ciphertexts of all plaintexts it consists of.
· The IV for the first message is chosen randomly by using a secure pseudorandom number generator. The last ciphertext block of the i-th message is used as the IV for the (i + 1)-st message.
Let Alice be an honest user of the system. Victor, an adversary, convinced her to play chosen­ plaintext attack game (CPA game) with him.
The game is the following:
1. Alice selects a key k  {0, 1}n and chooses a bit b  {0, 1}. 2. Victor submits a sequence of q queries to Alice. For i = 1, 2, . . . , q repeat
(a) Victor chooses a pair of messages, mi,0, mi,1 of the same length. (b) Alice encrypts mi,b with the key k and gets ci (the sequence of corresponding IV and
ciphertexts). She sends ci to Victor.

7

3. Victor outputs a bit b  {0, 1}.
Let W be the event that Victor guesses the bit, that is b = b. We define Victors's advantage with respect to E as CPAadv := |Pr[W] - 1/2|. Victor wins the game if he can build an efficient algorithm such that CPAadv is not negligible.
Task. Construct an efficient probabilistic polynomial-time (PPT) algorithm that wins the CPA game against this implementation with an advantage close to 1/2.
2.7.2 Solution
We describe two deterministic algorithms that win the given CPA game with two queries in Algorithms 2,3. Let 0 and 1 denote all zeros and all ones vectors from the space Fn2 .
Algorithm 2 The first deterministic algorithm q1: (a) Victor chooses a pair of messages m1,0 = m1,1 = 0 and sends them to Alice;
(b) Alice sends c1 = (IV, Ek(IV )) to Victor; q2: (a) Victor chooses a pair of messages m2,0 = IV  Ek(IV ), m2,1 = IV  Ek(IV )  1 and
sends them to Alice; (b) Alice sends c2 = (Ek(IV ), C) to Victor. Depending on the value of b, the ciphertext C
is equal to Ek(IV ) if b = 0, and it holds C = Ek(IV  1) if b = 1.
Finally, Victor outputs b = 0 if C = Ek(IV ) and b = 1 otherwise.
Algorithm 3 The second deterministic algorithm q1: (a) Victor chooses a pair of messages m1,0 = 0, m1,1 = 1 and sends them to Alice;
(b) Alice sends c1 = (IV, C) to Victor, where the ciphertext C is equal to Ek(IV ) if b = 0, and it holds C = Ek(IV  1) if b = 1;
q2: (a) Victor chooses a pair of messages m2,0 = m2,1 = IV  C and sends them to Alice; (b) Alice sends c2 = (Ek(IV ), Ek(IV )) to Victor.
Finally, Victor outputs b = 0 if C = Ek(IV ) and b = 1 otherwise.
There were several solutions from the participants that proposed the aforementioned approaches, as well as many 3-queries deterministic and probabilistic algorithms.
2.8 Problem "Stairs-Box"
2.8.1 Formulation
Nicole was climbing stairs and has found a box containing a curious permutation on the set of elements {0, 1, . . . , 63}:
S = [ 13,18,20,55,23,24,34, 1,62,49,11,40,36,59,61,30, 33,46,56,27,41,52,14,45, 0,29,39, 4, 8, 7,17,50, 2,54,12,47,35,44,58,25,10, 5,19,48,43,31,37, 6, 21,26,32, 3,15,16,22,53,38,57,63,28,60,51, 9,42 ]
So, the element 0 it maps to 13, the element 1 to 18, etc.
8

Nicole understands that it is possible to consider such a permutation as a vectorial Boolean function S : F62  F62 if every number between 0 and 63 one replaces with a binary vector of length 6. For instance, S(000010) = (010100), since S maps 2 to 20. She knows that S can be given in terms of coordinate functions as S(x) = (s1(x), . . . , s6(x)), and each Boolean function si can be represented in the algebraic normal form using binary operations XOR and AND in the following way: si(x) = IP(N) aI iI xi , where P(N ) is the power set of N = {1, . . . , 6} and aI  F2.
A label on the box said that the function S can be represented as a composition of three maps in the following way:
S = A  X  B,
where A, B : F62  F62 are linear maps and X is a function with a short arithmetic expression modulo 64. Nicole knows that a linear map over F62 can be defined by multiplication with a 6 × 6 matrix over F2. But she wonders what is supposed by "a short arithmetic expression modulo 64"? Probably, Nicole also should consider maps as classical modular operations such as addition, substraction, multiplication modulo 64?..
Help Nicole to find the secret function X and the respective maps A, B!
2.8.2 Solution
Arithmetic operations modulo 26 can be reduced modulo smaller powers of 2. Most importantly, the output modulo 2 depends only on the input modulo 2 (1 bit), the output modulo 2i depends only on the input modulo 2i (i input bits, 1 i 6).
It follows that there must exist linear combinations of outputs of S with algebraic degrees less or equal to each of 1, 2, 3, 4, 5, 5 ("staircase"). And indeed, such combinations do exist for the given S-box S. While there is some freedom left in choosing such combinations, the number of possibilities is reasonably small. Any such choice identifies a candidate for the linear map A. The same idea can be applied to S-1 to obtain candidates for B. Using the fact that i least significant bits of the output of X must depend only on i least significant bits of the input of X, correct candidates for A, B can be recovered in a sequential bit-by-bit manner.
There exist 8 solutions, any of which was accepted as a correct answer:
X : Z64  Z64, X(x)  {x + 1, x + 17, x + 33, x + 49, 33x + 1, 33x + 17, 33x + 33, 33x + 49}.
In total, 15 teams managed to solve this problem completely and 12 teams got only partial progress. Many teams guessed the linear shape of the polynomial of X and used creative ways to verify their guess. Teams of Gongyu Shi, Xinzhou Wang, Yu-hang Jii (China) and Weidan Ji, Wenwen Xia, Zhang Hongyi (China) used the Walsh spectrum exploiting its invariance under composition of the function with linear maps and further recovered A, B efficiently by matching the rows/columns of the Linear Approximation Tables (LAT) of S and X. The team of Gyumin Roh, Hyunsik Jeong, Mincheol Son (South Korea) developed similar method but using Difference Distribution Table (DDT) instead of the LAT. Hieu Nguyen Duy (Vietnam) used more direct approach to reconstructing A, B row-by-row/column-by-column with the constraint of the partial solution X modulo 2i having the form linear polynomial x  ax + b.
9

2.9 Problem "Hidden RSA"
2.9.1 Formulation
Bob has learned about the public-key cryptography and now anyone can send a secret message to him. The message is encoded by a nonnegative integer x which has at most 70 digits in the decimal representation. To send a message for Bob, one has to enter it on his webpage [11]. After the message is entered, it is immediately encrypted using RSA. The encryption result is
Encr(x) = xe mod n,
where n is a modulus (product of two distinct odd primes p and q) and e is a public exponent (coprime with p - 1 and q - 1). Bob is afraid of hackers and does not disclose either n or e (even though this contradicts the usual usage of the RSA cryptosystem).
Victor has intercepted the encrypted message
y = 71511896681324833458361392885184344933333159830863878600189212073777582178173,
which Alice has sent to Bob. Help Victor to decrypt y. You can enter any allowed message x on the Bob's website [11] and
receive in response the corresponding ciphertext Encr(x).

2.9.2 Solution

Victor takes advantage of the fact that RSA typically uses a small open exponent e. Victor views

small candidate exponents e^ = 3, 5, . . ., searching for the correct one among them and at the same

time determining n.

Viktor processes e^ as follows. First, he checks the condition 2e^ Encr(2). If the condition is not satisfied, then e^ is rejected. Second, Victor defines n^ = 2e - Encr(2). This is an estimate of the

modulus n in the sense that if e^ = e, then n^ is a multiple of n. Third, for several random x Victor

refines the estimate:

n^  gcd(n^, (xe^ mod n^) - Encr(x)).

If e^ = e, then the estimate n^ quickly converges to n. If e^ = e, then n^ quickly converges to 1. Using the method described above, Victor finds e = 65537 and

n = 76200708443433250012501342992033571586971760218934756930058661627867825188509.

The module n (256-bit) can be quickly factorized using programs like msieve or cado-nfs. As a result, prime divisors can be found

p = 232086664036792751646261018215123451301, q = 328328681700354546732404725320581286809.

Then the secret exponent is determined d = e-1 mod (p - 1)(q - 1) = = 58041460011714671214337771652949080061981291861469879231637604933853779098273

and the desired message

yd mod n = 202010181600.

This is the NSUCRYPTO'2020 start time code (October 18, 2020, 16:00).

10

2.10 Problem "Orthomorphisms"

2.10.1 Formulation

A young cryptographer Bob wants to build a new block cipher based on the Lai-Massey scheme. The

Lai-Massey scheme depends on a finite group G with the neutral element e and an orthomorphism

of G. Bob decides to use a nonabelian group and chooses a dihedral group D2m, m 4, generated

by a, u with presentation

a2m-1 = e, u2 = e, ua = a-1u.

Let  be a permutation of a finite group G. Then  is called an orthomorphism of G if the mapping  :   -1() is a permutation of G.
Bob needs to construct an orthomorphism of D2m. He considers the set DMm consisting of all mappings ((qr11,,qr22,,bc11,,bc22)) on D2m given by

((qr11,,qr22,,bc11,,bc22)) : ai 

ar1i+c1 ar2i+c2 u

if i  {0, . . . , 2m-2 - 1}, if i  {2m-2, . . . , 2m-1 - 1},

((qr11,,qr22,,bc11,,bc22)) : aiu 

aq1i+b1 u, aq2i+b2 ,

if i  {0, . . . , 2m-2 - 1}, if i  {2m-2, . . . , 2m-1 - 1},

and depending on bi, ci, ri, qi  {0, . . . , 2m-1 - 1} for i  {1, 2}, where the operations addition and multiplication are over the residue ring Z2m-1.

Q1 Let m = 4. Help Bob to describe all orthomorphisms of DMm and find their number.
Q2 For each m 4, help Bob to describe all orthomorphisms of DMm, i. e. give necessary and sufficient conditions on bi, ci, ri, qi for i  {1, 2} such that ((qr11,,qr22,,bc11,,bc22)) is an orthomorphism of D2m .

2.10.2 Solution

Let Zn = {0, ..., n - 1} for a positive integer n 1.
Theorem. Let m 4. A mapping ((qr11,,qr22,,bc11,,bc22))  DMm is an orthomorphism if and only if bi, ci, ri, qi  Z2m-1 for i  {1, 2} satisfy one of the following conditions:
1. If r1  r2  3 (mod 4), then r1 = q2, r2 = q1, c1 = b2, c2 = b1, c1 + c2  1 (mod 2). 2. If r1  r2  2 (mod 4), then r1 = q1, r2 = q2,
q1 - 1  b1 + c1 (mod 2m-1), q2 - 1  b2 + c2 (mod 2m-1), b1 + c2  1 (mod 2), b2 + c1  1 (mod 2).
Proof of Theorem. Let  = ((qr11,,qr22,,bc11,,bc22)). It is clear that  is a permutation if and only if

2m-2 -1

2m-1 -1

{r1j + c1 } 

{q2j + b2} = ,

j=0

j=2m-2

2m-2 -1

2m-1 -1

{r1j + c1 } 

{q2j + b2} = Z2m-1 ,

j=0

j=2m-2

2m-1 -1

2m-2 -1

{r2j + c2} 

{q1j + b1} = ,

j=2m-2

j=0

2m-1 -1

2m-2 -1

{r2j + c2} 

{q1j + b1} = Z2m-1 ,

j=2m-2

j=0

11

where the operations addition and multiplication are over the residue ring Z2m-1. They are equivalent to conditions

r1j1 - q2j2  q22m-2 + b2 - c1 (mod 2m-1), r2j1 - q1j2  q12m-2 + b1 - c2 (mod 2m-1), r1(j1 - j2)  0 (mod 2m-1), r2(j1 - j2)  0 (mod 2m-1), q1(j1 - j2)  0 (mod 2m-1), q2(j1 - j2)  0 (mod 2m-1),

(3a) (3b) (3c) (3d) (3e) (3f )

which hold for all j1, j2  Z2m-2 and all j1, j2  Z2m-2 with j1 = j2. From conditions (3c) ­ (3f), it follows that

r1  0 (mod 4), r2  0 (mod 4), q1  0 (mod 4), q2  0 (mod 4).

(4)

Note that  :   -1() is given by

 : ai  a(r1-1)i+c1

if i  Z2m-2 ,

a(r2-1)i+c2 u if i  {2m-2, ..., 2m-1 - 1},

 : aiu  a-(q1-1)i-b1

if i  Z2m-2 ,

a-(q2-1)i-b2 u if i  {2m-2, ..., 2m-1 - 1},

where the operations addition, multiplication and subtraction are over Z2m-1. For each i  {1, 2}, we suppose r~i = ri - 1 mod 2m-1, q~i = 1 - qi mod 2m-1, ~bi = 2m-1 - bi. It is clear that  is a permutation if and only if

2m-2 -1

2m-2 -1

{r~1j + c1} 

q~1j + ~b1

j=0

j=0

= ,

2m-2 -1

2m-2 -1

{r~1j + c1} 

q~1j + ~b1

j=0

j=0

= Z2m-1 ,

2m-1 -1

2m-1 -1

{r~2j + c2} 

j=2m-2

j=2m-2

q~2j + ~b2

= ,

2m-1 -1

2m-1 -1

{r~2j + c2} 

j=2m-2

j=2m-2

q~2j + ~b2

where the operations addition and multiplication are over the residue ring Z2m-1. They are equivalent to conditions

= Z2m-1 ,

(r1 - 1)j1 - (1 - q1)j2  -b1 - c1 (mod 2m-1),

(5a)

(r2 - 1)j1 - (1 - q2)j2  -b2 - c2 (mod 2m-1),

(5b)

(r1 - 1)(j1 - j2)  0 (mod 2m-1),

(5c)

(r2 - 1)(j1 - j2)  0 (mod 2m-1),

(5d)

(q1 - 1)(j1 - j2)  0 (mod 2m-1),

(5e)

(q2 - 1)(j1 - j2)  0 (mod 2m-1),

(5f )

which hold for all j1, j2  Z2m-2 and all j1, j2  Z2m-2 with j1 = j2. From conditions (5c) ­ (5f), it follows that

r1  1 (mod 4), r2  1 (mod 4), q1  1 (mod 4), q2  1 (mod 4).

(6)

12

Then we will use the following Lemma.

Lemma. Let d Then

4, R(d) = {r  Z2d-1|r  t (mod 4), t  {1, 2, 3}} , A¯(d)(h1, h2) = h1j1 - h2j2 mod 2d |j1, j2  Z2d-1 , h1, h2  R(d).

 Z2d \{2d-1}  A¯(d)(h1, h2) = Z2d \{h2} Z2d  {2j|j  Z2d-1 }

if h1 = h2, h1  h2  1 (mod 2), if h2 = 2d - h1, h1  h2  1 (mod 2), if h2 / {h1, 2d - h1}, h1  h2  1 (mod 2),
if h1  h2  2 (mod 4).

Proof of Lemma. For all s, v1, v2  Z2d-1, we denote

sA¯(d)(v1, v2) = sb mod 2d|b  A¯(d)(v1, v2) .

Let t be an element from A¯(d)(h1, h2). Therefore, t = h1i1 - h2i2 mod 2d for some i1, i2  Z2d-1. Let hi  1 ( mod 2) for some i  {1, 2}. Without loss of generality, we suppose h1  1 ( mod 2). Then h-1 1t = i1 - h-1 1h2i2 mod 2d. So, t = i1 - h · i2 mod 2d, where t = h-1 1t, h = h-1 1h2. Obviously, A¯(d)(h1, h2) = A¯(d)(h1, h1h) = h1A¯(d)(1, h). Now, we consider two cases. Case 1. Let h be odd. For all i1, i2  Z2d-1, we have
2d-1 (mod 2d) if h = 1, i1 - i2h  2d - 1 (mod 2d) if h = 2d - 1.

If h  {3, 5, 7, ..., 2d - 3}, then

2d-1 -1

A¯(d)(1, h) =

{j1 - h · j2 |j1  Z2d-1 } =

j2=0

= Z2d-1  2d - h, 2d - h + 1, ..., 2d-1 - h - 1  ...  2d - 2h, 2d - 2h + 1, ..., 2d-1 - 2h - 1 

 2h + 2d-1, 2h + 1 + 2d-1, ..., 2h - 1  ...  h + 2d-1, h + 1 + 2d-1, ..., h - 1 = Z2d,

where the operations addition and subtraction are over Z2d.

Hence,

 Z2d

\{2d-1

}

if h = 1,



A¯(d)(1, h) = Z2d\{2d - 1} if h = 2d - 1,

 Z2d

if h  {3, 5, ..., 2d - 3}.

Case 2. Let h be even. From condition (4), it follows that h2  2 (mod 4). Thus, h  2 (mod 4). Hence,

2d-1 -1

A¯(d)(1, h) =

{j1 - h · j2|j1  Z2d-1 } =

j2=0

= Z2d-1  2d - h, 2d - h + 1, ..., 2d-1 - h - 1  ...  2h, 2h + 1, ..., 2h + 2d-1 - 1 

 h + 2d-1, h + 1 + 2d-1, ..., 2d - 2, 2d - 1, 0, 1, ..., h - 1 = Z2d,

where the operations addition and subtraction are over Z2d.

13

So, if hi  1 (mod 2) for some i  {1, 2}, then

 Z2d

\{2d-1

},



A¯(d)(h1, h2) = Z2d \{2d - h1},

 Z2d ,

if h1 = h2, if h2 = 2d - h1, if h2 / {h1, 2d - h1}.

Suppose h1  h2  2 (mod 4). Thus, t = 2t~ mod 2d, where t~ = h~1i1 - h~2i2 mod 2d-1, h~1 = h1/2, h~2 = h2/2. Note that h~1  h~2  1 (mod 2). From

Z2d-1 = h~1j1 - h~2j2 mod 2d-1|j1, j2  Z2d-1 ,

we get

A¯(d)(h1, h2) = {2j|j  Z2d-1 } .

End of Lemma proof.

From Lemma and conditions (3a), (3b), it follows that we must consider four cases:

· r1  r2  1 (mod 2), · r1  1 (mod 2), r2  2 (mod 4), · r1  2 (mod 4), r2  1 (mod 2), · r1  r2  2 (mod 4).

If r1  r2  1 (mod 2), then

r1  {q2, 2m-1 - q2}, r2  {q1, 2m-1 - q1}.

(7)

From condition (6), we get r1  r2  3 (mod 4). For each i, j  {1, 2}, i = j, if rj = 2m-1 - qi, then qi  1 (mod 4) that contradicts (6).
Consequently, rj = 2m-1 - qi for qi  1 (mod 4). From Lemma and conditions (5a), (5b), we get

b1 + c1  1 (mod 2), b2 + c2  1 (mod 2).

(8)

If r1 = q2, r2 = q1, then relations (3a), (3b) hold if and only if c1, c2, b1, b2 satisfy conditions 2m-2  q22m-2 + b2 - c1 (mod 2m-1), 2m-2  q12m-2 + b1 - c2 (mod 2m-1),

i.e.

c1 = b2, c2 = b1.

(9)

From (8) and (9), we get c1 + c2  1 (mod 2). Let i, j  {1, 2}, i = j. If rj  1 (mod 2), ri  2 (mod 4), then

rj  {qi, 2m-1 - qi}, ri  qj  2 (mod 4).

(10)

From (10), it follows that rj - 1  1 - qj (mod 2). Therefore, from relations (5a), (5b) and

Lemma, we get that condition (10) is impossible.

If r1  r2  2 (mod 4), then q22m-2 + b2 - c1  1 (mod 2), q12m-2 + b1 - c2  1 (mod 2).

Thus,

b1 + c2  1 (mod 2), b2 + c1  1 (mod 2).

(11)

14

From Lemma and relations (5a), (5b), we have ri - 1  {1 - qi, 2m-1 - 1 + qi} for each i  {1, 2},

where

-bi - ci =

2m-2 1 - qi

if ri - 1 = 1 - qi, if ri - 1 = 2m-1 - 1 + qi,

where the operations addition and subtraction are over Z2m-1.
If ri - 1 = 1 - qi for some j  {1, 2}, then rj = 2 - qj. Hence, qj  0 (mod 4) that contradicts (4). So, there is only one relation ri - 1 = 2m-1 - 1 + qi (mod 2m-1) for each i  {1, 2}. Thus,

ri = qi for each i  {1, 2}.

(12)

If r1  r2  2 (mod 4), then  is a permutation if and only if conditions (11), (12) hold and qi - 1 = bi + ci mod 2m-1 for each i  {1, 2}.

End of Theorem proof.

Let OMDm be the subset of MDm consisting of all orthomorphisms. From Theorem, it follows that |OMD4| = 28.
Full and complete solutions for this problem were proposed by four team. The best one was
given by the team of Jeremy Jean and Hugues Randriam (France).

2.11 Problem "JPEG Encoding"
2.11.1 Formulation
In order to decrease the readability of the exchanged messages, Alice and Bob decided to encode their messages using JPEG image compression. They write (or draw) their message in a graphics software, save it as a JPEG file and then encrypt the resulting file using some encryption algorithm.
Let us describe the details of the JPEG encoding. The matrix of pixels is first divided into 8 × 8 matrices, and then the matrices of the type presented below are obtained from them using discrete cosine transform (DCT) and quantization. An interesting characteristic of these matrices is that most of the non-zero data is concentrated in the upper left corner of the matrix, and most of the data in the lower right corner is 0. After that, the matrix is encoded using 0's and 1's.
One example of the matrix encoding is the following algorithm:
1. First, the zigzag rule is used to convert the 8 × 8 matrix into a one-dimensional vector; 2. Then the Exp-Golomb code is used to encode each number in the vector. Each number (aside
from 0, which is encoded as just one bit 0) is encoded by three parts:
­ length: a sequence of 1's corresponding to the length of the binary representation of the number, followed by 0 to mark the end of the length sequence;
­ sign: a bit representing the sign of the number: 0 for negative, 1 for positive number; ­ residual: the binary representation of the number, with the leading 1 omitted.
For example, the number 47 is encoded as the sequence 1111110 1 01111 ;
length sign residual
3. All encoded sequences are then concatenated and a 6-bit sequence is added to the front. These 6 bits represent the number of non-zero elements in the encoded sequence.

15

Figure 4: Zig-zag transformation of the matrix

An example. Let us consider how the algorithm works. We can see that after Exp-Golomb coding (see Fig. 4), the 8 × 8 DCT quantized matrix above can be binarized using 91 bits (see below). Note that using the inverse process of the encoding method, we can get the original 8 × 8 matrix from these 91 bits.

001110 1111110101111 111101001 111100100 11011 111101010 11010 0 100 1110001 101 11000 100 101 1110000 101

# of non-zero elements

47

9

-12

3

10

2 0 -1 -5

1 -2 -1 1

-4

1

Problem for a special prize! Your task is to design an encoding algorithm providing as short as possible output strings for the given 100 000 matrices (here is a file with matrices, and non-zero elements of each matrix are concentrated in the upper left corner). The less the sum of the lengths of the strings, the more scores you get for this problem. The encoding process must be reversible, that is, the original matrix can be obtained from the bit string using inverse coding.

2.11.2 Solution
By the authors opinion there were no great algorithms suggested. So, the problem remains open. Let us discuss some criterions that were used for checking. Any adequate algorithm for data
processing should take into account the internal structure of the data involved. Therefore, the algorithms like: 1) get bits from the text file with matrices neglecting the matrix numeric data itself and compress them just as a stream of bits, scored low; 2) mechanical replacement of the suggested Exp-Golomb code with Huffman code or arithmetic code scored low; 3) the absence of the decoding procedure scored low; 4) not working code scored low. The higher score got solutions which: 1) provided working encoder and decoder; 2) provided data analysis and were able to utilize the results of the data analysis in the algorithm; 3) provided good compression.
The initial authors' algorithm that used the Exp-Golomb code provides the compression size equal to 6 694 303 bits. The lowest compression size 5 878 894 bits was achieved by team of Nhat Linh LE Tan and Viet Sang Nguyen (France). Unfortunately, this algorithm just used the Huffman code instead of Exp-Golomb code. Also, the team of Mikhail Kudinov, Alexey Zelenetskiy, and Denis Nabokov (Russia) suggested an interesting solution. They made several reasonable observations about the data and proposed changes into Exp-Golomb encoding depending on the position in the matrix which allows to improve compression. Their result was 5 684 601 bits. Unfortunately, there were some problems with executing the codes provided during the Olympiad.

2.12 Problem "Collisions"
2.12.1 Formulation
Consider a hash function H that takes as its input a message m consisting of k · n bits and returns an n-bit hash value H(m). The message m is at least one block long (k 1), and can be split

16

into k blocks of n bits each: m1, m2, . . ., mk. Let f be a function which takes an n-bit input and returns an n-bit output. We will use  to denote the bitwise exclusive-or operator.
The hash function H is defined iteratively as follows:
hi := mi  f (hi-1  mi),
where all n bits of h0 are zero, and H(m) := hk. An illustration of function H is given in Fig. 5.
Figure 5: The hash function H.
A collision for H is defined as a pair of distinct messages (m, m ) so that H(m) = H(m ). Given a message m and its corresponding hash value H(m), a second preimage for H is defined as a message m = m so that H(m) = H(m ).
Suppose that f is a secret random function and that you have obtained 10 · n random different pairs (x, f (x)) of argument and value of the function f . Under these restrictions, solve the following problems. Algorithms in Q1 and Q2 must give a solution with a high probability (> 1/2).
Q1 Propose an algorithm which finds a collision for H.
Q2 Propose an algorithm which, given a message m and its corresponding hash value H(m), finds a second preimage m for H.
Q3 Suppose that n = 256 bits and the message m is "A random matrix is likely decent". Find a second preimage m for this message. Remark 1. The text message is converted into a bit sequence as follows: first, each character is converted into a 8-bit integer according to the UTF-8 encoding, and then these integers are concatenated together using the big-endian ordering. For example, the string "Hello" is converted into the sequence of integers (72, 101, 108, 108, 111) which then gives the following binary string: 0100100001100101011011000110110001101111. You can give your answer to this task in the form of a binary sequence or a hexadecimal sequence. Remark 2. You can evaluate the hash function H on any input message here [12]. The message being hashed should be presented as either a binary sequence or a hexadecimal sequence, starting with a symbol b or h which specifies the representation. Here [13] you can find a list of values of the function f on 512 different inputs (binary sequences are presented as integers).
2.12.2 Solution Let || denote the concatenation of bit strings. Below we give solutions for all subproblems.
Q1. It is easy to notice that H(x||f (x)) = 0 for any n-bit string. Therefore, for any two vectors x, y with known values f (x), f (y), messages x||f (x) and y||f (y) produce the same hash value 0.
Q2. By Q1, we can see that for any message m and any n-bit string x it holds
H(x||f (x)||m) = H(m).
17

So, we can easily construct 10·n preimages for any given message m. Alternatively, one can append messages to the end: H m||H(m)  x||H(m)  f (x) = H(m).
Q3. This subproblem essentially asks one to apply their solution for Q2 to a specific example. The easiest solution is to append the string 0||f (0) to the message. The hexadecimal representation of the given message "A random matrix is likely decent" is

m = 412072616e646f6d206d6174726978206973206c696b656c7920646563656e74.

Taking the value of f (0) from the given list, one can construct the following collision:

m = 0||f (0)||m = 0000000000000000000000000000000000000000000000000000000000000000 ff1282609f458d732888e2736fd1b98cc36f809b1c116e77015b8d7d4d8996ae 412072616e646f6d206d6174726978206973206c696b656c7920646563656e74.

Let us describe also an alternative solution for Q2 that was found by Andy Yu (Taiwan). Let us denote gi = hi-1  mi for i = 1, 2, . . . , k. We then claim that

j
hj = gi  f (gi)
i=1

for any j = 1, 2, . . . , k. The proof is by induction. Since g1 = h0  m1 = m1, we have h1 =

m1  f (m1) = g1  f (g1). Let j > 1 and assume that hj-1 =

j-1 i=1

(gi



f

(gi)).

Then

j-1

j

hj = mj  f (mj  hj-1) = gj  hj-1  f (gj) = gj  f (gj)  gi  f (gi) = gi  f (gi),

i=1

i=1

which proves the claim. Note now that H(m) = hk =

k i=1

gi



f (gi).

If

we

find

a

set

of

values

g1, g2, . . . , gs such that H(m) =

s i=1

gi



f (gi),

we

can

easily

construct

a

second

preimage

m

by

flipping the definition of gi's:

j-1

mj = gj  hj-1 = gj  gi  f (gi), j = 1, 2, . . . s.

(13)

i=1

So, the task now becomes the following: given the set of 10 · n pairs {(xi, f (xi))}1i=0·1n, find a subset of indices i1, . . . , is such that H(m) = xi1  f (xi1)  . . .  xis  f (xis). Let us denote yi = xi  f (xi), i = 1, . . . , 10 · n. Then our goal is to express H(m) as a linear combination of vectors yi. Representing yi's as binary vectors of length n, we can easily solve this task by writing out and solving a system of binary linear equations with n equations and 10 · n variables. But this

works only if the value H(m) is in the linear span of the vectors yi. The probability of this event can be estimated as follows:

Pr[H(m) is in the span of yi's] Pr[yi's span the whole space Fn2 ] = = Pr[Random binary n × 10 · n matrix has full rank n] =

=

(210n

- 1)(210n

- 2)(210n - 4) . . . (210n 210n2

- 2n-1)

=

n-1
(1 - 2-10n+i)

i=0

n-1
1 - 2-10n+i = 1 - 2-10n(2n - 1) 1 - 2-9n.

i=0

Here the 4th line is obtained from the 3rd by repeatedly applying (1 - a)(1 - b) 1 - a - b.

So, the algorithm is then the following:

18

1. Calculate yi = xi  f (xi) for i = 1, 2 . . . 10 · n. 2. Construct an n × 10 · n matrix A using yi's as its columns. 3. Solve the linear system A · z = H(m). The probability of success of this step is at least
1 - 2-9n. 4. Taking vectors yi for which zi = 1, reconstruct the second preimage m using (13). If m = m,
shuffle the order of yi's.
As well as the solution described above, notable solutions with extensive research was given by the team of Nhat Linh LE Tan and Viet Sang Nguyen (France), the team of Mircea-Costin Preoteasa, Gabriel Tulba-Lecu, and Ioan Dragomir (Romania).

2.13 Problem "Bases"

2.13.1 Formulation

Problem for a special prize! Let us consider the vector space Fr2 consisting of all binary vectors of length r. For any d vectors xi = (xi1, . . . , xir), i = 1, . . . , d, d > 0, it is defined the componentwise product of these vectors equal to (x11 . . . xd1, . . . , x1r . . . xdr). The empty product (when no element is

involved in it) equals the all-ones vector.

s i

Let s

d > 1 be positive integers and let r be defined by the formula r =

d i=0

s i

,

where

denotes the binomial coefficient. Let B be a basis of the vector space Fr2, and let F  Fr2 be a

family of s binary vectors such that all possible componentwise products of up to d vectors from

the family F (including the empty product) form the basis B.

Given s, d, r defined above, describe all (or at least some) bases B for which such family F exists

or prove that such bases do not exist.

Suggest practical applications of such bases.

Example. Let s = 2, d = 2 and r = 4. Consider the following family of 2 vectors F =
{(1100), (0110)}. Then all componentwise products of 0, 1 and 2 vectors from the family F form the basis B = {(1111), (1100), (0110), (0100)} of the vector space F42.

2.13.2 Solution

The problem "determine what are the bases" was not solved. This problem remains open. The

sub-problem "determine some bases" was solved constructively by the team of Mikhail Kudinov,

Alexey Zelenetskiy, and Denis Nabokov (Russia). Let us describe the main ideas of this solution.

We will prove that such bases exist for all s d > 1 and give a construction of such bases.

Let 1 be all-one vector and r =

d i=0

s i

.

Suppose that there exists F

 Fr2 such that F

=

{v1, v2, . . . , vs} and B = {vi1 . . . vik | 1 i1 < i2 < . . . < ik s and 0 k d} is a basis of Fr2. Let

A be (r × r)-matrix over Fn2 whose rows are exactly the vectors from B. The rank of A is equal to r

since B is a basis. Let A(i) denote the i-th column of A. We number the rows of A and, accordingly,

the coordinates of A(i) as follows. The row corresponding to the vector vi1vi2 . . . vik we number as i1i2, . . . , ik, the first row of A we number as 0. For each A(i), the coordinate number 0 is nonzero and the coordinates 1, 2, . . . , s determine the rest coordinates. Namely, the coordinate i1i2 . . . ik is

equal to the product of coordinates numbered i1, i2, . . . , ik.

Case s = d. In this case r =

d i-0

d i

= 2d. Let x = (x0, x1, . . . , xr-1)  Fr2 with x0 = 1 and

x1, . . . , xd determine xd+1, . . . , xr-1. The number of such vectors is equal to 2d = r. Only these

vectors can be the columns of the matrix A. Since A has r columns and its rank is r, then A (and

as a consequence, a basis in Fr2) is uniquely defined by these vectors up to permutation of columns. Thus, if there are bases in Fr2, then the number of them is r! = (2d)!.

19

Let us prove that these bases exist for an arbitrary d. Let us consider Fr2, r = 2d, as a set of values vectors of all Boolean functions in d variables. Since each Boolean function has the unique

algebraic normal form (ANF), then the values vectors of all 2d elementary monomial functions

{1, x1, x2, . . . , xd, x1x2, . . . , xd-1xd, . . . , x1 . . . xd} form a basis in Fr2. Case s > d. Let us construct an invertible matrix A (and as a consequence, a basis in Fr2) for

an arbitrary s > d. Let the first column of A be the vector (1, 0, 0, . . . , 0). The next s columns

are (1, 1, 0, . . . , 0), (1, 0, 1, . . . , 0), ..., (1, 0, . . . 0, 1, 0, . . . , 0). We denote them as A1. The next

s 2

vectors we denote as A2. Each vector in A2 has only four nonzero coordinate numbered 0, i, j, ij,

1

i<j

s.

Analogically, the set Aj consists of

s j

vectors and each vector has 2j nonzero

coordinates numbered 0, i1, i2, . . . , ij, i1i2, i1i3, . . . , i1i2 . . . ij, 1 i1 < i2 < . . . , ij s.

The matrix A constructed above is a triangular matrix and each element on the main diagonal

is equal to 1. Therefore, the matrix A is invertible. Any permutation of the columns gives us a

new matrix, whose rows give us a basis. Thus, we have r! bases in Fr2.

2.14 Problem "AES-GCM"
2.14.1 Formulation
Alice is a student majoring in cryptography. She wants to use AES-GCM-256 to encrypt the communication messages between her and Bob (for more details of GCM, we refer to [15]). The message format is as follows:

Header Initialization Vector

Encrypted Payload

Authentication Tag

8 bytes

12 bytes

n bytes

16 bytes

However, Alice made some mistakes in the encryption process since she is new to AES-GCM. Your task is to attack the communications.

Q1 You intercepted some messages sent by Alice. You can find these messages in the directory "Task 1". Moreover, you know that the plaintext (unencrypted payload) of the first message (0.message) is "Hello, Bob! How's everything?" (without quotes, encoded in UTF-8). Try to decrypt any message in the directory "Task 1".

Q2 In this task, you further know that the AAD (additional authenticated data) used by Alice in each message is Header || Initialization Vector:

Header Initialization Vector

Encrypted Payload

Authentication Tag

Additional Authenticated Data

You want to tamper some messages in the directory "Task 2".
You pass this task if you can modify at least one bit in some message so that Bob can still decrypt the message successfully.

Q3 Alice has noticed that the messages sent by her have been tampered with. So she decides to enhance the security of her encryption process. Instead of using Header || Initialization Vector as the additional authenticated data (AAD), Alice further generates 8 bytes data X by some deterministic function f and the AES secret key K, where

X = f (K).

20

In each message, she uses Header || Initialization Vector || X as the AAD.
You also intercepted some messages sent by Alice, see these messages in the directory "Task 3". Try to tamper any message!
Q4 Bonus problem (extra scores, a special prize!)
You have successfully tampered with the messages in Q2. However, the attacks will be easy to detect if the tampered message cannot be decrypted to some meaningful plaintext.
In this task, try to tamper the messages in Q2 so that the tampered message can still be decrypted to some plaintext that people can understand. Remark: Tampering with the Header or Initialization Vector of a message will not be accepted as a solution, you need to tamper with the encrypted payload to produce some other ciphertext which did not appear in any message included.

2.14.2 Solution
Let us give solutions or ideas for all subproblems. Q1. Note that blocks of the ciphertext Ci are obtained by XORing blocks of the plaintext Pi
with the values Ek(CBi). The values Ek(CBi) depend on the IV and some other parameters which are common for all messages within one subproblem. Going through the messages, we can see that the messages number 0, 5 and 6 all use the same initialization vector. Since we know the plaintext for the message number 0, we can compute the first 29 bytes of the values Ek(·) for this IV and use them to decipher the entirety of the 20-byte message number 5 and 29 symbols of the 46-byte message number 6:

m5 = Lincoln Park, 10:15. m6 = Nostalgia is a eternal motif

Q2. In this subproblem, the messages number 1 and 6 also have the same initialization vector. We can apply the Forbidden Attack [16] to reconstruct the secret value H, which will allow us to forge messages by changing the ciphertext and recalculating the Authentication Tag. In this solution, we will briefly describe the attack.
Let A = A1||A2|| . . . ||Am be the AAD of a message, and let C = C1||C2|| . . . ||Cn be the encrypted payload. Then the Authentication Tag can be presented as follows:

m+n+1

AuthTag = Ek(CB0) 

TiH m+n+2-i,

i=1

(14)

where T = A1||A2|| . . . ||Am||C1||C2|| . . . ||Cn||(len(A)||len(C)) and all operations are performed in the Galois field F2128.
Let us consider (14) as an equation which we want to solve for H. Since we know the AuthTag,
the AAD and the ciphertext for every message, each coefficient in this equation is known except
for Ek(CB0). However, since the messages number 1 and 6 have the same IV , they also have the same value Ek(CB0). Subtracting equations of the form (14) constructed for the messages number 1 and 6 one from another, we obtain the following equation:

AuthTag1 - AuthTag6 = g(H),

21

where g(H) is a polynomial in the variable H with all coefficients known. We can find the root of it in the field F2128 :
H = a126 + a125 + a122 + a120 + a119 + a116 + a114 + a111 + a110 + a107 + a99 + a96 + a95 + a94 + a93 + a92 + a90 + a89 + a87 + a85 + a84 + a83 + a82 + a81 + a80 + a78 + a76 + a73 + a67 + a66 + a62 + a61 + a60 + a59 + a56 + a53 + a52 + a49 + a47 + a45 + a40 + a39 + a38 + a37 + a36 + a35 + a34 + a33 + a29 + a28 + a24 + a22 + a21 + a19 + a18 + a17 + a16 + a14 + a11 + a10 + a9 + a6 + a4 + a2,
where a is the generator of the field. Knowing H, we can easily find Ek(CB0) and calculate the Authentication Tag for any ciphertext which was obtained using the same IV as in the messages number 1 and number 6.
Q3. Observing messages from the subproblem, we can notice that the messages number 1, 3 and 7 have the same Header h, the same IV and the same length of the ciphertext len(Cj), j = 1, 3, 7. Let us split the Initialization Vector IV = IV0||IV1 so that the AAD for each of the three messages can be written as A = A1||A2, where A1 = h||IV0 and A2 = IV1||X||032. Then for j = 1, 3, 7, we have:
AuthTagj = Ek(CB0)  A1H23  A2H22  C1jH21  C2jH20  . . .  C2j0H2  (len(A)||len(C)H.
Here, we do not know Ek(CB0) and we also do not know A2 since it contains the secret value X = f (K). However, since the degrees of all three equations are the same, when we subtract one from another, the term with A2 vanishes along with Ek(CB0). So, we can still apply the method used in Q2 to solve these equations for H. After trying all possible combinations, we find the only value of H which satisfies all equations at once:
H = a123 + a122 + a112 + a110 + a107 + a102 + a100 + a99 + a97 + a96 + a95 + a92 + a90 + a87 + a85 + a83 + a82 + a81 + a78 + a77 + a74 + a73 + a71 + a70 + a65 + a63 + a62 + a60 + a59 + a58 + a57 + a54 + a53 + a50 + a49 + a47 + a45 + a43 + a42 + a41 + a37 + a36 + a32 + a30 + a28 + a23 + a13 + a12 + a10 + a7 + a5 + a3 + 1.
Knowing H, we can once again modify any of the ciphertexts of the messages number 1, 3 or 7 and recalculate the Authentication Tag.
Q4. This subproblem remains open in general as there were no complete theoretical solutions given. However, many different approaches were presented to modify these particular messages utilizing the properties of the natural language.
Some participants suggested that we can flip the least significant bits in parts of the ciphertext in order to obtain a text with a "typo". Alternatively, we can try shuffling parts of ciphertexts encrypted with the same IV , which may produce a readable text, although likely not semantically connected.
Other participants used the properties of the natural English language to decipher the messages number 1 and 6 by hand. Note that, since the messages use the same IV , if we XOR the shorter ciphertext C6 with the part of the longer ciphertext C1, we will get
C6  C1 = P 6  P 1.
22

Trying to find pairs of texts P 1, P 6 that are readable and sum to C6  C1 by hand, it is possible to discover the following two texts:
P 6 = ``Do not you want to know who has taken it?'' cried his wife impatiently. P 1 = However little known the feelings or views of such a man may be on his
Note that we cannot be completely sure that these texts were the original messages, and we also cannot guarantee which text is P 1 and which is P 6. However, it is highly likely we correctly decrypted the message number 6. We can now replace it with an arbitrary new message P~6 of the same length, and its corresponding ciphertext can be calculated as follows: C~6 = P~6  C6  P 6. We are also able to calculate an Authentication Tag for this new message as we have solved Q2 and know H.
The most complete solutions to this problem were given by the team of Himanshu Sheoran, Sahil Jain, and Tirthankar Adhikari (India), the team of Mikhail Kudinov, Alexey Zelenetskiy, and Denis Nabokov (Russia), the team of Pham Cong Bach, Phu Nghia Nguyen, and Ngan Nguyen (Vietnam), the team of Roman Sychev, Diana Bespechnaya, and Nikolay Prudkovskiy (Russia), the team of Roman Lebedev, Vladimir Sitnov, Ilia Koriakin (Russia).
Acknowledgments. We thank Alexey Oblaukhov for fruitful discussions and valuable comments.
References
[1] Agievich S., Gorodilova A., Idrisova V., Kolomeec N., Shushuev G., Tokareva N. Mathematical problems of the second international student's Olympiad in cryptography. Cryptologia. 2017, V. 41, No. 6, pp. 534­565.
[2] Agievich S., Gorodilova A., Kolomeec N., Nikova S., Preneel B., Rijmen V., Shushuev G., Tokareva N., Vitkup V. Problems, solutions and experience of the first international student's Olympiad in cryptography. Prikladnaya Diskretnaya Matematika (Applied Discrete Mathematics). 2015, No. 3, pp. 41­62.
[3] Geut K., Kirienko K., Sadkov P., Taskin R., Titov S. On explicit constructions for solving the problem "A secret sharing". Prikladnaya Diskretnaya Matematika. Prilozhenie. 2017, No. 10, pp. 68­70 (in Russian).
[4] Gorodilova A., Agievich S., Carlet C., Gorkunov E., Idrisova V., Kolomeec N., Kutsenko A., Nikova S., Oblaukhov A., Picek S., Preneel B., Rijmen V., Tokareva N. Problems and solutions of the Fourth International Students' Olympiad in Cryptography (NSUCRYPTO). Cryptologia. 2019, V. 43, I. 2, pp. 138­174.
[5] Gorodilova A., Agievich S., Carlet C., Hou X., Idrisova V., Kolomeec N., Kutsenko A., Mariot L., Oblaukhov A., Picek S., Preneel B., Rosie R., Tokareva N. The Fifth International Students' Olympiad in Cryptography - NSUCRYPTO: problems and their solutions. Cryptologia. 2020, V. 44, I. 3, pp. 223­256.
[6] Gorodilova A., Tokareva N., Agievich S., Carlet C., Gorkunov E., Idrisova V., Kolomeec N., Kutsenko A., Lebedev R., Nikova S., Oblaukhov A., Pankratova I., Pudovkina M., Rijmen V., Udovenko A. On the Sixth International Olympiad in Cryptography NSUCRYPTO. Journal of Applied and Industrial Mathematics, 2020, Vol. 14, No. 4, pp. 623­647.
23

[7] Kiss R., Nagy G. P. On the nonexistence of certain orthogonal arrays of strength four. arXiv:2011.09935. https://arxiv.org/abs/2011.09935
[8] Tokareva N., Gorodilova A., Agievich S., Idrisova V., Kolomeec N., Kutsenko A., Oblaukhov A., Shushuev G. Mathematical methods in solutions of the problems from the Third International Students' Olympiad in Cryptography. Prikladnaya Diskretnaya Matematika (Applied Discrete Mathematics). 2018, No. 40, pp. 34­58.
[9] https://nsucrypto.nsu.ru/ [10] https://nsucrypto.nsu.ru/unsolved-problems/ [11] https://nsucrypto.nsu.ru/archive/2020/round/2/task/3/ [12] https://nsucrypto.nsu.ru/archive/2020/round/2/task/8 [13] https://nsucrypto.nsu.ru/media/MediaFile/Collisions-Values_of_F.txt [14] https://stylesuxx.github.io/steganography/ [15] Dworkin M. Sp 800-38d. Recommendation for block cipher modes of operation: Galois/counter
mode (GCM) and GMAC. National Institute of Standards & Technology, 2007. https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf [16] B¨ock H., Zauner A., Devlin S., Somorovsky J., Jovanovic Ph. Nonce-Disrespecting Adversaries: Practical Forgery Attacks on GCM in TLS. Cryptology ePrint Archive: Report 2016/475. https://eprint.iacr.org/2016/475.pdf
24

