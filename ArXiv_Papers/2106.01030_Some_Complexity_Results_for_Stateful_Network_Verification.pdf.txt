arXiv:2106.01030v1 [cs.LO] 2 Jun 2021

Some Complexity Results for Stateful Network Verification
Kalev Alpernas · Aurojit Panda · Alexander Rabinovich · Mooly Sagiv · Scott Shenker · Sharon Shoham · Yaron Velner
Abstract In modern networks, forwarding of packets often depends on the history of previously transmitted traffic. Such networks contain stateful middleboxes, whose forwarding behaviour depends on a mutable internal state. Firewalls and load balancers are typical examples of stateful middleboxes.
This work addresses the complexity of verifying safety properties, such as isolation, in networks with finite-state middleboxes. Unfortunately, we show that even in the absence of forwarding loops, reasoning about such networks is undecidable due to interactions between middleboxes connected by unbounded ordered channels. We therefore abstract away channel ordering. This abstraction is sound for safety, and makes the problem decidable. Specifically, safety checking becomes EXPSPACE-complete in the number of hosts and middleboxes in the network. To tackle the high complexity, we identify two useful subclasses of finite-state middleboxes which admit better complexities. The simplest class includes, e.g., firewalls and permits polynomial-time verification. The second class includes, e.g., cache servers and learning switches, and makes the safety problem coNP-complete.
Finally, we implement a tool for verifying the correctness of stateful networks.
A preliminary version of this work appeared in [41].
K. Alpernas Tel Aviv University E-mail: kalev.alp@gmail.com A. Panda NYU A. Rabinovich Tel Aviv University M. Sagiv Tel Aviv University S. Shenker UC Berkeley S. Shoham Tel Aviv University Y. Velner Hebrew University of Jerusalem

2

Kalev Alpernas et al.

Keywords Safety Verification · Stateful Networks · Middleboxes · Channel Systems · Petri Nets · Complexity Bounds

1 Introduction
Modern computer networks are extremely complex, leading to many bugs and vulnerabilities which affect our daily life. Therefore, network verification is an increasingly important topic addressed by the programming languages and networking communities (e.g., see [21, 9,18,19,17,37,26,14]). Previous network verification tools leverage a simple network forwarding model which renders the datapath immutable; i.e., normal packets going through the network do not change its forwarding behaviour, and the control plane explicitly alters the forwarding state at relatively slow time scales. Thus, invariants can be verified before each control-plane initiated change and these invariants will be enforced until the next such change. While the notion of an immutable datapath supported by an assemblage of routers makes verification tractable, it does not reflect reality. Modern enterprise networks are comprised of roughly 2/3 routers 1 and 1/3 middleboxes [38]. A simple example of a middlebox is a stateful hole-punching firewall which permits traffic from untrusted hosts only after they have received a message from a trusted host. Middleboxes -- such as firewalls, WAN optimizers, transcoders, proxies, load-balancers, intrusion detection systems (IDS) and the like -- are the most common way to insert new functionality in the network datapath, and are commonly used to improve network performance and security. While useful, middleboxes are a common source of errors in the network [31], with middleboxes being responsible for over 40% of all major incidents in networks.
This work addresses the problem of verifying safety of networks with middleboxes, referred to as stateful networks. We model such a network as a finite undirected graph with two types of nodes: (i) hosts which can send packets, (ii) middleboxes which react to packet arrivals and forward modified packets. Each node in the network has a fixed number of ports, connected by network edges (links).
From a verification perspective, it is possible to view a middlebox as a procedure with local mutable state which is atomically changed every time a packet is transmitted. The local state determines the forwarding behaviour.2 Thus, the problem of network verification amounts to verifying the correctness of a specialized distributed system where each of the middleboxes operates atomically and the order of packet processing by different middleboxes is arbitrary.
Real middleboxes are generally complex software programs implemented in several hundreds of thousands of lines of code. We follow [29, 28] in assuming that we are provided with middlebox models in the form of finite-state transducers. In our experience one can naturally model the behaviour of most middleboxes this way. For every incoming packet, the transducer uses the packet header and the local state to compute the forwarding behaviour (output) and to update its state for future packets. The transducer can be non-deterministic to allow modelling of middleboxes like load-balancers whose behaviour depends not just on the state, but also on a random number source. We symbolically represent the local state of each middlebox by a fixed set of relations on finite elements, each with a fixed arity.
1 In this work we do not distinguish between routers and switches, since they obey similar forwarding models.
2 Routers may be considered a degenerate case of middleboxes, whose state is constant and hence their forwarding behaviour does not change over time.

Some Complexity Results for Stateful Network Verification

3

The Verification Problem We define network safety by means of avoiding "bad" middlebox states (e.g., states from which a middlebox forwards a packet in a way that violates a network policy). Given a set of bad middlebox states, we are interested in showing that for all packet scenarios the bad states cannot be reached. This problem is hard since the number of packets is unbounded and the states of one middlebox can affect another via transmitted packets.

1.1 What is Decidable About Middlebox Verification
In Section 2.4, we prove that for general stateful networks the verification problem is undecidable. This result relies on the observation that packet histories can be used to count, similarly to results in model checking of infinite ordered communication channels [8]. Simulating counting is immediate when the network configuration admits forwarding loops. However, such configurations are usually avoided in real networks. In order to address realistic networks, we show that the verification problem is undecidable even for networks without forwarding loops.
In order to obtain decidability, we introduce an abstract semantics of networks where the order of packet processing on each channel (connecting two middleboxes or a middlebox and a host) is arbitrary, rather than first-in, first-out (FIFO). Thus, middlebox inputs are multisets of packets which can be processed in any order. This abstraction is conservative, i.e., whenever we verify that the network does not reach a bad state, it is indeed the case. However, the verification may fail even in correct networks, resulting in false alarms. Since packets are atomically processed, we note that network designers can impose ordering even in this abstract model by sending acknowledgments for received packets, and dropping outof-order packets.
In fact, the abstraction of the packet order over channels closely corresponds to assumptions made by network engineers: since packets in modern networks can traverse multiple paths, be buffered, or be chosen for more complex analysis, network software cannot assume that packets sent from a source to a server are received by a server in order. Network protocols therefore commonly build on TCP, a protocol which uses acknowledgments and other mechanisms to ensure that servers receive packets in order. Since packet ordering is enforced by causality (by sending acknowledgments) and by software on the receiving end, rather than by the network semantics, correctness of such networks typically does not rely on the order of packet processing. Therefore we can successfully verify a majority of network applications despite our abstraction.

1.2 Complexity of Stateful Verification
In Section 5, we show that the problem of network verification when assuming a nondeterministic order of packet processing is complete for exponential space, i.e., it is decidable, and in the worst case, the decision procedure can take exponential space in terms of hosts and middleboxes. This is proved by showing that the network safety problem is equivalent to the coverability problem of Petri nets, which is known to be EXPSPACE-complete [32, 22]. This result is not surprising, and resembles previous work on message passing systems with unordered communication channels [22,36].
Since the problem is complete, it is impossible to improve this upper-bound without further assumptions. Therefore, we consider limited cases of middleboxes permitting more

4

Kalev Alpernas et al.

Fig. 1: Middlebox hierarchy with worst-case time complexity for each category.
efficient verification procedures, as shown in Figure 1. We identify four classes of middleboxes with increasing expressive power and verification complexity: (i) stateless middleboxes whose forwarding behaviour is constant over time, (ii) increasing middleboxes whose forwarding behaviour increases over time, i.e., as the history of packets is extended, the set of forwarded packets may never decrease, (iii) progressing middleboxes whose forwarding behaviour cannot regress to a previous state, i.e., the transition relation of the transducer does not include cycles besides self-cycles (or cycles of "equivalent states"), and hence the forwarding behavior stabilizes after some time, and (iv) arbitrary middleboxes without any restriction. For example, NATs, Switches and simple ACL-based firewalls are stateless; hole-punching stateful firewalls are increasing ­ as time proceeds more hosts become "trusted" and hence more packets are being forwarded rather than dropped; and learningswitches and cache-proxies are progressing and not increasing ­ information that is learnt is never unlearned, but the forwarding behaviour may decrease as a result of learning (e.g., a learning switch would forward a packet to the right port rather than broadcasting it).
For stateless and increasing middleboxes, we prove that any packet which arrives once can arrive any number of times, leading to a polynomial-time verification algorithm, using a fixed-point computation. We note that efficient near linear-time algorithms for stateless verification are known (e.g., see [19]). Our result generalizes these results to increasing networks and is in line with the recent work in [13, 23].
For progressing middleboxes, we show that verification is coNP-complete. The main insight is that if a bad state is reachable then there exists a small (polynomial) input scenario leading to a bad state. This means that tools like SAT solvers which are frequently used for verification can be used to verify large networks in many cases but it also means that we cannot hope for a general efficient solution unless P=NP.
Finally, we note that unlike the known results in stateless networks, the absence of forwarding loops does not improve the upper bound, i.e., we show that our lower bounds also hold for networks without forwarding loops.
Packet Space Assumption Previous works in stateless verification [18, 14] assume that packet headers have n-bits, simulating realistic packet headers which can be large in practice. This makes the complexity of checking safety of stateless networks PSPACE-hard. Our model avoids packet space explosion by only supporting three fields: source, destination, and packet tags. We make this simplification since our work primarily focuses on middlebox policies (rather than routing). As demonstrated in Section 4.2, middlebox policies are commonly specified in terms of the source and destination hosts of a packet and the network port (service) being accessed. For example, at the application level, firewalls may decide

Some Complexity Results for Stateful Network Verification

5

how to handle a packet according to a small set of application types (e.g., skype, ssh, etc.). Source, destination and packet tag are thus sufficient for reasoning about safety with respect to these policies. This simplification is also supported by recent works (e.g. [19]) which suggest that in practice the forwarding behaviour depends only on a small set of bits.

Lossless Channels Previous works on infinite ordered communication channels have introduced lossy channel systems [2] as an abstraction of ordered communication that recovers decidability. Lossy channel systems allow messages to be lost in transit, making the reachability problem decidable, but with a non-elementary lower bound on time complexity. In our model, packets cannot be lost. On the other hand, the order of packets arrival becomes nondeterministic. With this abstraction, we manage to obtain elementary time complexity for verification.

Initial Experience We implemented a tool which accepts symbolic representations of middleboxes and a network configuration and verifies safety. For increasing (and stateless) networks, the tool generates a Datalog program and a query which holds iff a bad state is reachable. Then, the query is evaluated using existing Datalog engines [27].
For arbitrary networks (and for progressing networks), the tool generates a petri-net and a coverability property which holds iff the network reaches a bad state. To verify the coverability property we use LOLA [34,1] -- a Petri-Net model checker.

1.3 Main Results and Outline
This work addresses the complexity of verifying the safety of stateful networks. It makes the following main contributions:
­ We introduce a formal model for stateful networks with finite-state middleboxes, inspired by communicating finite state machines [8] (Section 2). We further propose a symbolic representation of middleboxes, resulting in some cases in an exponentially more succinct description compared to an explicit representation as a finite state machine (Section 2.1). We use the formal model to show that verifying safety properties in stateful networks is undecidable, even when the network configuration does not admit forwarding loops (Section 2.4).
­ We adopt an unordered abstraction inspired by [22, 36] to define a conservative abstraction of networks in which packets can be processed out of order (Section 3). Under this abstraction, the safety problem of stateful networks becomes decidable, but EXPSPACE-complete. Interestingly, we show that for a certain class of networks (namely, increasing networks) this abstraction is in fact precise for safety (Section 4).
­ We identify four classes to which we classify networks, characterized by the forwarding behaviours of their middleboxes: stateless, increasing, progressing and arbitrary (Section 4). We characterize these classes both semantically and syntactically via restrictions on the symbolic representation of the middleboxes (Section 4.1), and demonstrate that these classes capture real-world middleboxes (Section 4.2).
­ We show that different network classes admit better complexity results than the EXPSPACE complexity of arbitrary networks: PTIME for stateless and increasing networks (Section 6.1), and coNP for progressing networks (Section 6.2). The upper bounds are made more realistic by stating them in terms of a symbolic representation of middleboxes, i.e., the middlebox code, rather than the explicit state space. We match the upper

6

Kalev Alpernas et al.

bounds with lower bounds (Section 5), which are obtained with standard middleboxes, and thus reflect the complexity of realistic networks. ­ We present initial empirical results using Petri nets and Datalog engines to verify safety of networks (Section 7). Finally, we discuss related work and conclude in Section 8.

2 A Formal Model for Stateful Networks
In this section, we present a formal model of networks with stateful middleboxes. We define a concrete network semantics, and present the safety verification problem, as well as the special case of isolation. Finally, we show that the safety verification problem is undecidable under the concrete semantics.
A network N is a finite undirected graph of hosts and middleboxes, equipped with a packet domain. Formally, N = (H  M, E, P), where H is a finite set of hosts, M is a finite set of middleboxes, E  {{u, v} | u, v  H  M} is the set of (undirected) edges and P is a set of packets.
Packets In real networks, a packet consists of a packet header and a payload. The packet header contains a source and a destination host ids and additional arbitrary stream of control bits. The payload is the content of the packet and may consist of any arbitrary sequence of bits. The cardinality of the set of packets is determined by the possible range of control bits and the possible space of payloads, and need not be finite.
In this work, P is a set of abstract packets. An abstract packet p  P consists of a header only, in the form of a triple (s, d,t), where s, d  H are the source and destination hosts (respectively) and t is a packet tag that ranges over a finite domain T . Intuitively, T stands for an abstract set of services or security policies. Therefore, P = H × H × T is a finite set.
Middlebox behaviour in our model is defined with respect to abstract packets and is oblivious of the underlying concrete packets.
Each host h  H is associated with a set of packets that it can send, denoted Ph  P.

2.1 Stateful Middleboxes
A middlebox m  M in a network N has a set of ports Pr and a forwarding transducer F. The set of ports Pr consists of all the adjacent edges of m in the network N,
The forwarding transducer of a middlebox is a tuple F = ( , , Qm, q0m, m) where: ­  = P × Pr is the input alphabet in which each letter consists of a packet and an input
port, ­  = 2P×Pr is the output alphabet in which each letter describes (possibly empty) sets of
packets sent over the different ports, ­ Qm is a possibly infinite set of states, ­ q0m  Qm is the initial state, and ­ m  Qm ×  ×  × Qm is the transition relation, which describes both the output and
the change of state in response to an input. Note that the alphabet  is finite (since abstract packets are considered). We often refer to the transition relation m as a function m : Qm ×   2 ×Qm , where m(q, (p, pr)) = {(o, q ) | (q, (p, pr), o, q )  m}. If m(q, (p, pr)) = 0/ , we say that m is undefined for the packet p arriving on port pr in state q.

Some Complexity Results for Stateful Network Verification

7

We extend m to sequences h  (P × Pr) in the natural way: m(q, ) = {(, q)} and m(q, h · (p, pr)) = {(i · o , q ) | qi  Qm. (i, qi)  m(q, h)  (o , q )  m(qi, (p, pr))}. The language of a state q  Qm is L(q) = {(h, )  (P × Pr) × (2P×Pr) | q  Qm. (, q )  m(q, h)}. The language of F, denoted L(F), is the language of q0m. We also define the set of histories leading to q  Qm as h(q) = {h  (P × Pr) |   (2P×Pr). (, q)  m(q0m, h)}.
F is deterministic if for every q  Qm and every (p, pr)   , |m(q, (p, pr))|  1. If
F is deterministic, then every history leads to at most one state and output, in which case F defines a (possibly partial) forwarding function f : (P × Pr) × (P × Pr)  2P×Pr where f(h, (p, pr)) = o for the (unique) output o  2P×Pr such that (h · (p, pr),  · o)  L(F) for some   (2P×Pr). If no such output o exists, then f is undefined. The forwarding function f
defines the (possibly empty) set of output packets (paired with output ports) that m will send
to its neighbors following a history h of packets that m received in the past and input packet p arriving on input port pr. We note that f(h, (p, pr)) = 0/ should not be confused with the case where f(h, (p, pr)) is undefined.
If F is nondeterministic, a forwarding relation fr  (P × Pr) × (P × Pr) × 2P×Pr is
defined in a similar way.
Note that every forwarding function f can be defined by an infinite-state deterministic
transducer: Qm will include a state for every possible history, with  as the initial state. The
transition relation m will map a state and an input packet to the set of output packets as defined by f, and will change the state by appending the packet to the history.

2.1.1 Finite-State Middleboxes
Arbitrary middlebox functionality, defined via infinite-state transducers, makes middleboxes Turing-complete, and hence impossible to analyze. To make the analysis tractable, we focus on abstract middleboxes, whose forwarding behaviour is defined by finite-state transducers. Nondeterminsm can then be used to overapproximate the behaviour of a concrete, possibly infinite-state, middlebox via a finite-state abstract middlebox, allowing a sound abstraction w.r.t. safety.
In the sequel, unless explicitly stated otherwise, we consider finite-state middleboxes. We identify a middlebox with its forwarding relation and the transducer that implements it, and use m to denote each of them.

2.1.2 Symbolic Representation of Middleboxes
To allow a more succinct representation, we use a symbolic representation of finite-state middleboxes, where a state of a middlebox m is described by the valuation of a finite set of relations R1, . . . , Rk defined over finite domains (e.g., hosts). The transition relation m is also described symbolically using (nondeterministic) update operations of the relations and output. The syntax for the symbolic representation is described in Figure 2.
Technically, we describe m on an input packet (src, dst, tag) arriving from port prt by a sequence of loop-free guarded commands, which we call a guarded command block. Each guarded command in the block consists of a command and a guard, which determines whether the command should be executed. Guards are Boolean expressions over relation membership predicates of the form e in R (where e = (e1, . . . , en) for an n-ary relation R) and element equalities e1 = e2. Each ei is either a constant or a variable that refers to packet fields: src, dst, tag, prt. Commands are of the form: (i) output set of tuples,

8

Kalev Alpernas et al.

mbox ::= input(src, dst,tag, prt) : gcmd [ gcmd ]

gcmd ::= grd  cmd

guarded command

cmd ::= output { exp [, exp ]}

output a packet

| abort

terminate-abnormally

| id.insert exp

add tuple to relation id

| id.remove exp

remove tuple from id

| cmd ; cmd | gcmd [ gcmd ]

sequence of commands guarded command block

exp ::= src | dst | tag | prt

variable

| constant

constant

grd ::= grd and grd

| grd or grd

| not atom

| atom

atom ::= exp = exp

equality

| exp in id

membership test

Fig. 2: A simple language for representing finite state middleboxes. exp denotes a vector of exp separated by commas.

(ii) abort, (iii) insert tuple e to relation R, (iv) remove tuple e from relation R, (v) sequential composition, and (vi) guarded command block.
The semantics of insert, remove and sequential composition is straightforward. An output command produces output. In case more than one output is executed, e.g., in the case of a sequential composition of output commands, the output of the execution is the union of all output commands. Blocks of guarded commands are executed non deterministically. That is, all the guards in the block are evaluated, and one command whose guard is evaluated to true is executed. If no guard evaluates to true then the empty set is produced as output, and no relation changes are made. The abort command is used to signify that m is not defined on the given input.
A symbolic middlebox program represents a finite-state middlebox where each state represents an interpretation (state) of all the relations, and the transition relation is defined by the main guarded command block in the natural way. Note that since all the relations in the program are over finite domains, the set of states is indeed finite.
Lemma 1 Every finite-state middlebox has a symbolic representation.
Proof Let Q = {q0, . . . , qn} be the finite set of states of m, and q0 be the initial state. We construct a symbolic middlebox program A over the constants q0, . . . , qn with a single unary relation R. Initially, R = {q0}. Each transition (q , o)  m(q, (p, pr)) of m is represented by a guarded command in the main guarded command block. The guard checks whether q  R and whether the packet is (p, pr). The command is a sequential composition of three commands: The first command removes the (only) current state q from R. The second inserts the new state q and the third outputs the tuples in o according to m. If m(q, (p, pr)) = 0/ , the abort command is used.
Remark 1 We note that the construction of a symbolic representation in Lemma 1 results in a linear blowup of the representation, whereas the construction of the explict-state middlebox represented by a symbolic representation potentially results in an exponential blowup,

Some Complexity Results for Stateful Network Verification

9

input(src, dst,tag, prt) : prt = 1  // hosts within organization trusted.insert dst ; output {(src, dst,tag, 2)} prt = 2  src in trusted 
// trusted hosts outside organization output {(src, dst,tag, 1)} // otherwise (untrusted host) output 0/

input(src, dst,tag, prt) : prt = 1  (dst, src,tag) in cache 
// previously stored response output {(this, src,tag, 1)} prt = 1  // new request output {(this, dst,tag, 2)} prt = 2  // response to a request cache.insert(src, dst,tag) ; output{(this, dst,tag, 1)}

(a) A hole-punching firewall.

(b) A Cache Proxy.

Fig. 3: Symbolic representation of middleboxes.

suggesting that the symbolic representation is at least as succinct and is potentially exponentially more succinct than the explicit state representation.
Example 1 Figure 3a contains a symbolic representation of a hole-punching Firewall which uses a unary relation trusted. It assumes that port 1 connects hosts inside a private organization to the firewall and that port 2 connects public hosts. By default, messages from public hosts are considered untrusted and are dropped. trusted is a unary relation which stores public hosts that become trusted once they receive a packet from private hosts.
Figure 3b contains a simplified, nondeterministic, version of a Proxy server (or cache server). A proxy stores copies of documents (packet payloads) that passed through it. Subsequent requests for those documents are provided by the proxy, rather than being forwarded. Technically, the middlebox has two ports, namely, a request port from which requests are received and a response port from which responses arrive. Our modelling abstracts away the packet payloads and keeps only their types. Consequently we use nondeterminism to also account for different requests with the same type. The internal relation cache stores responses for packet types.

2.2 Concrete (FIFO) Network Semantics
The concrete semantics of a network N = (H  M, E, P) is given by a transition system defined over a set of configurations. In order to define the semantics we first need to define the notion of channels which capture the transmission of packets in the network. Formally, each (undirected) edge {u, v}  E in the network induces two directed channels: (u, v) and (v, u). The channel (v, u) is an ingress channel of u, as well as an egress channel of v. It consists of the sequence of packets that were sent from v to u and were not yet received by u (and similarly for the channel (u, v)). The capacity of channels is unbounded, that is, the sequence of packets may be arbitrarily long. In the concrete semantics, the channels admit a first-in-first-out (FIFO) behavior: Whenever a middlebox forwards a packet p from a certain port it removes it from the head of the corresponding ingress channel and adds the generated packets to the tails of the corresponding egress channels (note that the mapping between channels and middlebox ports is unique).
Configurations and Runs A configuration of a network consists of the content of each channel and the state of every middlebox. Channels have an unbounded capacity, resulting in an

10

Kalev Alpernas et al.

infinite number of configurations even for finite state middleboxes. The initial configuration
of a network consists of empty channels and initial states for all middleboxes. A configu-
ration c2 is a successor of configuration c1 if it can be obtained by either: (i) some host h sending a packet p  Ph to a neighbor, thus appending the packet p to the corresponding channel; or (ii) some middlebox m processing a packet p from the head of one of its ingress channels, changing its state to q and appending output o to its egress channels where q , o are defined in accordance with m, i.e., if q is the current state of m and pr is the port associated with the ingress channel then (o, q )  m(q, (p, pr)). This model corresponds to asynchronous networks with non-deterministic event order.
A run of a network from configuration c0 is a sequence of configurations c0, c1, c2, . . . such that ci+1 is a successor configuration of ci. A run is a run from the initial configuration. The set of reachable configurations from a configuration ci is the set of all configurations that reside on a run from ci. The set of reachable configurations of a network is the set of reachable configurations from the initial configuration.

2.3 Safety Verification of Stateful Networks
In this section we define the safety verification problem in stateful networks, as well as the special case of isolation.
To describe safety properties, we augment middleboxes with a special abort state that is reached whenever m(q, (p, pr)) = 0/ , i.e., the forwarding behaviour is undefined (not to be confused with the case where (0/ , q )  m(q, (p, pr)) for some q  Qm). This lets middleboxes function as "monitors" for safety properties. If m(q, (p, pr)) = 0/ , and h  h(q), i.e., h is a history leading to q, we say that m aborts on h · (p, pr) (and every extension thereof). In the symbolic representation, this is captured by the abort command.
We define abort configurations as network configurations where at least one middlebox is in an abort state.
Safety The input to the safety problem consists of a network N. The output is True if no abort configuration is reachable in N, and False otherwise.
Isolation and Reachability An important example of a safety property is isolation. Informally, isolation is the requirement that certain packets (e.g., packets from a certain host) never reach some host. In the isolation problem, the input is a network N, a set of hosts Hi  H and a forbidden set of packets Pi  P. The output is True if there is no run of N in which a host from Hi receives a packet from Pi, and False otherwise.
The isolation problem can be formulated as a safety problem by introducing an isolation middlebox mhi for every host hi  Hi. The role of mhi is to monitor all traffic to hi, and abort if a forbidden packet p  Pi arrives. All other packets are forwarded to hi. (Figure 4 shows a symbolic representation of such a middlebox connected to hi on port 0 and to the rest of the network on port 1.) Clearly, isolation holds if and only if the resulting network is safe.
The Reachability problem is the dual of the isolation problem (i.e., the output is flipped).
Example 2 Figure 5 shows several examples of interesting middlebox topologies for verification. In all of the topologies shown we want to verify a variant of the isolation property. In Figure 5a we want to verify that A, a host, cannot send more than a fixed number of packets to B. Here r1 and r2 are rate limiters, i.e., they count the number of packets they have seen going from one host to the other, and lb is a load balancer that evenly spreads packets from

Some Complexity Results for Stateful Network Verification

11

input(src, dst,tag, prt) : prt = 0  output {(src, dst,tag, 1)} prt = 1  (src, dst,tag) in forbidden  abort prt = 1  ¬((src, dst,tag) in forbidden)  output {(src, dst,tag, 0)}

Fig. 4: Isolation checking middlebox.

r1

lb

A

r2

B

(a) Load Balancer and Rate Limiter

A

f

c

S1

B

S2

(b) Firewall and Proxy

f1

f2

pub11

pri11 pub21

pri21

(c) Multi-tenant data center

Fig. 5: Interesting network topologies for verification.

A along both paths (to minimize the load on any one path). In Figure 5b we want to ensure that host A cannot access data that originates in S1, but should be allowed to access data from S2, where f is a firewall and c is a proxy (cache) server. Finally in Figure 5c we show a multi-tenant datacenter (e.g., Amazon EC2), where many independent tenants insert rules into firewalls ( f1 and f2) and we want to ensure that the overall behaviour of these rules is correct. For example, we would like to ensure that pri1 cannot communicate with pri2, and pub2 communicates with pri1 only if pri1 initiates the connection.

2.4 Undecidability of Safety w.r.t. the FIFO Semantics
In this section, we prove undecidability of the safety problem by showing that (the specific example of) checking isolation w.r.t. the FIFO semantics is undecidable, even when the network does not have forwarding loops. Forwarding loops occur in networks when a packet reaches the same middlebox (or router) multiple times during the packet's traversal of the network. In the case of deterministic networks (e.g., stateless networks that consist solely of routers), forwarding loops result in the packet traversing the network in an infinite path, never reaching the packet's destination. In general, the existence of forwarding loops is considered a fault in the network design [15].
It is well known that an automaton with an ordered channel of messages (also known as a communicating FSM) can simulate a Turing machine [8]. This can be used to show that the isolation problem over ordered channels is undecidable in the presence of forwarding loops: a forwarding loop allows a packet to traverse the network and reach the same middlebox any number of times. Therefore, it allows one middlebox in the network to simulate a communicating FSM by having all packets rerouted to it. However, it turns out that forwarding loops are not the root cause for undecidability. In this work, we prove that the isolation problem is still undecidable even in the absence of forwarding loops.
To formally define forwarding loops, we augment every packet sent by a host with a unique packet id (e.g., the host id combined with a time stamp). Middlebox forwarding is oblivious to this augmentation: forwarding relations do not depend on the packet id, nor do they change it. We say that a network has a forwarding loop if there is a run in which a

12

Kalev Alpernas et al.

packet with the same packet id is received by the same middlebox twice (i.e., a run in which a packet that originates from a middlebox is received by the same middlebox again, possibly after modifications).
We now prove the undecidability result. For completeness of the presentation, our proof shows a reduction from the halting problem of 2-counter machines rather than from reachability of communicating FSMs. However, the same idea of avoiding forwarding loops could be applied to the reduction from commmunicating FSMs sketched above.
Theorem 1 The isolation problem under the FIFO network semantics is undecidable even for networks with finite-state middleboxes and without forwarding loops.
Proof We prove undecidability by a reduction from the (undecidable) halting problem of a two-counter machine to the reachability problem, which is the complement of the isolation problem. A two-counter machine M consists of a finite set of control states Q, an initial state q0  Q, a final state q f  Q, and a set of instructions per state (state transitions). An instruction determines the next state and manipulates the value of the counters c1, c2 (initially the value of the two counters is 0). An instruction is in one of the two following forms [25]:
­ q1 : ci = ci + 1 ; GOTO q2. The instruction increments ci and changes the state from q1 to q2.
­ q1 : If ci = 0 GOTO q2 Else ci := ci - 1 ; GOTO q3. The instruction changes the state to q2 if the counter value is zero; otherwise it decrements the counter and goes to state q3. We first describe a reduction that constructs a network with forwarding loops and allows
discarding of packets. We then describe how to get rid of the forwarding loops and the discard operation. Our reduction constructs a network with three middleboxes: a controller middlebox that simulates the state in Q, a c1 middlebox that helps simulate the value of the first counter, and a c2 middlebox that helps simulate the value of the second counter, as illustrared in Figure 6. The network has two hosts: initiator and target. Intuitively, the initiator host initiates the simulation of the counter machine, and the target host receives a packet if and only if the counter machine reaches the final state q f . Isolation holds if and only if the target host receives no packet. Both hosts are connected to the controller, which is also connected to c1 and c2. The set of packet tags is T = {#, 1}. Recall that this determines the set of (abstract) packets. The simulation is done by making sure that the total number of 1 packets on the ingress and egress channels of each ci corresponds the value of the simulated counter.
In our construction, the middleboxes decide on forwarding based on the packet tag only. Middlebox ci forwards all of its received packets back to the controller host. We now describe the forwarding behaviour of the controller. Initially, the initiator sends two # packets to the controller. From that point on, the initiator sends only 1 packets. As our network model does not allow to restrict the order in which hosts send packets, this scheme is enforced by the controller: if any other packet arrives, the controller goes to a sink state in which it discards all received packets. The controller forwards the first # to c1 and the second # to c2. When the controller gets a 1 packet from the initiator it simulates a single step of the counter machine, as follows. In an increment operation of ci, the controller sends a 1 packet to ci. To simulate a zero test of ci, the controller receives two packets from ci (if packets from other hosts or middleboxes are received, then the controller goes to a sink state). If the first received packet is #, then the controller forwards it back to ci. If the second one is also #, then the value of the counter is zero. If it is 1, then it is discarded (the value of ci is decremented by 1). If both packets are 1, then the first one is discarded and the second is

Some Complexity Results for Stateful Network Verification

13

Fig. 6: The network resulting from the reduction from the halting problem for Two Counter Machines.
forwarded back to ci. The simulation of the states of the counter machine is performed by the states of the controller middlebox in a straightforward manner. Finally, if the controller simulates a transition to q f , then it forwards the packet to the target host. Hence, the counter machine halts if and only if the target host is not isolated.
Construction without discard operation. To avoid packet discarding we add a dummy host, and packets that should be discarded are forwarded to the dummy host.
Construction without forwarding loops. To avoid forwarding loops, we add a repeater host to every middlebox. In the new construction, if a middlebox receives a packet with tag t and needs to forward it to port p, then it discards it, and (i) if the next packet that it receives is not from its repeater with tag t, then it goes to a sink state. (ii) otherwise, it forwards the packet it got from its repeater to port p.
3 Abstract Network Semantics
In this section we define an abstract network semantics, called the unordered semantics, which recovers decidability of the safety problem. A similar setting was explored in [22, 36] to recover decidability and obtain the same complexity results we show in Theorem 4
In the concrete (FIFO) network semantics channels are ordered. In an ordered channel, if a packet p1 precedes a packet p2 in an ingress channel of some middlebox, then the middlebox will receive packet p1 before it receives packet p2. We abstract this semantics by an unordered network semantics, where the channels are unordered, i.e., there is no restriction on the order in which a middlebox receives packets from an ingress channel. In this case, the sequence of pending packets in a channel is abstracted by a multiset of packets. Namely, the only relevant information is how many occurrences each packet has in the channel. The definitions of configurations and runs w.r.t. the unordered semantics are adapted accordingly. Note that this change does not affect the capacity of the network edges. Consequently the set of network configurations remains infinite.
Remark 2 Every run with respect to the FIFO network semantics is also a run with respect to the unordered semantics. Therefore, if safety holds with respect to the unordered semantics, then it also holds for the FIFO semantics, making the unordered semantics a sound abstraction of the FIFO semantics with respect to safety.
The abstraction can introduce false alarms, where a violation exists with respect to the unordered semantics but not with respect to the concrete semantics. This is demonstrated by Example 3 which presents a network that violates isolation with respect to the unordered semantics, but satisfies isolation with respect to the FIFO semantics. Still, in many cases,

14

Kalev Alpernas et al.

Fig. 7: A network with two hosts and two authentication middleboxes. Isolation in this network is preserced under the FIFO semantics, but is violated under the unordered semantics.
the abstraction is precise enough to enable verification. In particular, in Lemma 4 we show that for an important class of networks, the two semantics coincide with respect to safety.
Lossy channel semantics is another overapproximation of the FIFO network semantics considered in the literature, where the order on the channels is maintained, but packets can be lost. We note that the unordered semantics also over-approximates the lossy semantics with respect to safety, as any violating run with respect to the lossy semantics can be simulated by a run with respect to the unordered semantics where "lost" packets are starved until the violation occurs.
Example 3 Consider a network with two hosts (h1 and h2), each connected to an authentication middlebox (m1 and m2 respectively), as depicted in Figure 7. The authentication middleboxes are connected to each other as well. Each authentication middlebox forwards all packets from a host only if the first packet seen from that host is an authentication key (k1 and k2 for m1 and m2 respectively), otherwise it drops all packets from that host. We would like to verify isolation between h1 and h2. Namely, we would like to verify that no packet with source h1 arrives at h2 and vice versa.
A possible scenario violating isolation w.r.t the unordered semantics is: (i) h1 sends k1 and then sends k2; (ii) m1 receives k1 and then receives k2 (and forwards both packets in that order). (iii) m2 receives k2 before it receives k1 (i.e., the order on the channel between m1 and m2 was not maintained). m2 forwards k2 to h2 and isolation is violated.
On the other hand, if all channels are FIFO, then if h1 first sends k2, it and all subsequent packets from h1 will be dropped by m1. If h1 first sends k1 instead, m1 will forward it to m2, which in turn will drop it and all subsequent packets from h1. Consequently, isolation between h1 and h2 is preserved under the FIFO semantics.
Decidability of Safety w.r.t. the Unordered Semantics In the unordered semantics, the network forms a special case of monotone transition systems: We define a partial order  between network configurations such that c1  c2 if the middlebox states in c1 and c2 are the same and c2 has at least the same packets (for every packet type) in every channel. The network is monotone in the sense that for every run from c1 there is a corresponding run from any bigger c2, since more packets over a channel can only add possible scenarios. The partial order is trivially a well-quasi-order (as the number of packets cannot be negative), and the predecessor relation is clearly computable. The classical results of Abdulla et al. [3] and Finkel et al. [12] prove that in monotone transition systems a backward reachability algorithm always terminates and thus, the safety problem is decidable. Formal arguments and complexity bounds are provided by Theorem 4.

Some Complexity Results for Stateful Network Verification

15

4 Classification of Stateful Middleboxes
Encouraged by the decidability of safety w.r.t. the unordered semantics, we are now interested in investigating its complexity. As a first step, in this section, we identify three special classes of forwarding behaviours of middleboxes within the class of arbitrary middleboxes. Namely, stateless, increasing, and progressing middleboxes. We show that these classes capture the behaviours of real world middleboxes. The classes naturally extend to classes of networks: a network is stateless (respectively, increasing, progressing or arbitrary) if all of its middleboxes are. As we show in Section 5 and Section 6, each of these classes results in a different complexity of the safety problem. Our definitions apply both for finite-state and infinite-state middleboxes.

Stateless Middlebox A middlebox m is stateless if it can be implemented as a transducer with a single state (in addition to the abort state), i.e., its forwarding behaviour does not depend on its history (with the exception of abort). Formally, a middlebox m is stateless if for every two histories h1, h2  (P × Pr), packet p  P, port pr  Pr and output set o  2P×Pr, (h1, (p, pr), o)  fr iff (h2, (p, pr), o)  fr.
Increasing Middlebox A middlebox m is increasing if its forwarding relation fr is monotonically increasing w.r.t. its history, where histories are ordered by the subsequence relation3, denoted by . Formally, a middlebox m is increasing if for every two histories h1, h2  (P × Pr): if h1 h2, then for every packet p, port pr and output sets o1, o2  2P×Pr, if (h1, (p, pr), o1)  fr and (h2, (p, pr), o2)  fr then o1  o2. Intuitively, this means that new information can only expand the forwarding policy of an increasing middlebox, or lead to an abort.
Remark 3 The "increasing" property implies that the forwarding relation of an increasing middlebox is in fact a function. Hence, the middlebox can be implemented by a deterministic transducer. In the following we will refer to the forwarding function f of increasing middleboxes instead of the forwarding relation fr.
The following lemma ensures that the behaviour of an increasing middlebox can be precisely captured by a finite-state deterministic transducer. Its proof uses Higman's lemma [16] (based on well quasi ordering).
Lemma 2 Any infinite-state increasing middlebox has an implementation as a deterministic finite-state increasing middlebox.
Proof Consider an infinite-state increasing middlebox m, and its forwarding function f : (P × Pr) × (P × Pr)  2P×Pr. Recall that f might be a partial function.
Let f(h) denote an × k output matrix for the middlebox m and history h, where |P| = and |Pr| = k. We further denote P = {p1, . . . , p } and Pr = {pr1, . . . , prk}. Every entry in the output matrix f(h) contains the output set for the corresponding pair of packet and port, or if it is undefined. Formally f(h)i, j = f(h, (pi, pr j)) or f(h)i, j = when f is undefined for the input.
As P and Pr are finite, we get that there is a finite number of different output matrices. We denote them by A1, . . . , An. With every output matrix Ai we associate the set of matching
3 A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.

16

Kalev Alpernas et al.

histories h(Ai) = {h | f(h) = Ai}. Note that h(A1)  . . .  h(An) = (P × Pr) and that h(Ai)  h(A j) = 0/ for every i = j (since the forwarding function is deterministic). Therefore, for every history h there exists a unique i such that h  h(Ai).
In the following, we will show that for every Ai, the set h(Ai) is regular and thus we can implement the forwarding function f of m by using finite-state automata to recognize
the matrix that corresponds to the current history and then forwarding the current packet
accordingly. We show that for every output matrix A, h(A) is regular. We define a partial order 
over matrices as: A  B iff Ai, j  Bi, j for every pair of indices i, j, (where X  for every X  2P×Pr). We denote by UP(A) the upwards closure of {A} with respect to the  order on matrices. We extend the definition of h(A) to sets of matrices: for a (possibly infinite) set of matrices A we define h(A ) = AA {h | f(h) = A}. We note that since m is increasing, the set h(UP({A})) is upwards closed with respect to the subsequence relation over histories. Indeed, if h1  h(UP(A)), then f(h1)  A. For every h2 h1, f(h1)  f(h2) (as m is increasing), and thus f(h2)  A, which means that h2  h(UP(A)) as well. Hence, by Higman's lemma and the finite basis property of wqo, we get that h(UP(A)) has a finite basis (which consists of histories). We denote the basis {h1, . . . , ho}. Then h  h(UP(A)) if and only if h hi for some i = 1, . . . , o.
We further observe that for a given history hi, the (infinite) set {h | hi h} is a regular language, and as regular languages are closed under finite union, we get that the (infinite) set of histories h(UP(A)) is regular. Finally, we note that h(A) = h(UP(A)) \ {h(UP(A )) | A  A  A = A}. Since there are finitely many output matrices, closure properties of regular languages imply that h(A) is regular.
To complete the proof, we describe the transducer contruction. Let Di be a finite-state automaton that recognizes h(Ai). We construct a finite-state transducer m for m, as follows. m runs D1, . . . , Dn in parallel. They all start from their initial states, and on every new packet p that arrives from port pr, m updates the states of D1, . . . , Dn in parallel based on (p, pr). Exactly one of them, say Di, will reach an accepting state, in which case m will process the packet as defined by Ai. Correctness is ensured since for every history h, Di accepts h if and only if h  h(Ai), which by definition ensures that f(h) = Ai. In addition, the construction results in a finite-state transducer since the number of matrices is finite.

Precision of Abstract Semantics in Increasing Networks Recall that in general, safety w.r.t. the FIFO semantics and the unordered semantics do not coincide. However, the following lemmas show that for increasing networks (with either finite-state or infinite-state middleboxes) they must coincide, making the abstraction precise for such networks. Intuitively, this is because in increasing networks if a packet p reaches a middlebox m once, then unless a middlebox in the network reaches an abort state, the packet p can reach m again, thus enabling the simulation of unordered channels with ordered ones. The following lemma formalizes this claim.
Lemma 3 Let N be an increasing network. For every middlebox m, packet p and port pr, if there exists a run r of N from the initial configuration in the FIFO semantics such that in the last step m receives p from pr, then from any configuration there exists a run, in the FIFO semantics, that ends in a step in which m receives p from pr (or in abort).
Proof We prove the assertion by induction on |r| (the length of the run from the initial configuration). We fix m, p, pr, r, and an arbitrary configuration c from which we wish to show a run.

Some Complexity Results for Stateful Network Verification

17

If |r| = 1, then it must be the case that m received the packet from a neighbor host. Hence, c has a run in which the same neighbor host sends the same packet to m, and after all the previous packets in the ingress channel of m are processed, the packet p arrives from port pr.
If |r| > 1, then we consider two distinct cases. In the first case, the packet was sent to m by a neighbor host, and by the same arguments as before the assertion holds. In the second case, the packet was sent to m by a neighbor middlebox m . Let h = (p1, pr1), . . . , (pn, prn) be the history of packets received by m before it sent the packet, and let (p , pr ) be the packet that triggered the forwarding of p from m to m. Since these packets were received by m before the last step of r it must be the case that there exist n + 1 runs r1, . . . , rn, r such that run ri ends when m receives packet (pi, pri), and run r ends when m receives (p , pr ). Each of the runs r1, . . . , rn, r has a length of at most |r| - 1, since they are subsequences of the prefix of r that excludes the packet (p, pr) sent from m to m.
Hence, by the induction hypothesis there is a run over N that begins in c and ends in some configuration c1 after m received the packet (p1, pr1). Similarly, for every i = 1, . . . , n there is a run that begins in ci and ends in some configuration ci+1 after m received the packet (pi, pri). Finally, there is a run from cn+1 to a configuration c that ends after m received (p , pr ). Consider the history h of m that is formed in the run c ; c1 ; . . . cn+1 ; c . Regardless of the history of m in c (which is the prefix of h ), we get that h is a subsequence of h (as (pi+1, pri+1) is added after (pi, pri)). Hence, after m receives (p , pr ), it must forward p to m (due to the fact that fm (h, (p , pr ))  fm (h , (p , pr ))). Hence, after m processes all the packets in its ingress channel, it will receive (p, pr) (or will get to an abort state).
In Lemma 4, we use the property shown in Lemma 3 to prove that any reachable configuration in an unordered network, is also a reachable configuration of a FIFO network. Given an unordered violating run, we use the construction described in the proof of Lemma 3 to build a FIFO run that ends in the packet that caused the violation in the unordered run, or in a FIFO violating run in case the construction from Lemma 3 resulted in an abort state.
Lemma 4 Let N be an increasing network. Then the output of the safety problem in N w.r.t. the FIFO semantics and the unordered semantics is identical.
Proof Recall that any (violating) run w.r.t. the FIFO semantics is also a viable (violating) run w.r.t. the unordered semantics. Therefore, in order to prove the assertion of the lemma, it suffices to prove that for every violating run w.r.t. the unordered semantics there is a violating run w.r.t. the FIFO semantics.
We prove that for every unordered run r and every middlebox m there exists an ordered run r s.t. r|m r |m where r|m is the history of middlebox m in run r.
The proof is by induction on the length of the unordered run r. The base case, where |r| = 0, is clear as the history is necessarily empty.
For |r| > 0, the induction hypothesis guarantees that for the prefix of r of length |r - 1|, denoted r-1, there exists an ordered run r-1 s.t. r-1|m r-1|m. If m is not the recipient of the last packet, then we consider r = r-1. The resulting history for middlebox m is r |m = r-1|m, and because r|m = r-1|m in this case, we have that r|m r |m.
If m is the recipient of the last packet, we consider two distinct cases. In the first case, the final packet (p, pr) in r was sent by a neighbor host. Since hosts can send packets in any configuration, we append the last event of r to r-1, resulting in the ordered run r . The resulting history for middlebox m is r |m = r-1|m · (p, pr), and because r|m = r-1|m · (p, pr), we have that r|m r |m.

18

Kalev Alpernas et al.

In the second case, the final packet (p, pr) in r was sent by a neighbor middlebox m .
We consider the history of middlebox m for r-1 -- the prefix of r of length |r - 1|, denoted h = r-1|m = (p0, pr0), · · · , (pl, prl) . By the induction hypothesis, there exists an ordered run r-1 s.t. r-1|m r-1|m , and by Lemma 3 we get that for every packet (pi, pri) in h from any configuration there exists an ordered run that ends in middlebox m receiving (pi, pri), or there exists a run that leads to a safety violation (in which case we have reached the goal
of this construction and are done).
We proceed by constructing the run r . We first construct the run r~ = r-1 · r1 · · · rl where r-1 is the ordered run guaranteed by the induction hypothesis s.t. r-1|m r-1|m, and ri is the ordered run ending in the middlebox m receiving the packet (pi, pri), starting from the configuration at the end of the previous run. The construction ensures that r-1|m r~|m (since r-1|m r-1|m). In addition, because r-1|m = (p0, pr0), · · · , (pl, prl) r~|m and m is increasing, m can send the packet (p, pr) to m after r~. We obtain r by appending to
r~ the final event of r, where m sends the packet (p, pr) to m. Since r |m = r~|m · (p, pr), r|m = r-1|m · (p, pr) and r-1|m r~|m, we get that r|m r |m.
In particular, we can construct an ordered run in which m has an aborting history.

Progressing Middlebox In order to define progressing middleboxes, we define an equivalence relation between middlebox states based on their forwarding behaviour. States q1, q2 are equivalent, denoted q1  q2, if L(q1) = L(q2). A middlebox m is progressing if it can be implemented by a transducer in which whenever the state is changed into a non-equivalent state, it will never return to an equivalent state. Formally, if (o , q )  m(q, (p, pr)) and q  q (where q, q are reachable states of m) then for any future sequence of packets h  (P × Pr), if ( , q )  m(q , h) for some  and q , then q  q.
As opposed to increasing middleboxes, progressing middleboxes might require infinitely many states. In this case nondeterminism is essential as it allows to support the abstraction of infinite-state middleboxes via finite-state transducers.
Example 4 (Infinite-state progressing middlebox) Consider the packet space H ×H ×{0, 1}, and a deterministic middlebox m with a single port whose forwarding function is defined as follows. As long as all received packets have tag 0, then each packet is forwarded (as is) back to the single port. When a packet with tag 1 arrives for the first time, if the number of previous packets is prime, then all future packets are discarded. Otherwise, all future packets are forwarded back to the single port. Prime numbers are not recognizable by finitestate machines. Hence, there is no finite-state implementation of m. On the other hand, m is progressing since its state always progresses (from counting to always discarding or always forwarding).
Finite-state progressing middleboxes have the following useful property:
Lemma 5 Every finite-state progressing middlebox has an implementation as a finite-state transducer whose underlying state graph has a tree structure, except for, possibly, self-loops.
Proof We show an implementation as a directed acyclic graph (DAG), possibly with self loops. The transformation to a tree is then straightforward. Let m be a minimal transducer that implements the progressing middlebox. We consider the language L(q) of each state q in m. Minimality ensures that no two states in m have the same language (otherwise they are equivalent and can be merged). Therefore, each state q represents a unique language L(q).
Towards a contradiction we assume that there is a directed loop that is not a self-loop in m. A loop implies that there are two states q1  q2 in m such that q1 transitions to q2 by

Some Complexity Results for Stateful Network Verification

19

some sequence h2 and q2 transitions back to q1 by some sequence h3. Further, by minimality of m, q1 is reachable by some sequence h1.
Since m is progressing, contradiction is obtained.
The next lemma summarizes the hierarchy of the classes (as illustrated by Figure 1).
Lemma 6 ­ Any stateless middlebox is also increasing. ­ Any increasing middlebox is also progressing.
Proof The first part of the lemma is straightforward. Consider the second part of the lemma. Let m be a deterministic transducer of an in-
creasing middlebox and f is its forwarding function. Towards a contradiction assume that m is not progressing, i.e. there exist two states q1  q2 and three histories h0, h1, h2 s.t. (0, q1)  m(q0, h0), (1, q2)  m(q0, h0 · h1) and (2, q1)  m(q0, h0 · h1 · h2).
Because q1  q2, there exists a history h s.t. f(h0 · h) = f(h0 · h1 · h), and since m is increasing it must be the case that f(h0 · h)  f(h0 · h1 · h).
However, since m is deterministic and h0 and h0 · h1 · h2 lead to the same state, namely q1, it must be that f(h0 · h) = f(h0 · h1 · h2 · h) and we get that f(h0 · h1 · h)  f(h0 · h1 · h2 · h), in contradiction to the fact that m is increasing.

4.1 Syntactic Characterization of Middlebox Classes
The classes of middleboxes defined above can be characterized via syntactic restrictions on their symbolic representation. In Section 6 we will use the syntactic characterization to obtain more realistic complexity upper bounds, stated in terms of the symbolic representation rather than the explicit state-space of middleboxes.
A middlebox representation is syntactically stateless if it does not use any insert or remove command on any relation. A middlebox representation is syntactically increasing if it does not use the remove command on any relation, does not use negated membership predicates in the guards and all guards are mutually exclusive (i.e. no two guards can be true at the same time). A middlebox representation is syntactically progressing if it does not use the remove command on any relation.
Lemma 7 Every stateless finite-state middlebox has an equivalent syntactically stateless symbolic representation and vice versa.
Proof The lemma is trivial for stateless middleboxes, as both the transducer and the symbolic representation simply describe a fixed forwarding table.
Lemma 8 Every increasing finite-state middlebox has an equivalent syntactically increasing symbolic representation and vice versa.
Proof We first show that every increasing finite-state middlebox has an equivalent syntactically increasing symbolic representation. Let m be an increasing finite-state middlebox implemented by a deterministic transducer with state set Q = {q0, . . . , qn}, where q0 is the initial state. By Lemma 6 and Lemma 5 we may assume w.l.o.g that the underlying graph of m is a tree. We construct a symbolic program A with one unary relation R over the constants q-1, q0, . . . , qn. Initially R = {q0}. To describe A we need the next three notations. To reduce the notational burden, we use packets p instead of pairs (p, pr) of a packet and an input port. For a state qi and a packet p we denote the successor state of qi according to packet p by

20

Kalev Alpernas et al.

qi p (we note that possibly qi p= qi). The successor state is unique since the transducer is deterministic. We denote by qi(p) the output of m when m is in state qi and packet p is received. We denote the (single) predecessor of qi in the tree by pre(qi) (we note that in case the state qi has a self loop, the predecessor function returns the unique predecessor of qi that is not qi. i.e., pre(qi) = q j s.t. qi = q j). For uniformity, we assume that the root q0 also has a predecessor, namely, q-1 with q-1(p) = 0/ for every packet p.
We now describe how A processes a packet p: ­ Relation update. For every qi  R: insert qi p to R. ­ Output. For every qi  R: output qi(p) \ pre(qi)(p). We first observe that A can be implemented as a syntactically increasing program. Indeed, the "for every" loops can be replaced by a sequential composition of finitely many guarded commands consisting of positive relation membership queries, and only insert update operations.
We now show that the forwarding behaviours of A and m are identical and hence A is indeed a correct symbolic representation of m. Let h be an arbitrary history and let p be an arbitrary packet. By a simple induction we get that the states in the relation R are exactly the states that m visited while processing the history h. We assume w.l.o.g that the set of visited states (after history h) is {q0, . . . , qk} and that qi = pre(qi+1). We prove, by induction on k, that the outputs of m and A are identical. In the base case k = 0, and the proof follows as we defined pre(q0)(p) = q-1 and q-1(p) = 0/ . For k > 1, we observe that since m is increasing and a prefix is also a subsequence, then qk-1(p)  qk(p). Hence, qk(p) = (qk(p) \ qk-1(p))  qk-1(p). By the induction hypothesis, we get that A first outputs qk-1(p), and by the implementation of A, we get that it then outputs qk(p) \ qk-1(p). Hence, overall A outputs qk(p), and the proof of the claim is complete.
To conclude, we proved that A is a syntactically increasing symbolic representation of m.
For the converse direction, we show that the forwarding behaviour of a middlebox given via a syntactically increasing symbolic representation is increasing. Let A be a syntactically increasing symbolic program. For simplicity we assume that A has only one relation R. The mutually exlusive guard requirement implies determinstic execution. Consequently, for a history h we can denote by Rh the unique content of relation R after h. We claim that if h1 h2, then Rh1  Rh2 . The proof follows from the fact that all the guards in A have positive conditions and from the fact that elements are only added to the relation. As the forwarding behaviour depends only on the state of the relation, and since all conditions are positive, we get that the forwarding behaviour is increasing.
Lemma 9 Every progressing finite-state middlebox has an equivalent syntactically progressing symbolic representation and vice versa.
Proof We first show that every progressing finite-state middlebox has an equivalent syntactically progressing symbolic representation. Let m be a progressing finite-state middlebox, and by Lemma 5 we may assume w.l.o.g that the underlying state graph of m is a tree. Let Q = {q0, . . . , qn} be the states of m. We construct a symbolic program A similarly to the construction in the proof of Lemma 8 (with one unary relation R over the constants q0, . . . , qn, where initially R = {q0}, and where R accumulates the traversed states). When a packet p is processed, the program identifies the current state by computing a maximal (according to topological order) state qi in R (this is implemented using a guard for every path from the tree root to each state in the state tree). It then adds qi p to R and outputs qi(p). Since m is a tree, there always exists exactly one maximal state in R, and we get that A always simulates m correctly.

Some Complexity Results for Stateful Network Verification

21

For the converse direction, we show that the forwarding behaviour of a middlebox given via a syntactically progressing symbolic representation is progressing. Let A be a syntactically progressing symbolic program. For simplicity we assume that A has only one relation R. We recall that the domain of R is always finite, and thus it has only a finite number of different states (interpretations). We construct a middlebox m whose states are exactly the states of R, and the forwarding function is exactly according to those states. As A is progressing, we get that elements are only added to R, and thus the underlying graph of m is progressing.

4.2 Examples
In this section, we introduce several middleboxes, each of which resides in one of the classes of the hierarchy presented above.
ACL Switch An ACL switch has a fixed access control list (ACL) that indicates which packets it should forward and which packets it should discard. Typically the rules in the list refer to the port number or to hosts that are allowed to use a certain service. As such, the forwarding policy of an ACL switch is based only on the source host and/or ingress port of the current packet, and does not depend on previous packets. Hence, an ACL switch can be implemented by a stateless middlebox.
Hole-Punching Firewall A hole-punching firewall is described in Example 1. As the set of trusted hosts depends on the history of the middlebox, a hole punching firewall cannot be captured by a stateless middlebox. (Formally, given two different histories, the forwarding function might produce a different output for the same packet and port.)
However, a hole punching firewall is an increasing middlebox. This follows since for every source host s and two histories h1 h2, if s is trusted according to h1, then it is also trusted according to h2. The proof of the latter is by induction on |h1|. In the base case |h1| = 0, and therefore s is in the initial list of trusted hosts (and therefore, it is trusted also in h2). If |h1| > 0, then h1 = h1 · (p, pr). We consider two distinct cases: In the first case s was trusted before the last packet p in h1 was received. Hence, by the induction hypothesis we get that s is trusted also in h2. In the second case s became trusted only after the last packet p was processed. In this case, p had a trusted source host s1 (according to h1) with destination s. Since h1 h2, there exist h2, h2 such that h2 = h2 · (p, pr) · h2 and h1 h2. By the induction hypothesis, the source host s1 of the last packet p is also trusted according to h2, and therefore s is trusted also in h2 · (p, pr). As the set of trusted hosts never decreases, s remains trusted in h2.
Learning Switch A learning switch dynamically learns the topology of the network and constructs a routing table accordingly. Initially, the routing table of the switch is empty. For every host h the switch remembers the first port from which a packet with source h has arrived. When a packet arrives, if the port of the destination host is known, then the packet is forwarded to that port; otherwise, the packet is forwarded to all connected ports excluding the input-port.
A learning switch is a progressing middlebox. Intuitively, after the middlebox's forwarding function has changed to incorporate the destination port for a certain host h, it will never revert to a state in which it has to flood a packet destined to h. A learning switch is however, not an increasing middlebox, as packets destined to a host whose location is not known are

22

Kalev Alpernas et al.

input(src, dst,tag, prt) : ¬ ((dst, prt) in connected)  connected.insert(src, prt); // remember src's port (dst, 1) in connected  output {(src, dst,tag, 1)} (dst, 2) in connected  output {(src, dst,tag, 2)} (dst, 3) in connected  output {(src, dst,tag, 3)} ¬ ((dst, 1) in connected)  ¬ ((dst, 2) in connected)  ¬ ((dst, 3) in connected)  output {(src, dst,tag, oprt) | oprt in allPorts and oprt = prt} // flood

Fig. 8: A learning switch with three ports.
initially flooded, but after the location of the host is learned, a single copy of all subsequent packets is sent.
Figure 8 depicts a symbolic representation of a learning switch that uses a binary relation connected storing connections between hosts and ports. If the port of the destination host is known, then the packet is forwarded to that port; otherwise, the packet is forwarded to all connected ports excluding the input-port. The last command in the program is a syntactic shorthand used to avoid the explicit enumeration of incoming ports required to correctly perform the flood operation.
Proxy Server The Proxy server as described in Example 1 is a progressing middlebox. After it has stored a response, it nondeterministically replies with the stored response, or sends the request to the server again. Once a new request is responded by a proxy the forwarding behaviour changes as it takes into account the new response, and it never returns to the previous forwarding behaviour (as it does not "forget" the response). This example demonstrates how nondeterminism is used to model middleboxes whose concrete behaviour depends on packet payloads. In a concrete network model that does not abstract away the packet payload, the proxy middlebox would always reply to a request with a stored response and never forward it to the server.
Round-Robin Load Balancer A load balancer is a device that distributes network traffic across a number of servers. In its simplest implementation, a round-robin load balancer with n out-ports (each connected to a server) forwards the i-th packet it receives to outport i (mod n). Round-robin load balancers are not progressing middleboxes, as the same forwarding behaviour repeats after every cycle of n packets.
Figure 9 depicts a symbolic representation of a round-robin load balancer with 3 ports: port 0 is an `input' port, and ports 1 and 2 are `output' ports on which the load balancer splits the incoming traffic. It uses a unary relation nextport to hold the port to which the next packet is to be sent.
Remark 4 In practice, middlebox behaviour can also be affected by timeouts and session termination. For example, in a firewall, a trusted host may become untrusted when a session terminates (which makes the firewall behaviour no longer increasing). Similarly, cached content of a cache server expires after a certain period of time (which violates progress). In this work, we do not model timeouts and session termination.

Some Complexity Results for Stateful Network Verification

23

input(src, dst,tag, prt) : (prt = 0  (1) in nextport)  output {(src, dst,tag, 1)} (prt = 0  (1) in nextport)  nextport.remove 1 (prt = 0  (1) in nextport)  nextport.insert 2 (prt = 0  (2) in nextport)  output {(src, dst,tag, 2)} (prt = 0  (2) in nextport)  nextport.remove 2 (prt = 0  (2) in nextport)  nextport.insert 1 (prt = 1  prt = 2)  output {(src, dst,tag, 0)}

Fig. 9: A 3-port round-robin load-balancer.
5 Lower Bounds on Complexity of Safety w.r.t. the Unordered Semantics
When considering the unordered network semantics, the safety problem becomes decidable for networks with finite-state middleboxes. In this section, we analyze its complexity lower bounds. The complexity bounds are w.r.t the input size, namely, (i) the number of hosts; (ii) number of middleboxes; and (iii) the encoding size of the middleboxes functionality, i.e., the size of the explicit state machine (if the encoding is explicit) or the number of characters in the symbolic representation (if the encoding is symbolic).
In Section 6 we present matching upper bounds for networks represented symbolically. Since symbolic representations are at least as succinct as explicit-state descriptions of finitestate middleboxes, all the lower bounds obtained for the explicit finite-state model apply for the symbolic one as well, and all the upper bounds obtained for the symbolic model are applicable to the explicit finite-state model, resulting in tight complexity bounds, both for explicit finite-state middleboxes and for symbolic ones.
We obtain lower bounds for the safety verification problem by considering the isolation problem. Recall that the isolation problem reduces to a safety problem by the introduction of isolation middlebox. Since isolation middleboxes are stateless, they do not change the class of the input network. We can therefore deduce that the same lower bounds also hold for the more general safety problem.

5.1 Unordered Safety in Progressing Networks is coNP-hard.
Lemma 10 The isolation problem w.r.t. the unordered network semantics for a progressing network is coNP-hard.
Proof We show a reduction from the (NP-hard) Hamiltonian Path problem to the reachability problem, which is the complement of the isolation problem. Recall that the Hamiltonian Path problem is given a directed graph G(V, E), a source vertex s  V and a target vertex t  V , and it determines whether there is a simple path from s to t in G with length |V |.
In the reduction, we use flood-once middleboxes that upon receiving a packet with a numeric tag (from a finite domain) increment the packet tag and flood the new packet. All following packets that arrive at the middlebox are discarded. These flood-once middleboxes are finite-state progressing middleboxes.
We construct a network with a single flood-once middlebox for every vertex in the graph and connect them in accordance with the edges in the graph. In addition, we create two hosts hs and ht and connect them to the middleboxes representing the source and target in the

24

Kalev Alpernas et al.

graph. We use packet tags {0, . . . , |V |}. Host hs sends packets with tag 0. The reachability problem is to determine whether ht can receive a packet with tag |V |.
The flood once middleboxes ensure that the packet tags `count' the length of the path. Thus, a Hamiltonian Path corresponds to a packet with the tag |V | arriving at the destination host ht , and the correctness of the reduction follows.
The following lemma shows that a similar result can be obtained using more "standard" middleboxes, namely, stateless middleboxes and learning switches.
Lemma 11 The isolation problem w.r.t. the unordered network semantics for a network where each middlebox is either stateless or a learning switch is coNP-hard.
Proof The proof is by reduction from the (NP-hard) Hamiltonian Path problem to the reachability problem. We use the same notation as used in the proof of Lemma 10. W.l.o.g we assume that the out-degree of all vertices of the directed graph G is two. For the reduction, we construct a network with three hosts, namely, hs, ht and hd, and 4|V | middleboxes, as described below. The topology of the resulting network is illustrated in Figure 11. The set of packet tags is {0, . . . , |V |}. As before, the reachability problem is to determine whether host ht can receive a packet with tag |V |.
We now describe the network in more detail. With every vertex v we associate three stateless middleboxes, namely, vA, vB and vC, and a learning switch vLS, illustrated in Figure 10. Intuitively, these middleboxes will simulate a "flood once" middlebox. The middlebox vA is connected to vB, vC and vLS. The middlebox vLS is connected to vB and vC as well as to vA, and if (v, u1)  E and (v, u2)  E, then vB has a link to (u1)A and vC is connected to (u2)A. Host hs is connected to (vs)A and is allowed to send only the packet (hs, ht , 0) (source hs, destination ht , and tag 0). Host ht is connected to (vt )B and (vt )C. Host hd is a dummy host, disconnected from any middlebox. Its purpose is merely to allow three distinct host ids. The forwarding function of the learning switch is as described in Section 4.2. The forwarding function of the stateless middleboxes is defined as follows:
­ packets received by vA from some uB or uC: if the packet is (hs, ht , n), namely, source is hs, destination is ht and packet tag is n, then forward it to vLS.
­ packets received by vA from vLS: if the packet is (hd, hs, n), then forward packet (ht , hd, n) to vLS.
­ packets received by vB, vC from vLS: if the packet is (hs, ht , n) forward packet (hd, hs, n) to vLS. If the packet is (ht , hd, n) forward packet (hs, ht , n + 1) to the appropriate uA. Otherwise, discard.
All other packets are discarded. We first give an informal description of how a packet is processed and then turn to
formally prove the correctness of the reduction. When vA receives a (hs, ht , n) packet from some uB or uC it sends it to the learning switch. When vLS first receives the packet it forwards it to all of its neighbors except for vA (from which it was received) and marks the port connected to vA as the destination port to hs. vB and vC reply with (hd, hs, n), and when the first of these packets arrives to vLS, then it marks either vB or vC as the destination of hd. In addition, as the port connected to vA is marked as the destination to hs, the learning switch sends the packets (hd, hs, n) to vA. vA responds with (ht , hd, n). When vLS receives the packet it marks the port connected to vA as the destination for ht and forwards the packet to vB or vC (depending on which was marked as the destination for hd). vB or vC increments the tag and forwards the packet to a neighbor uA. All additional packets of the form (hs, ht , n ) that will arrive to vA after vB or vC has already incremented the tag will be forwarded by vLS back to vA (as it was marked as the destination port to ht ), and in vA they will be discarded.

Some Complexity Results for Stateful Network Verification

25

Fig. 10: The network `gadget' associated with vertex v in the reduction from the Hamiltonian Path problem to network reachaility. The vertex v has an incoming edge from ui and an outgoing edge to vertex u j in the input graph G.

Fig. 11: The network resulting from the reduction from the Hamiltonian Path problem to network reachability.
We now give a formal proof. We claim two assertions: (i) For every v  V , at most one of the middleboxes vB and vC forwards a packet to an adjacent node (other than vLS). (ii) Both vB and vC will never forward the same packet twice. The proof of item (i) is due to the fact that every packet passes through the learning switch and the learning switch will mark only one of vB or vC as the destination of hd. The proof of item (ii) is due to the fact that if a packet p is generated as a result of vB (vC) sending a packet to an adjacent middlebox, then at this stage vA is already marked by the learning switch as the destination of ht . Therefore, when the packet p reaches vA, it will be forwarded from the learning switch back to vA and will be discarded. Hence, it can never reach vB (vC) again. By the two assertions we get that reachability holds if and only if a packet visited |V | different middleboxes (v1)X1 , . . . , (v|V|)X|V| for Xi  {B,C}, and each such middlebox was visited exactly once. Hence, reachability holds iff a Hamiltonian path exists.
5.2 Unordered Safety in arbitrary networks is EXPSPACE-hard.
The result in this section is similar to previous work on message passing systems with unordered communication channels [22,36], and is included here for completeness of presentation.
The lower bound is obtained by a reduction from the VASS control state reachability problem. We first present the problem and its known complexity results. A vector addition

26

Kalev Alpernas et al.

system with states (VASS) is a weighted directed graph (V, E, v0, w : E  Zk), where V is a finite set of vertices (Control States), E  V × V is a set of directed edges, v0 is the initial vertex, and w is a weight function that assigns a k-dimensional weight vector to every edge. A (finite) path  in the directed graph is valid if it begins in v0 and every prefix of  has a non-negative sum of weights in every dimension.
The VASS control state reachability problem gets as input a VASS and a reachability set R  V , and checks whether there exists a valid path in the VASS to (at least) one vertex in R.
Lemma 12 ([10,22,32]) The VASS control state reachability problem is EXPSPACEcomplete. Moreover, it is EXPSPACE-hard even when the coefficients of every vector in the image of the weight function are bounded by ±1, and even when every vector has at most one non-zero dimension.
To simplify our proofs we define the class of simple VASSs as all VASSs that satisfy: ­ Every weight vector has exactly one non-zero coefficient which is either +1 or -1. ­ All the outgoing edges of every vertex v have different weight vectors. Formally, for
every v1, v2, v3  V , if (v1, v2), (v1, v3)  E and w(v1, v2) = w(v1, v3), then v2 = v3. The next claim is a simple corollary of Lemma 12.
Corollary 1 The control state reachability problem over simple VASS systems is EXPSPACE-hard.
Next, we show a reduction from control state reachability over simple VASS systems to stateful network reachability.
The reduction is straightforward: given a VASS system (V, E, v0, w : E  Zk) and a reachability set R  V we construct a network with two hosts, namely h1 and h2 and one middlebox m (see Figure 12). The network reachability problem is to determine whether a packet with source host h1 can reach h2. The set of packet tags is T = {1, . . . , k} (where k is the number of dimensions in the VASS system). We denote by pt = (h1, h2,t), and PT = {pt | t  T } the packets host h1 sends. We associate each packet pt with a vector t  Nk that consists of 1 in dimension t and the rest of the dimensions are zero. The set of states of m is V (with initial state v0) with the addition of one sink state. When in sink state, the middlebox discards all incoming packets and remains in sink state. We now describe the transitions of the middlebox m from state v  V :
­ Upon receipt of a packet pt from port 1: ­ If v  R, then forward the packet to port 3 (reachability is obtained). ­ If there exists u  V such that (v, u)  E (of the VASS) and w(v, u) = t, then: · Forward pt to port 2 · Change state to u ­ Else (such u does not exists), discard packet and go to sink state.
­ Upon receipt of a packet pt from port 2: ­ If v  R, then forward the packet to port 3 (reachability is obtained). ­ If there exists u  V such that (v, u)  E (of the VASS) and w(v, u) = -t, then: · Discard the packet · Change state to u
­ Upon receipt of a packet from port 3, go to sink state. ­ Upon receipt of a packet p  PT from any port, go to sink state.
In order to prove the correctness of the reduction we give the next definitions and notations. A VASS configuration is a tuple (v, c)  V × Nk which consists of a vertex and a

Some Complexity Results for Stateful Network Verification

27

port 2

port 1

m port 3

h1

h2

Fig. 12: The network resulting in the reduction from the VASS control state reachability problem.

vector. A configuration is reachable in n steps if there exists a valid path in the VASS with length exactly n and total sum of weights c. We denote by SVASS(n) the (finite) set of all configurations that are reachable in n steps.
A VASS-network configuration is a tuple (v, c)  V × Nk, where v is the state of the middlebox m and c corresponds to the multiplicity of the packets of PT in the multiset of packets in port 2. That is, if the multiplicity of packet pt in the multiset is r, then dimension t of c is r. We say that a VASS-network configuration is reachable in n steps if there exists a scenario that consists of exactly n middlebox packet processing events that forms the configuration. We denote by SNetwork(n) the (finite) set of all VASS-network configurations that are reachable in n steps.
Lemma 13 For every n  0: SVASS(n) = SNetwork(n) - ({sink} × Nk).
Proof The proof is by induction over n. The proof for n = 0 is trivial. For n > 0, let (v, c) be an arbitrary VASS configuration in SVASS(n-1). We claim that every successor configuration of (v, c) is also in SNetwork(n). The proof is straightforward. If the successor is reachable by an addition of positive vector r, then a corresponding successor in the network is obtained when h1 sends a packet of type r and m processes the packet. If the successor is reachable by an addition of negative vector r, then by the induction hypothesis there exists a pending packet in port 2 with type r, and a successor in the network is obtained when m processes one packet from port 2 with type r. Hence, we get that SVASS(n)  SNetwork(n) - ({sink} × Nk). The proof that SNetwork(n) - ({sink} × Nk)  SVASS(n) follows from similar arguments.
The next lemma follows immediately from Lemma 13 and Corollary 1.
Lemma 14 The reachability problem w.r.t. the unordered network semantics for an arbitrary network is EXPSPACE-hard.

6 Upper Bounds on Complexity of Safety w.r.t. the Unordered Semantics
This section provides complexity upper bounds for the safety problem of stateful networks w.r.t. the unordered semantics of networks. Our complexity analysis considers symbolic representations of middleboxes (which might be exponentially more succinct than explicitstate representations). The obtained upper bounds match the lower bounds from Section 5 (hence, the bounds are tight).
Remark 5 The complexity upper bounds we present are under the assumption that all relations used to define middlebox states may have at most polynomial number of elements

28
StateData := {m  InitialRelationValues(m) | m  M} PacketData := {m  NeighborHostPackets(m) | m  M} while fixed-point not reached
foreach m  M, (p, pr)  PacketData(m) let q = StateData(m) if m(q, (p, pr)) = 0/ then return violation // abort state reached let (q , o)  m(q, (p, pr)) StateData := AddData(m, q ) PacketData := AddPacketsToNeighbors(m, o)
return safe

Kalev Alpernas et al.

Fig. 13: Safety checking of increasing networks.

(polynomial in the size of the network and the size of the middlebox representation). To enforce this limitation we assume that the arity of relations is constant. If the arity of the relation is bounded by a constant c, then the number of elements is bounded by the polynomial nc, where n is the size of the network.
In all of our examples we use relations with arity at most three, and since abstract packets have only three attributes, we believe that most applications will use relations with small arity.
The Input to the Safety Verification Problem The input to the safety verification problem is given in the form of a network topology description, and the symbolic representations of the middleboxes in the network.
The complexity results in this section are given in terms of the number of hosts in the network |H|, the size of the type domain |T |, the total number of ports in the network |Pr|, the number of middleboxes in the network |M|, and the total size of the symbolic representation |S| =  |Si| where |Si| is the size of the symbolic representation of middlebox mi.
In our complexity analysis we sometime refer to the set of packets in the networks. Recall that the set of packets in the networks is P = H × H × T , and so the size of P is |P| = |H|2|T |. Finally, in our complexity analysis we also refer to  |Ri| which denotes the total size of the domains of relations of middleboxes in the network where Ri is the domain of relation Ri. Note that |Ri| is polynomial in the in the size of |H|, |Pr| and |T |, as the arity of Ri is fixed and the domains of its dimensions are taken from H, Pr and T .

6.1 Unordered Safety of Increasing Networks is in PTIME
In this section, we show that safety of syntactically increasing networks is in PTIME. Figure 13 presents a polynomial algorithm for determining safety of a syntactically in-
creasing network. The algorithm performs a fixed-point computation of the set of all tuples present in middlebox relations in reachable middlebox states, as well as the set of all different packets transmitted in the network. For every middlebox m  M, the algorithm maintains the following sets:
­ StateData(m): a set of pairs of the form (R, d) where R is a relation of m, and d is a tuple in the domain of R, indicating that there is a run in which d  R.
­ PacketData(m): a set of pairs of the form (p, pr), where p is a packet and pr is a port of m, indicating that p can reach m from port pr.

Some Complexity Results for Stateful Network Verification

29

StateData(m) is initialized to reflect the initial values of all middlebox relations. PacketData(m) is initialized to include the packets Ph that can be sent from neighbor hosts h  H. As long as a fixed-point is not reached, the algorithm iterates over all middleboxes and their packet data. For each middlebox m and (p, pr)  PacketData(m), m is run over (p, pr) from a state q in which every relation R contains all the tuples d such that (R, d)  StateData(m). The sets StateData(m) and PacketData(m ) for every neighbor m of m, are updated to reflect the discovery of more elements in the relations (more reachable states), and more packets that can be transmitted.
As the algorithm only adds relation elements and packets, the number of additions is bounded by (|P||Pr| +  |Ri|). At every iteration of the while loop, at least one relation element or packet is added to StateData or PacketData respectively. The number of foreach iterations in every single while iteration is bounded by |P||Pr|. The runtime of every foreach iteration is linear in the runtime of the corresponding middlebox, which is linear in the size of its symbolic representation. This is because the computation of m(q, (p, pr)) consists of executing the middlebox program, and since the symbolic representation does not have loops, the runtime is linear. Hence, the runtime of a single iteration of the foreach loop can be bounded by |S|.
The total running time of the algorithm is then bounded by (|P||Pr| +  |Ri|)|P||Pr||S|, and hence polynomial.
The correctness of the algorithm relies on the next lemma, which is a variation of Lemma 3.
Lemma 15 For every increasing network, if there is a run in the unordered semantics in which packet p arrives to port pr of middlebox m, then any run r in the unordered semantics has an extension in which packet p arrives to m from port pr. Moreover, if there is a run in which element d is in a relation R, then any run has an extension in which element d is in the relation R.
We now use Lemma 15 to prove that in every iteration the data structure of the algorithm under-approximates PacketData and StateData.
Lemma 16 For every iteration of the algorithm there is a run r, such that if (p, pr)  PacketData(m), then in r there is a step in which p arrived to m from port pr, and if (R, d)  StateData(m), then in r there is a step in which d was added to R.
Proof The proof is by induction on the number of iterations performed by the algorithm. The proof for the base case (zero iterations performed) is trivial -- the initial state of the PacketData and StateData matches the initial state of the network.
For the n-th iteration, let (p, pr)  PacketData(m). We consider two distinct cases. In the first case, after the n - 1-th iteration, (p, pr)  PacketData(m). Then by the induction hypothesis, there exists a run r such that in r there is a step in which p arrived to m from port pr. In the second case, (p, pr) was added to PacketData in the n-th iteration. In this case, after iteration n - 1 there must have existed a middlebox m adjacent to m, a state q in which {(R1, d1), · · · , (Rk, dl)}  StateData(m ), and (p , pr ), such that as a result of running m over (p , pr ) from state q, (p, pr) was sent to m. By the induction hypothesis, there exist runs r1,1, · · · , rk,l in which (R1, d1), · · · , (Rk, dl) (respectively) are added to StateData(m ), as well as a run r0 in which p arrives to m from pr . Then by Lemma 15 we can constructs a run r in which m is in state q and p has arrived to m from pr . The configuration c, which is obtained by m processing p , is a successor of the last configuration of r . We denote the resulting run by r, and note that in the last step of r, p arrived to m from port pr.

30

Kalev Alpernas et al.

The proof for (R, d)  StateData(m) follows from similar arguments. Finally we use Lemma 15 to construct a witness run for the n-th iteration.
The next lemma shows that when fixed-point occurs the data structure over-approximate PacketData and StateData.
Lemma 17 When the algorithm reaches a fixed-point, if (p, pr) / PacketData(m) (respectively., (R, d) / StateData), then there is no run in which m receives p from port pr (resp., d is added to R).
Proof Let r be the witness run that the fixed-point under-approximates (r exists by Lemma 16). Towards a contradiction we assume that there is a run r in which m receives p from port pr (respectively, d was added to R), but such an event did not occur in r. By Lemma 15, we get that r has an extension in which the event does happen. But such an extension contradicts the fact that a fixed-point occurred. Hence, the data structure overapproximates all runs.
Lemma 16 and Lemma 17 imply that the algorithm determines the safety problem, and the next theorem follows.
Theorem 2 The safety problem of syntactically increasing networks w.r.t. the unordered semantics is in PTIME.
Proof Safety is violated iff there exists a run r that ends in a configuration c where some middlebox is in state q with packet p pending on its port pr such that m(q, (p, pr)) = 0/ .
By lemmas 16 and 17, the latter holds iff at some iteration of the algorithm (p, pr)  PacketData(m), and the values pf m's relations in state q are included in StateData(m), in which case the algorithm identifies the safety violation.
Remark 6 Recall that for increasing networks, safety w.r.t. the unordered semantics and the FIFO semantics coincide. As such, the polynomial upper bound applies to both.
Remark 7 The complexity analysis of the algorithm used the property that |P| is polynomial in the network representation. If n-tag packet headers are allowed, i.e. P = H × H × T1 . . . × Tn, then |P| is no longer polynomial in the network representation, damaging the complexity analysis of the algorithm. In fact, in this case the safety problem w.r.t. the unordered semantics becomes PSPACE-hard even for stateless middleboxes.
Intuitively, n-tag packet headers allow a middlebox to maintain the state of n automata in the packet header, supporting a reduction from the emptiness problem of the intersection of n automata, which is PSPACE-hard [20].
Proof The PSPACE-hardness proof is by reduction from the problem of deciding the emptiness of intersection of n automata [20], which is formally defined as:
­ Input: n automata A1, . . . , An over alphabet {0, 1} with state set Q (w.l.o.g. all automata have the same set of states).
­ Question: is there a word w  {0, 1} that is accepted by all n automata? The reduction is as follows. Given n automata with state set Q we define a network with one host and one middlebox. The packets consist of n + 1-tuples of tags from the domain T = Q  {0, 1}. Intuitively, the first n tags hold the states of the n automata, and the last tag is an input symbol for the automata. The middlebox has two ports. Port 0 is connected to the host and port 1 is a self loop.
The symbolic representation of the middlebox has four parts:

Some Complexity Results for Stateful Network Verification

31

1. Initial state verifier. The first part handles packets from port 0. If the packet's first n tags do not correspond to the n initial states, then the middlebox discards the packet. Otherwise it sends the packet to port 1.
2. Advance state. The second part handles packets from port 1. In a sequence of n|Q| commands, the program advances the state of each automaton (i.e., changes the corresponding packet tag) according to the symbol in tag n + 1. After the sequence, the program continues to the third part.
3. Accepting state verifier. If the packet's tag corresponds to n accepting states, then the program aborts. Otherwise the program continues to the fourth part.
4. New symbol generator. In the fourth part the program generates two packets that differ only in their n + 1 tag. In one packet the tag has value 0 and in the second it has value 1. Both packets are sent back to port 1. It is an easy observation that the intersection of the n automata is non-empty iff abort is
invoked.

6.2 Unordered Safety of Progressing Networks is in coNP
We prove coNP-membership of the safety problem in syntactically progressing networks by proving that there exists a witness run for safety violation if and only if there exists a "short" witness run, where a witness run for safety violation is a run from the initial configuration in which at least one middlebox reaches an abort state.
The proof considers the network states that arise in a run. A network state captures the states of all middleboxes (not to be confused with a network configuration, which also includes the content of every channel). Formally, let N be a network whose middleboxes are defined symbolically via (in total) n relations, namely R1, . . . , Rn. Then the network state consists of the values of (R1, . . . , Rn).
In order to construct a "short" witness run, we wish to bound both the number of different network states in a run and the number of steps in which a run stays in the same state. The former is bounded due to the progress of the network: once the state of some middlebox changes along a run, it will not change back to the previous state. The latter is more tricky. To provide a bound, we wish to analyze the packets that "affect" the run. We define the notion of active packets. The active packets are a superset of the packets that actually affect the run.
Active packets Let r be a finite run of a network. We say that a packet p is active in step i of r, if it resides in the ingress channel of some middlebox m and it is processed (i.e., received by m) in some future step of r. A packet is inactive, if it is pending in the ingress channel of m until the end of the run.
The next lemmas show that only a few active packets are needed to reach a certain state in the network. Intuitively, the proof of the lemma traverses the run from the last configuration to the first, and removes inactive packets (and steps that produce only inactive packets), which in turn makes other, earlier, packets inactive. For a run r and a network state s that appears in r, we denote by r[s] an interval of the run that includes all consecutive occurrences of s (for runs of progressing networks, the interval is unique).
Lemma 18 Let r be a run in which the network state changes exactly k times, and the different states are s1, s2, . . . , sk (in this order). Then for every prefix rsi of r that ends in a state si, there is an extension esi to rsi such that: (i) esi visits the network states si, . . . , sk;

32

Kalev Alpernas et al.

(ii) esi has at most k - i active packets in every step; and (iii) the number of active packets in esi may decrease only after a change in the network state.
Proof The proof is by induction over |r| - |rsi |. For the base case r = rsi and the proof is trivial. For |r| > |rsi |, we extend the prefix rsi by one step according to r. We denote this extended prefix by r . Let p be the last packet that was processed in r , and let m be the middlebox that processes p. That is, m and p are responsible for the step that extends rsi to r.
We consider two distinct cases. In the first case, the network state in the last configuration of r is still si. Then by the induction hypothesis we get that there is an extension esi with at most k - i active packets in interval esi [si]. We consider the set of packets that were created by m after processing p. If this set has at least one active packet in esi , then we define esi to be esi prepended by the last step of r , where p is marked as active and all the active packets of esi remain active. Surely, there are no more than k - i active packets in the first step of esi since at least one of the active packets in esi resulted from p and hence did not yet exist in this step, so it balances out the addition of p as an active packet. In addition, the total
number of active packets is not decreased in this step (thus, the claim holds). Otherwise, we define esi to be esi , i.e. we skip the processing of p, and turn it to inactive.
In the second case, the last state in r is si+1. Then by the induction hypothesis we get that there is an extension esi+1 with at most k - i - 1 active packets. In this case we construct esi simply by prepending to esi the last step of r . That is, p is marked as active and all the active packets of esi+1 remain active. There are only k - i - 1 + 1 = k - i active packets. Hence, the claim holds. This completes the proof.
Lemma 19 Let r be a run in which the network state changes exactly k times, and the different states are s1, s2, . . . , sk (in this order). Then there exists a run r such that: (i) r visits the network states s1, s2, . . . , sk; and (ii) r stays in state si at most (k - i)2|P||M| steps.
Proof For the sake of the proof we give a unique id to every active packet according to the
following rules: ­ If a host sends an active packet, then the packet gets some unique id (for example,
maximal id assigned so far + 1). ­ If an active packet p1 was processed by a middlebox, and the middlebox forwards only
one active packet p2, then p2 gets the id of p1. ­ If an active packet p1 was processed by a middlebox, and the middlebox forwards more
than one active packet, then each active packet gets a unique id (for example, maximal
id assigned so far + 1). We now return to the proof. Let e be the shortest extension for the prefix of r that consists of the initial configuration that satisfies the assertions of Lemma 18. The extension e clearly visits s1, . . . , sk. We claim that it stays in state si at most (k - i)2|P||M| steps. The proof of the claim follows from the fact that if there are two steps j1 < j2 in e [si] such that in both steps a middlebox m received an active packet p with id id, and no new active packet (i.e.,
an active packet with a new packet id) was generated between those rounds, then a run in which m does not process packet p with id id is shorter by one step, and reaches the same configuration in step j2 - 1. Hence, if a certain middlebox processed more than |P|(k - i) packets, then it must be the case that either a new active packet was created, or it processed
the same packet twice. The proof is complete by the pigeonhole principle and by the fact that there are at most k - i active packets and |M| middleboxes.
The next lemma shows that there is a short witness for reachability of a state in pro-
gressing networks.

Some Complexity Results for Stateful Network Verification

33

Lemma 20 Let N be a syntactically progressing network whose middleboxes are defined symbolically via relations R1, . . . , Rn (in total). Then there is a run ending in an abort state if and only if there is such a run whose length is at most (ni=1 |Ri|)3|P||M|.
Proof The proof is an immediate corollary of Lemma 19. If there is a run r that leads to a certain state of R1, . . . , Rn, then since all middleboxes are progressing we get that the number of intermediate network states k is at most (ni=1 |Ri|). We denote the intermediate states by s1, . . . , sk. By Lemma 19, there is also a run r that visits the same k states and stays in state si at most (k - i)2|P||M|  k2|P||M| steps. Therefore |r |  k3|P||M|.
Since the size of each relation is polynomial in the size of the network, we conclude:
Theorem 3 The safety problem w.r.t. the unordered semantics for progressing networks is coNP-complete.
Proof The lower bound follows from Lemma 10. The upper bound is obtained by first observing that the complement of the safety problem is polynomially reducible to the reachability of a state in the network (by adding a special abort state). In addition, the state reachability problem is in NP: since the arity of each relation in the considered middlebox programs is fixed, its size is polynomial in the size of the network. Hence, by Lemma 20, there is a witness run for reachability whose length is polynomial. Thus, the NP procedure is to guess the short run and verify it, in time linear in the length of the run multiplied by |S| (the size of the symbolic representation of the middleboxes which also bounds the time it takes to compute their transitions).

6.3 Unordered Safety of Arbitrary Networks is in EXPSPACE
In this section we show how to solve the reachability problem of symbolic networks by a reduction to the coverability problem of Petri Nets, which is EXPSPACE-complete [22, 32].
Similarly to the lower bound result (Section 5.2), the upper bound result on the complexity of safety of arbitrary networks is similar to previous work ([22, 36]), and is included here for completeness of presentation.
A Petri Net is a four-tuple C = (P, T , I , O) where P is a set of places, T is a set of transitions, I : T  N|P| is an input function and O : T  N|P| is an output function. A marking µ  N|P| denotes the number of tokens assigned to each place. Given a marking, a transition t  T can be fired (equivalently enabled) if I (t)  µ. Firing a transition t  T from marking µ produces a new marking µ = µ - I (t) + O(t) [30]. We denote a firing of a transition by µ t µ . In the following, we will refer to non-zero dimensions in I (t) as consumed tokens, and non-zero dimensions in O(t) as produced tokens. A finite run in a Petri Net from a marking µ0 is a series of transitions and resulting markings µ0 t0 µ1 t1 · · · tk µk s.t. t0 can be fired from µ0 and each following transition can be fired from the previous marking.
The coverability problem asks, given a Petri Net C , an initial marking µ0 and a target marking µ, whether there is a finite run leading to a marking µ s.t. µ  µ.
We now show how we encode a symbolic network as a Petri Net, and how we formulate the reachability problem as a Petri Net coverability problem. We first describe the role of every place and the initial marking, and then we describe the set of transitions used to simulate a run of the network.

34

Kalev Alpernas et al.

Places The places are partitioned to sets of places in the following way: ­ Channel places. To keep track of the packets over the unbounded channels, we assign a place to every pair of packet p  P and channel. The number of tokens in the place corresponds to the number of instances of packet p on the channel. The initial marking for each packet place is 0. ­ Active and non-active relation places. For every element d in every relation R in every middlebox we have two places. The active place will have the marking 1 when the element is in the relation. When the element is not in the relation the non-active place will the marking 1. The initial marking for the active (respectively, non-active) place is 1 if initially the element is in the relation (resp., not in the relation). Otherwise, the initial marking is 0. The markings for both places will only be 0 or 1. We need two places since the Petri Net semantics does not allow to encode negative (i.e., non-membership) conditions. ­ Global command place. We have a single place that is used to make sure that at most one middlebox is processing a packet in every step. The initial marking for the place is 1; it is consumed whenever a packet processing starts, and produced when it ends. ­ Command places. We have a place for every triple of command, processed packet and input port in every middlebox in the network. The markings on the places are used to keep track of the next command to be executed. In particular, each guarded command block has a single place (for every combination of packet and input port) rather than a place for each guarded command in the block. This ensures that only one of the guarded commands in the block whose guards evaluate to true is executed. Having a separate command place for every packet processed and every input port allows us to evaluate variables that appear in the command (including the guards). The initial marking for the topmost guarded command block in each middlebox (with every combination of packet and input port) is 1. The initial marking for the rest is 0. ­ Auxiliary guard places. To allow conjunction and disjunction in the guard we add auxiliary guard places. The initial marking for each of these places is 0. ­ Abort place. To keep track of the safety state of the network, we assign a single place for all abort calls made during the network run. The initial marking for the place is 0.

Transitions For each middlebox in the network we define a "command transition" for each combination of processed command, input packet, input port, and next command, as explained below. For some commands only a single "next" command exists, however, since we allow non-determinism, some commands (specifically, guarded command blocks with overlapping guards) have multiple "next" commands, in which case a separate transition is defined for each one of them.
For a guarded command block we define a set of "command transitions". This allows us to handle complex guards (i.e. guards which contain conjunction and disjunction in addition to atomic propositions). To do so, we recursively decompose each guard while producing a sequence of transitions that simulates the evaluation of the boolean formula in the guard.
To correctly simulate cases in which no guard in a guarded command block is evaluated to true, and as a result no command is processed, we add a default guarded command to each guarded command block. The guard of the default guarded command is a conjunction of the negations of the guards of the other guarded commands in the block. The command of the default guarded command is output 0/ .
Each of the command transitions of the first command in the middlebox (i.e. the topmost guarded command block) consumes a token from the global command place, and each terminating command that can be executed in the middlebox run produces a token in the

Some Complexity Results for Stateful Network Verification

35

global command place. Note that the addition of default guarded commands as described above means that the terminating commands are well defined (i.e. for every command in the middlebox, if it is terminating in some run then it is a terminating command in every run that it is executed in). Each of the command transitions of the first command in the middlebox also consumes a token from the corresponding channel place. Furthermore, every command transition consumes its command place, and produces the command place of the following command, specifically the place corresponding to the combination of the next command to be executed and the same input packet and input port as the packet and port processed in the current command (or the first command in case it is a terminating command).
In addition to the above, the command transition associated with a command, input packet, input port and next command consumes and produces tokens in the places relevant to the corresponding command, as well as the guards (in the case of a guarded command block), as described below.
Since we have a command transition for every combination of command, input packet and input port, when we translate the command to a transition we consider the values of the variables (src, dst, type and port) at that transition based on the packet and port currently processed by the middlebox, and simplify the command (and guards) accordingly. For example, for the command trusted.insert dst, packet (h0, h1,t0) and port pr0, the command simplifies to trusted.insert h1. In particular, atomic equality predicates are now essentially equalities between constants, and are trivially simplified.
The transition for each guarded command in a guarded command block consumes a token from the command place for the guarded command block, and produces a token in the command place of the first command in the guarded command, as well as consuming and producing the tokens of the guard as described below.
We begin by describing the tokens consumed and produced by the atomic propositions of the guards (after simplification). Note that since guards do not change the state of the network, all tokens consumed by the guard must also be produced by the guard.
­ Relation membership (d  R). Consume (and produce) tokens in the active place for element d in relation R.
­ Negated relation membership (d / R). Consume (and produce) tokens in the inactive place for element d in relation R. Next, we describe how disjunction and conjunction are handled: In the case of a guarded
command whose guard's formula  contains a disjunction or conjunction, we produce a series of transitions by recursively decomposing the formula, and producing a set of transitions for every decomposition step. Each decomposition step introduces new auxiliary guard places. We denote by ci = c j an intermediate step in the decomposition process where ci is the place that initiates the evaluation of  and c j is the place of the next step in the execution. Specifically, initially, ci is the command place for the guarded command and c j is the command place of the command. The recursive decomposition of guard ci = c j is as follows:
­ Conjunction ( = 1  2). We introduce five auxiliary places, denoted c1, c2, c3, c4 and c5, two intermediate steps, and four new transitions. The first transition consumes one token from ci and produces two tokens in c1. The second and third transitions consume one token each from c1 and produce a token in c2 and c3 respectively. We produce two intermediate steps: c2 =1 c4 and c3 =2 c5. Finally, we produce a final transition that consumes one token from both c4 and c5, and produces a token in c j.
­ Disjunction ( = 1  2). We introduce four auxiliary places, denoted c1, c2, c3 and c4, two intermediate steps, and four new transitions. The first transition consumes a token from ci and produces a token in c1. Likewise, the second transition consumes a token

36

Kalev Alpernas et al.

from ci and produces a token in c2. We produce two intermediate steps: c1 =1 c3 and c2 =2 c4. The third transition consumes a token from c3 and produces a token in c j. Likewise, the fourth transition consumes a token from c4 and produces a token in c j.
The process is performed recursively on ci =1 c j and ci =2 c j. The process terminates for ci = c j once  is an atomic proposition, in which case a single transition is produced, which consumes a token from ci, consumes and produces the tokens for the atomic proposition as described above, and produces a token in c j.
Finally, we describe the dimensions consumed and produced by the commands output, insert, remove and abort.
­ output. Produce: the appropriate packets in the egress channel. We note that in the special case of output 0/ no tokens are produced.
­ insert. We replace every insert command with a guarded command block consisting of two guarded commands. The first guarded command represents the case where the element is already in the relation, in which case the guard will be a relation membership predicate, and the command will be output 0/ . The second guarded command represents the case where the element is not in the relation. The guard of the command will be a negated relation membership predicate to the guard, and the transition produced from the command will consume and produce the following: Consume: a token from the appropriate non-active place of the new element. Produce: a token in the appropriate active place of the new element.
­ remove. Analogous to insert. ­ abort. Produce: a token in the abort place.
This concludes the description of the command transitions.
Finally, for every host h and every packet p  Ph we have a "host transition" that produces a token in the corresponding ingress channel place of the neighbor middlebox.

From Network Safety to Petri Net Coverability Non-safety of the network amounts to a run in the Petri Net where an abort place gets a token. The target marking for the coverability problem is therefore a vector of 0s, with 1 in the abort place.
As the reduction is polynomial, we get that the stateful network reachability problem is in EXPSPACE.
The reduction, combined with the lower bound implies:
Theorem 4 The safety problem of arbitrary stateful networks w.r.t. the unordered semantics is EXPSPACE-complete.

7 Implementation and Case Studies
In this section, we present several examples of networks consisting of stateful middleboxes and their safety properties. We describe a prototype implementation of a tool for verification of stateful networks, and describe our initial experience while running the tool on the networks listed in Example 2 and illustrated in Figure 5. For the experiments we used a machine equipped with a quad core Intel Core i7-4790 CPU and 32GB of memory, running Ubuntu Linux 14.04.

Some Complexity Results for Stateful Network Verification

37

7.1 Network Examples
Load Balancer and IDS As an example consider the network shown in Figure 5a. Here A is a host, lb is a load balancer, which can send a packet received from A to either r1 or r2. Both r1 and r2 are rate limiters, i.e., they count and limit the number of packets sent between host pairs. Let us consider a case where the administrator wants to ensure that exactly 8 packets sent by A can be received by B. If the load balancer in this case sends packets from A to both r1 and r2, then this rate limit does not hold.
Firewall and Proxy Consider the network in Figure 5b. Here, c is a content addressable cache, which on receiving a packet checks if it has previously seen either server S1 or S2 respond to a packet of the same type; if so it sends back the previously observed response, otherwise it forwards the request to the packets original destination. f is a learning firewall. We want to ensure that A cannot receive data from S1, while B should be able to receive data from both S1 and S2. This is complicated by the fact that c's response is based on the packet type: in the current configuration if B sends a request for type t to server S1 then A can access the response by subsequently sending a request with the same type t addressed to server S2. In general this problem is not solvable without changing the cache to be policy aware.

Multi-Tenant Datacenter Consider a multi-tenant datacenter such as Amazon EC2 shown in
Figure 5c. In such datacenters each tenant (customer who purchase VMs from the provider)
gets to add rules about their VMs, to the firewall to which their VMs are connected. For example in Figure 5c, each tenant i owns VMs pubi1 and prii1, and programs the rules for firewall fi. Given a set of rules for firewall f1 and f2 we verify that VMs of the same tenant can communicate with each other and that pri VMs of one tenant can send packets to pub
VMs of the other.

7.2 results
Increasing Middleboxes Increasing networks are verified using LogicBlox, a Datalog based database system [5]. The Multi-Tenant Datacenter example is an increasing network. Our tool produced a datalog program with 35 predicates, 153 rules and 29 facts. LogicBlox successfully reached a fixed point in 3s, and proved all required properties.
Arbitrary Middleboxes Progressing and Arbitrary networks are verified using LOLA, a Petri-Net model checker [34,1]. In the Load Balancer and Rate Limiter example our tool created a P/T net with 243 places and 663 transitions; it was successfully verified in 30ms. In the Firewall and Proxy example our tool produced a P/T net with 530 places and 4447 transitions. LOLA successfully verified the resulting petri-net in 0.2s.

8 Conclusion and Related Work
In this work, we investigated the complexity of reasoning about stateful networks. We developed three algorithms and several lower bounds. In the future we hope to develop practical verification methods utilizing the results in this work. Below we survey some of the most closely related work and conclude with open questions and future work.

38

Kalev Alpernas et al.

8.1 Related Work
Topology-Independent Verification The earliest use of formal verification in networking focused on proving correctness and checking security properties for protocols [11, 33]. Recent works such FlowLog [26] and VeriCon [6] also aim to verify the correctness of a given middlebox implementation w.r.t any possible network topology and configuration, e.g., flow table entries only contain forwarding rules from trusted hosts.
Immutable Topology-Dependent Verification Recent efforts in network verification [24, 9, 18,19,39,37,4,14] have focused on verifying network properties by analyzing forwarding tables. Some of these tools including HSA [17], Libra [42] and VeriFlow [19]. These tools perform near real-time verification of simple properties, but they cannot handle dynamic (mutable) datapaths.
Mutable Topology-Dependent Verification SymNet [40] has suggested the need to extend these mechanisms to handle mutable datapath elements. In their mechanism the mutable middlebox states are encoded in the packet header. This technique is only applicable when state is not shared across a flow (i.e., the middlebox can punch holes, but do no more), and will not work for cache servers or learning switches.
The work in [29] is the most similar to our model. Their work considers Python-like syntax enriched with uninterpreted functions that model complicated functionality. However [29] do not define formal network semantic (e.g., FIFO vs ordered channels) and do not give any formal claim on the complexity of the solution.
Channel Systems Channel systems, also called Finite State Communicating Machines, are systems of finite state automata that communicate via asynchronous unbounded FIFO channels [7,8]. They are a natural model for asynchronous communication protocolsand, indeed, they form the semantic basis of protocol specification languages such as SDL and Estelle. Unbounded FIFO channels can simulate unbounded Turing machine tape and therefore all verification problems are undecidable. Abdulla and Jonsson [2] introduced lossy channel systems where messages can be lost in transit. In their model the reachability problem is decidable but has a non-primitive lower bound [35].
In this work we use unordered (non-lossy) channels as a different relaxation for channel systems. The unordered semantics over-approximates the lossy semantics w.r.t. safety, as any violating run w.r.t. the lossy semantics can be simulated by a run w.r.t. the unordered semantics where "lost" packets are starved until the violation occurs.
The unordered semantics admits verification procedures with elementary complexity, and turns out to be sufficiently precise for many network protocols in which order is not guaranteed and hence not relied on.

8.2 Future Work
Exploration of Network Semantics In this work we have outlined two possible network semantics, namely FIFO and Unordered packet processing order. Various other network semantics could be considered, along with their effect on expressibility and complexity results, and the precision loss in safety analysis. One such network semantics is the Sticky Channel semantics, where packets can be added by the sending middlebox and read by the receiving middlebox but cannot be removed. This network semantics corresponds to networks in which middleboxes can arbitrarily retransmit messages.

Some Complexity Results for Stateful Network Verification

39

Modelling Packet Payload In this work we have only considered packet headers. However, some middlebox behaviour depends on the content of the packet payload (Intrusion Detection Systems are one such example). A potential approach to bridging this gap could be to model middleboxes using register automata. This would allow us to reason about letters from an infinite alphabet, thus modelling the arbitrary nature of packet payloads, while potentially retaining the decidability of reasoning about such systems.

Liveness In this work we have limited ourselves to reasoning about safety properties. However, various liveness and performance properties are just as important when approaching the creation of networks. Reasoning about liveness properties such as guarantees on packet arrival, or performance properties such as load estimates or packet traversal times would require the development of a new model for describing the network semantics and middlebox behaviour. In particular, unordered semantics are ill suited for most sorts of reasoning on liveness properties.

Further Aspects of Network Security In addition to safety properties that can be expressed by checker middleboxes and liveness properties there are various other network security properties that can be considered when reasoning about networks. Non-interference and information leakage are two examples of security properties which cannot be modeled by our current approach.

Reasoning About Progressing Networks Under the FIFO Semantics We've seen that in arbitrary networks reasoning is undecidable under the FIFO semantics but EXPSPACEcomplete under the unordered semantics, and that for increasing networks the two semantics coincide. This leaves the question of reasoning about progressing network under the FIFO semantics open.

Acknowledgements This publication is part of projects that have received funding from the European Research Council (ERC) under the European Union's Seventh Framework Program (FP7/2007­2013) / ERC grant agreement no. [321174-VSSC], and Horizon 2020 research and innovation programme (grant agreement No [759102-SVIS]). The research was supported in part by Len Blavatnik and the Blavatnik Family foundation, the Blavatnik Interdisciplinary Cyber Research Center, Tel Aviv University, and the Pazy Foundation. This material is based upon work supported by the United States-Israel Binational Science Foundation (BSF) grants No. 2016260 and 2012259. This research was also supported in part by NSF grants 1704941 and 1420064, and funding provided by Intel Corporation.

References
1. Lola 2.0 sources. http://download.gna.org/service-tech/lola/lola-2.0.tar.gz 2. Abdulla, P., Jonsson, B.: Verifying programs with unreliable channels. In: Logic in Computer Science
(LICS), pp. 160­170. IEEE (1993) 3. Abdulla, P.A., C era¯ns, K., Jonsson, B., Tsay, Y.K.: General decidability theorems for infinite-state sys-
tems. In: Logic in Computer Science (LICS), pp. 313­321. IEEE (1996) 4. Anderson, C.J., Foster, N., Guha, A., Jeannin, J.B., Kozen, D., Schlesinger, C., Walker, D.: NetKAT:
Semantic foundations for networks. In: POPL (2014) 5. Aref, M., ten Cate, B., Green, T.J., Kimelfeld, B., Olteanu, D., Pasalic, E., Veldhuizen, T.L., Washburn,
G.: Design and implementation of the logicblox system. In: ACM SIGMOD International Conference on Management of Data, pp. 1371­1382 (2015) 6. Ball, T., Bjørner, N., Gember, A., Itzhaky, S., Karbyshev, A., Sagiv, M., Schapira, M., Valadarsky, A.: Vericon: towards verifying controller programs in software-defined networks. In: ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI, p. 31 (2014)

40

Kalev Alpernas et al.

7. Bochmann, G.V.: Finite state description of communication protocols. Computer Networks (1976) 2(4), 361­372 (1978)
8. Brand, D., Zafiropulo, P.: On communicating finite-state machines. Journal of the ACM (JACM) 30(2), 323­342 (1983)
9. Canini, M., Venzano, D., Peres, P., Kostic, D., Rexford, J.: A nice way to test openflow applications. In: 9th USENIX Symposium on Networked Systems Design and Implementation (NSDI'12) (2012)
10. Cardoza, E., Lipton, R., Meyer, A.R.: Exponential space complete problems for petri nets and commutative semigroups (preliminary report). In: Proceedings of the eighth annual ACM symposium on Theory of computing, pp. 50­54. ACM (1976)
11. Clarke, E.M., Jha, S., Marrero, W.R.: Using state space exploration and a natural deduction style message derivation engine to verify security protocols. In: Programming Concepts and Methods, IFIP TC2/WG2.2,2.3 International Conference on Programming Concepts and Methods (PROCOMET '98) 8-12 June 1998, Shelter Island, New York, USA, pp. 87­106 (1998)
12. Finkel, A., Schnoebelen, P.: Well-structured transition systems everywhere! Theoretical Computer Science 256(1), 63­92 (2001)
13. Fogel, A., Fung, S., Pedrosa, L., Walraed-Sullivan, M., Govindan, R., Mahajan, R., Millstein, T.D.: A general approach to network configuration analysis. In: 12th USENIX Symposium on Networked Systems Design and Implementation, NSDI 15, Oakland, CA, USA, May 4-6, 2015, pp. 469­483 (2015)
14. Foster, N., Kozen, D., Milano, M., Silva, A., Thompson, L.: A coalgebraic decision procedure for netkat. In: Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015, pp. 343­355 (2015)
15. Hengartner, U., Moon, S., Mortier, R., Diot, C.: Detection and analysis of routing loops in packet traces. In: Proceedings of the 2nd ACM SIGCOMM Workshop on Internet measurment, pp. 107­112. ACM (2002)
16. Higman, G.: Ordering by divisibility in abstract algebras. Proceedings of the London Mathematical Society pp. 326­336 (1952)
17. Kazemian, P., Chang, M., Zeng, H., Varghese, G., McKeown, N., Whyte, S.: Real time network policy checking using header space analysis. In: 10th USENIX Symposium on Networked Systems Design and Implementation (NSDI '13) (2013)
18. Kazemian, P., Varghese, G., McKeown, N.: Header space analysis: Static checking for networks. In: 9th USENIX Symposium on Networked Systems Design and Implementation (NSDI '12) (2012)
19. Khurshid, A., Zhou, W., Caesar, M., Godfrey, B.: Veriflow: verifying network-wide invariants in real time. Computer Communication Review 42(4), 467­472 (2012)
20. Kozen, D.: Lower bounds for natural proof systems. In: 18th Annual Symposium on Foundations of Computer Science, pp. 254­266. IEEE (1977)
21. Kuzniar, M., Peresini, P., Canini, M., Venzano, D., Kostic, D.: A soft way for openflow switch interoperability testing. In: CoNEXT, pp. 265­276 (2012)
22. Lipton, R.: The reachability problem requires exponential space. Department of Computer Science. Yale University 62 (1976)
23. Lopes, N.P., Bjørner, N., Godefroid, P., Jayaraman, K., Varghese, G.: Checking beliefs in dynamic networks. In: 12th USENIX Symposium on Networked Systems Design and Implementation, NSDI 15, Oakland, CA, USA, May 4-6, 2015, pp. 499­512 (2015)
24. Mai, H., Khurshid, A., Agarwal, R., Caesar, M., Godfrey, B., King, S.T.: Debugging the Data Plane with Anteater. In: SIGCOMM (2011)
25. Minsky, M.L.: Recursive unsolvability of post's problem of "tag" and other topics in theory of turing machines. Annals of Mathematics pp. 437­455 (1961)
26. Nelson, T., Ferguson, A.D., Scheer, M.J.G., Krishnamurthi, S.: Tierless programming and reasoning for software-defined networks. In: Proceedings of the 11th USENIX Symposium on Networked Systems Design and Implementation, NSDI 2014, Seattle, WA, USA, April 2-4, 2014, pp. 519­531 (2014)
27. OpenStack: LogicBlox. http://www.logicblox.com/ retrieved 07/07/2015 28. Panda, A., Argyraki, K.J., Sagiv, M., Schapira, M., Shenker, S.: New directions for network verifica-
tion. In: 1st Summit on Advances in Programming Languages, SNAPL 2015, May 3-6, 2015, Asilomar, California, USA, pp. 209­220 (2015) 29. Panda, A., Lahav, O., Argyraki, K., Sagiv, M., Shenker, S.: Verifying isolation properties in the presence of middleboxes. arXiv preprint arXiv:1409.7687 (2014) 30. Peterson, J.L.: Petri nets. ACM Computing Surveys (CSUR) 9(3), 223­252 (1977) 31. Potharaju, R., Jain, N.: Demystifying the dark side of the middle: a field study of middlebox failures in datacenters. In: Proceedings of the 2013 Internet Measurement Conference, IMC 2013, Barcelona, Spain, October 23-25, 2013, pp. 9­22 (2013) 32. Rackoff, C.: The covering and boundedness problems for vector addition systems. Theoretical Computer Science 6(2), 223­231 (1978)

Some Complexity Results for Stateful Network Verification

41

33. Ritchey, R.W., Ammann, P.: Using model checking to analyze network vulnerabilities. In: Security and Privacy (2000)
34. Schmidt, K.: Lola a low level analyser. In: Application and Theory of Petri Nets 2000, pp. 465­474. Springer (2000)
35. Schnoebelen, P.: Verifying lossy channel systems has nonprimitive recursive complexity. Information Processing Letters 83(5), 251­261 (2002)
36. Sen, K., Viswanathan, M.: Model checking multithreaded programs with asynchronous atomic methods. In: International Conference on Computer Aided Verification, pp. 300­314. Springer (2006)
37. Sethi, D., Narayana, S., Malik, S.: Abstractions for model checking sdn controllers. In: FMCAD (2013) 38. Sherry, J., Hasan, S., Scott, C., Krishnamurthy, A., Ratnasamy, S., Sekar, V.: Making middleboxes some-
one else's problem: Network processing as a cloud service. In: SIGCOMM (2012) 39. Skowyra, R., Lapets, A., Bestavros, A., Kfoury, A.: A verification platform for sdn-enabled applications.
In: HiCoNS (2013) 40. Stoenescu, R., Popovici, M., Negreanu, L., Raiciu, C.: Symnet: static checking for stateful networks. In:
Proceedings of the 2013 workshop on Hot topics in middleboxes and network function virtualization, pp. 31­36. ACM (2013) 41. Velner, Y., Alpernas, K., Panda, A., Rabinovich, A., Sagiv, M., Shenker, S., Shoham, S.: Some complexity results for stateful network verification. In: International Conference on Tools and Algorithms for the Construction and Analysis of Systems, pp. 811­830. Springer (2016) 42. Zeng, H., Zhang, S., Ye, F., Jeyakumar, V., Ju, M., Liu, J., McKeown, N., Vahdat, A.: Libra: Divide and conquer to verify forwarding tables in huge networks. In: NSDI (2014)

