arXiv:2106.00232v1 [cs.DS] 1 Jun 2021

Multimodal Transportation with Ridesharing of Personal Vehicles
Qian-Ping Gu1, Jiajian Leo Liang1 1School of Computing Science, Simon Fraser University, Canada
qgu@sfu.ca, leo liang@sfu.ca
Abstract: The current public transportation system is unable to keep up with the growing passenger demand as the population grows in urban areas. The slow or lack of improvements for public transportation pushes people to use private transportation modes, such as carpooling and ridesharing. However, the occupancy rate of personal vehicles has been dropping in many cities. In this paper, we propose a centralized transit system that integrates public transit and ridesharing, which is capable of matching drivers and public transit riders such that the riders would result in shorter travel time. The optimization goal of the system is to assign as many riders to drivers as possible for ridesharing. We describe an exact approach and approximation algorithms to achieve the optimization goal. We conduct an extensive computational study to show the effectiveness of the transit system for different approximation algorithms. Our experiments are based on the real-world traffic data in Chicago City; the data sets include both public transit and ridesharing trip information. The experiment results show that our system is able to assign more than 60% of riders to drivers, leading to a substantial increase in occupancy rate of personal vehicles and reducing riders' travel time. Keywords: Multimodal transportation, ridesharing, approximation algorithms, computational study
1 Introduction
As the population grows in urban areas, commuting between and within large cities is time and resource demanding. Due to the growing passenger demand, the number of vehicles on the road for both public and private transportation has increased to handle the demand. The public transportation system is unable to keep up with the demand in terms of service quality. This pushes many people to use personal vehicles for work commute. In the United States, personal vehicles are the main transportation mode [6]. However, the occupancy rate of personal vehicles in the United States is 1.6 persons per vehicle in 2011 [12, 21] (and decreased to 1.5 persons per vehicle in 2017 [6]), which can be a major cause for congestion and pollution. Many people in populated cities opt for shared mobility for its convenience; this kind of ridesharing/ridehailing service is called mobility-on-demand (MoD) and offered by companies such as Uber, Lyft and DiDi. Although MoD service may improve convenience, the problem of traffic congestion is not resolved. This is the reason municipal governments
1

encourage the use of public transit; the major drawback of public transit is the inconvenience of last mile/leg (or first mile) transportation compared to personal vehicles [25]. With the increasing popularity in ridesharing/ridehailing service, there may be potential in integrating private and public transportation. From the research report [9], it is recommended that public transit agencies should build on mobility innovations to allow public-private engagement in ridesharing because the use of shared modes increases the likelihood of using public transit. As pointed out by Ma et al. [17], some basic form of collaboration between MoD services and public transit already exists (for first and last mile transportation). There is an increasing interest of collaboration by private companies and public sector entities [19].
Integrating public and private transportation can be an effective way to solve traffic congestion for work commute. We investigate the potential effectiveness of integrating public transit with ridesharing of personal vehicles to reduce traffic congestion for work commute. For example, people who drive their vehicles to work can pick-up riders (who use public transit regularly) and drop-off them at some transit stops, and those riders can take public transit to their destinations. In this way, riders are presented with a cheaper alternative than ridesharing for the entire trip, and it is more convenient than using public transit only. The transit system also gets a higher ridership, which matches the recommendation of [9] for a more sustainable transportation system. Our research focuses on a centralized system that is capable of matching drivers and riders satisfying their trips' requirements while achieving some optimization goal; the requirements of a trip may include an origin and a destination locations, time constraints, capacity of a vehicle, and so on (formal definition in Section 2). When a rider is assigned a driver, we call this ridesharing route, and it is compared with the fastest public transit route for this rider which uses only public transit. If the ridesharing route is faster than the public transit route, the ridesharing route is provided to both the rider and driver. To increase the number of rider participants, our system-wide optimization goal is to maximize the number of riders, each of whom is assigned a ridesharing route. We call this the maximization problem.
In the literature, there are many papers about standalone ridesharing/carpooling, from theoretical to empirical studies (e.g., [1, 4, 13, 26]). For literature reviews on ridesharing, readers are referred to [2, 10, 18, 24]. On the other hand, there are only a few papers study the integration of public transit with dynamic ridesharing. Aissat and Varone [3] proposed an approach in which a public transit route for each rider is given, and their algorithm tries to substitute part(s) of every rider's route with ridesharing. Any part of a rider's original transit route is replaced only if ridesharing substitution is better than the original part. Their algorithm finds the best route for each rider in first-come first-serve basis (system-wide optimization goal is not considered) and is computational intensive. Huang et al. [14] presented a more robust approach, compared to [3], by combining two networks N, N
2

(representing the public transit and ridesharing network respectively) into one single routable graph G. The graph G uses the time-expanded model to maintain the information about all public vehicles schedule, riders' and drivers' origins, destinations and time constraints. In general, a stop node in G represents a public vehicle's/driver's stop location, and a time node represents time events of this vehicle/driver at this stop. An edge between two nodes implies possible transfer for riders from one vehicle to the other (i.e., the departure time of a vehicle is after the arrival of the other); this also implies a rider can be pick-up/dropped-off from/at a public stop within time constraints. The authors apply this idea to create the ridesharing network graph N and connect the two networks N, N by creating edges between them whenever a rider can be pick-up/dropped-off from/at a public stop within time constraints. For each rider travel query, a shortest path is found on G. Their approach is also first-come first-serve basis and does not achieve system-wide optimization goal.
Ma [16] and Stiglic et al. [23] proposed models to integrate ridesharing and public transit as graph matching problems to achieve system-wide optimization goals. Algorithm presented in [16] uses the shareability graph (RV-graph) [20] and the extension of RV-graph, called RTVgraph [4]. In fact, the approach used by Stiglic et al. [23] is similar, except [23] supports more rideshare match types. A set of driver and rider trip announcements and a public transit network with a fixed cyclic timetable are given. For a pre-transit rideshare match, a set of riders is assigned to a driver, and the driver pick-ups each rider by traveling to each rider's origin, then drop-of them at some public transit stops. For a post-transit rideshare match, a driver picks-up a set of riders at a public transit stop and then transport each rider one by one to their destinations. A set of riders can only be assigned to a driver if certain constraints are met, such as capacity of the driver's vehicle and the travel time constraints of the driver and riders. Each of the driver and rider is represented by a node. There is an edge between a driver and a rider if the rider can be served by the driver. If a group of riders can be served by a driver, a node containing the group is created, and an edge between the driver and the group is also created. From this graph, a matching problem is formulated as an integer linear program (ILP) and solved by standard branch and bound (CPLEX). The optimization goal in [16] is to minimize cost related to waiting time and travel time, but ridesharing routes are not guarantee to be better than transit route. Although the optimization goal in [23] aligns with ours, there are some limitations in their approach; they limit at most two passengers for each rideshare match and use the closest transit stop to the destination as the drop-off stop, and more importantly, ridesharing routes assigned to riders is more likely to be longer than public transit routes.
In this paper, we use a similar solution approach as in [16, 23]. We extend [23] to eliminate the limitations described above. We also give approximation algorithms for the optimization problem to ensure solution quality. Our discrete algorithms allow to control the trade-off
3

between solution quality and computational time. We conduct a numerical study based on real-life data in Chicago City. Our main contributions are summarized as follows:
1. We propose a centralized system that integrates public transit and ridesharing for work commute, along with an exact algorithm approach.
2. We prove our maximization problem is NP-hard and give a 2-approximation algorithm for the problem. We show that previous O(k)-approximation algorithms [5, 7] for the k-set packing problem are 2-approximation algorithms for our maximization problem. Our approximation algorithm is more time and space efficient than previous algorithms.
3. We conduct a numerical study based on real-life data to evaluate the potential of having an integrated transit system and the effectiveness of different approximation algorithms.
The rest of the paper is organized as follows. In Section 2, we give the preliminaries of the paper, describe a centralized system that integrates public transit and ridesharing, and define the maximization problem. In Section 3, we describe our solution approach and exact algorithm. We then propose approximation algorithms in Section 4. We discuss our numerical experiments and results in Section 5. Finally, Section 6 concludes the paper.
2 Problem definition and preliminaries
In the problem multimodal transportation with ridesharing (MTR), a set A = D  R of trip announcements is given, where D is the set of driver announcements, R is the set of rider announcements and D  R = . Each trip announcement is expressed by an integer label i, and a trip announcement is referred to as a trip for short. Each trip consists of an individual, a vehicle (for driver trip) and some requirements. A connected public transit network with a fixed timetable T is given. In this paper, we assume the timetable T is part of the centralized system and can be accessed quickly. Specifically, we assume that for any source o and destination d in the public transit network, T gives the fastest travel time from o to d. A ridesharing route i for a rider i  R is a travel plan using a combination of public transportation modes and ridesharing to reach i's destination satisfying the requirements of i, whereas a public transit route ^i for a rider i is a travel plan using only public transportation modes. The multimodal transportation with ridesharing problem asks to provide at least one feasible route (if possible) for every rider i  R. We denote an instance of multimodal transportation with ridesharing problem by (N, A, T ), where N is an edge-weighted directed graph (network) for both private and public transportation. We call a public transit station or stop just station. The terms rider and passenger are used interchangeably (although passenger emphasizes that a rider who has been provided with a ridesharing route).
4

The requirements of each trip i in A are specified by i's parameters submitted by the individual. In general, the parameters of a trip i contain an origin location, a destination location, an earliest departure time, a latest arrival time and a maximum trip time. A driver trip i also contains a capacity of the vehicle, a preferred path (optional) to reach the destination, a limit on the detour time/distance, and a limit on the number of stops a driver wants to make to pick-up/drop-off passengers. A rider trip i also contains an acceptance rate of a route with ridesharing, that is, a ridesharing route i is given to a rider i if the travel time of i is shorter than any public transit route ^i by acceptance rate i (between 0 and 1). For example, suppose the best public transit route ^i takes 100 minutes for rider i and i = 0.9. A ridesharing route i is given to i if t(i)  i · t(^i) = 90 minutes, where t(·) is the travel time. We consider two match types for practical reasons.
· Type 1 (rideshare-transit): a driver may make multiple stops to pick-up different passengers, but makes only one stop to drop-off all passengers. In this case, the pickup locations are the passengers' origin locations, and the drop-off location is a public station.
· Type 2 (transit-rideshare): a driver makes only one stop to pick-up passengers and may make multiple stops to drop-off all passengers. In this case, the pick-up location is a public station and the drop-off locations are the passengers' destination locations.
Riders and drivers specify one of the match types to participate in; they are allowed to choose either but not both in hope to increase the chance being selected. For the latter case, the system assigns them one of the match types such that the optimization goal is achieved.
The optimization goal is to assign accepted ridesharing route to as many riders as possible. Formally, we are considering the problem of maximizing the number of passengers, each of whom is assigned a ridesharing route i for every i  R such that t(i)  i · t(^i) for any public transit route ^i. We make some simplifications in our model:
· Given a source-destination station pair (o, d) in a public transit system with departure time t at s, we use a simplified transit system in our experiments to calculate the fastest public transit route from o to d.
· The time it takes to pick-up and drop-off riders, walking time between a ridesharing service and public transit, and waiting time for transit are not considered.
· Uncertainty in travel times is ignored (we assume average travel time for any route).
For a trip i in A, let oi and di denote the origin and the destination of i respectively. A ridesharing route j of Type 1 for a passenger j is feasible if all requirements of both trips i and j are satisfied (i is the driver), and there exist paths (oi, oj, s) and (s, di) in N , where s is
5

a drop-off location. We extend this to a set (i) \ {i} = {j1, j2, . . . , jk} of passengers that can be served by driver i (i  (i) as well): a feasible ridesharing route jy for every jy  (i), there exists a path (oi, oj1, oj2, . . . , ojk, s) with drop-off location s, and a path from s to di. For match Type 2, it is symmetric: a ridesharing route j offered by i to pick-up j at station s is feasible if all requirements of trips i and j are satisfied, and there exist paths in N from oi to s and from dj to di. The extension to a set of passengers (i) \ {i} = {j1, j2, . . . , jk} served by a driver i is similar: a feasible ridesharing route jy for every jy  (i), there exists a path (s, oj1, oj2, . . . , ojk) with pick-up location s, and a path from the final passenger's drop-off location to di. for every passenger j  (i) \ {i} = {j1, j2, . . . , jk}, there exists a feasible ridesharing route j with i = d(j) such that the destination of j is dj and there is a path from the last passenger's drop-off location ojk to di.
A set (i) is feasible if route j is feasible for every trip j  (i), which must satisfy the constraints (requirements) specified by the parameters of trips in (i) collectively. We outline a list of general constraints below:
· Capacity constraint limits the number of passengers a driver is willing to serve. · Travel time constraint enforces the total travel duration and travel time of each trip
(driver and passenger) to be within its specified range of departure and arrival time. · Stop constraint limits the number of unique locations visited by driver i to pick-up all
passengers of (i) (symmetric for Type 2). · Acceptance constraint enforces the travel duration of each passenger j's ridesharing
route to be within the acceptable range (t(j)   · t(^j) for 0 <   1).
A set (i) with at least one passenger satisfying the above constraints is called a feasible match. Therefore, a rideshare-transit (Type 1) feasible match (i) means all passengers in match (i) are picked-up at their origins and dropped-off at a public station. Then, i drives to destination di while each passenger j of (i) takes transit to reach destination dj. A transitrideshare (Type 2) feasible match (i) means all passengers in match (i) are picked-up at a public station and dropped-off at their destinations. Then, i drives to destination di after dropping the last passenger. We describe our algorithms for Type 1 only. Algorithms for Type 2 can be described with the constraints on the drop-off location and pick-up location of a driver exchanged, and we omit the description.
3 Exact algorithm
An exact algorithm is presented in this section, which is similar to the matching approach described in [4, 20] for ridesharing and in [16, 23] for MTR.
6

3.1 Integer program formulation
The exact algorithm is summarized as follows. First, we compute all feasible matches for each driver i. Then, we create a bipartite (hyper)graph H(D, R, E), where D(H) is the set of drivers, and R(H) is the set of riders. There is a hyperedge e = (i, J) in E(H) between i  D(H) and a non-empty subset J  R(H) if {i}  J is a feasible match, denoted by J (i), for driver i. An example is given in Figure 1. Any driver i and rider j with no feasible match

Figure 1: A bipartite hypergraph for all possible matches of an instance (N, A, T ).

is removed from D(H) and R(H) respectively, namely, no isolated vertex. Let Ej be the set of edges in E associated with trip j  A, that is, for any e = (i, J) in Ej, either i = j or j  J. For an edge e = (i, J), let A(e) = {i}  J and p(e) = |J| be the number of riders represented by e. To solve the problem of maximizing the number of passengers, each of whom is given a ridesharing route (refer to as the maximization problem), we give an integer program formulation:

maximize

p(e) · xe

(1)

eE (H )

subject to

xe  1,

jA

(2)

eEj

xe  {0, 1},

 e  E(H)

(3)

The binary variable xe indicates whether the edge e = (i, J) is in the solution (xe = 1) or not (xe = 0). If xe = 1, it means that all passengers in J are served by i. Inequality (2) in the ILP formulation guarantees that each driver serves at most one feasible set of passengers and each passenger is served by one driver.

Observation 3.1. A match (i) for any driver i  D is feasible if and only if for every subset P of (i) \ {i}, the match between i and P is feasible [22].

From Observation 3.1, we have the following proposition.

7

Proposition 3.1. Let i1, i2, . . . , ij be a set of drivers in D and P be a maximal set of passengers served by i1, . . . , ij. There always exists a solution such that (ia)  (ib) =  (1  a = b  j) and i1aij (a) = P .
Theorem 3.1. Given a bipartite graph H(D, R, E) representing an instance of the multimodal transportation with ridesharing maximization problem. An exact solution to the integer program (1)-(3) solves the maximization problem.
Proof. From inequality (2) in the integer program, the solution found by the integer program is always feasible to the maximization problem. By Proposition 3.1 and objective function (1), the maximum number of passengers are served.

3.2 Computing feasible matches

Let i be a driver in D. The maximum number of feasible matches for i is

ni j=0

|R| j

.

Assuming

the capacity ni is a very small constant (which is reasonable in practice), the above summation

is polynomial in R, that is, O((|R| + 1)ni) (partial sums of binomial coefficients). Let K =

maxiD ni be the maximum capacity among all vehicles (driver trips). Then, in the worst case, |E(H)| = O(|D| · (|R| + 1)K).

We compute all feasible matches for each trip in two phases. In phase one, for each driver

i, we find all feasible matches (i) = {i, j} with one rider j. In phase two, for each driver i, we

compute all feasible matches (i) = {i, j1, .., jp} with p riders, based on the feasible matches (i) with p - 1 riders computed previously, for p = 2 and upto the number of passengers i

can serve. Before describing how to compute the feasible matches, we first introduce some

notations and specify the feasible match constraints we consider. Each trip i  A is specified

by the parameters (oi, di, ni, zi, pi, i, i, i, i, i), where the parameters are summarized in Table 1 along with other notation. The maximum trip time i of a driver i can be calculated as i = t(pi) + zi if pi is given; otherwise i = t(oi, di) + zi. For a passenger j, j is more flexible; it is default to be j = t(^i), where ^i is the fastest public transit route. For any driver i  D, a match (i) is feasible if all trips of (i) satisfy the following constraints

collectively. (I) Capacity constraint: |(i) \ {i}|  ni. (II) Travel time constraint: every trip i  A departs from oi no earlier than i and arrives at di no later than i; the total travel duration of i is at most i. (III) Stop constraint: the number of unique locations visited by driver i to pick-up for (Type 1) or drop-off for (Type 2) all passengers of (i) is

at most i. (IV) Acceptance constraint: for route j of each passenger j  (i) \ {i}, t(j)  j · t(^j), where ^j is the public transit route with shortest travel time for j.

Phase one (Algorithm 1). Now we describe how to compute a feasible match between a driver and a passenger for Type 1. The computation for Type 2 is similar and we omit it.

8

Notation oi di ni zi pi i
i i i i i ^i d(i) t(pi) t(i) & t(^i) t(u, v) & t^(u, v)

Definition Origin (start location) of i (a vertex in N ) Destination of i (a vertex in N ) Number of seats (capacity) of i available for passengers (driver only) Detour time i willing to make for offering services (driver only) A preferred path of i from oi to di in N (driver only) Maximum number of stops i willing to make to pick-up passengers for match Type 1 and to drop-off passengers for match Type 2. Earliest departure time of i Latest arrival time of i Maximum trip time for i Acceptance rate (0  i < 1) for a ridesharing route i (rider only) Route for i using a combination of public transit and ridesharing (rider only) Route for i using only public transit (rider only) The driver of ridesharing route i Travel time for traversing path pi by private vehicle Travel time for traversing route i and ^i resp. Travel time from location u to v by private vehicle and public transit resp.

Table 1: Parameters for a trip announcement i.

For every trip i  D  R, we first compute the set Sdo(i) of feasible drop-off locations for trip i. Each element in Sdo(i) is a station-time tuple (s, i(s)) of i, where i(s) is the earliest possible time i can reach station s. The station-time tuples are computed by the following preprocessing procedure.
· We find all feasible station-time tuples for each passenger j  R. A station s is feasible for j if j can reach dj from s within time window [j, j], t(oj, s) + t^(s, dj)  j and t(oj, s) + t^(s, dj)  j · t^(oj, dj).
­ The earliest possible time to reach station s for j can be computed as j(s) = j + t(oj, s) without pick-up and drop-off time. Since we do not consider walking time and waiting time, j(s) also denotes the earliest departure time of j at station s.
­ Let t^(s, dj) be the travel time of a fastest public route. s is time feasible if j(s) + t^(s, dj)  j, t(oj, s) + t^(s, dj)  j and t(oj, s) + t^(s, dj)  j · t^(oj, dj).
· Next, we find all feasible station-time tuples for each driver i  D using a similar calculation.

­ Without considering pick-up and drop-off time, the earliest arrival time of i to reach s is i(s) = i+t(oi, s). Station s is time feasible if i(s)+t(s, di)  i and t(oi, s)+t(s, di)  i.

9

After the preprocessing, the Algorithm 1 finds all matches consists of a single passenger. For each pair (i, j) in D × R, let i(oj) = max{i, j - t(oi, oj)} be the latest departure time for driver i from oi such that i can still pick-up j at the earliest; this minimizes the time (duration) needed for driver i to wait for passenger j, and hence, the total travel time of i is minimized. The process of checking if the match (i) = {i, j} is feasible for all pairs of (i, j) can be performed as in Algorithm 1 in Figure 2.

Algorithm 1 Single passenger

1: for each pair (i, j) in D × R do

2: for each station s in Sdo(i)  Sdo(j) do

3:

t1 = t(oi, oj) + t(oj, s); t2 = t(oj, s); /* travel duration for i and j to reach s resp. */

4:

t = i(oj) + t1; /* earliest departure time at station s */

5:

if t  i(s)  (t1 + t(s, di)  i)  t  j(s)  (t2 + t^(s, dj)  {j and j · t^(oj, dj)}) then

6:

create an edge (i, J = {j}) in E(H) to represent (i) = {i, j}.

7:

break inner for-loop; /* can be allowed to run to completion for a better route */

8:

end if

9: end for 10: end for

Figure 2: Algorithm for computing matches consists of a single passenger.

Phase two (Algorithm 2). We extend Algorithm 1 to create matches with more than one passenger. Let H(D, R, E) be the graph after computing all possible matches consists of a single passenger (instance computed by Algorithm 1). We start with computing feasible matches consists of two passengers, then three passengers, and so on. Let (i) be the set of matches found so far for driver i and (i, p) = {(i) | p = |(i) \ {i}|} be the set of matches with p passengers. Let ri = (l0, l1, . . . , lp, s) denotes an ordered potential path (travel route) for driver i to pick-up all p passengers of (i) and drop-off them at station s, where l0 is the origin of i and ly is the pick-up location (origin of passenger jy), 1  y  p. We extend the notion of i(oj), defined above, to all locations of ri. That is, i(lp) is the latest departure time of i to pick-up all passengers j1, . . . , jp such that the waiting time of i is minimized, and hence, travel time of i is minimized. All possible combinations of ri are enumerated to find a feasible path ri; the process of finding ri is described in the following.
· First, we fix a combination of ri such that |(i)|  ni + 1 and ri satisfies the stop constraint. The order of the pick-up origin locations is known when we fix a path ri.
· The algorithm determines the actual drop-off station s in ri = (l0, l1, . . . , lp, s). Let jy be the passenger corresponds to pick-up location ly for 1  y  p and l0 = oi. For each

10

station s in 0yp Sdo(jy), the algorithm checks if ri = (l0, l1, . . . , lp, s) admits a time feasible path for each trip in (i).
­ The total travel time (duration) for i from l0 to s is ti = t(l0, l1) + · · · + t(lp-1, lp) + t(lp, s). The total travel time (duration) for jy from ly to s is tjy = t(ly, ly+1) + · · · + t(lp-1, lp) + t(lp, s), 1  y  p.
­ Since the order for i to pick up jy (1  y  p) is fixed, i(lp) can be calculated as i(lp) = max{i, j1 - t(l0, l1), j2 - t(l0, l1) - t(l1, l2), . . . , jp - t(l0, l1) - · · · - t(lp-1, lp)}. The earliest arrival time at s for all trips in (i) is t = i(lp) + ti.
­ If t  i(s), ti + t(s, di)  i, and for 1  y  p, t  jy (s), tjy + t^(s, djy )  jy and tjy + t^(s, djy )  jy · t^(ojy , djy ), then ri is feasible.
· If ri is feasible, add the match corresponds to ri to H. Otherwise, check next combination of ri until a feasible path ri is found or all combinations are exhausted.
The pseudo code for the above process is given in Algorithm 2 ( Figure 3). It can be easily shown that the calculation of i(lp) indeed minimizes the total travel time of i to reach lp.
Theorem 3.2. Given a feasible path ri = (l0, . . . , lp, s) for driver i that serves p passengers in a match (i). The latest departure time i(lp) calculated above minimizes the total travel time of i to reach lp.
Proof. Prove by induction. For the base case i(l1) = max{i, j1 - t(l0, l1)}, i does not need to wait for j1. Hence, the total travel time of i to pick-up j1 is minimized with departure time i(l1). Assume the lemma holds for 1  y - 1 < p, that is, i(ly-1) minimizes the total travel time of i to reach ly-1. We prove for y. From the calculation, i(ly) = max{i(ly-1), jy - t(l0, l1) - t(l1, l2) - · · · - t(ly-1, ly)}. By the induction hypothesis, i(ly) minimizes the total travel time of i.
The running time of Algorithm 2 heavily depends on the number of subsets of passengers to be checked for feasibility. One way to speed up Algorithm 2 is to use dynamic programming (or memoization) to avoid redundant checks on a same subset. For each feasible match |(i)| = p of a driver i  D, we store every feasible path ri = {i, j1, . . . , jp, s} and extend from each feasible path ri to insert a new trip to minimize the number of ordered potential paths we need to test. We can further make sure that no path is tested twice during execution. First, the set R of riders is given a fixed ordering (based on the integer labels). For a feasible path ri of a driver i, the check of inserting a new rider j into ri is performed only if j is larger than every rider in ri according to the fixed ordering. A heuristic approach to speed up Algorithm 2 is given in Section 5.2.
11

Algorithm 2 Compute all matches

1: for i = 1 to |D| do

2: p = 2;

3: while (p  ni and (i, p - 1) = ) do

4:

for each match (i) in (i, p - 1) do

5:

for each j  R s.t. j / (i) do

6:

/* check if (i)  {j} satisfies Observation 3.1, and if not, skip j */

7:

if (((i) \ {q})  {j})  (i, p - 1) for all q  (i) \ {i} then

8:

if ((i)  {j} has not been checked) and (feasibleInsert((i), j)) then

9:

create an edge (i, J) in E(H) to represent J (i) = {i, J}.

10:

add (i)  {j} to (i, p).

11:

end if

12:

end for

13:

end for

14:

p = p + 1;

15: end while 16: end for 17: Procedure feasibleInsert((i), j)

/* find a feasible path for i to serve (i)  {j} if exists */

18: Let ri = (l0, l1, . . . , lp, s) denotes a potential path for driver i to serve trips in (i)  {j}.

19: for each station s in 0yp Sdo(jy) do 20: for each combination of ri = (l0, . . . , lp, s) that satisfies the stop constraint do

21:

ti = t(l0, l1) + · · · + t(lp-1, lp) + t(lp, s); tjy = t(ly, ly+1) + · · · + t(lp-1, lp) + t(lp, s);

22:

t = i(lp) + ti; /* the earliest arrival time at s for all trips in (i) */

23:

if [(t  i(s)  (ti + t(s, di)  i)) and (for 1  y  p, t  jy (s)  (tjy + t^(s, djy ) 

24:

jy · t^(ojy , djy ))  (tjy + t^(s, djy )  jy ))] then

25:

return True;

26: end for

27: end for

28: return False;

Figure 3: Algorithm for computing matches consists of multiple passengers.

12

4 Approximation algorithms
We show that the maximization problem defined in Section 3 is NP-hard and give approximation algorithms for the problem. When every edge in H(D, R, E) consists of only two vertices (one driver and one passenger), the maximization problem is equivalent to maximum matching, which can be solved in polynomial time. However, if the edges consist of more than two vertices, they become hyperedges. In this case, the integer program (1)-(3) becomes a formulation of the maximum weighted set packing problem, which is NP-hard [11, 15]. Our maximization problem is a special case of the maximum weighted set packing problem. We first show our maximization problem instance H(D, R, E) is indeed NP-hard.
4.1 NP-hardness
It was mentioned in [20] that their minimization problem related to shareability hypernetwork is NP-Complete, which is similar to our maximization problem formulation. However, an actual reduction proof was not described. In this section, we prove our maximization problem is NP-hard by a reduction from a special case of the maximum 3-dimensional matching problem (3DM). An instance of 3DM consists of three disjoint finite sets A, B and C, and a collection F  A × B × C. That is, F is a collection of triplets (a, b, c), where a  A, b  B and c  C. A 3-dimensional matching is a subset M  F such that all sets in M are pairwise disjoint. The decision problem of 3DM is that given (A, B, C, F) and an integer q, decide whether there exists a matching M  F with |M|  q. We consider a special case of 3DM: |A| = |B| = |C| = q; it is still NP-complete [11, 15]. Given a 3DM instance (A, B, C, F) with |A| = |B| = |C| = q, we construct an instance H(D, R, E) (bipartite hypergraph) of the maximization problem as follows:
· D(H) = A, the set of drivers and R(H) = B  C, the set of passengers.
· For each f  F, create a hyperedge e(f ) in E(H) containing elements (a, b, c), where a represents a driver and {b, c} represent two different passengers. Further, create edges e (f ) = {a, b} and e (f ) = {a, c}.
Theorem 4.1. It is NP-hard to maximize the number of passengers in R, each of whom is given a ridesharing route.
Proof. We prove the theorem by showing that an instance (A, B, C, F) of the maximum 3dimensional matching problem has a solution M of cardinality q if and only if the bipartite hypergraph instance H(D, R, E) has a solution X with 2q passengers.
Assume that (A, B, C, F ) has a solution M = {m1, m2, . . . , mq}. For each mi (1  i  q), add the corresponding hyperedge e(mi)  E(H) to X. Since mi  mj =  for 1  i = j  q
13

and each edge e  X contains two passengers, X is a valid solution to H(D, R, E) with 2q passengers.
Assume that H(D, R, E) has a solution X with 2q passengers served. For every e(f )  X, add the corresponding set f  F to M. In order to serve 2q passengers, |X| = |D| = q and every e(f )  X must contain two different passengers. Hence, M is a valid solution to (A, B, C, F) s.t. |M| = q.
The size of H(D, R, E) is polynomial in q. It takes a polynomial time to convert a solution of H(D, R, E) to a solution of the 3DM instance (A, B, C, F) and vice versa.
4.2 2-approximation algorithm
For consistency, we follow the convention in [5, 7] that a -approximation algorithm for a maximization problem is defined as  · w(C)  OP T for  > 1, where w(C) and OP T are the values of approximation and optimal solutions respectively. In this section, we give a 2-approximation algorithm to the maximization problem instance H(D, R, E). Our 2-approximation algorithm (refer to as ImpGreedy) is a simplified version of the simple greedy [5, 7, 20] discussed in Section 4.3, except the running time and memory usage are significantly improved by computing a solution directly from H(D, R, E) without solving the independent set/weighted set packing problem.
4.2.1 Description of ImpGreedy Algorithm
For a maximization problem instance H(D, R, E), we use  to denote a current partial solution, which consists of a set of matches represented by the hyperedges in E(H). Let P () = e Je (called covered passengers). Initially,  = . In each iteration, we add a match with the most number of uncovered passengers to , that is, select an edge e = (i, Je) such that |Je \ P ()| is maximum, and then add e to . Remove Ee = jA(e)Ej from E(H) (Ej is defined in Section 3). Repeat until P () = R or || = |D|. The pseudo code of ImpGreedy algorithm is shown in Figure 4.
Algorithm 3 ImpGreedy Algorithm Input: The hypergraph H(D, R, E) for problem instance (N, A, T ). Output: A solution  to (N, A, T ) with 2-approximation ratio. 1:  = ; P () = ; 2: while (P () = R and |V () < |D|) do 3: compute e = argmaxeE(H)|Je \ P ()|;  =   {e}; update P (); remove Ee from E(H); 4: end while
Figure 4: 2-approximating algorithm for problem instance (N, A, T ).
14

In ImpGreedy Algorithm, when an edge e is added to , Ee is removed from E(H), so Property 4.1 holds for . From this, the following holds.
Property 4.1. At most one edge e from Ei for every i  D can be selected in any solution.
4.2.2 Analysis of ImpGreedy Algorithm Let  = {x1, x2, . . . , xa} be a solution found by Algorithm 3, where xi is the ith edge added to . Throughout the analysis, we use OP T to denote an optimal solution, that is, P (OP T )  P (). Further, i = 1bi xb for 1  i  a, 0 =  and a = . The driver of match xi is denoted by d(xi). The main idea of our analysis is to add up the maximum difference between the number of covered passengers by selecting xi in  and not selecting xi in OP T . For each xi  , by Property 4.1, there is at most one y  OP T with d(y) = d(xi). We order OP T and introduce dummy edges to OP T such that d(yi) = d(xi) for 1  i  a. Formally, for 1  i  a, define
OP T (i) = {y1, . . . , yi | 1  b  i, d(yb) = d(xb) if yb  OP T, otherwise yb a dummy edge}.
A dummy edge yb  OP T (i) is defined as d(yb) = d(xb) with Jyb = . The gap of an edge xi   is defined as
gap(xi) = |Jyi| - |Jxi \ P (i-1)| + |Jxi|, where Jxi = (Jxi \P (i-1))P (OP T \) is the maximum subset of passengers in Jxi \P (i-1) that are also covered by drivers in OP T \ . The intuition is that the sum of gap(xi) for all xi   states the maximum possible number of passengers may not be covered by . Let P (OP T (i)) = 1bi Jyb and P (OP T (i)) = 1bi Jxb for any i  [1, . . . , a]. Then the maximum gap between  and OP T can be calculated as xa gap(x) = |P (OP T (a))| + |P (OP T (a))| - |P (a)|. First, we show that P (OP T ) = P (OP T (a))  P (OP T (a)).
Proposition 4.1. Let  = {x1, . . . , xa}, P (OP T (a)) = 1ia Jyi and P (OP T (a)) = 1ia Jxi. Then, P (OP T ) = P (OP T (a))  P (OP T (a)).
Proof. By definition, P (OP T ) = P (OP T (a))  P (OP T \ OP T (a)). For any z in OP T \ OP T (a), d(z) = d(x) for every x  . If Jz \ P () = , then z would have been found and added to  by Algorithm 3. Hence, Jz \ P () = , implying Jz  P (OP T (a)) and P (OP T \ OP T (a))  P (OP T (a)).
Lemma 4.1. Let OP T be an optimal solution and  = {x1, x2, . . . , xa} be a solution found by the algorithm. For any 1  i  a, xi gap(x) = |P (OP T (i))| - |P (i)| + |P (OP T (i))|  |P (i)|.
15

Proof. Recall that OP T (i) = {y1, . . . , yi} as defined above. For yb  OP T (i), 1  b  i, d(yb) = d(xb). We prove the lemma by induction on i. Base case i = 1: |P (OP T (1))| - |P (1)| + |P (OP T (1))|  |P (1)|. By definition, gap(x1) = |Jy1| - |Jx1 \ 0| + |Jx1|. Since x1 is selected by the algorithm, it must be that |Jx1|  |Ju| for all u  V (G ), so |Jy1|  |Jx1|. Thus,

gap(x1) = |Jy1| - |Jx1 \ 0| + |Jx1|  |Jx1|  |Jx1|.
Assume the statement is true for i - 1  1, that is, xi-1 gap(x)  |P (i-1)|, and we prove for i  a. By the induction hypothesis, both P (OP T (i - 1)) and P (OP T (i - 1)) are included in the calculation of xi-1 gap(x). More precisely, xi-1 gap(x) = |P (OP T (i - 1))| - |P (i-1)| + |P (OP T (i - 1))|  |P (i-1)|. If |Jyi|  |Jxi \ P (i-1)|, the lemma is true since we can assume |Jxi|  |Jxi|. Suppose |Jyi| > |Jxi \ P (i-1)|. Before xi is selected, the algorithm must have considered yi and found that |Jxi \ P (i-1)|  |Jyi \ P (i-1)|. Then, |Jyi| > |Jxi \ P (i-1)|  |Jyi \ P (i-1)|, implying Jyi  P (i-1) = . We have

|Jxi \ P (i-1)| + |Jyi  P (i-1)|  |Jyi \ P (i-1)| + |Jyi  P (i-1)| = |Jyi|.

(4)

Let Jyi  (Jyi P (i-1)) be the set of passengers covered by P (OP T (i-1))P (OP T (i- 1)), namely Jyi  (P (OP T (i - 1))  P (OP T (i - 1))). Then by the induction hypothesis,

gap(x)  P (i-1) - |Jyi  P (i-1)| + |Jyi|.

(5)

xi-1

Adding xi-1 gap(x) and gap(xi) together:

(

gap(x)) + (gap(xi))

xi-1

= |P (OP T (i - 1))| - |P (i-1)| + |P (OP T (i - 1))| + |Jyi \ Jyi| - |Jxi \ P (i-1)| + |Jxi|

 (|P (i-1)| - |Jyi  P (i-1)| + |Jyi|) + |Jyi \ Jyi| - |Jxi \ P (i-1)| + |Jxi|

from (5)

= |P (i-1)| - |Jyi  P (i-1)| + |Jyi| - |Jxi \ P (i-1)| + |Jxi|

 |P (i-1)| - |Jyi  P (i-1)| + |Jyi  P (i-1)| + |Jxi|

from (4)

= |P (i-1)| + |Jxi|  |P (i-1)| + |Jxi \ P (i-1)|

by defintion of Jxi

= P (i)

Therefore, by the property of induction, the lemma holds.

Theorem 4.2. Given the hypergraph instance H(D, R, E). Algorithm 3 computes a solution  to H such that 2|P ()|  |P (OP T )|, where OP T is an optimal solution, with running time O(|D| · |V |).

16

Proof. Let  = {x1, . . . , xa}, P (OP T (a)) = 1ia Jyi and P (OP T (a)) = 1ia Jxi. By Proposition 4.1, P (OP T ) = P (OP T (a))  P (OP T (a)), and by Lemma 4.1, |P (OP T (a))| + |P (OP T (a))| - |P (a)|  |P (a)|. We have
|P (OP T )|  |P (OP T (a))| + |P (OP T (a))|  2|P ()|.
In each iteration of the while-loop, it takes O(E) to find an edge x with maximum |Jx \P ()|, and there are at most |D| iterations. Hence, Algorithm 3 runs in O(|D| · |E|) time.

4.3 Approximation algorithms for maximum weighted set packing

Now, we explain the algorithms for the maximum weighted set packing problem, which solve

our maximization problem. Given a universe U and a family S of subsets of U, a packing is a

subfamily C  S of sets such that all sets in C are pairwise disjoint. Every subset S  S has

at most k elements and is given a real weight. The maximum weighted k-set packing problem

(MWSP) asks to find a packing C with the largest total weight. We can see that the maximiza-

tion problem on H(D, R, E) is a special case of the maximum weighted k-set packing problem,

where the trips of D  R is the universe U and E(H) is the family S of subsets, and every

e  E(H) represents at most k = K + 1 trips (K is the maximum capacity of all vehicles).

Hence, solving MWSP also solves our maximization problem. Chandra and Halldo´rsson [7]

presented

a

2(k+1) 3

-approximation

and

a

2(2k+1) 5

-approximation

algorithms

(refer

to

as

BestImp

and

AnyImp

respectively),

and

Berman

[5]

presented

a

(

k+1 2

+

)-approximation algorithm

(refer to as SquareImp) for the weighted k-set packing problem (here, k = K + 1), where the

latter still has the best approximation ratio.

The three algorithms in [5, 7] (AnyImp, BestImp and SquareImp) solve the weighted k-set

packing problem by first transferring it into a weighted independent set problem, which con-

sists of a vertex weighted graph G(V, E) and asks to find a maximum weighted independent

set in G(V, E). We briefly describe the common local search approach used in these three

approximation algorithms. A claw C in G is defined as an induced connected subgraph that

consists of an independent set TC of vertices (called talons) and a center vertex Cz that is connected to all the talons (C is an induced star with center Cz). The local search of AnyImp, BestImp and SquareImp uses the same central idea, summarized as follows:

1. The approximation algorithms start with an initial solution (independent set) I in G found by a simple greedy (refer to as Greedy) as follows: select a vertex u  V (G) with largest weight and add to I. Eliminate u and all u's neighbors from being selected. Repeatedly select the largest weight vertex until all vertices are eliminated from G.

2. While there exists claw C in G w.r.t. I such that independent set TC improves the

17

weight of I (different for each algorithm), augment I as I = (I \ N (TC))  TC; such TC is called an improvement.
To apply these algorithms to our maximization problem, we need to convert the bipartite hypergraph H(D, R, E) to a weighted independent set instance G(V, E), which is straightforward. Each hyperedge e  E(H) is represented by a vertex ve  V (G). The weight w(ve) = p(e) for each e  E(H) and ve  V (G). There is an edge between ve, ve  V (G) if e  e =  where e, e  E(H). We observed the following property.
Property 4.2. When the size of each set in the set packing problem is at most k (|e| = k, e  E(H)), the graph G(V, E) has the property that it is (k + 1)-claw free, that is, G(V, E) does not contain an independent set of size k + 1 in the neighborhood of any vertex.
Applying this property, we only need to search a claw C consists of at most k talons, which upper bounds the running time for finding a claw within O(nk), where n = |V (G)|. When k is very small, it is practical enough for solving our maximization problem instance H(D, R, E) computed by Algorithm 2 from (N, A, T ). It has been mentioned in [20] that the approximation algorithm in [7] can be applied to the ridesharing problem. However, only the simple greedy (Greedy) with k-approximation was implemented in [20]. Notice that algorithm ImpGreedy (Algorithm 3) is a simplified version of algorithm Greedy, and Greedy is used to get an initial solution in algorithms AnyImp, BestImp and SquareImp. From Theorem 4.2, we have Corollary 4.1.
Corollary 4.1. Greedy, AnyImp, BestImp and SquareImp algorithms compute a solution to H(D, R, E) with 2-approximation ratio.
Since ImpGreedy finds a solution directly on H(D, R, E) without converting it to G(V, E) and solving the independent set problem of G(V, E), it is more time and space efficient than the algorithms for MWSP. In the rest of this paper, Algorithm 3 is referred to as ImpGreedy.
5 Numerical experiments
We create a simulation environment, which consists of a public transit system and a ridesharing system. We implement our proposed approximation algorithm (ImpGreedy) and Greedy, AnyImp and BestImp algorithms for the k-set packing problem to evaluate the benefits of having an integrated transportation system supporting public transit and ridesharing. The results of SquareImp are not discussed because its performance is same as AnyImp; this is due to the implementation of the search/enumeration order of the verices and edges in the independent set instance G(V, E) being fixed.
18

5.1 Description and characteristics of datasets

We built a simplified transit network of Chicago to simulate practical scenarios of public transit and ridesharing. The roadmap data of Chicago is retrieved from OpenStreetMap1. We used the GraphHopper2 library to construct the logical graph data structure of the roadmap. The Chicago city is divided into 77 officially community areas, each of which is assigned an area code. We examined two different dataset in Chicago to reveal some basic traffic pattern (the datasets are provided by the Chicago Data Portal (CDP) and Chicago Transit Authority (CTA)3, maintained by the City of Chicago). The first dataset is bus and rail ridership, which shows the monthly averages and monthly totals for all CTA bus routes and train station entries. We denote this dataset as PTR, public transit ridership. The PTR dataset range is chosen from June 1st, 2019 to June 30th, 2019. The second dataset is rideshare trips reported by Transportation Network Providers (sometimes called rideshare companies) to the City of Chicago. We denote this dataset as TNP. The TNP dataset range is chosen from June 3rd, 2019 to June 30th, 2019, total of 4 weeks of data. Table 2 and Table 3 show some basic stats of both datasets.

Total Bus Ridership Total Rail Ridership 12 busiest bus routes
The busiest bus routes selected

20,300,416 19,282,992 3, 4, 8, 9, 22, 49, 53, 66, 77, 79, 82, 151 4, 9, 49, 53, 77, 79, 82

# of original records # of records considered # of shared trips # of non-shared trips The most visited community areas selected

8,820,037 7,427,716 1,015,329 6,412,387 1, 4, 5, 7, 22, 23, 25, 32, 41, 64, 76

Table 2: Basic stats of the PTR dataset

Table 3: Basic stats of the TNP dataset

In the PTR dataset, the total ridership for each bus route is recorded; there are 127 bus routes in the dataset. We examined the 12 busiest bus routes based on the total ridership and selected 7 out of the 12 routes as listed in Table 2 to build the transit network (excluded bus routes either serve a small community or too close to train stations). We also selected all the major trains/metro lines within the Chicago area except the Brown Line and Purple Line since they are too close to the Red and Blue lines. Note that the PTR dataset also provides the total rail ridership. However, it only provides the number of riders entering every station in each day; it does not provide the number of riders exit from a station nor the time related to the entries.
Each record in the TNP dataset describes a passenger trip served by a driver who provides the rideshare service; a trip record consists of the pick-up and drop-off time and the pick-up
1Planet OSM. https://planet.osm.org 2GraphHopper 1.0. https://www.graphhopper.com 3CDP. https://data.cityofchicago.org. CTA. https://www.transitchicago.com

19

Frequency (in hundreds)

500

Average number of trips departed from each area

400

400

300

300

200

200

Average number of trips arrived at each area

100

100

0

10

20

30Commun4i0ty area 50

60

70

0

10

20

30Commun4i0ty area 50

60

70

Figure 5: The average number of trips per day departed from and arrived at each area.

and drop-off community area of the trip, and exact locations are provided sometimes. We removed records where the pick-up or drop-off community area is hidden for privacy reason or not within Chicago, which results in 7.4 million ridesharing trips. We calculated the average number of trips per day departed from/arrived at each area. The results are plotted in Figure 5; the community areas that have the highest number of departure trips are almost the same as that of the arrival trips. We selected 11 of the 20 most visited areas as listed in Table 3 (area 32 is Chicago downtown, areas 64 and 76 are airports) to build the transit network for our simulation.
From the selected bus routes, trains and community areas, we create a simplified public transit network connecting the selected areas, depicted in Figure 6. Each rectangle on the figure represents an urban community within one community area or across two community

Figure 6: Simplified public transit network of Chicago with 13 urban communities and 3 designated locations. Figure on the right has the Chicago city map overlay for scale.
20

areas, labeled in the rectangle. The blue dashed rectangles/urban communities are chosen due to the busiest bus routes from the PTR dataset. The rectangles/urban communities labeled with red area codes are chosen due to the most visited community areas from the TNP dataset. The dashed lines are the trains, which resemble the major train services in Chicago. The solid lines are the selected bus routes connecting the urban communities to their closest train stations. There are also three designated locations/destinations that many people want to travel to/from throughout the day; they are the two airports and downtown region in Chicago.
The travel time between two locations (each location consists of the latitude and longitude coordinates) uses the fastest/shortest route computed by the GraphHopper library, which is based on personal cars. The shortest paths are computed in real-time, unlike many previous simulations where the shortest paths are precomputed and stored. As mentioned in Section 2, we do not explicitly consider service time, which consists of: pick-up and drop-off time, walking time and waiting time between a ridesharing service and public transit service. Instead, we multiply a small constant > 1 to the fastest route to mimic the service time and the waiting time for public transit. For instance, consider two consecutive metro stations s1 and s2. The travel time t(s1, s2) is computed by the fastest route, and the travel time by train between from s1 to s2 is t^(s1, s2) = 1.15 · t(s1, s2). The constant for bus service is 2. Rider trips originated from most locations must take a bus to reach a metro station when ridesharing service is not involved.
5.2 Generating instances
In our simulation, we partition the time from 6:00 to 23:59 each day into 72 time intervals (each has 15 minutes), and we only focus on weekdays. To see ridesharing traffic pattern, we calculated the average number of served trips per hour for each day of the week using the TNP dataset. The dashed (orange) line and solid (blue) line of the plot in Figure (7a) represent shared trips and non-shared trips respectively. A set of trips are called shared trips if this set of trips are matched for the same vehicle consecutively such that their trips overlap, namely, more than one passenger are presented in the same vehicle. For all other trips, we call them non-shared trips. From the plot, the peak hours are between 7:00 AM to 9:00AM and 4:00PM to 7:00PM on weekdays for both non-shared and shared trips. The number of trips generated for each interval is plotted in Figure (7b), which is a scaled down and smoothed version of the TNP dataset for weekdays. The ratio between the number of drivers and riders generated is roughly 1:3 (1 driver and 3 riders) for each interval. For each time interval, we first generate a set R of riders and then a set D of drivers. We do not generate a trip where its origin and destination are close. For example, no trip with origin Area25 and destination Area15 is generated.
21

Number of trips (in hundreds)

250

non-shared trips

shared trips

200

150

100

50

0

M00

M08

M16

Tu00 Tu08

Tu16

W00

W08 TimeW16

Th00

Th08 Th16

Fr00

Fr08

Fr16

Fr24
(b) Total number of driver and rider

(a) Average numbers of shared and non-shared trips in TNP dataset. trips generated for each time interval.

Figure 7: Plots for the number of trips for every hour from data and generated.

Generation of rider trips. We first assume that the numbers of riders entering and exiting a station are the same each day. Next we assume that the the numbers of riders in PTR over the time intervals each day follow a similar distribution of the TNP trips over the time intervals. Each day is divided into 6 different consecutive time periods (each consists of multiple time intervals): morning rush, morning normal, noon, afternoon normal, afternoon rush, and evening time periods. Each time period determines the probability and distribution of origins and destinations. Based on the PTR dataset and Rail Capacity Study by CTA [8], many riders are going into downtown in the morning and leaving downtown in the afternoon. To generate a rider trip j during morning rush time period, we first decide a pickup area which is a community area selected uniformly at random. The origin oj is a random point within the selected pickup area. Then, we use standard normal distribution to determine the dropoff area, where downtown area is within two SDs (standard deviations), airports are more than two and at most three SDs, and the community areas are more than three SDs away from the mean. The destination dj is a random point within the selected dropoff area. The above is repeated until at riders are generated, where at + at/3 (riders + drivers) is the total number of trips for time interval t shown in Figure (7b). For any pickup area c and time interval t, ct denotes be the number of generated riders originated from c for time interval t, that is, c ct = at. Other time periods follow the same procedure, and all community areas and locations can be selected as pickup and dropoff areas:

1. Morning normal: for pickup area, community areas are within two SDs, downtown is more than two and at most three SDs and airports are more than three SDs away from the mean; and destination area is selected using uniform distribution.
2. Noon: both pickup and dropoff are selected using uniform distribution.
3. Afternoon normal: for pickup area, downtown and airport are within two SDs and community areas are more than two SDs away from the mean; for dropoff area, community

22

areas are within two SDs and downtown and airports are more than two SDs away from the mean.
4. Afternoon rush: for pickup area, downtown is within two SDs, airports are more than two SDs and at most three SDs and community areas are more than three SDs away from the mean; and for dropoff area, community areas are within two SDs, airports are more than two SDs and at most three SDs and downtown is more than three SDs away from the mean.
5. Evening: for both pickup and dropoff areas, community areas are within two SDs, downtown is more than two and at most three SDs and airports are more than three SDs away from the mean.

Generation of driver trips. We examined the TNP dataset to determine if there are enough drivers who can provide ridesharing service to riders that follow match Types 1 and 2 traffic pattern. First, we removed any trip from TNP if it is too short (less than 15 minutes or origin and destination are adjacent areas). We calculated the average number of trips per hour originated from every pre-defined area in the transit network (Figure 6), and then plotted the destinations of such trips in a grid heatmap. In other words, each cell (c, r) in the heatmap represents the the average number of trips per hour originated from area c to destination area r in the transit network (Figure 6). An example of heatmap is depicted in Figure 8. From the heatmaps, many trips are going into the downtown area (A32) in the

Average number of trips per hour

A1 0 0 0.2 0 1.8 1.2 3.6 0.2 0.6 0.2 0.4 1.6 1.0 0.8 0.4 0.4 0.2 0 0.2 0.4

A2 0 0 0 0.2 1.8 1.0 0.8 1.4 1.2 0.8 2.6 1.2 0.2 0 0 0.4 0.8 0.2 1.2 0.6 A4 0.6 0 0 0 1.6 0.2 1.2 3.6 5.4 1.2 2.4 1.0 1.6 0.2 0 0.2 0 0 0 0.4

160

A5 5.8 1.0 0 0 0.2 0 2.2 2.8 0.6 3.6 10.8 1.4 3.6 2.0 0 4.2 1.8 2.2 0 0

A7 12.0 5.2 2.6 0.6 0 6.0 9.4 7.0 0 3.2 9.4 3.8 5.8 1.6 0.6 8.2 6.0 0.6 2.0 1.4

140

A14 0.4 0 0.2 0 0 0 0 0.4 0.2 0.8 1.2 0.2 0.6 0.2 0.4 0 0 0 0.6 0

A15 1.8 1.8 0.6 0 1.4 0 0 0 0.6 1.4 0.2 0.4 0.8 0 0 0 0 0.2 0 0

120

A19 0 2.0 0.8 0.2 0.4 5.8 0 0 0.4 2.4 0.8 1.8 0.6 0 0 0.2 0.6 0.2 0 0

A22 3.2 4.8 0.4 0 0 0.2 7.8 6.6 0 0.4 6.4 2.0 1.8 5.4 0 0.2 3.4 1.0 0.4 0.2 A23 1.2 1.4 1.4 0.6 0.4 1.2 2.8 0 0 0 2.6 2.2 5.8 0.2 0.6 0.2 3.4 0.2 0.8 0.2

100

A25 0.4 3.6 0 0.4 1.0 3.0 0.4 0.4 6.8 0.8 0 2.4 3.4 0.2 1.2 2.0 0.4 2.4 3.0 2.0 A30 0 0.4 0 0.2 0.8 0.6 0 1.0 2.6 3.4 3.8 0 4.0 0.6 0.2 1.8 1.2 3.2 2.0 0.6

80

A32 42.4 29.2 36.2 78.8 54.0 20.6 27.6 15.8 97.0 39.6 37.2 28.6 0 28.8 19.6 48.0 24.6 12.0 26.8 17.0

A41 0.6 0.2 2.0 0.2 10.8 1.4 3.0 0.6 7.2 3.0 1.4 4.0 14.6 0 0 1.2 0.2 7.4 1.4 3.8

60

A42 0.8 0.2 0.2 0 0 0.2 0 0 0.6 0.2 0.2 0.2 1.0 0 0 0 1.2 0.6 0 1.2

A43 0.6 0 0.2 0 0 0 0 0 0 0.6 0.4 0.2 3.6 0.2 0 0 0.6 2.8 0.6 2.8

40

A61 0 0.6 0.8 0 0.8 0 0 0.6 2.0 1.0 4.0 1.6 1.2 0 1.0 3.0 0 5.6 1.6 2.6

A66 0.6 0 0 0.2 0.2 0 0 0 0.4 0.4 0.2 1.2 0.4 1.8 1.8 2.6 0.2 0 0 0.4 A69 0 0 0 0 0 0 0.2 0 0 0.2 0.2 0.8 1.0 0.6 0 0.6 1.0 0.6 0 0

20

A71 0.2 0 0 0 0.2 0.4 0 0 0 0.6 0.6 0.4 4.6 0 0 4.2 0 0.6 0 0 A1 A2 A4 A5 A7 A14 PAi1c5k-Au1p9loAc2a2tioAn23(CAo2m5 mA3u0nitAy32arAe4a1) A42 A43 A61 A66 A69 A71 A1 A2 A4 A5 A7 AP14icAk1-u5pA1lo9cAa2t2ioAn23(CAo25mAm30unA3it2yAa4r1eAa4)2 A43 A61 A66 A69 A71

0

Figure 8: Traffic heatmaps for the average number of trips originated from one area (x-axis) during hour 7:00 (left) and hour 17:00 (right) to every other destination area (y-axis).

morning; and as time progresses, more and more trips leave downtown. This traffic pattern confirms that there are enough drivers to serve the riders in our simulation. The number of shared trips shown in Figure 7a also suggests that many riders are willing to share a same

Drop-off location (Community area)

23

vehicle. We slightly reduce the difference between the values of each cell in the heatmaps and use the idea of marginal probability to generate driver trips. Let d(c, r, h) be the value at the cell (c, r) for origin area c, destination r and hour h. Let P (c, h) be sum of the average number of trips originated from area c for hour h (the column for area c in the heatmap corresponds to hour h), that is, P (c, h) = r d(c, r, h) is the sum of the values of the whole column c for hour h. Given a time interval t, for each area c, we generate ct/3 drivers (ct is defined in Generation of rider trips) such that each driver i has origin oi = c and destination di = r with probability d(c, r, h)/P (c, h), where t is contained in hour h. The probability of selecting an airport as destination is fixed at 5%.
After the origin and destination of a rider/driver trip have been determined, we decide other parameters of the trip. The capacity ni of drivers' vehicles is selected from three ranges: the low range [1,2,3], mid range [3,4,5], and high range [4,5,6]. During morning/afternoon peak hours, roughly 95% and 5% of vehicles have capacities randomly selected from the low range and mid range respectively. It is realistic to assume vehicle capacity is lower for morning and afternoon peak-hour commute. While during off-peak hours, roughly 80%, 10% and 10% of vehicles have capacities randomly selected from low range, mid range and high range respectively. The number i of stops equals to ni if ni  3, else it is chosen uniformly at random from [ni - 2, ni] inclusive. The detour limit zi of each driver is within 5 to 20 minutes because traffic and service time are not considered. The general information of the base instances is summarized in Table 4.

Major trip patterns
# of intervals simulated # of trips per interval Driver:rider ratio Capacity ni of vehicles Number i of stops limit Earliest departure time i Driver detour limit zi Latest arrival time i Travel duration i of driver i Travel duration j of rider j Acceptance rate Train and bus travel time

from urban communities to downtown and vice versa for peak and off-peak hours respectively; trips specify one match type for peak hours and can be in either type for off-peak hours Start from 6:00 AM to 11:59 PM; each interval is 15 minutes varies from [350, 1150] roughly, see Figure 7 1:3 approximately low: [1,3], mid: [3,5] and high: [4,6] inclusive i = ni if ni  3, or i  [ni - 2, ni] if ni  4 immediate to 2 intervals after a trip announcement is generated 5 minutes to min{2 · t(oi, di) (driver's fastest route), 20 minutes} at most 1.5 · (t(oi, di) + zi) + i i = t(oi, di) + zi j = t(^i), where ^i is the fastest public transit route 80% for all riders (0.8 times the fastest public transit route) average at 1.15 and 2 times the fastest route by car, respectively

Table 4: General information of the base instances.

When the number of trips increases, the running time for Algorithm 2 and the time needed to construct the k-set packing instance also increase. This is due to the increased number of

24

feasible matches for each driver i  D. In a practical setup, we may restrict the number of different matches a driver can have. We call each match produced by Algorithm 1 base match, which consists of exactly one driver and one passenger. To make the simulation feasible, we limit the numbers of base matches for each driver and each rider, and the number of total feasible matches for each driver. More specifically, we use reduction configuration (x%, y, z) to denote that for each driver i, the number of base matches of i is reduced to x percentage and at most y total feasible matches are computed for i; and for each rider j, at most z base matches containing j are used. We also call reduction configuration just Config for short.

5.3 Computational results

We use the same transit network and same set of generated trip data for all algorithms. All experiments were implemented in Java and conducted on Intel Core i7-2600 processor with 1333 MHz of 8 GB RAM available to JVM. Since the optimization goal is to assign accepted ridesharing route to as many riders as possible, the performance measure is focused on the number of riders served by ridesharing routes, followed by the total time saved for the riders as a whole. We record both of these numbers for each approximation algorithm. The base case instance uses the parameter setting described in Section 5.2 and Config (30%, 600, 20). The experiment results are shown in Table 5. The results of ImpGreedy and Greedy are

ImpGreedy

Total number of riders served

27413

Avg number of riders served per interval

380.736

Total time saved of all riders (sec)

21274094

Avg time saved of riders per interval (sec) 295473.53

Total number of riders and public transit duration

Greedy AnyImp BestImp

27413

28248

28258

380.736 392.333 392.472

21274094 21951637 21956745

295473.53 304883.85 304954.79

45314 and 83024638 seconds

Table 5: Base case solution comparison between the approximation algorithms.

aligned since they are essentially the same algorithm - 60.5% of total passengers are assigned ridesharing routes and 25.6% of total time are saved. The results of AnyImp and BestImp are similar because of the density of the graph G(V, E) due to Observation 3.1. For AnyImp and BestImp, roughly 62.4% of total passengers are assigned ridesharing routes and 26.4% of total time are saved. On average, passengers are able to reduce their travel time by 25-26% by using public transit plus ridesharing. The results of these four algorithms are not too far apart. However, it takes too long for AnyImp and BestImp to run to completion. A 10-second limit is set for both algorithms in each iteration for finding an independent set improvement. With this time limit, AnyImp and BestImp run to completion within 15 minutes for almost all intervals.
We also examine this from the drivers' perspective; we recorded both the mean occupancy

25

Occupancy rate Vacancy rate

rate and vacancy rate of drivers. The mean occupancy rate is calculated as, in each interval,

the number of passengers served divided by the number of drivers who serve them. The mean

vacancy rate is calculated as, in each interval, the number of drivers with feasible matches

who are not assigned any passenger divided by the total number of drivers with at least

one feasible match. The results are depicted in Figure 9. The occupancy rate results show

Mean occupancy rate for each interval (higher the better)

2.1

ImpGreedy/Greedy BestImp

2.0

1.9

1.8

1.7

1.6

6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Hour of the day

Mean vacancy rate for each interval (lower the better)

0.14

ImpGreedy/Greedy BestImp

0.12

0.10

0.08

0.06

0.04

0.02

0.00 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Hour of the day

Figure 9: The mean occupancy rate and vacancy rate of drivers for each interval.

that in many intervals, 1.9-2 passengers are served by each driver on average. The vacancy rate of drivers show that 3-8% (0-4% resp.) of drivers are not assigned any passenger while such drivers have some feasible matches for ImpGreedy (BestImp respectively) during all hours except afternoon peak hours; on the other hand, this time period has the highest occupancy rate. This is most likely due to the origins of many trips are from the same area (downtown). If the destinations of drivers and riders do not have the same general direction from downtown, the drivers may not be able to serve any riders. On the other hand, when their destinations are aligned, drivers are likely to serve more riders.
Another major component of the experiment is to measure the computational time of the algorithms, which is highly affected by the base match reduction configurations. By reducing more matches, we are able to improve the running time of AnyImp and BestImp significantly, but sacrifice performance slightly. We tested 12 different Configs:
· Small1 (20%,300,10), Small2 (20%,600,10), Small3 (20%,300,20), Small4-10 (20%,600,20). · Medium1 (30%,300,10), Medium2 (30%,600,10), Medium3 (30%,300,20), Medium4-10 (30%,600,20).
· Large1 (40%,300,10), Large2 (40%,600,10), Large3-10 (40%,300,20), and Large4-10 (40%,600,20).
Configs with label "-10" have a 10-second limit to find an independent set improvement, and all other Configs have 20-second limit. Notice that all 12 Configs have the same sets of driver/rider trips and base match sets but generate different feasible match sets. The performance and running time results of all 12 Configs are depicted in Figures 10 and 11 respectively. The results are divided into peak and off-peak hours for each Config (averaging all intervals of peak hours and off-peak hours). The running time of ImpGreedy and

26

Number of riders

Computational time (second)

Average number of riders served during peak hours

480

IAmnpyGImrepedy

GBeresetIdmyp

470

Average number of riders served during off-peak hours

355

ImpGreedy AnyImp

Greedy BestImp

350

460

345

340

450

335

440

330

430

325

420

320

Small1 Small2 Small3 Small4 MeRdeiudmu1cMteidoinumc2oMnedfiigumur3Maetidoiunm4 Large1 Large2 Large3 Large4 Small1 Small2 Small3 Small4 MeRdeiudmu1cMteidoinumc2oMnedfiigumur3Maetidoiunm4 Large1 Large2 Large3 Large4

Figure 10: Average performance of peak and off-peak hours for different configurations.

1400

Average computational time for peak hours

ImpGreedy

Greedy

1200

AnyImp

BestImp

Average computational time for off-peak hours

350

ImpGreedy

Greedy

300

AnyImp

BestImp

1000

250

800

200

600

150

400

100

200

50

0

0

Small1 Small2 Small3 Small4 MeRdeiudmu1cMteidoinumc2oMnedfiigumur3Maetidoiunm4 Large1 Large2 Large3 Large4 Small1 Small2 Small3 Small4 MeRdeiudmu1cMteidoinumc2oMnedfiigumur3Maetidoiunm4 Large1 Large2 Large3 Large4

Figure 11: Average running time of peak and off-peak hours for different configurations.

Greedy are within seconds for all Configs as shown in Figure 11. On the other hand, it may not be practical to use AnyImp and BestImp for peak hours since they require around 15 minutes for most Configs. Since AnyImp and BestImp provide better performance than ImpGreedy/Greedy when each Config is compared side-by-side, one can use ImpGreedy/Greedy for peak hours and AnyImp/BestImp for off-peak hours so that it becomes practical. The increase in performance from Small1 to Small3 is much larger than that from Small1 to Small2 (same for Medium and Large), implying any parameter in a configuration should not be too small. The increase in performance from Large1 to Large4 is higher than that from Medium1 to Medium4 (similarly for Medium and Small). Therefore, it is more important to have a balanced configuration than a configuration emphasizes only one or two parameters.
Because ImpGreedy does not create the independent set instance, it runs quicker than Greedy. More importantly, ImpGreedy uses less memory space than Greedy does. We tested ImpGreedy and Greedy with the following Configs: Huge1 (100%,600,10), Huge2 (100%,2500,20) and Huge3 (100%,10000,30) (these Configs have the same sets of driver/rider trips and base match sets as those in the previous 12 Configs). The focus of these Configs is to

27

see if Greedy can handle large number of feasible matches. The results are shown in Table 6. Greedy cannot run to completion for all configurations because in many intervals, the whole

ImpGreedy Avg running time for peak/off-peak hours (sec) Avg number of riders served for peak/off-peak hours Avg time saved of riders per interval (sec) Greedy Avg running time Avg instance size G(V, E) of afternoon peak (|E(G)|) Avg time creating G(V, E) of afternoon peak (sec)

Huge1 0.08 / 0.03 406.9 / 339.0 284891.8
Huge1 N/A 0.02 billion 14.6

Huge2 0.43 / 0.12 458.8 / 355.4 302774.1
Huge2 N/A 0.38 billion 320.9

Huge3 1.2 / 0.29 484.1 / 361.9 310636.9
Huge3 N/A 5.47 billion 3726.79

Table 6: The results of ImpGreedy and Greedy using Unlimited reduction configurations.

graph G(V, E) of the independent set instance is too large to hold in memory. The average number of edges for afternoon peak hours is 0.02, 0.38 and 5.47 billion for Huge1, Huge2 and Huge3 respectively. Further, the time it takes to create G(V, E) can excess practicality. Hence, using Greedy (AnyImp and BestImp) for large instances may not be practical. In addition, the performance of ImpGreedy with Huge3 is better than that of AnyImp/BestImp with Large4.
Lastly, we also looked at the total running times of the approximation algorithms including the time for computing feasible matches (Algorithms 1 and 2). The running time of Algorithm 1 solely depends on computing the shortest paths between the trips and stations. Table 7 shows that Algorithm 1 runs to completion within 500 seconds on average for peak hours. As for Algorithm 2, when many trips' origins/destinations are concentrated in one area, the running time increases significantly, especially for drivers with high capacity. Running time of Algorithm 2 can be reduced significantly by Configs with aggressive reductions. Combining

Alg1 Alg2 ImpGreedy Greedy AnyImp BestImp

Small3 Small4 Medium3 Medium4 Large4 Huge3

485.2 485.2 485.2 485.2 485.2 485.2

26.8 28.2 43.6 50.1 72.0 339.4

0.021 0.029 0.031 0.048 0.076
1.2

2.0 3.6 3.7 7.7 12.2 N/A

840.5 599.1 1312.1 971.5 1121.3 N/A

876.4 629.9 1371.0 990.0 1167.2 N/A

Total computational time

ImpGreedy Greedy AnyImp BestImp

512.1

514.1 1352.5 1388.5

513.4

517.0 1112.5 1143.3

532.5

543.0 1840.9 1899.9

535.3

543.0 1506.8 1525.3

557.3

569.5 1678.6 1724.4

825.8

N/A

N/A

N/A

Table 7: Average computational time (in seconds) of peak hours for all algorithms.

the results of this and previous (Table 6) experiments, ImpGreedy is capable of handling large instances while providing quality solution compared to other approximation algorithms.
From the experiment results in Figures 10 and 11, it is beneficial to dynamically select different algorithms and reduction configurations for each interval depending on the number of trips. With large problem instances, previous approximation algorithms are not efficient

28

(time and memory consuming), so they require aggressive reduction to reduce the instance size. On the other hand, ImpGreedy is much faster and capable of handling large instances. The running time of ImpGreedy can also be an advantage to improve the quality of solutions. For example, as shown in Figures 10 and 11, for the same set of drivers and riders, ImpGreedy assigns more riders when taking Meduim/Medium4 as inputs than AnyImp/BestImp on Small1/Small2, and uses less time than AnyImp/BestImp. When the size of an instance is not small and a solution must be computed within some time-limit, ImpGreedy has a distinct advantage over the previous approximation algorithms.
6 Conclusion and future work
Based on real-world transit datasets in Chicago, our study has shown that integrating public and private transportation can benefit the transit system as a whole, Recall that we focus on work commute traffic, and we only consider two match types that emphasize this transit pattern (with the flexibility to choose either type). Just from these two types, our base case experiments show that more than 60% of the passenger are assigned ridesharing routes and able to save 25% of travel time. Majority of the drivers are matched with at least one passenger, and vehicle occupancy rate has improved close to 3 (including the driver) on average. These results suggest that ridesharing can be a complement to public transit. Our experiments show that the whole system is capable of handling more than 1000 trip requests in real-time using ordinary computer hardware. It is likely that the performance results of ImpGreedy can be further improved by extending it with the local search strategy of AnyImp and BestImp. Perhaps the biggest challenge for scalability comes from computing the base matches (Algorithm 1) since it has to compute many shortest paths in real-time; it may be worth to apply heuristics to reduce the running time of Algorithm 1 for scalability. To better understand scalability and practicality, it is important to include different match types and a more sophisticated simulation which includes real transit schedule and transit demand.
References
[1] N. Agatz, A. Erera, M. Savelsbergh and X. Wang. Dynamic ride-sharing: A simulation study in metro Atlanta. Transportation Research Part B, 45(9):1450-1464, 2011.
[2] N. Agatz, A. Erera, M. Savelsbergh, and X. Wang. Optimization for dynamic ride-sharing: A review. European Journal of Operational Research, 223:295-303, 2012.
[3] K. Aissat and S. Varone. Carpooling as Complement to Multi-modal Transportation. In: Proceedings of ICEIS 2015. Cham, Springer. LNBIP 241, pp 236-255, 2015.
29

[4] J. Alonso-Mora, S. Samaranayake, A. Wallar, E. Frazzoli and D. Rus. On-demand high-capacity ride-sharing via dynamic trip-vehicle assignment. Proceedings of the National Academy of Sciences (PNAS), 114(3):462-467, 2017.
[5] P. Berman. A d/2 approximation for maximum weight independent set in d-claw free graphs. In Proceedings, Seventh Scandinavian Workshop on Algebraic Theory (SWAT), Lecture Notes in Computer Science, Vol. 1851, pp. 214-219, Springer-Verlag, New York/Berlin, July 2000.
[6] Center for Sustainable Systems, University of Michigan. Personal Transportation Factsheet. Pub. No. CSS01-07, 2020.
[7] B. Chandra and M. Halld´orsson. Greedy local improvement and weighted set packing approximation. In SODA, pages 169-176, 1999.
[8] Chicago Transit Authority. System-Wide Rail Capacity Study. Published June 2017; Revised February 2019. https://www.transitchicago.com/assets/1/6/RP_CDMSMITH_RCM_ Task2AExecutiveSummary_20170628_FINAL.pdf
[9] S. Feigon and C. Murphy. Shared mobility and the transformation of public transit. TCRP Technical Report, Transportation Research Board, Washington, 2016.
[10] M. Furuhata, M. Dessouky, F. Ord´on~ez, M. Brunet, X. Wang and S. Koenig. Ridesharing: The state-of-the-art and future directions. Transp. Research Part B, 57:28-46, 2013.
[11] M.R. Garey and D.S. Johnson. Computers and Intractability: A Guide to the Theory of NPCompleteness, W.H. Freeman and Company, 1979.
[12] K. Ghoseiri, A. Haghani, and M. Hamedi. Real-time rideshare matching problem. Final Report of UMD-2009-05, U.S. Department of Transportation, 2011.
[13] Q. Gu, J.L. Liang and G. Zhang. Approximate Ridesharing of Personal Vehicles Problem. Proc. of the 2020 International COCOA. LNCS 12577:3-18, 2020.
[14] H. Huang, D. Bucher, J. Kissling, R. Weibel and M. Raubal. Multimodal route planning with public transport and carpooling. IEEE Transactions on Intelligent Transportation Systems, pp 1-13, 2019.
[15] R. M. Karp. Reducibility Among Combinatorial Problems. In R.E. Miller; J.W. Thatcher; J.D. Bohlinger (eds.). Complexity of Computer Computations. New York: Plenum. pp. 85103, 1972.
[16] T.-Y Ma. On-demand dynamic Bi-/multi-modal ride-sharing using optimal passenger-vehicle assignments. In: 2017 EEEIC / I&CPS Europe, pp. 1-5, 2017.
[17] T.-Y Ma, S. Rasulkhani, J.Y.J. Chow and S. Klein. A dynamic ridesharing dispatch and idle vehicle repositioning strategy with integrated transit transfers. Transportation Research Part E: Logistics and Transportation Review, 128:417-442, 2019.
[18] A. Mourad, J. Puchinger and C. Chu. A survey of models and algorithms for optimizing shared mobility. Transportation Research Part B, 123:323-346, 2019.
30

[19] A. Raghunathan, D. Bergman, J. Hooker, T. Serra, S. Kobori. Seamless multimodal transportation scheduling, 2018.
[20] P. Santi, G. Resta, M. Szell, S. Sobolevsky, S.H. Strogatz and C. Ratti. Quantifying the benefits of vehicle pooling with shareability networks. Proceedings of the National Academy of Sciences (PNAS), 111(37):13290-13294, 2014.
[21] A. Santos, N. McGuckin, H.Y. Nakamoto, D. Gray, and S. Liss. Summary of travel trends: 2009 national household travel survey. Technical report, US Department of Transportation Federal Highway Administration, 2011.
[22] M. Stiglic, N. Agatz, M. Savelsbergh, and M. Gradisar. The benefits of meeting points in ride-sharing systems. Transportation Research Part B: Methodological, 82:36-53, 2015.
[23] M. Stiglic, N. Agatz, M. Savelsbergh, and M. Gradisar. Enhancing urban mobility: Integrating ride-sharing and public transit. Computers & Operations Research, 90:12-21, 2018.
[24] A. Tafreshian. N. Masoud and Y. Yin, Frontiers in Service Science: Ride Matching for Peerto-Peer Ride Sharing: A Review and Future Directions. Service Science, 12(2-3):41-60, 2020.
[25] H. Wang and A. Odoni. Approximating the performance of a "last mile" transportation system. Transportation Science, 50:659-675, 2014.
[26] Z. Xu, Y. Yin and J. Ye. On the supply curve of ride-hailing systems. Transportation Research Part B: Methodological, 132:29-43,2020.
31

