More Identifiable yet Equally Performant Transformers for Text Classification
Rishabh Bhardwaj1, Navonil Majumder1, Soujanya Poria1, Eduard Hovy2
1 Singapore University of Technology and Design, Singapore 2 Carnegie Mellon University, Pittsburgh, PA, USA rishabh bhardwaj@mymail.sutd.edu.sg
{navonil majumder, sporia}@sutd.edu.sg hovy@cs.cmu.edu

arXiv:2106.01269v1 [cs.CL] 2 Jun 2021

Abstract
Interpretability is an important aspect of the trustworthiness of a model's predictions. Transformer's predictions are widely explained by the attention weights, i.e., a probability distribution generated at its self-attention unit (head). Current empirical studies provide shreds of evidence that attention weights are not explanations by proving that they are not unique. A recent study showed theoretical justifications to this observation by proving the non-identifiability of attention weights. For a given input to a head and its output, if the attention weights generated in it are unique, we call the weights identifiable. In this work, we provide deeper theoretical analysis and empirical observations on the identifiability of attention weights. Ignored in the previous works, we find the attention weights are more identifiable than we currently perceive by uncovering the hidden role of the key vector. However, the weights are still prone to be non-unique attentions that make them unfit for interpretation. To tackle this issue, we provide a variant of the encoder layer that decouples the relationship between key and value vector and provides identifiable weights up to the desired length of the input. We prove the applicability of such variations by providing empirical justifications on varied text classification tasks. The implementations are available at https://github.com/declare-lab/ identifiable-transformers.
1 Introduction
Widely adopted Transformer architecture (Vaswani et al., 2017) has obviated the need for sequential processing of the input that is enforced in traditional Recurrent Neural Networks (RNN). As a result, compared to a single-layered LSTM or RNN model, a single-layered Transformer model is computationally more efficient, reflecting in a relatively shorter training time (Vaswani et al.,

2017). This advantage encourages the training of

deep Transformer-based language models on large-

scale datasets. Their learning on large corpora

has already attained state-of-the-art (SOTA) per-

formances in many downstream Natural Language

Processing (NLP) tasks. A large number of SOTA

machine learning systems even beyond NLP (Lu

et al., 2019) are inspired by the building blocks of

Transformer that is multi-head self-attention (Rad-

ford et al., 2018; Devlin et al., 2018).

A model employing an attention-based

mechanism generates a probability distribu-

tion a = {a1, . . . , an} over the n input units

z = {z1, . . . , zn}. The idea is to perform a

weighted sum of inputs, denoted by

n i=1

ai

zi

,

to produce a more context-involved output. The

attention vector, a, are commonly interpreted as

scores signifying the relative importance of input

units. However, counter-intuitively, it is recently

observed that the weights generated in the model

do not provide meaningful explanations (Jain and

Wallace, 2019; Wiegreffe and Pinter, 2019).

Attention weights are (structurally) identifiable

if we can uniquely determine them from the output

of the attention unit (Brunner et al., 2019). Iden-

tifiability of the attention weights is critical to the

model's prediction to be interpretable and repli-

cable. If the weights are not unique, explanatory

insights from them might be misleading.

The self -attention transforms an input sequence

of vectors z = {z1, . . . , zn} to a contextual-

ized output sequence y = {y1, . . . , yn}, where

yk =

n i=1

a(k,i)

zi.

The

scalar

a(k,i)

captures

how

much of the ith token contributes to the contextual-

ization of kth token. A Transformer layer consists

of multiple heads, where each head performs self-

attention computations, we break the head compu-

tations in two phases:

· Phase 1: Calculation of attention weights a(k,i). It involves mapping input tokens to

key and query vectors. The dot product of kth query vector and ith key vector gives a(k,i).
· Phase 2: Calculation of a contextualized representation for each token. It involves mapping input tokens to the value vectors. The contextualized representation for kth token can be computed by the weighted average of the value vectors, where the weight of ith token is a(k,i) computed in first phase.
The identifiability in Transformer has been recently studied by Brunner et al. (2019) which provides theoretical claims that under mild conditions of input length, attention weights are not unique to the head's output. Essentially their proof was dedicated to the analysis of the computations in the second phase, i.e., token contextualization. However, the theoretical analysis ignored the crucial first phase where the attention weights are generated. Intrinsic to their analysis, the attention identifiability can be studied by studying only the second phase of head computations. However, even if we find another set of weights from the second phase, it depends on the first phase if those weights can be generated as the part of key-query multiplication.
In this work, we probe the identifiability of attention weights in Transformer from a perspective that was ignored in Brunner et al. (2019). We explore the previously overlooked first phase of selfattention for its contribution to the identifiability in Transformer. During our analysis of the first phase, we uncover the critical constraint imposed by the size of the key vector1 dk. The flow of analysis can be described as
· We first show that the attention weights are identifiable for the input sequence length ds no longer than the size of value vector dv (§3.1) (Brunner et al., 2019)2.
· For the case when ds > dv, we analyse the attention weights as raw dot-product (logits) and the softmaxed dot-product (probability simplex), independently. An important theoretical finding is that both versions are prone to be unidentifiable.
· In the case of attention weights as logits (§3.2.1), we analytically construct another set of attention weights to claim the unidentifiability. In the case of attention weights as
1The size of key and query vector is expected to be the same due to the subsequent dot product operation
2The sequence length denotes number of tokens at input.

softmaxed logits (§3.2.2), we find the attention identifiability to be highly dependent on dk. Thus, the size of key vector plays an important role in the identifiability of the self-attention head. The pieces of evidence suggest that the current analysis in Brunner et al. (2019) ignored the crucial constraints from the first phase in their analysis.
To resolve the unidentifiability problem, we propose two simple solutions (§4). For the regular setting of the Transformer encoder where dv depends on the number of attention heads and token embedding dimension, we propose to reduce dk. This may lead to more identifiable attention weights. Alternatively, as a more concrete solution, we propose to set dv equal to token embedding dimension while adding head outputs as opposed to the regular approach of concatenation (Vaswani et al., 2017). Embedding dimension can be tuned according to the sequence length up to which identifiability is desired. We evaluate the performance of the proposed variants on varied text classification tasks comprising of ten datasets (§5).
In this paper, our goal is to provide concrete theoretical analysis, experimental observations, and possible simple solutions to identifiability of attention weights in Transformer. The idea behind identifiable variants of the Transformer is--the harder it is to obtain alternative attention weights, the likelier is they are identifiable, which is a desirable property of the architecture. Thus, our contribution are as follows:
· We provide a concrete theoretical analysis of identifiability of attention weights which was missing in the previous work by Brunner et al. (2019).
· We provide Transformer variants that are identifiable and validate them empirically by analysing the numerical rank of the attention matrix generated in the self-attention head of the Transformer encoder. The variants have strong mathematical support and simple to adopt in the standard Transformer settings.
· We provide empirical evaluations on varied text classification tasks that show higher identifiability does not compromise with the task's performance.

2 Background

2.1 Identifiability
A general trend in machine learning research is to mathematically model the input-output relationship from a dataset. This is carried out by quantitatively estimating the set of model parameters that best fit the data. The approach warrants prior (to fitting) examination of the following aspects:
· The sufficiency of the informative data to the estimate model parameters, i.e., practical identifiability. Thus, the limitation comes from the dataset quality or quantity and may lead to ambiguous data interpretations (Raue et al., 2009).
· The possibility that the structure of the model allows its parameters to be uniquely estimated, irrespective of the quality or quantity of the available data. This aspect is called structural identifiability. A model is said to be structurally unidentifiable if a different set of parameters yield the same outcome.
In this work, we focus on the structural identifiability (Bellman and A° stro¨m, 1970). It is noteworthy that the goodness of the fit of a model on the data does not dictate its structural identifiability. Similar to Brunner et al. (2019), we focus our analysis on the identifiability of attention weights, which are not model parameters, yet demands meaningful interpretations and are crucial to the stability of representations learned by the model.
2.2 Transformer Encoder Layer
We base our analysis on the building block of Transformer, i.e., the encoder layer (Vaswani et al., 2017). The layer has two sub-layers. First sublayer performs the multi-head self-attention, and second is feed-forward network. Given a sequence of tokens {x1, . . . , xds}, an embedding layer transforms it to a set of vector {z1, . . . , zds}  Rde, where de denotes token embedding dimension. To this set, we add vectors encoding positional information of tokens {p1, . . . , pds}  Rde.
Multi-head Attention. Input to a head of multihead self-attention module is W  Rds×de, i.e., a sequence of ds tokens lying in a de-dimensional embedding space. Tokens are projected to dq-size query, dk-size key, and dv-size value vectors using linear layers, resulting in the respective matrices Query Q  Rds×dq , Key K  Rds×dk , and Value

Figure 1: An illustration for a Transformer with two-head attention units. Triangles depict matrix weights. The left side shows concatenation of head outputs fed to a linear layer. The right side shows another interpretation of the same set of operations where we consider a linear transform applied to each head first. The transformed head outputs are then added.

V  Rds×dv . The attention weights A  Rds×ds can be computed by

Q KT

A = softmax

.

(1)

dq

The (i, j)th element of A shows how much of ith
token is influenced by jth token. The output of a head H  Rds×de is given by

H = A V D = A T,

(2)

where D  Rdv×de is a linear layer and the matrix T  Rds×de denotes the operation V D. The Rds×de output of multi-head attention can be ex-
pressed as a summation over H obtained for each head3. The ith row of multi-head output matrix corresponds to the de dimensional contextualized representation of ith input token. In the original work, Vaswani et al. (2017), the multi-head op-
eration is described as the concatenation of A V
obtained from each head followed by a linear transformation D  Rde×de. Both the explanations are
associated with the same sequence of matrix opera-
tions as shown in fig. 1.
In regular Transformer setting, a token vector is ti  {(zj + pj)}di=s 1 is de = 512 dimensional, number of heads h=8, size of dk=dq=dv=de/h=64.

Feed-Forward Network. This sub-layer performs the following transformations on each token representation at the output of a head:

y1 = Linear1(Norm(ti + head output for ti)) y2 = Norm(ti + ReLU(Linear2(y1)))

Linear1 and Linear2 are linear layers with 2048 and 512 nodes, respectively. Norm denotes minibatch layer normalization.
3For simplicity, we have omitted head indices.

3 Identifiability of Attention

The output of an attention head H is the product of A and T (eq. (2)). Formally, we define identifiability of attention in a head:

Definition 3.1. For an attention head's output H, attention weights A are identifiable if there exists a unique solution of A T = H.

The above definition can be reformulated as

Definition 3.2. A is unidentifiable if there exist an A~, (A~ = 0), such that (A + A~) is obtainable from
phase-1 of head computations and satisfy

(A + A~) T = A T = A~ T = 0. (constraint-R1)

Under this constraint, we get a~i T = 0 where a~i is the ith row of A~ . The set of vectors which when multiplied to T gets mapped to zero describes the left null space of T denoted by LN(T). The dimension of the left null space of T can be obtained by
taking the difference of the total number of rows (ds) and the number of linearly independent rows, i.e, rank of the matrix T denoted by rank(T). Let dim(·) denotes the dimension of a vector space,
then

LN(T) = {v | vT T = 0} (3)

dim LN(T) = ds - rank(T).

(4)

3.1 "A" is Identifiable for ds  dv

If dim(LN(T)) = 0 then LN(T) = {0}, it leads to the only solution of constraint-R1 that is A~ = 0. Therefore, the unidentifiabilty condition does not hold. Now we will prove such a situation exists when the number of tokens is not more than the size of value vector.
The matrix T in eq. (2) is product of ds × dv value matrix V and dv × de transformation D. We utilize the fact that the rank of product of two matrices P and Q is upper bounded by the minimum of rank(P) and rank(Q), i.e., rank(P Q)  min rank(P), rank(Q) . Thus, the upper bound on rank(T) in eq. (4) can be determined by

rank(T)  min rank(V), rank(D)

 min min(ds, dv), min(dv, de)

 min ds, dv, dv, de

(5)

 min ds, dv

(as de > dv)

= min ds, 64
where the last inequality is obtained for a head in the regular Transformer for which dv=64.

Figure 2: Numerical rank of T (IMDB) and dimension of its left null space are scattered in blue and red, respectively.

Numerical rank. To substantiate the bounds on rank(T) as derived above, we set up a model with a single encoder layer (§6). The model is trained to predict the sentiment of IMDB reviews (§5). We feed the review tokens to the model and store the values generated in T of the first head. A standard technique for calculating the rank of a matrix with floating-point values and computations is to use singular value decomposition. The rank of the matrix will be computed as the number of singular values larger than the predefined threshold4. The fig. 2 illustrates how the rank changes with the sequence length ds. The numerical rank provides experimental support to the theoretical analysis.

rank(T) =

ds if ds  dv, dv if ds > dv.

(6)

Thus,

dim LN(T) = ds - rank(T)

=0

if ds  dv,

(ds - dv) if ds > dv.

= max (ds - dv, 0) (7)
With this, we infer A is identifiable if ds  dv = 64. For the identifiability study, since we focus on

a model's capability of learning unique attention weights, we will assume T has the maximum ob-

tainable rank set by its upper bound.

3.2 Idenitifiability when ds > dv (the hidden role of dk)
In this case, from eq. (7), we obtain a non zero value of dim LN(T) . It allows us to find infinite A~ 's satisfying (A + A~ ) T = A T. However,
4The threshold value is max(ds, de)  eps  || T ||2. The eps is floating-point machine epsilon value, i.e., 1.19209e-07 in our experiments

constraint-R1 demands A~ to be obtainable from the first phase of self-attention. As a first step, we focus our analysis on the attention matrix without applying softmax non-linearity, i.e., A = QKT . The
dq
analysis is crucial to identify constraints coming from the first phase of self-attention in Transformer that impact identifiability. Insights from this will help us analyse softmax version of A.

3.2.1 Attention Weights as Logits
Since the logits matrix A is obtained from the product of Q and KT , we can assert that

rank(A)  min rank(Q), rank(KT )

 min de, dk, dq, de

(8)

= dk.

Therefore, the rank of attention matrix producible by the head in the first phase of self-attention can at most be equal to the size of key vectors dk. On this basis, the head can produce only those A + A~ satisfying

rank(A + A~ )  dk

(constraint-R2)

Proposition 3.3. There exists a non-trivial A~ that satisfy (A + A~) T = A T and constraint-R2. Hence,
A is unidentifiable.

Proof. Let a1, . . . , ads and a~1, . . . , a~ds denote rows of A and A~ , respectively. Without the loss

of generality, let a1, . . . , adk be linearly indepen-

dent rows. For all j > dk, aj can be repre-

sented as a linear combination

dk i=1

ji ai,

where

ji is a scalar. Next, we independently choose first k rows of A~ that are {a~1, . . . , a~dk } from

LN(T). From the same set of coefficients of

linear combination ji for i  {1, . . . , dk} and j  {dk+1, . . . , ds}, we can construct jth row of A~

as a~j =

dk i=1

ji

a~i.

Now,

since

we

can

construct

the jth row of (A + A~ ) from the linear combina-

tion of its first dk rows as

dk i=1

ji (ai

+

a~i),

the

rank of (A + A~ ) is not more than dk. For a set of

vectors lying in a linear space, a vector formed by

their linear combination should also lie in the same

space. Thus, the artificially constructed rows of A~ belongs to LN(T). Therefore, there exist an A~

that establishes the proposition which claims the

unidentifiability of A.

3.2.2 Attention Weights as Softmaxed Logits
The softmax over attention logits generates attention weights with each row of A (i.e., ai's) is constrained to be a probability distribution. Hence, we can define constraint over A~ as

(A + A~ )  0

(P1)

A~ T = 0

(P2)

A~ 1 = 0.

(P3)

P1 is non-negativity constraint on (A + A~ ) as it

is supposed to be the output of softmax; P2 denotes A~  LN(T); P3 can be derived from the fact (A + A~ )1 = 1 = (A 1 + A~ 1) = 1 = A~ 1 = 0
as (A 1 = 1). Where 1  Rds is the vector of

ones. The constraint in P2 and P3 can be combined and reformulated as A~ [T, 1] = 0. Following

the similar analysis as in eq. (7), we can obtain

dim LN([T, 1]) = max ds - (dv + 1), 0 . Dis-
regarding the extreme cases when ai is a one-hot
distribution, Brunner et al. (2019) proved the existence and construction of non-trivial A~ 's satisfying all the constraints P1, P2, and P3.5

However, the proof by Brunner et al. (2019)

missed the constraint-R2, hence the existence of a non-trivial A~ satisfying only the set of constraints

P1, P2 and P3 may not be a valid proposition to

claim attention weights unidentifiability. Essen-

tially, the work largely ignored the constraints com-

ing from the rank of the matrix that produces A

after softmax 6. Let Al denote logits

QKT
dq

and softmax(Al) = (A + A~ ), where softmax is

operated over each row of Al. We add an extra

constraint on Al

rank(Al)  dk.

(P4)

The constraint P4 confirms if there exists a logit matrix Al that can generate (A + A~ ), given constraints P1, P2, and P3 are satisfied. The possibility of such an Al will provide sufficient evidence that A is unidentifiable. Next, we investigate how the existence of A~ is impacted by the size of key vector dk (query and key vector sizes are the same, i.e., dq =dk ).
Let (A + A~ )(i, k) denotes (i, k)th element of the matrix. We can retrieve the set of matrices Al such that softmax(Al) = A + A~ , where
Al(i, k) = ci + log(A + A~ )(i, k) (9)
5For the sake of brevity, we skip the construction method. 6(input to the softmax is equivalent to A in §3.2.1)

Figure 3: Column vectors (c + ^ak) of Al, where a(i,k) represents log(A + A~ )(i, k).
for some arbitrary ci  R; log denotes natural logarithm. As shown in fig. 3, the column vectors of Al can be written as c + ^a1, . . . , c + ^ads.
For an arbitrarily picked A~ satisfying constraint P1, P2, and P3, the dimensions of affine span S of {^a1, . . . , ^ads} could be as high as ds - 1 (fig. 4). In such cases, the best one could do is to choose a ca  S such that the dimension of the linear span of {^a1 - ca, . . . , ^ads - ca}, i.e., rank(Al) is ds - 1. Hence, to satisfy P4, ds - 1  dk = ds  dk + 1. Thus, the set of (A + A~ ) satisfying constraint P1, P2 and P3 are not always obtainable from attention head for ds > dk. We postulate
Although it is easier to construct A~ satisfying constraints P1, P2 and P3, it is hard to construct A~ satisfying constraint P4 over the rank of logit matrix Al. Therefore, A becomes more identifiable as the size of key vector decreases.

with token sequence length ds ranging from 66 to 128 7. For each review, we construct 1000 A~ 's satisfying constraints P1, P2, and P3 --
First, we train a Transformer encoder-based IMDB review sentiment classifier (§6). We obtain an orthonormal basis for the left null space of [T, 1] using singular value decomposition. To form an A~ , we generate ds random linear combinations of the basis vectors (one for each of its row). Each set of linear combination coefficients is sampled uniformly from [-10, 10]. All the rows are then scaled to satisfy the constraint P1 as mentioned in Brunner et al. (2019). Using eq. (9), we obtain a minimum rank matrix Al's by putting c = -^a1. Figure 5 depicts the obtained numerical rank of Al. We observed all the obtained Al from (A + A~ ) (using eq. (9)) are full-row rank matrices. However, from the first phase of self-attention, the maximum obtainable rank of Al is dk = 64. Thus, the experimentally constructed Al's do not claim unidentifiability of A as it fails to satisfy the constraint P4, while for Brunner et al. (2019), it falls under the solution set to prove unidentifiability as it meets constraints P1, P2 and P3.

Figure 4: This is a simplified illustration for the case ds = 3. Affine space (translated linear subspace) spanned by vectors ^a1, ^a2 and ^a3. ca can be any arbitrary vector in affine space. By putting c = -ca, we can obtain a linear subspace whose rank is equal to rank of the affine subspace.
Experimental evidence. We conduct an experiment to validate the minimum possible numerical rank of Al by constructing A~ . For A~ to be obtainable from the phase 1, the minimum possible rank of Al should not be higher than dk. From IMDB dataset (§5), we randomly sample a set of reviews

Figure 5: The blue curve denotes the expected rank of Al's obtained from (A + A~ ), where A~ satisfies the constraints P1, P2, and P3. The red curve denotes the maximum permissible rank of Al that is obtainable from phase 1 of the head.
4 Solutions to Identifiability
Based on the Identifiability analysis in §3, we propose basic solutions to make Transformer's attention weights identifiable.
Decoupling dk. Contrary to the regular Transformer setting where dk = dv, a simple approach is to decrease the value of dk that is the size of the key and query vector. It will reduce the possible
7dim LN(T, 1) > 0 for ds > dv + 1 = 65

solutions of A~ by putting harder constraints on the rank of attention logits, i.e., Al in eq. (9). However, theoretically, dk decides the upper bound on dimensions of the space to which token embeddings are projected before the dot product. Higher the upper bound, more degree of freedom to choose the subspace dimensions as compared to the lower dk variants. Thus, there is a plausible trade-off when choosing between dk induced identifiability and the upper bound on the dimension of projected space.
Head Addition. To resolve the unidentifiability issue when sequence length exceeds the size of value vector, we propose to keep the value vector size and token embedding dimension to be more than (or equal to) the maximum allowed input tokens, i.e., dv  ds-max. In Vaswani et al. (2017), dv was bound to be equal to de/h, where de is token embedding dimension and h is number of heads. This constraint on dv is because of the concatenation of h self-attention heads to produce de-sized output at the first sub-layer of the encoder. Thus, to decouple dv from this constraint, we keep dv = de and add each head's output.8
5 Classification Tasks
For the empirical analysis of our proposed solutions as mentioned in §4, we conduct our experiments on the following varied text classification tasks:
5.1 Small Scale Datasets
IMDB (Maas et al., 2011). The dataset for the task of sentiment classification consist of IMDB movie reviews with their sentiment as positive or negative. Each of the train and test sets contain 25,000 data samples equally distributed in both the sentiment polarities.
TREC (Voorhees and Tice, 2000). We use the 6-class version of the dataset for the task of question classification consisting of open-domain, facet-based questions. There are 5,452 and 500 samples for training and testing, respectively.
SST (Socher et al., 2013). Stanford sentiment analysis dataset consist of 11,855 sentences obtained from movie reviews. We use the 3-class version of the dataset for the task of sentiment classification. Each review is labeled as positive, neutral, or negative. The provided train/test/valid split is 8,544/2,210/1,101.
8ds-max < de as in the regular Transformer setting.

5.2 Large Scale Datasets
SNLI (Bowman et al., 2015). The dataset contain 549,367 samples in the training set, 9,842 samples in the validation set, and 9,824 samples in the test set. For the task of recognizing textual entailment, each sample consists of a premisehypothesis sentence pair and a label indicating whether the hypothesis entails the premise, contradicts it, or neutral.
Please refer to Zhang et al. (2015) for more details about the following datasets:
Yelp. We use the large-scale Yelp review dataset for the task of binary sentiment classification. There are 560,000 samples for training and 38,000 samples for testing, equally split into positive and negative polarities.
DBPedia. The Ontology dataset for topic classification consist of 14 non-overlapping classes each with 40,000 samples for training and 5,000 samples for testing.
Sogou News. The dataset for news article classification consist of 450,000 samples for training and 60,000 for testing. Each article is labeled in one of the 5 news categories. The dataset is perfectly balanced.
AG News. The dataset for the news articles classification partitioned into four categories. The balanced train and test set consist of 120,000 and 7,600 samples, respectively.
Yahoo! Answers. The balanced dataset for 10class topic classification contain 1,400,000 samples for training and 50,000 samples for testing.
Amazon Reviews. For the task of sentiment classification, the dataset contain 3,600,000 samples for training and 400,000 samples for testing. The samples are equally divided into positive and negative sentiment labels.
Except for the SST and SNLI, where the validation split is already provided, we flag 30% of the train set as part of the validation set and the rest 70% were used for model parameter learning.
6 Experimental Setup
Setting up the encoder. We normalize the text by lower casing, removing special characters, etc.9
9https://pytorch.org/text/_modules/ torchtext/data/utils.html

For each task, we construct separate 1-Gram vocabulary (U ) and initialize a trainable randomly sampled token embedding (U × de) from N (0, 1). Similarly, we randomly initialize a (ds-max × de) positional embedding.
The encoder (§2.2) takes input a sequence of token vectors (ds × de) with added positional vectors. The input is then projected to key and query vector of size dk  {1, 2, 4, 8, 16, 32, 64, 128, 256}. For the regular Transformer setting, we fix the number of heads h to 8 and the size of value vector dv = de/h that is 64. For each token at the input, the outputs of attention heads are concatenated to generate a de-sized vector. For the identifiable variant of the Transformer encoder, dv = de = 512, this is equal to ds-max to keep it identifiable up to the maximum permissible number of tokens. The outputs of all the heads are then added. Each token's contextualized representations (added head outputs) are then passed through the feed-forward network (§2.2). For classification, we use the encoder layer's output for the first token and pass it through a linear classification layer. In datasets with more than two classes, the classifier output is softmaxed. In the case of SNLI, we use the shared encoder for both premise and hypothesis; the output of their first tokens is then concatenated just before the final classification layer. We use Adam optimizer, with learning rate =0.001, to minimize the cross-entropy loss between the target and predicted label. For all the experiments, we keep the batch size as 256 and train for 20 epochs. We report the test accuracy obtained at the epoch with the best validation accuracy.
Numerical rank. To generate the numerical rank plot on IMDB dataset as shown in fig. 2, we train a separate Transformer encoder-based classifier. For a particular ds value, we sample 100 reviews from the dataset with token length  ds and clip each review to the maximum length ds. The clipping will ensure the number of tokens is ds before feeding it to the encoder. The numerical rank is calculated for T's obtained from the first head of the encoder.
7 Results and Discussion
For the identifiable variant, similar to §3.1, we plot the numerical rank of T with input sequence length as shown in fig. 6. Unlike fig. 2, where dim LN(T) linearly increases after ds = 64, we find the dimension is zero for a larger ds ( 380). The zero dimensional (left) null space of T con-

firms there exist no nontrivial solution to the constraint constraint-R2, i.e., A~ = {0}. Thus, the attention weights A are identifiable for a larger range of length of the input sequence.
Figure 6: Scatter plots in red and blue show rank(T) and dim LN(T) , respectively, for matrices T obtained from the second phase of attention by feeding IMDB samples to the encoder. The green line shows the desired rank(T) for which dim LN(T) = 0 and thus attention weights are identifiable.
It is important that the identifiability of attention weights should not come at the cost of reduced performance of the model. To investigate this issue, we compare the performance of the identifiable Transformer encoder against its regular settings (§6) on varied text classification tasks.
For the regular setting, as discussed in §4 as one of the solutions, the Transformer can be made identifiable by decreasing the size of the key vector dk. The rows of the Table 1 corresponding to Con denotes regular Transformer setting with varying size of key vector. We observe the classification accuracy at the lower dk is comparable or higher than large dk values, thus, the enhanced identifiability does not compromise with the model's classification accuracy. However, we notice a general performance decline with an increase in the size of the key vector. We speculate that for simple classification tasks, the lower-dimensional projection for key and query vector works well. However, as the task becomes more involved, a higher dimension for the projected subspace could be essential. Nonetheless, as we do not have strong theoretical findings, we leave this observation for future work.
Another solution to identifiability is to increase dv to de and add the heads' outputs. This setting corresponds to the Add rows in the Table 1. For key vector size dk= 1, 2, and 4, We find the identifiable Transformer's performance is comparable

Dataset IMDB TREC SST SNLI Yelp DBPedia Sogou AG News Yahoo Amazon

Version
Con Add Con Add Con Add Con Add Con Add Con Add Con Add Con Add Con Add Con Add

1 0.884 0.888 0.836 0.841 0.643 0.599 0.675 0.683 0.913 0.914 0.979 0.979 0.915 0.915 0.906 0.902 0.695 0.697 0.924 0.925

2 0.888 0.885 0.836 0.842 0.625 0.618 0.674 0.677 0.911 0.915 0.977 0.978 0.907 0.908 0.903 0.908 0.690 0.695 0.925 0.923

Size of key vector (dk)

4

8 16 32 64

0.886 0.888 0.846 0.824 0.803

0.887 0.884 0.886 0.882 0.877

0.840 0.822 0.823 0.764 0.786

0.835 0.842 0.841 0.836 0.809

0.627 0.609 0.603 0.582 0.574

0.628 0.633 0.628 0.629 0.592

0.673 0.672 0.662 0.659 0.659

0.674 0.676 0.673 0.669 0.663

0.907 0.898 0.879 0.862 0.857

0.916 0.914 0.915 0.916 0.910

0.977 0.971 0.966 0.961 0.957

0.979 0.977 0.978 0.973 0.970

0.898 0.900 0.893 0.888 0.868

0.906 0.904 0.913 0.914 0.910

0.904 0.904 0.886 0.877 0.870

0.907 0.906 0.897 0.899 0.901

0.684 0.664 0.644 0.627 0.616

0.696 0.693 0.693 0.694 0.688

0.923 0.922 0.900 0.892 0.887

0.925 0.924 0.924 0.920 0.907

128 0.788 0.832 0.706 0.809 0.573 0.581 0.655 0.664 0.849 0.909 0.951 0.969 0.858 0.906 0.870 0.897 0.597 0.649 0.882 0.896

256 0.755 0.825 0.737 0.771 0.554 0.586 0.648 0.655 0.837 0.891 0.949 0.964 0.838 0.899 0.869 0.893 0.574 0.683 0.873 0.889

Table 1: The test accuracy on varied text classification tasks spread over ten datasets. Con means the regular concatenation of heads with dv = de/h, Add denotes encoder variant where dv = de and outputs of heads are added. In the regular Transformer encoder Con, the concatenation of dv-sized output of h heads followed by de × de linear transformation can be understood as first doing linear dv × de linear transform of each head and then addition of the transformed output (fig. 1). In the Add variant, we first add h dv-sized head outputs followed by de × de linear transformation.

to the regular settings. For dk  8, as a general observation, we find the performance of Add does not drop as drastically as Con with an increase in dk. This could be due to the larger size of value vector leading to the more number of parameters in Add that compensate for the significant reduction in the model's accuracy.
On the large-scale datasets, we observe that Add performs slightly better than Con. Intuitively, as shown in fig. 1, we can increase the size of value vector to increase the dimension of the space on which each token is projected. A higher dimensional subspace can contain more semantic information to perform the specific task.
Even though the theoretical analysis shows the possibility of a full row rank of T and identifiable attention weights, the T obtained from a trained model might not contain all the rows linearly independent as ds increases. We can explain this from the semantic similarities between words cooccurring together (Harris, 1954). The similarity is captured as the semantic relationship, such as dot product, between vectors in a linear space. As the number of tokens in a sentence, i.e., ds increases, it becomes more likely to obtain a token vector from the linear combination of other tokens.

8 Conclusion
This work probed Transformer for identifiability of self-attention, i.e., the attention weights can be uniquely identified from the head's output. With theoretical analysis and supporting empirical evidence, we were able to identify the limitations of the existing study by Brunner et al. (2019). We found the study largely ignored the constraint coming from the first phase of self-attention in the encoder, i.e., the size of the key vector. Later, we proved how we can utilize dk to make the attention weights more identifiable. To give a more concrete solution, we propose encoder variants that are more identifiable, theoretically as well as experimentally, for a large range of input sequence lengths. The identifiable variants do not show any performance drop when experiments are done on varied text classification tasks. Future works may analyse the critical impact of identifiability on the explainability and interpretability of the Transformer.
Acknowledgments
This research is supported by A*STAR under its RIE 2020 Advanced Manufacturing and Engineering programmatic grant, Award No.­ A19E2b0098.

References
Ror Bellman and Karl Johan A° stro¨m. 1970. On structural identifiability. Mathematical biosciences, 7(34):329­339.
Samuel R Bowman, Gabor Angeli, Christopher Potts, and Christopher D Manning. 2015. A large annotated corpus for learning natural language inference. arXiv preprint arXiv:1508.05326.
Gino Brunner, Yang Liu, Damian Pascual, Oliver Richter, Massimiliano Ciaramita, and Roger Wattenhofer. 2019. On identifiability in transformers. arXiv preprint arXiv:1908.04211.
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.

Ellen M. Voorhees and Dawn M. Tice. 2000. The TREC-8 question answering track. In Proceedings of the Second International Conference on Language Resources and Evaluation (LREC'00), Athens, Greece. European Language Resources Association (ELRA).
Sarah Wiegreffe and Yuval Pinter. 2019. Attention is not not explanation. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLPIJCNLP), pages 11­20.
Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015. Character-level convolutional networks for text classification. arXiv preprint arXiv:1509.01626.

Zellig S Harris. 1954. Distributional structure. Word, 10(2-3):146­162.

Sarthak Jain and Byron C Wallace. 2019. Attention is not explanation. arXiv preprint arXiv:1902.10186.

Jiasen Lu, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks. In Advances in Neural Information Processing Systems, pages 13­23.

Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. 2011. Learning word vectors for sentiment analysis. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 142­150, Portland, Oregon, USA. Association for Computational Linguistics.

Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training.

Andreas Raue, Clemens Kreutz, Thomas Maiwald, Julie Bachmann, Marcel Schilling, Ursula Klingmu¨ller, and Jens Timmer. 2009. Structural and practical identifiability analysis of partially observed dynamical models by exploiting the profile likelihood. Bioinformatics, 25(15):1923­1929.

Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D Manning, Andrew Y Ng, and Christopher Potts. 2013. Recursive deep models for semantic compositionality over a sentiment treebank. In Proceedings of the 2013 conference on empirical methods in natural language processing, pages 1631­1642.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in neural information processing systems, pages 5998­6008.

A Background on Matrices
A.1 Span, Column space and Row space
Given a set of vectors V := {v1, v2, . . . , vn}, the span of V, span(V), is defined as the set obtained from all the possible linear combination of vectors in V, i.e.,
n
span(V) := { ivi | i  R, i  {1, 2, . . . , n}}.
i=1
The span(V) can also be seen as the smallest vector space that contains the set V.
Given a matrix A  Rm×n, the column space of A, Cs(A), is defined as space spanned by its column vectors. Similarly, the row space of A, Rs(A), is the space spanned by the row vectors of A. Cs(A) and Rs(A) are the subspaces of the real spaces Rm and Rn, respectively. If the row vectors of A are linearly independent, the Rs(A) will span Rm. A similar argument holds between Cs(A) and Rn.
A.2 Matrix Rank
The rank of a matrix P (denoted as rank(P)) tells about the dimensions of the space spanned by the row vectors or column vectors. It can also be seen as the number of linearly independent rows or columns. The following properties hold
rank P  min mp, np
rank P Q  min rank(P), rank(Q) .
Where, P and Q are mp × np and mq × nq dimensional matrices, respectively.
A.3 Null Space
The left null space of a mp × np matrix P can be defined as the set of vectors v -
LN P = {vT  R1×mp | vT P = 0} (10)
If the rows of P are linearly independent (P is full-row rank) the left null space of P is zero dimensional. The only solution to the system of equations v P = 0 is trivial, i.e., v=0. The dimensions of the null space, known as nullity, of P can be calculated as
dim LN(P) = mp - rank(P). (11) The nullity of P sets the dimensions of the space v lies in. In §3, we utilize our knowledge of appendix A.2 and appendix A.3 to analyse identifiability in a Transformer.

