Towards Verification of Dynamic Quantum Circuits

arXiv:2106.01099v1 [quant-ph] 2 Jun 2021

(New Ideas and Emerging Results Paper)

Lukas Burgholzer

Robert Wille

Institute for Integrated Circuits, Johannes Kepler University Linz, Austria

Software Competence Center Hagenberg GmbH (SCCH), Austria

lukas.burgholzer@jku.at

robert.wille@jku.at

https://iic.jku.at/eda/research/quantum/

Abstract--Quantum computers are reaching a level where interactions between classical and quantum computations can happen in real-time. This marks the advent of a new, broader class of quantum circuits: dynamic quantum circuits. They offer a broader range of available computing primitives that lead to new challenges for design tasks such as simulation, compilation, and verification. Due to the non-unitary nature of dynamic circuit primitives, existing techniques for these tasks are no longer applicable in an out-of-the-box fashion. In this work, we discuss the resulting consequences for quantum circuit verification and present first ideas for corresponding automatic methods. More precisely, we propose two different schemes that eventually allow to treat the involved circuits as if they were not dynamic at all. By this, we provide a basis for applying existing techniques for quantum circuit verification to this broader class of circuits.
Index Terms--quantum computing, equivalence checking, verification, dynamic circuits
I. INTRODUCTION
Capabilities of quantum computers built today are steadily growing. New devices do not only feature more and more qubits which are less prone to errors, but also allow for a much tighter classical control loop. This is witnessed by the recently published OpenQASM 3.0 specification by IBM [1] and the ability to perform conditional resets on IBM's quantum computers [2]. Through the interaction of classical computation with the gates and measurements of a quantum circuit, new computing primitives such as mid-circuit measurements, mid-circuit resets, and classically-controlled operations become possible. This marks the advent of a new, broader class of circuits: dynamic quantum circuits.
With these rapid advances in physical realizations also comes the need for quantum software that aids developers and users to keep up with this pace. Otherwise, we might end up in situation where we have powerful quantum computers available, but no efficient means to use them. Besides challenges, e.g., for classical/quantum design and compilation in general, this also poses new challenges for quantum circuit verification.
Verification of quantum circuits (sometimes also referred to as equivalence checking) is an essential part in the design flow for modern quantum computing. It checks whether two supposably equivalent quantum circuits G and G indeed realize the same functionality. Important applications include (1) ensuring that the originally intended functionality of a quantum algorithm is preserved throughout the whole compilation process that the algorithm's circuit representation undergoes in order to be executable on an actual device, or (2)

that alternative (e.g., optimized) realizations of certain building blocks in quantum circuits are functionally equivalent to their original implementation.
In the past, several complementary approaches have been proposed for tackling this problem [3]­[12]. However, practically all of these approaches expect the underlying functionality to be unitary--which circuits containing dynamic circuit primitives no longer are. As such, none of the existing techniques for verifying quantum circuits are applicable in an out-of-the-box fashion.
In this work, we discuss the resulting consequences for quantum circuit verification and show that reinventing the wheel is not necessary in order to use existing tools for verifying this broader class of circuits. To this end, we propose two different schemes targeted at two slighlty different verification scenarios.
First, we consider the question whether two circuits G and G which might contain dynamic circuit primitives are functionally equivalent as a whole. We show that any dynamic quantum circuit can be transformed to a circuit only containing unitary operations. By transforming the dynamic circuit primitives in this fashion, all existing techniques for verifying quantum circuits can be employed for the broader class of dynamic circuits.
Second, we consider the question whether two circuits G and G are functionally-equivalent given a fixed input state. We show how to extract the output state vector of a dynamic circuit, as if it did not contain dynamic circuit primitives, by cleverly applying classical quantum circuit simulation. Any existing quantum circuit simulator might be utilized to realize the proposed scheme.
Overall, this provides the basis for addressing the upcoming challenges in the verification of dynamic quantum circuits by exploiting the available state of the art in quantum circuit verification to a full extent.
The rest of this work is structured as follows. Section II provides the necessary background and motivation for this work. Then, Section III introduces dynamic circuits and explains the resulting problem for quantum circuit verification in detail, along with the general idea of solving this problem. Section IV elaborates on the first proposed scheme, while Section V presents the second one. Finally, we provide some discussion about both methods and conclude in Section VI.

|q2 = |0 |q1 = |0 |q0 = |0
| = |1

H

H

H
3 8

6 12 88

T S H S H H

q1 : |0 H

H

 4

-

 4

 8

-

 8

c0

c2

3

4

q0 : |0 H

c1

3 8

-

 4

c0

q2 : |0 H

 : |0 X

-

3 4

3 4

-

3 8

3 8

3 16

-

 8

H

-

3 16

3 16

-

 4

H

c2

 4

-

 4

c1

|0

(a) Original circuit

(b) Compiled to 5-qubit IBMQ London

Fig. 1.

3-bit

precision

QPE

circuit

for

U

=

p

(

3 8

)

and

|

= |1 , resulting in estimate ~ = 0.c2c1c0

II. BACKGROUND AND MOTIVATION
Throughout this work, we assume that the reader is familiar with the basic principles of quantum computing. This section establishes the notation used in the remainder of this work and provides the necessary background information on quantum circuits. We also review the Quantum Phase Estimation algorithm (which is used as a running example) and motivate the importance of verifying quantum circuits. While the individual descriptions are kept brief, we refer the unacquainted reader to the provided references for further details.
A. Quantum Circuits
In the traditional quantum circuit model [13]­[15] a quantum circuit G, acting on n qubits, is specified by a sequence of quantum gates g0, . . . , g|G|-1. Each quantum gate gi, acting on k  n qubits (most frequently k = 1 or k = 2), can be described by a unitary 2k × 2k matrix Ui.
Given an initial state | (represented as a 2n-dimensional state vector), the evolution of this initial state under the quantum circuit can be described by successively multiplying the individual gate matrices with the current state vector1. Eventually, performing all multiplications results in a final state vector that encodes the probabilities of measuring the individual computational basis states. When conducted on a classical computer, we typically speak of (classical) quantum circuit simulation.
B. Quantum Phase Estimation
The key ideas of this work will be illustrated by means of a particular quantum algorithm, namely Quantum Phase Estimation (QPE, [15]), which represents one of the key subroutines in important quantum algorithms such as Shor's algorithm [16] for factoring numbers, the HHL algorithm [17] for solving linear systems, or quantum principal component analysis [18] for machine learning. It solves the problem of determining the eigenvalue (i.e., the phase) of a unitary operator U given an eigenvector state | , i.e., determining   [0, 1) such that
U | = e2i | .
To this end, the QPE algorithm calculates an m-bit estimate ~ = 0.cm-1 . . . c0 of . First, controlled-U 2k operations (k = 0, . . . , m - 1) are used to write the m-bit Fourier basis
1Before being applied to the state vector, the individual gate matrices have to be extended to the full system size by forming tensor products with identity matrices. We slightly abuse the notation and reuse the symbols Ui also for the extended matrices whenever the meaning is apparent from the context.

representation of U 's phase to an m-qubit register. Afterwards,

the inverse quantum Fourier transform (QFT, [15]) is applied

to transform the result to the computational basis. Whenever 

is representable using m bits, the algorithm succeeds with

certainty, while otherwise, it yields a suitably high chance

for

success

(with

a

probability

larger

than

4 2

 0.405).

An

example illustrates the idea.

Example

1.

Assume

U

is

given

by

p(

3 8

)

=

diag

(1,

e2i

3 16

)

and | = |1 . Then, Fig. 1a shows the quantum circuit realiz-

ing the 3-bit precision QPE algorithm. It applies three rounds

of controlled-Z rotations and then uses the three-qubit inverse

Fourier transform to obtain the desired estimate ~ = 0.c2c1c0

from

the

measurement

results.

Since



=

3 16

=

0.0011

cannot

be exactly represented using three fractional bits, running the

algorithm yields |001 and |010 as the most probable output

states.

C. Verification of Compilation Results
Executing a quantum algorithm on an actual quantum computer requires compiling the algorithm's description G to a representation G that adheres to all constraints imposed by the targeted device. This typically involves several steps such as synthesis [14], [19]­[21], mapping [22]­[27], and optimizations [28]­[30].
Example 2. Quantum computers manufactured by IBM natively support arbitrary single-qubit operations and the two-qubit controlled-NOT (or CNOT) operation [31]. A possible realization of the QPE circuit from Fig. 1a on the five-qubit, T -shaped IBMQ London architecture [32] is shown in Fig. 1b. It requires a total of two SWAPs to conform to the architecture's coupling map and consists of 25 single-qubit and 18 CNOT operations.
Verifying that the original circuit's functionality is preserved throughout the individual stages of the compilation process is a vital task in the quantum computing design flow. In general, the functionality of a quantum circuit G = g0, . . . , g|G|-1 is represented by the 2n × 2n system matrix U = U|G|-1 · · · U0. Thus, comparing the functionality of two quantum circuits G and G reduces to the comparison of the respective system matrices U and U . While conceptually simple, this quickly amounts to a non-trivial task due to the fact that the involved matrices grow exponentially with respect to the number of qubits. Although equivalence checking of quantum circuits has even been shown to be QMA-complete [33], several methods for tackling this problem have been proposed [3]­[12].

III. DYNAMIC CIRCUITS AND RESULTING PROBLEM
The circuit model of quantum computing, as discussed in the previous section, has been the de-facto standard for designing quantum circuits to be executed on the current generation of quantum computers. However, this describes quantum circuits in a static fashion--with no opportunity to stir the computation in some direction based on outcomes of intermediate results. Recently, IBM announced that their quantum computers now allow for interactions with classical computing instructions within the runtime of a quantum circuit [2]. These "real-time compute capabilities" enable what IBM refers to as dynamic quantum circuits. In the following, we describe what constitutes these new kind of circuits and discuss the resulting challenges for verifying quantum circuits that might contain dynamic circuit primitives.

A. Dynamic Quantum Circuits and Their Benefits

By allowing the interaction of real-time classical computations with the gates and measurements of traditional quantum circuits, the quantum circuit model reviewed in Section II-A is extended by primitives such as mid-circuit measurement, mid-circuit reset, and classically-controlled quantum operations. As a consequence, circuits are no longer static, but rather dynamic.
Eventually, these primitives will be necessary for quantum computers to achieve fault-tolerance by realizing quantum error correction schemes. However, already in the near term, interesting use cases for teleportation [34] and new algorithms like iterative QPE [35] or repeat until success [36] arise that employ dynamic circuit primitives in order to, e.g., reduce the required number of qubits--a limited resource thus far.
For example, even our running example, i.e., the QPE algorithm reviewed in Section II-B, may exploit dynamic circuit primitives to reduce the number of qubits at the cost of multiple measurements: Instead of an m-qubit register for computing the Fourier base representation of the unitary's phase, a single qubit is used and repeatedly measured. Starting from the least significant bit of the resulting estimate ~ = 0.cm-1 . . . c0, each measurement adds one bit of information to the estimated phase. The result of each measurement then influences the rotation angles applied to the working qubit in the next iteration. This requires the availability of the measurement results and application of quantum operations based on them within the coherence time of the quantum computer's qubits. One of the first realizations of the Iterative Quantum Phase Estimation (IQPE) algorithm on an actual system has recently been demonstrated by researchers from IBM Quantum on one of their devices [37].

Example 3. Assume again that, as in Example 1, we want

to iteratively estimate the phase  of the unitary operator

U

=

p(

3 8

)

corresponding

to

the

eigenvector

state

|

= |1

up to a precision of three bits. Fig. 2 shows an alternative

quantum circuit that utilizes dynamic circuit primitives. In-

stead of the 3-qubit register considered before in Fig. 1a, a

|q0 = |0 H

H

12
| = |1 8

c0 c1 c2

|0 H

-

 2

H

6 8

|0 H

-

 4

-

 2

H

3 8

Fig. 2. Dynamic version of the QPE circuit from Fig. 1a

single working qubit in combination with mid-circuit measurements, resets, and classically-controlled single-qubit rotations is used to iteratively compute individual bits of the phase estimate. Compiling this circuit to an actual device requires no SWAP operations at all, since only two qubits interact with each other. After decomposing the controlled phase gates, a circuit with 2 qubits, 15 single-qubit gates, 6 CNOT gates, 2 reset operations, and 3 classically-controlled single-qubit rotations results (in contrast to 4 qubits, 25 single-qubit, and 18 CNOT operations in the compiled circuit from Fig. 1b). As a consequence, the quantum cost of the resulting circuit is considerably reduced--significantly improving the expected fidelity when executing the circuit on an actual device.
B. Resulting Problem
Existing frameworks for verifying quantum circuits such as [3]­[12] generally assume the circuit to only contain unitary operations. Ultimately, only then can the functionality of a quantum circuit be characterized by a unitary matrix. With the availability of dynamic circuit primitives for conducting quantum computations, the question arises how circuits using these primitives can be verified. After all, resets, measurements, and classically-controlled operations are all non-unitary operations. As such, existing techniques cannot be applied in an outof-the-box fashion. In this work, we show that reinventing the wheel is not necessary to allow the usage of existing techniques in combination with dynamic circuits. To this end, we propose two different schemes targeted at two slightly different verification scenarios.
First, we consider the question whether two circuits G and G which might contain dynamic circuit primitives are functionally equivalent as a whole--an extremely important question when, e.g., evaluating alternative realizations of certain building blocks in large quantum algorithms such as the inverse QFT in the QPE algorithm or the oracle in Grover's search [38]. In any case, it has to be ensured that the alternative realization realizes the exact same functionality given any input. As already shown in Section II-C, given two circuits G and G which do not contain dynamic circuit primitives, this reduces to the comparison between the corresponding unitary matrices U and U . We will show in Section IV that any dynamic quantum circuit can be transformed to a circuit only containing unitary operations and no intermediate measurements. This way, all existing techniques for verifying the equivalence of two (static) quantum circuits can be employed for the broader class of dynamic circuits.

While the above technique conceptually allows to verify dynamic circuits, it requires to extend a circuits description by as many qubits as it contains mid-circuit resets. Due to the exponential scaling of the resulting unitary functionality, the complexity of verifying such instances may prove too much to handle for existing verification tools. The following observation helps to derive an alternative for these cases: In many quantum algorithms (such as, e.g., Grover's algorithm [38]), the initial state of the computation is fixed (e.g., to the all zero state |0 . . . 0 ). Hence, it might not be necessary at all to ensure that two circuits are fully functionally-equivalent, but rather that they produce functionally-equivalent output states for the fixed input state. In Section V, we show, that the output state vector of a dynamic circuit can be iteratively extracted from classically simulating the circuit using any available classical quantum circuit simulator.
IV. UNITARY RECONSTRUCTION THROUGH CIRCUIT TRANSFORMATION
Dynamic circuit primitives allow to reuse qubits over the course of a quantum computation and to influence the execution based on classical measurement outcomes. In order to employ existing verification tools for verifying circuits using these primitives, the circuit descriptions G and G have to be transformed in such a way, that comparisons of the form U =? U are possible. This is accomplished by transforming the dynamic circuit primitives to unveil the underlying unitary functionality.
Reset operations pose the first hurdle to overcome in this endeavour. Mathematically, resetting a qubit corresponds to computing the partial trace of the whole system over this qubit (i.e., discarding it), before replacing it with |0 0|. Alternatively, it can be interpreted as measuring the qubit, applying an X operation conditioned on the measurement result being |1 , and then discarding the measurement result. Physically, quantum computers developed by IBM implement the reset primitive by repeating the pattern of measuring and conditionally applying an X operation several times to realize high-fidelity qubit resets [37]. Algorithmically, any reset operation can be translated to introducing a new qubit to the circuit and applying all subsequent operations involving the qubit to be reset to the new qubit. In this fashion, any n-qubit circuit containing r reset instructions can be transformed to a circuit acting on n+r qubits and containing no reset primitives.
Example 4. Consider again the circuit for the 3-bit precision IQPE algorithm from Example 3 shown in Fig. 2. By iteratively replacing each of the reset operations with a new qubit and translating all subsequent gates to the newly introduced qubits, a circuit acting on four qubits results, as shown in Fig. 3a.
Once qubit reuse is eliminated from a dynamic circuit, the only potentially non-unitary primitives remaining are mid-circuit measurements and classically-controlled operations conditioned on their result. In order to get rid of these operations, we resort to one of the most fundamental results in quantum computing: the deferred measurement principle [15].

|q2 = |0 H

|q1 = |0 H

|q0 = |0 H

H

12
| = |1 8
c0 c1 c2

-

 2

H

6 8

-

 4

-

 2

H

3 8

(a) Circuit after substituting new qubits for every reset

|q2 = |0 H

-

 4

-

 2

H

c2

|q1 = |0 H

-

 2

H

c1

|q0 = |0 H

H

c0

| = |1

12 6 3 8 88

(b) Circuit after applying deferred measurement principle

Fig. 3. Unitary reconstruction scheme for IQPE circuit from Fig. 2

It states that delaying measurements until the end of a quantum computation does not affect the probability distribution of outcomes. As a consequence, it follows that measurement and classical-conditioning on its result commute. Thus, any midcircuit measurement can be delayed until the very end of the quantum circuit--replacing any classically-controlled operations along the way by proper quantum operations controlled by the respective qubit.
Example 5. Assume that all reset operations of the IQPE circuit from Example 3 have been eliminated, e.g., by transforming the circuit as described in Example 4. Then, applying the deferred measurement principle in order to delay all measurements to the end of the circuit and replacing the phase rotations controlled by the measurement outcomes with phase gates controlled on the respective qubits, results in a circuit as shown in Fig. 3b--free of dynamic circuit primitives.
By combining both aforementioned steps, i.e., substituting reset operations with "fresh" qubits and applying the deferred measurement principle, any dynamic quantum circuit can be transformed to a representation without the use of dynamic circuit primitives. For one, this allows to verify that a dynamic circuit actually realizes the intended functionality of its static counterpart.
Example 6. Compare the transformed circuit obtained in Example 5 (shown in Fig. 3b) to the original QPE algorithm shown in Fig. 1a. Both circuits differ in the order of the qubits the controlled phase gates are applied to and the inverse QFT's SWAP operation in the middle of the original circuit. Back-propagating the effect of this SWAP operation towards the input qubits leads to precisely the same circuit representation as obtained from transforming the IQPE circuit. Thus, both circuits are indeed equivalent.

V. STATE VECTOR EXTRACTION FROM SIMULATION
While the approach presented in the previous section conceptually allows to verify dynamic circuits, it requires to extend a circuit's description by as many qubits as it contains mid-circuit resets. Due to the resulting unitary functionality scaling as 2n+r × 2n+r, the complexity of verifying such instances increases quickly. Although verification methodologies such as [3], [4] frequently allow to reduce the complexity of the verification by exploiting the reversibility of quantum operations, they might not be able to handle this immense complexity in the worst case.
Motivated by the fact that most high-level quantum algorithms (such as, e.g., Grover's algorithm [38]), assume a fixed input state, we argue that it is sufficient to show that two realizations of such an algorithm produce functionally-equivalent output state vectors given the fixed input state for the circuits to be considered functionally equivalent. Verifying that two circuits G and G , which do not contain dynamic circuit primitives, result in functionally-equivalent output states given a particular input state | amounts to classically simulating both computations with | as input and computing the fidelity between the resulting states. In this regard, the fidelity between two pure states, which is defined as the squared overlap of the respective state vectors, acts as a similarity and, hence, equivalence measure between the outputs.
However, in the presence of dynamic circuit primitives in a circuit, obtaining the state vector responsible for producing the circuit's output distribution is no longer as straightforward. This is due to the non-unitary nature of the dynamic circuit primitives, that no longer allow to deterministically simulate the quantum circuit in one go using quantum circuit simulators such as [39]­[41] on a classical computer. For example, each time a reset operation is encountered this would technically require the calculation of the partial trace of the system over the particular qubit (and reinitializing it to |0 ). However, the partial trace is an operation that maps pure states to mixed states. One possible approach for solving this problem would be to repeatedly simulate the dynamic circuit and stochastically realize dynamic circuit primitives such as measurements and resets. However, one would have to perform huge amounts of individual runs in order to reason about the output distribution in a statistically significant way. Another approach requires leaving the pure state picture and using a density matrix simulator (such as, e.g., [42]­[44]). Although resets can be handled deterministically using such a simulator, mid-circuit measurements and classic-controlled operations again require repeated simulations of the circuit.
In the following, we propose a technique that allows to extract the complete output state vector of a dynamic circuit given a particular input state as if the circuit would not contain dynamic circuit primitives at all. To this end, consider a quantum circuit G involving m measurements. Assume that each mid-circuit measurement is followed by a reset operation--corresponding to reusing a qubit--and that the circuit contains any number of classically-controlled opera-

tions. Then, each measurement during the circuit simulation constitutes a branching point where the amplitudes of the qubit to be measured are check-pointed and the simulation splits into two independent simulations: one assuming the measurement outcome is |0 and the other one assuming the outcome is |1 . Depending on the outcome, a subsequent reset operation is translated to a no-op (in case of |0 ) or to an X gate (in case of |1 ), while any classically-controlled operation is either ignored (in case of |0 ) or applied (in case of |1 ). The amplitude of observing a particular basis state |i = |(im-1 . . . i0)2 can then be reconstructed from the product of the check-pointed amplitudes along the path of simulations corresponding to the outcomes i0 to im-1. An example illustrates the idea.

Example 7. Consider again the IQPE algorithm for estimat-

ing

the

phase



of

the

unitary

operator

U

=

p(

3 8

)

corre-

sponding to the eigenvector state | = |1 up to a precision

of three bits, as shown in Fig. 2. The circuit contains a total

of m = 3 measurements (necessary for the 3-bit precisison)

and uses the fixed input state |000  | = |0001 . Iteratively

simulating the circuit, check-pointing the amplitudes at each

of the measurements, and adjusting the subsequent circuit

parts to be simulated accordingly, results in a computational

flow as illustrated in Fig. 4. There, red arrows denote the

|0 -successor, while blue arrows denote the |1 -successor, i.e.,

the subsequent computations upon measuring |0 or |1 ,

respectively. The path indicated in bold represents the extrac-

tion of the amplitude for the |001 basis state--resulting in

1

e i 4



0.924

e

3i 8



0.981

e

7i 16



0.641

e

17i 16

.

2

VI. DISCUSSION AND CONCLUSIONS

In this work, we discussed the upcoming challenges that are currently emerging with the introduction of so-called dynamic quantum circuits, i.e., quantum circuits including primitives such as mid-circuit measurements, mid-circuit resets, or classically-controlled operations. We showed that, due to their non-unitary nature, existing solutions cannot be used for these circuits anymore (at least not in an out-of-the-box fashion). At the same time, however, we present ideas that eventually allow to treat the involved circuits as if they were not dynamic at all. More precisely, the usage of established verification techniques for dynamic quantum circuits is enabled by either
1) transforming the dynamic circuit primitives in a way that results in an overall larger circuit, but a unitary functionality (see Section IV), or
2) using classical simulation techniques to extract the state vector from a dynamic quantum circuit--given a fixed input (see Section V).
Having these ideas, it might seem that the approach proposed in Section IV merely reverses the circuit construction or compilation process. When, e.g., comparing the transformed version of the IQPE circuit shown in Fig. 3b with the original QPE circuit shown in Fig. 1a, one can almost establish a one-to-one relation between both circuits (as witnessed in Example 6). As such, it could be argued that there is nothing

|0 H H

...

|

...

4

least significant (qu)bit

|0 H H |
2

e 1

-

i 4

2

|0 H H

| 

0.383e

i 8

...

...

0.924e-

3i 8

|1 X H

-

 2

H

| 

0.831e

5i 16

0.556e-

3i 16

0.981e-

7i 16

0.195e

i 16

|000
|100 |010
|110

e 1

i 4

2

|1 X H

-

 2

H

| 2

|0 H

-

 4

H

| 

0.924e

3i 8

...

...

0.383e-

i 8

|1

|

XH

-

3 4

H



0.981e

7i 16

0.195e-

i 16

|001 |101

0.831e-

5i 16

|011

0.556e

3i 16

|111

most significant (qu)bit

Fig. 4.

State

vector

extraction

for

the

IQPE

circuit

with



=

3 8

shown in Fig. 2. Red (blue) arrows denote the |0 -successor (|1 -successor).

to be gained from using the technique. However, this is not the case, as almost no assumptions are made about the relation between G and G in general. Indeed, the only requirement is that the transformed versions of both circuits have the same number of primary inputs and outputs. The proposed transformation scheme "touches" nothing but reset, measurement and classically-controlled operations--which are "reversed". Eventually, this allows to use any existing verification tool, such as [12], [45], to verify the equivalence of two circuits G and G that might contain dynamic circuit primitives.
Extracting the output state vector of a dynamic circuit as proposed in Section V naturally requires a total of 2m individual simulations, where m is the number of mid-circuit measurements (and resets). However, large parts of the simulations can be shared in between simulation runs. For example, the circuit up until the first checkpoint only needs to be simulated once, while two simulations are necessary up until the second checkpoint, and so on. In general, the kth sub-circuit needs to be simulated in at most 2k variations. If any measurement along a path produces a zero amplitude, further simulations along that path need not be started at all. In addition, the individual simulations in between checkpoints are completely independent from another and, hence, could potentially be simulated in parallel. Overall, this results in the top-to-bottom construction of a structure similar to a decision diagram for

quantum states [39], [46]. An implementation of the proposed scheme might make use of this observation to exploit further redundancies during the extraction. Any existing quantum circuit simulator, such as [39]­[41], might be used to realize this scheme.
Overall, because of that, the ideas presented in this work provide a promising basis to address the challenges introduced by the advent of dynamic quantum circuits. To this end, we have shown that reinventing the wheel is not necessary in order to use established quantum circuit verification techniques for the verification of this new and broader class of circuits. It is left for future work, to actually integrate the proposed techniques into tool suites such as IBM's Qiskit [47], Microsoft's QDK [48], Google's Cirq [49], Amazon's Braket [50], or the JKQ framework [51].
ACKNOWLEDGMENTS
This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No. 101001318). It has partially been supported by the LIT Secure and Correct Systems Lab funded by the State of Upper Austria as well as by the BMK, BMDW, and the State of Upper Austria in the frame of the COMET program (managed by the FFG).

REFERENCES
[1] A. W. Cross et al. (2021). "OpenQASM 3: A broader and deeper quantum assembly language." arXiv: 2104.14722 [quant-ph].
[2] IBM Quantum, "Quantum circuits get a dynamic upgrade with the help of concurrent classical computation," 2021. [Online]. Available: https: //www.ibm.com/blogs/research/2021/02/quantum- phase- estimation/ (visited on 05/12/2021).
[3] S. Yamashita and I. L. Markov, "Fast equivalence-checking for quantum circuits," in Int'l Symp. on Nanoscale Architectures, 2010.
[4] L. Burgholzer and R. Wille, "Advanced equivalence checking for quantum circuits," IEEE Trans. on CAD of Integrated Circuits and Systems, 2021.
[5] L. Burgholzer, R. Raymond, and R. Wille, "Verifying results of the IBM Qiskit quantum circuit compilation flow," in Int'l Conf. on Quantum Computing and Engineering, 2020, pp. 356­365.
[6] L. Burgholzer, R. Kueng, and R. Wille, "Random stimuli generation for the verification of quantum circuits," in Asia and South Pacific Design Automation Conf., 2021.
[7] G. F. Viamontes, I. L. Markov, and J. P. Hayes, "Checking equivalence of quantum circuits and states," in Int'l Conf. on CAD, 2007.
[8] P. Niemann, R. Wille, and R. Drechsler, "Equivalence checking in multi-level quantum systems," in Int'l Conf. of Reversible Computation, 2014.
[9] S.-A. Wang, C.-Y. Lu, I.-M. Tsai, and S.-Y. Kuo, "An XQDDbased verification method for quantum circuits," in IEICE Trans. Fundamentals, 2008, pp. 584­594.
[10] K. N. Smith and M. A. Thornton, "A quantum computational compiler and design tool for technology-specific targets," in Int'l Symp. on Computer Architecture, 2019, pp. 579­588.
[11] X. Hong, M. Ying, Y. Feng, X. Zhou, and S. Li. (2021). "Approximate Equivalence Checking of Noisy Quantum Circuits." arXiv: 2103.11595 [quant-ph], [Online]. Available: http://arxiv.org/abs/2103.11595.
[12] M. Amy, "Towards large-scale functional verification of universal quantum circuits," in International Conference on Quantum Physics and Logic, 2019.
[13] D. Deutsch, "Quantum computational networks," Proc. R. Soc. Lond. A, vol. 425, no. 1868, pp. 73­90, 1989.
[14] A. Barenco et al., "Elementary gates for quantum computation," Phys. Rev. A, vol. 52, no. 5, pp. 3457­3467, 1995.
[15] M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information. Cambridge University Press, 2010.
[16] P. W. Shor, "Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer," SIAM J. Comput., vol. 26, no. 5, pp. 1484­1509, 1997.
[17] A. W. Harrow, A. Hassidim, and S. Lloyd, "Quantum algorithm for linear systems of equations," Phys. Rev. Lett., vol. 103, no. 15, 2009.
[18] S. Lloyd, M. Mohseni, and P. Rebentrost, "Quantum principal component analysis," Nat. Phys., vol. 10, no. 9, pp. 631­633, 2014.
[19] D. Maslov, "On the advantages of using relative phase Toffolis with an application to multiple control Toffoli optimization," Phys. Rev. A, vol. 93, no. 2, p. 022 311, 2016.
[20] R. Wille, M. Soeken, C. Otterstedt, and R. Drechsler, "Improving the mapping of reversible circuits to quantum circuits using multiple target lines," in Asia and South Pacific Design Automation Conf., 2013.
[21] A. M.-v. de Griend and R. Duncan. (2020). "Architecture-aware synthesis of phase polynomials for NISQ devices." arXiv: 2004.06052 [quant-ph].
[22] P. Murali, J. M. Baker, A. Javadi-Abhari, F. T. Chong, and M. Martonosi, "Noise-adaptive compiler mappings for Noisy Intermediate-Scale Quantum computers," in Int'l Conf. on Architectural Support for Programming Languages and Operating Systems, 2019, pp. 1015­1029.
[23] M. Y. Siraichi, V. F. dos Santos, S. Collange, and F. M. Q. Pereira, "Qubit allocation," in Proc. Int'l Symp. on Code Generation and Optimization, 2018, pp. 113­125.
[24] A. Zulehner, A. Paler, and R. Wille, "An efficient methodology for mapping quantum circuits to the IBM QX architectures," IEEE Trans. on CAD of Integrated Circuits and Systems, vol. 38, no. 7, pp. 1226­ 1236, 2019.
[25] R. Wille, L. Burgholzer, and A. Zulehner, "Mapping quantum circuits to IBM QX architectures using the minimal number of SWAP and H operations," in Design Automation Conf., 2019.

[26] G. Li, Y. Ding, and Y. Xie, "Tackling the qubit mapping problem for NISQ-era quantum devices," in Int'l Conf. on Architectural Support for Programming Languages and Operating Systems, 2019.
[27] S. Sivarajah, S. Dilkes, A. Cowtan, W. Simmons, A. Edgington, and R. Duncan, "T|ket>: A Retargetable Compiler for NISQ Devices," Quantum Sci. Technol., vol. 6, no. 1, p. 014 003, 2020.
[28] T. Itoko, R. Raymond, T. Imamichi, and A. Matsuo, "Optimization of quantum circuit mapping using gate transformation and commutation," Integration, vol. 70, pp. 43­50, 2020.
[29] G. Vidal and C. M. Dawson, "Universal quantum circuit for twoqubit transformations with three controlled-NOT gates," Phys. Rev. A, vol. 69, no. 1, p. 010 301, 2004.
[30] K. Hietala, R. Rand, S.-H. Hung, L. Li, and M. Hicks. (2020). "Proving Quantum Programs Correct." arXiv: 2010.01240.
[31] A. Asfaw et al. (2020). "Learn Quantum Computation Using Qiskit," [Online]. Available: http://community.qiskit.org/textbook.
[32] IBM Q, IBM Q. [Online]. Available: https://www.research.ibm.com/ ibm-q/ (visited on 04/10/2020).
[33] D. Janzing, P. Wocjan, and T. Beth, ""Non-identity check" is QMAcomplete," Int. J. Quantum Inform., vol. 03, no. 03, pp. 463­473, 2005.
[34] C. H. Bennett, G. Brassard, C. Crépeau, R. Jozsa, A. Peres, and W. K. Wootters, "Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels," Phys. Rev. Lett., vol. 70, no. 13, pp. 1895­1899, 1993.
[35] M. Dobsicek, G. Johansson, V. S. Shumeiko, and G. Wendin, "Arbitrary accuracy iterative phase estimation algorithm as a two qubit benchmark," Phys. Rev. A, vol. 76, no. 3, p. 030 306, 2007.
[36] A. Paetznick and K. M. Svore. (2014). "Repeat-Until-Success: Nondeterministic decomposition of single-qubit unitaries." arXiv: 1311 . 1074 [quant-ph].
[37] A. D. Corcoles et al. (2021). "Exploiting dynamic quantum circuits in a quantum algorithm with superconducting qubits." arXiv: 2102.01682 [quant-ph].
[38] L. K. Grover, "A fast quantum mechanical algorithm for database search," Proc. of the ACM, pp. 212­219, 1996.
[39] A. Zulehner and R. Wille, "Advanced simulation of quantum computations," IEEE Trans. on CAD of Integrated Circuits and Systems, vol. 38, no. 5, pp. 848­859, 2019.
[40] G. G. Guerreschi, J. Hogaboam, F. Baruffa, and N. P. D. Sawaya, "Intel Quantum Simulator: A cloud-ready high-performance simulator of quantum circuits," Quantum Sci. Technol., vol. 5, p. 034 007, 2020.
[41] B. Villalonga et al., "A flexible high-performance simulator for verifying and benchmarking quantum circuits implemented on real hardware," Npj Quantum Inf., vol. 5, no. 1, pp. 1­16, 2019.
[42] G. F. Viamontes, I. L. Markov, and J. P. Hayes, "Graph-based simulation of quantum computation in the density matrix representation," in Quantum Information and Computation II, vol. 5436, 2004, pp. 285­ 296.
[43] T. Grurl, J. Fuß, and R. Wille, "Considering decoherence errors in the simulation of quantum circuits using decision diagrams," in Int'l Conf. on CAD, 2020.
[44] A. Li, O. Subasi, X. Yang, and S. Krishnamoorthy, "Density matrix quantum circuit simulation via the BSP machine on modern GPU clusters," in Int'l Conf. for High Performance Computing, Networking, Storage and Analysis, 2020.
[45] L. Burgholzer and R. Wille, "QCEC: A JKQ tool for quantum circuit equivalence checking," Softw. Impacts, vol. 7, p. 100 051, 2021.
[46] A. Zulehner, S. Hillmich, and R. Wille, "How to efficiently handle complex values? Implementing decision diagrams for quantum computing," in Int'l Conf. on CAD, 2019.
[47] G. Aleksandrowicz et al., "Qiskit: An open-source framework for quantum computing," Zenodo, 2019.
[48] Quantum Development Kit, Microsoft. [Online]. Available: https : / / microsoft.com/en-us/quantum/development-kit.
[49] Cirq: A python framework for creating, editing, and invoking Noisy Intermediate Scale Quantum (NISQ) circuits. [Online]. Available: https://github.com/quantumlib/Cirq.
[50] Amazon Braket, 2021. [Online]. Available: https://aws.amazon.com/ braket/ (visited on 06/02/2021).
[51] R. Wille, S. Hillmich, and L. Burgholzer, "JKQ: JKU tools for quantum computing," in Int'l Conf. on CAD, 2020.

