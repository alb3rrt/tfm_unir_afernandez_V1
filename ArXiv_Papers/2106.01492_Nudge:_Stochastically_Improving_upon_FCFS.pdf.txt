Nudge: Stochastically Improving upon FCFS

arXiv:2106.01492v1 [cs.PF] 2 Jun 2021

ISAAC GROSOF, Carnegie Mellon University, USA KUNHE YANG, Tsinghua University, China ZIV SCULLY, Carnegie Mellon University, USA MOR HARCHOL-BALTER, Carnegie Mellon University, USA
The First-Come First-Served (FCFS) scheduling policy is the most popular scheduling algorithm used in practice. Furthermore, its usage is theoretically validated: for light-tailed job size distributions, FCFS has weakly optimal asymptotic tail of response time. But what if we don't just care about the asymptotic tail? What if we also care about the 99th percentile of response time, or the fraction of jobs that complete in under one second? Is FCFS still best? Outside of the asymptotic regime, only loose bounds on the tail of FCFS are known, and optimality is completely open.
In this paper, we introduce a new policy, Nudge, which is the first policy to provably stochastically improve upon FCFS. We prove that Nudge simultaneously improves upon FCFS at every point along the tail, for light-tailed job size distributions. As a result, Nudge outperforms FCFS for every moment and every percentile of response time. Moreover, Nudge provides a multiplicative improvement over FCFS in the asymptotic tail. This resolves a long-standing open problem by showing that, counter to previous conjecture, FCFS is not strongly asymptotically optimal.
CCS Concepts: · General and reference  Performance; · Mathematics of computing  Queueing theory; · Software and its engineering  Scheduling.
Additional Key Words and Phrases: scheduling; FCFS; response time; latency; sojourn time; stochastic dominance; M/G/1

1 INTRODUCTION

1.1 The Case for FCFS

While advanced scheduling algorithms are a popular topic in theory papers, it is unequivocal that the most popular scheduling policy used in practice is still First-Come First-Served (FCFS). There are many reasons for the popularity of FCFS. From a practical perspective, FCFS is easy to implement. Additionally, FCFS has a feeling of being fair.
However, there are also theoretical arguments for why one should use FCFS. For one thing, FCFS minimizes the maximum response time across jobs for any finite arrival sequence of jobs. By response time we mean the time from when a job arrives until it completes service.
For another thing, in an M/G/1 with a light-tailed job size distribution, FCFS is known to have a weakly optimal asymptotic tail of response time [5, 36]. Specifically, using  to denote response time, the asymptotic tail under FCFS is of the form:

P  FCFS >   FCFS- ,

(1)

where "" indicates that the ratio of the two quantities converges to 1 in the    limit. The exponent   in (1) is known to be optimal, while the optimality of FCFS is an open problem
[5]. The asymptotic tail growth under FCFS has been compared with more sophisticated policies
[5]. It has been shown that, for light-tailed job size distributions, the tail of response time under

Authors' addresses: Isaac Grosof, igrosof@cs.cmu.edu, Carnegie Mellon University, Computer Science Department, Pittsburgh, PA, USA; Kunhe Yang, yangkunhe19@gmail.com, Tsinghua University, Institute for Interdisciplinary Information Sciences, Beijing, China; Ziv Scully, zscully@cs.cmu.edu, Carnegie Mellon University, Computer Science Department, Pittsburgh, PA, USA; Mor Harchol-Balter, harchol@cs.cmu.edu, Carnegie Mellon University, Computer Science Department, Pittsburgh, PA, USA.

2

Isaac Grosof et al.

Processor-Sharing (PS), Preemptive Last-Come-First-Served (PLCFS), and Shortest-RemainingProcessing-Time (SRPT) each take the asymptotic form of

P{

>

}








-



,

where   is the worst possible exponential decay rate [25] over all work-conserving scheduling policies. Roughly, FCFS's tail exponent   arises from the tail of the workload distribution, while the other policies' tail exponent   arises from the tail of the busy period distribution, which is
much larger under light-tailed job size distributions.

1.2 The Case For Light-Tailed Job Size Distributions In this paper, we choose to focus on the case of light-tailed job size distributions. Light-tailed job size distributions show up naturally in workloads where all the transactions are of the same type (say shopping); while there is some variability in the time it takes to purchase an item, even high-variability distributions that arise in such settings are often light-tailed. Also, many natural distributions, like the Normal distribution, Exponential distribution, and all Phase-type distributions, are light-tailed. Finally, while heavy-tailed job size distributions are certainly prevalent in empirical workloads (see for example [9, 14, 37]), in practice, these heavy-tailed workloads are often truncated, which immediately makes them light-tailed. Such truncation can happen because there is a limit imposed on how long jobs are allowed to run. Alternatively, truncation can occur when a heavytailed job size distribution is divided into a few size classes as in [15, 18] where the smaller size classes end up being truncated distributions.

1.3 The Case for Non-Asymptotic Tails Within the world of light-tailed job size distributions, FCFS is viewed as the best policy. However, while FCFS has a weakly optimal asymptotic tail, it is not best at minimizing P{ >  } for all . In practice, one cares less about the asymptotic case than about particular  [17]. For example, one might want to minimize the fraction of response times that exceed  = 0.5 seconds, because such response times are noticeable by users. One might also want to meet several additional Service Level Objectives (SLOs) where one is charged for exceeding particular response time values, such as  = 1 minute, or  = 1 hour. SLOs are very common in the computing literature [8, 17, 24], in service industries [10, 34, 38], and in healthcare [4, 19]. Unfortunately, different applications have different SLOs. This leads us to ask:
When considering P{ >  }, is it possible to strictly improve upon FCFS for all values of ?
We are motivated by the fact that, for lower values of , Shortest-Remaining-Processing-Time (SRPT) is better than FCFS, although FCFS clearly beats SRPT for higher values of , as FCFS is weakly asymptotically optimal while SRPT is asymptotically pessimal [25, 26]. SRPT also minimizes mean response time [29], which is closely related to lower values of . This motivates us to consider whether prioritizing small jobs might have some benefit, even in the world of light-tailed job size distributions.
We ask more specifically:
Can partial prioritization of small jobs lead to a strict improvement over FCFS? Specifically, is there a scheduling policy which strictly improves upon FCFS with respect to P{ >  }, for every possible  including large ?

Nudge: Stochastically Improving upon FCFS

3

swap

small
x0

medium

large

extra-large

x1

x2

x3

Fig. 1. The Nudge algorithm.

Tail improvement ratio

0.08 0.07 0.06 0.05 0.04 0.03 0.02 0.01 0.00
t=0

Nudge improvement

Bounded Lomax Exponential Hyperexponential Uniform

t=5

t = 10

t = 15

t = 20

Fig. 2. Empirical tail improvement of Nudge over FCFS in an M/G/1. The tail improvement ratio (TIR) is defined as 1 - P  Nudge >  /P  FCFS >  . Specific job size distributions, each with mean 1: Uniform(0,2);
Exponential with mean 1; Hyperexponential with branches drawn from Exp(2) and Exp(1/3), where the first branch has probability 0.8 and where 2 = 3; BoundedLomax( = 2, max= 4,  = 2). Distributions in
legend ordered by asymptotic improvement. Simulations run with 10 billion arrivals. Load  = 0.8. Nudge
parameters: 1 = 1, 2 = 1, 3 = . Note that 1 = 2, so there are no medium-sized jobs. Empirically, Nudge often achieves its best performance with 1 = 2, though our proofs involve setting 1 < 2. See Section 9.

1.4 Our Answer: Nudge

This paper answers the above question in the affirmative. We will define a policy, which we call
Nudge, whose response time tail is provably better than that of FCFS for every value of , assuming a light-tailed job size distribution1 (see Theorem 4.2). We say that Nudge's response time stochastically improves upon that of FCFS, in the sense of stochastic dominance. Moreover, we prove that the
asymptotic tail of response time of Nudge is of the form

 { Nudge

>

}



- 
Nudge ,

with optimal decay rate   and a superior leading constant Nudge < FCFS (see Corollary 4.4). Thus, we demonstrate that FCFS is not strongly optimal, answering an open problem posed by

Boxma and Zwart [5]. In particular, this is contrary to a conjecture of Wierman and Zwart [40]

(see Section 2.1).

The intuition behind the Nudge algorithm is that we'd like to basically stick to FCFS, which we

know is great for handling the extreme tail (high ), while at the same time incorporating a little bit

of prioritization of small jobs, which we know can be helpful for the mean and lower . We need to

be careful, however, not to make too much use of size, because Nudge still needs to beat FCFS for

high ; hence we want just a little "nudge" towards prioritizing small jobs.

1Technically, a Class I job size distribution. See Definition 3.3.

4

Isaac Grosof et al.

We now describe the Nudge algorithm. Imagine that the job size distribution is divided into size regions, as shown in Fig. 1, consisting of small, medium, large, and extra large jobs. Most of the time, Nudge defaults to FCFS. However, when a "small" job arrives and finds a "large" job immediately ahead of it in the queue, we swap the positions of the small and large job in the queue. The one caveat is that a job which has already swapped is ineligible for further swaps. The size cutoffs defining small and large jobs will be defined later in the paper.
The degree of the tail improvement of Nudge over FCFS is non-trivial. In Fig. 2, we see that for many common light-tailed job size distributions, Nudge results in a multiplicative improvement of 4-7% throughout the tail. In Section 9.2, we show that with low load and a high-variability job size distribution, Nudge's improvement can be as much as 10-15% throughout the tail. The magnitude of these improvements highlights the importance of scheduling, even in the light-tailed setting.
We additionally present an exact analysis of the performance of Nudge. Nudge does not fit into any existing framework for M/G/1 transform analysis, including the recently developed SOAP framework [32] (see Section 2.3). Nonetheless, we derive a tagged-job analysis of Nudge in Theorem 4.5, deriving the Laplace-Stieltjes transform of response time of Nudge.

1.5 Contributions and Roadmap
This paper makes the following contributions.
· In Section 3.5, we introduce the Nudge policy. · In Sections 4 to 6 we prove that with appropriately chosen parameters, Nudge stochastically
improves upon FCFS for light-tailed2 job size distributions; we also give a simple expression
for such parameters. Moreover, in Section 8, we prove that Nudge achieves a multiplicative
asymptotic improvement over FCFS. · In Section 7, we derive the Laplace-Stieltjes transform of response time under Nudge. · In Section 9, we empirically demonstrate the magnitude of Nudge's stochastic improvement
over FCFS. We also discuss how to tune Nudge's parameters for best performance. · In Section 10, we discuss practical considerations for using Nudge. · In Section 11, we discuss several notable variants of Nudge.

2 PRIOR WORK Most prior work on scheduling to optimize the tail of response time focuses on the asymptotic case, characterizing P{ >  } in the    limit. We review these results in Section 2.1.
Our main result, Theorem 4.2, is a non-asymptotic statement, characterizing the behavior of P{ >  } for all , not just the    limit. There is much less prior work on the tail of response time outside of the asymptotic regime. We review the few results in this area in Section 2.2.
In addition to characterizing Nudge's tail of response time, we also give an exact transform
analysis of Nudge's response time. Our analysis requires a novel approach that significantly differs
from traditional analyses, as we discuss in Section 2.3.
Our paper's focus is the M/G/1 queue. All of the results cited in this section apply to the M/G/1,
with some also applying to more general models, such as the GI/GI/1.

2.1 Asymptotic Tails: Extensive Theory, but Open Problems Remain

When optimizing the asymptotic tail, the goal is to find a policy  such that for all scheduling

policies ,

P  > 

lim sup



 P{  >  }

2Technically, any Class I job size distribution. See Definition 3.3.

Nudge: Stochastically Improving upon FCFS

5

for some constant   [1, ). Such a policy  is called weakly optimal; if  = 1, then  is called strongly optimal [5]. While weak optimality has been well studied, proving or disproving strong optimality is much harder.
One major theme of the prior work is that optimizing the asymptotic tail looks very different
depending on the job size distribution.
· For light-tailed job sizes, FCFS is weakly optimal [5]. Specifically, the tail of response time has a form given in (1). Moreover, many popular preemptive policies such as PS, SRPT, and Foreground-Background (FB)3 are "weakly pessimal": they have the maximum possible asymptotic tail, up to a constant factor, of any work-conserving scheduling policy [25, 26].
· For heavy-tailed job sizes, the reverse is true: PS, SRPT, FB, and similar policies are all weakly optimal [5, 26, 33], while FCFS is weakly pessimal.

This state of affairs prompts a question: is any policy weakly optimal in both the light-tailed and heavy-tailed cases? Nair et al. [25] show that a variant of PS achieves this, but their variant requires knowledge of the system's load. Wierman and Zwart [40] show that any policy that is weakly optimal in both the light- and heavy-tailed cases requires knowing some information about the system parameters, such as the load.
The above results mostly characterize weakly optimal scheduling policies, but the problem of strongly optimizing the tail remains open. Boxma and Zwart [5] pose the strong optimality of FCFS as an open problem. Wierman and Zwart [40] go further and conjecture that FCFS is in fact strongly optimal for light-tailed job size distributions. Despite a large of body of work analyzing the tail asymptotics of FCFS [1­3, 28], the problem has remained open. We solve the problem by showing that FCFS is not strongly optimal. Specifically, our Corollary 4.4 implies

P  Nudge >  lim

= Nudge < 1.

 P  FCFS > 

FCFS

2.2 Non-asymptotic Tails: Few Optimality Results Characterizing P{ >  } outside the asymptotic regime is a much harder problem than characterizing the asymptotic tail. As such, the strongest results in this area are for relatively simple scheduling policies. For FCFS under light-tailed job size distributions, it is known that P{ >  } < - for the same constant   as appears in FCFS's asymptotic tail formula [21, 22]. As a result, this bound is tight
up to a constant factor [22], subject to subtleties discussed in Section 3.3. Beyond FCFS, one of the
few known results gives an improved characterization of response time under preemptive-priority
scheduling policies [3, Section 2].
Very little is known about more complicated scheduling policies. While the Laplace-Steiltjes
transform of  is known for a wide variety of scheduling policies [32, 35], these transforms do not readily yield useful bounds on P{ >  } for general job size distributions.
Given that characterizing P{ >  } is difficult, it comes as no surprise that optimizing P{ >  } is harder still. As such, rather than trying to crown a single optimal policy, we focus on a relative measure. Specifically, as we define in Definition 3.1, we say that policy 1 stochastically improves upon another policy 2 if P{ 1 >  }  P{ 2 >  } for all .
There are two stochastic improvement results in the literature, but both are much simpler than
our Nudge result. Both results start with a well-known policy that does not use job sizes and show
that a variation that does use job sizes stochastically improves response time.
· Nuyens et al. [26] show that SRPT and similar policies stochastically improve upon FB.

3FB at all times serves the jobs that have received the least service so far.

6

Isaac Grosof et al.

· Friedman and Henderson [11] and Friedman and Hurley [12] show that one can stochastically improve upon PS by using job sizes. Their policy, Fair Sojourn Protocol (FSP), guarantees in a sample-path sense that no job departs later than it would if the server were using PS.

The results above fit a common theme. Both FB and PS often share the server between multiple jobs. Sharing the server is fundamentally suboptimal. For example, when sharing the server between jobs 1 and 2, if we knew that we would finish job 1 first, then it would be better to devote the entire server to job 1 at first. Doing so improves the response time of job 1 without harming the response time of job 2. Roughly speaking, when FB and PS would share the server between jobs, SRPT and FSP serve the jobs one at a time, using job size information to choose the ordering.
FCFS is more difficult to stochastically improve upon than FB and PS. For one thing, FCFS never shares the server, removing this easy opportunity for stochastic improvement. Moreover, there is a sense in which FCFS is unimprovable: on any specific finite arrival sequence, FCFS minimizes the sorted vector of response times, where we order vectors lexicographically. For example, FCFS minimizes the maximum response time. As a result, the sample path arguments that work for improving FB and PS do not apply to improving FCFS.
In spite of these obstacles, we show in Theorem 4.2 that Nudge stochastically improves upon FCFS. Rather than reasoning in terms of sample paths, we take a fundamentally stochastic approach from the beginning. See our proofs in Section 5.

2.3 Transform of Response Time: Nudge Needs a Novel Approach In Theorem 4.5, we give a closed-form expression for the Laplace-Stieltjes transform of Nudge's response time. There has been much prior work on analyzing the transform of response time of the M/G/1 under various scheduling policies. Some analysis techniques cover a wide variety of scenarios [13, 32]. However, as we explain below, none of these prior techniques can analyze Nudge.
SOAP Policies. Policies in the SOAP class, introduced by Scully et al. [32], schedule jobs based on an index calculated from each job's size and attained service4, and their response time can be analyzed via the SOAP framework [32]. These include SRPT [31], FB [30], some multi-level processor sharing policies [23], and certain cases of the Gittins policy [27]. Unfortunately, Nudge is not a SOAP policy, so we cannot leverage this analysis method. This is because whether Nudge will swap a small job  with a large job  depends in part on whether any other jobs arrive between  and . In contrast, a SOAP policy would make such a decision based on properties of  and  alone.
Variations on FCFS. Nudge serves jobs in FCFS order by default and only ever swaps adjacent arrivals. One might therefore hope that Nudge could be analyzed as a variation on FCFS. There are many papers analyzing a variety of M/G/1 variants under FCFS scheduling. These include systems with generalized vacations [13] and exceptional first service [39]. Unfortunately, to the best of our knowledge, no prior analysis of a variation of FCFS applies to Nudge.
Other Analysis Techniques. There are a number of scheduling policies whose transform analyses do not fit into either of the previous categories, such as random order of service [20] and systems with accumulating priority [35]. However, these policies do not resemble Nudge, and the techniques used in their analyses do not readily apply to Nudge.

4The index can also depend on certain other characteristics of the job, e.g. its class if there are multiple classes of jobs. Size and attained service are the attributes relevant to Nudge.

Nudge: Stochastically Improving upon FCFS

7

3 MODEL
3.1 Notation
We consider the M/G/1 queue in which job sizes are known. Let  be the arrival rate,  be the job
size distribution, and min be the minimum possible job size. Specifically, let min be the infimum of the support of . We denote the load by  = E[] and assume 0 <  < 1.
The queueing time,  , is the time from when a job arrives until it first receives service. The response time,  , is the time from when a job arrives until it completes. We write  Alg and  Alg for

the queueing time and response time under scheduling algorithm Alg, respectively. For any continuous random variable  , we will use  (·) to denote the probability density
function (p.d.f.) of  . We write the  () for the Laplace-Stieltjes transform of  .

3.2 Stochastic Improvement In this paper, our goal is to prove that the Nudge policy stochastically improves upon the FCFS policy. We now define stochastic improvement, along with the related notion of tail improvement

ratio.

Definition 3.1 (Stochastic Improvement). For two scheduling algorithms Alg1 and Alg2, we say that Alg1 (strictly) stochastically improves upon Alg2 if, for any response time cutoff  > min, the probability that response time of Alg1 exceeds  is smaller than the probability that Alg2's response
time exceeds , i.e.,  > min, P  Alg1 >  < P  Alg2 >  .

Definition 3.2 (Tail improvement ratio). For any response time cutoff , the tail improvement ratio

of Alg1 versus Alg2 at , denoted TIR(), is defined as

P  Alg1 > 

TIR()  1 -

.

P  Alg2 > 

The asymptotic tail improvement ratio, denoted AsymTIR, is defined as

P  Alg1 > 

AsymTIR  lim inf TIR() = 1 - lim sup

.

 

 P  Alg2 > 

3.3 Class I "Light-Tailed" Distributions In this paper, we focus on job size distributions for which the FCFS policy has an asymptotically exponential waiting time distribution. This property of FCFS will be crucial for our analysis. Prior work has exactly characterized the job size distributions for which FCFS has this property. These distributions are known as "class I" distributions [1, 3, 28].
Definition 3.3 (Class I Distribution). For a distribution , let - be the rightmost singularity of  (), with - = - if  () is analytic everywhere.  is a class I distribution if and only if  > 0 and  (-) = .
Class I distributions can roughly be thought of as "well-behaved" light-tailed distributions. In contrast, class II distributions, the other class of light-tailed distributions, are very unusual and "paradoxical", and rarely occur as job size distributions.
For our paper, the key property of class I job size distributions is that they cause FCFS to have an asymptotically exponential waiting time distribution for all loads [1, 2]. However, as shown by [1, 2], the waiting time also exhibits an exponential tail for light load if the job size is class II. For this reason, while we focus only on class I distributions, we believe that our results also hold for class II under light load. In Section 3.4, we characterize the exponential waiting time in more detail.

8

Isaac Grosof et al.

3.4 Characterizing the FCFS Waiting Time Distribution

In this paper, we care about the exponential tail of the FCFS response time distribution. It turns out

to be simpler to focus on the FCFS waiting time distribution, which is closely related. We will make

use of two key concepts regarding the waiting time distribution. The first concept is the asymptotic exponential decay rate, as investigated in [2, 5]. We refer to this quantity as   and formally define

it to be the negative of the rightmost singularity of  FCFS. Based on the Cramer-Lundberg theory,

the waiting time distribution  FCFS takes an asymptotic exponential tail:


P  FCFS >   - .

(2)



The quantity   is the least positive real solution to the equation

 (- ) =  +   . 

We also define the normalized p.d.f. to be

 ( )






FCFS

(

)

·






.

(3)



Note that (2) relates to the c.d.f. of waiting time, while (3) relates to the p.d.f. of waiting time.

We characterize three important properties of the normalized p.d.f., namely its maximum, minimum, and asymptotic limit. Let max, min,  denote respectively the maximum, minimum and asymptotically limiting values of (·) over [0, ):

max  sup ( );
  [0,)

min  inf ( );
  [0,)






lim

 ( ) .

 

The following lemma, proven in Appendix A, implies these quantities are well defined.

Lemma 3.1. Suppose  is a continuous class I job size distribution. For any load , the normalized p.d.f. () is bounded above and below by positive constants, and lim () exists.
The ratio max/min will be particularly important in our analysis. Intuitively, we can think of the ratio as measuring the deviation of the queueing time  FCFS from a perfect exponential

distribution. The queueing time distribution is exactly an exponential distribution in an //1,
and diverges from an exponential to greater or lesser degree under any class I job size distribution.
The degree of divergence will show up in our later results.

3.5 Scheduling Algorithm: Nudge We now formally define the Nudge algorithm. Nudge(1, 2, 3) first divides jobs into four regions based on their sizes:
· "small": 0 = 0   < 1. · "medium": 1   < 2. · "large": 2   < 3. · "very large": 3   < 4 = .
Throughout the paper, we concentrate mostly on the "small" and the "large" jobs. For conciseness,
we define  , small  , large  , small large as follows.
Definition 3.4. We define small and large to be the distribution of small and large jobs, respectively. We also define small and large to be the fraction of small and large jobs, respectively.
small  [ | < 1], large  [ |2   < 3] small  P{ < 1} , large  P{2   < 3} .

Nudge: Stochastically Improving upon FCFS

9

To determine which job to serve, Nudge maintains an ordering over jobs which have not yet entered service. We call this ordering the "queue". For each job, we also track whether or not it each has already been "swapped".
Whenever a job completes, Nudge serves the job at the front of the queue (if any), and serves it to completion. By default, newly arriving jobs are placed at the back of the queue, resulting in FCFS scheduling by default. However, if three conditions are satisfied, then a "swap" is performed. If
(1) the arriving job is a small job,  , (2) the job at the back of queue is a large job,  , and (3) the job  at the back of queue has never been swapped, then Nudge places the small job  just ahead of  , in the second-to-last position in the queue. This is called a swap, and both  and  are now marked as having been "swapped." Because Nudge never swaps the same job twice, a job is only in the last position in the queue and eligible to be swapped immediately after it arrives. As a result, Nudge only ever swaps a job with the job that arrives immediately before or after it.

4 MAIN RESULTS 4.1 Nudge Improves upon FCFS Non-Asymptotically Our main goal is to show that Nudge stochastically improves upon FCFS. Nudge's performance crucially depends on the choice of parameters 1, 2, and 3, i.e. which jobs are small and which jobs are large. We begin by asking: given job size distribution  and load , for what choices of parameters 1, 2, and 3 does Nudge stochastically improve upon FCFS? We answer this in Theorem 4.1, which gives sufficient conditions on the parameters for Nudge to stochastically improve upon FCFS. We prove Theorem 4.1 in Section 5.

Theorem 4.1 (Stochastic Improvement Regime). Suppose  is a continuous class I job size distribution. Then Nudge(1, 2, 3) stochastically improves upon FCFS for any min < 1  2  3 satisfying5

·

max  +  

<

1 - large (- )-1 ,

(4)

min 

1 - small (- )-1

· 1 + 3  22.

(5)

With Theorem 4.1 in hand, our goal reduces to the following question: given  and , do there exist
parameters satisfying the sufficient condition from Theorem 4.1? We answer this in Theorem 4.2, showing that as long as the minimum job size min = 0, such parameters always exist. Our proof of Theorem 4.2 in Section 6 gives a simple construction of those parameters.

Theorem 4.2 (Existence of Stochastic Improvement). For any continuous class I job size distribution  with min = 0 and any load 0 <  < 1, there exist 1, 2, 3 satisfying (4) and (5), implying that Nudge(1, 2, 3) stochastically improves upon FCFS.

4.2 Nudge Improves upon FCFS Asymptotically
Having shown that Nudge stochastically improves upon FCFS, we ask: is Nudge's improvement
non-negligible in the asymptotic limit? We answer this in Theorem 4.3. Specifically, recall that in the    limit, P  FCFS >   FCFS- . We show that P  Nudge >   Nudge- and that, with appropriately set parameters, Nudge < FCFS. This implies that FCFS is not strongly

5Recall from Definition 3.4 that small and large depend on 1, 2, and 3. This applies throughout the paper.

10

Isaac Grosof et al.

optimal for asymptotic tail behavior (see Section 2.1), resolving a long-standing open problem [5, 40]. We also exactly derive the difference FCFS - Nudge. We prove Theorem 4.3 in Section 8, making use of Theorem 4.5.

Theorem 4.3 (Asymptotic Improvement Regime). Suppose  is a continuous class I job size distribution. For any min < 1  2  3, the asymptotic tail improvement ratio of Nudge(1, 2, 3) compared to FCFS is

 AsymTIR =   small large  +  

large (- )

-



 +



small

(-

)

-



 +





large

(-

)

small

(-



)

.

Furthermore, AsymTIR is positive, meaning Nudge < FCFS, if

 +   1 - large (- )-1

<

.



1 - small (- )-1

Note that the asymptotic improvement regime in Theorem 4.3 is a superset of the non-asymptotic improvement regime in Theorem 4.1, because max/min  1. Thus, whenever Theorem 4.1 guarantees a stochastic improvement, we also have FCFS > Nudge. Thus, by Theorem 4.2, there exists an asymptotic improvement whenever min = 0.

Corollary 4.4 (Existence of Asymptotic Improvement). For any continuous class I job size distribution  with min = 0 and any load 0 <  < 1, there exist 1, 2, 3 such that Nudge < FCFS.

While Theorem 4.3 shows that there is a multiplicative improvement in the asymptotic tail, we find empirically that the same multiplicative improvement exists throughout nearly the entire tail. See Fig. 2 and Section 9.

4.3 Exact Analysis of Nudge All of the above results compare Nudge's performance to that of FCFS. In particular, none of these results give an exact analysis of Nudge's response time. We give such an analysis in Theorem 4.5, in which we exactly derive  Nudge (). This result is nontrivial, because Nudge does not fall into any class of policies with known analyses (see Section 2.3). We prove Theorem 4.5 in Section 7.
Theorem 4.5 (Transform of Response Time). The response time of Nudge has Laplace-Stieltjes transform

 Nudge () =  FCFS () +   small large

large () (1 - small ())

 FCFS ( + ) -  FCFS ()





+ small () (1 - large ())

 FCFS ()


-

(1

-

/ () )

- / ()

 ()

 -

.

5 PROOF OF THEOREM 4.1: STOCHASTIC IMPROVEMENT REGIME Our goal in this section is to prove Theorem 4.1, which gives sufficient conditions on the parameters 1, 2, and 3 for Nudge to stochastically improve upon FCFS. To do so, we employ a tagged job approach. In particular, we follow an arbitrary tagged job  making its way through a pair of coupled systems, one employing the FCFS policy and one employing the Nudge policy, both with the same arrival process and job sizes.
We focus on one particular response time threshold , and in particular on the events , and , , where the tagged job  has response time greater than  in one system and below in the other

Nudge: Stochastically Improving upon FCFS

11

system. In (6), we write the difference in the response time tails of Nudge and FCFS in terms of the events , and , . In Lemma 5.1, we derive formulas for the probabilities of these events.
Using these formulas, in Lemma 5.2, we derive a sufficient condition for Nudge to improve upon FCFS relative to a specific threshold . This sufficient condition is dependent on the threshold . In order to remove this dependence, we prove Lemma 5.3, a technical lemma regarding arbitrary random variables.
Finally, in Section 5.2, we prove Theorem 4.1, by demonstrating that the conditions given in Theorem 4.1 ensure that the sufficient condition in Lemma 5.2 holds relative to every response time threshold , making use of Lemma 5.3 to do so.

5.1 Intermediate Lemmas

Consider a tagged job  that arrives into the steady state of the pair of coupled systems. We write

 Nudge and  FCFS for job 's response time in the Nudge and FCFS systems, respectively. For any





  0, define the events

, 

 FCFS





Nudge
<





,

, 

Nudge






<

 FCFS





.

Intuitively, , is the event in which Nudge decreases job 's response time relative to FCFS, specifically from above  to below . Similarly, , is the event in which Nudge increases job 's
response time relative to FCFS. We can write

P

Nudge


>



=

P

 FCFS


>

+ P ,

- P ,

.

(6)

The events , and , are defined using the Nudge and FCFS systems. Our next step is to express
them in terms of only the FCFS system, which we understand well. We begin by defining the relevant quantities in the FCFS system. Let - be the arrival immediately
before job , and let + be the arrival immediately after, and let

  amount of work in the system (either Nudge or FCFS) when job  arrives,





interarrival

time

between

jobs



and

+
,

  size of job .

We define analogous quantities for - and +. The work is the same in both systems because both

Nudge and FCFS are work-conserving. Note that Nudge will only ever swap job  with one of the adjacent arrivals, - or + (see Section 3.5).
Under what condition do we swap job  with job +? This happens if and only if the following

events occur:

(a) Job  is large, which is when 2   < 3. (b) Job + is small, which is when + < 1. (c) Job + arrives before job  enters service in the Nudge system.
(d) Job  has not swapped with any other job, namely job -.

Because job  cannot be both large and small, (a) implies (d). But (d) implies that (c) happens when
   . This is because in the absence of swaps, job  would enter service after  time. Therefore, the event that job  swaps with job + is

swap,+  {(2   < 3)  (+  1)  (   )}.

(7)

Crucially, this definition of swap,+ depends only on quantities in the FCFS system. We define swap-, analogously.

12
Lemma 5.1 (Evaluating P , and P , ). We have

Isaac Grosof et al.

P , = P swap,+  ( +    <  +  + + ) ,

(8)

P , = P swap-,  (- - - +    < - - - +  + - ) .

(9)

Proof. We begin by computing P

,

Nudge

.

The

event

,

occurs

only

if 


>  FCFS, which


in turn occurs only if job  swaps with the next arrival, namely job +. If this swap occurs, then

Nudge



=

 FCFS


+

+ .

We

know

that

 FCFS


=



+

 ,

so

(8)

follows

from

,

= swap,+



( FCFS  


<  Nudge)


= swap,+



( FCFS  


<

FCFS



+

+

)

= swap,+  ( +    <  +  + + ).

We now compute P , . By similar reasoning to the above, the event , occurs only if job 

swaps

with

job

-.

If

this

swap

occurs,

then

Nudge



=

 FCFS


-

- .

We

again

have

 FCFS


=



+

 ,

so

,

= swap-,



( Nudge  


<  FCFS)


= swap-,



( FCFS


-

-



<  FCFS)


= swap-,  ( +  - -   <  +  ).

To obtain (9), observe that conditioned on swap-, , we have  = - + - - - .



Now, we give sufficient conditions for Nudge to improve upon FCFS relative to a particular threshold .

Lemma 5.2 (Strict Improvement at a Given Threshold). Given any  > min, where min is the smallest value of ,

P

Nudge


>



<

P

FCFS


>

if the following inequality in terms of  holds:

max  +  

E






min

(

,small

+large

)

-   min(,small)

min



<

E






min ( , small + large )

-






min

(

,large

)

.

(10)

Proof. Because the tagged job  is a random sample arriving to the steady state of the system, by (6), we have P  Nudge >  < P  FCFS >  if and only if P , < P , . Our approach is to use Lemma 5.1 to bound each of P , and P , , from which the desired sufficient condition follows.

Nudge: Stochastically Improving upon FCFS

13

We begin by computing P , :

P ,

= P swap,+  ( +    <  +  + + )

[by Lemma 5.1]

= P{(   )  ( +    <  +  + + )  (2   < 3)  (+ < 1)} [by (7)]

 P{( +    <  +  + + )  (2   < 3)  (+ < 1)} [discarding    ]

= P ( -  - + )+    ( -  )+  (2   < 3)  (+ < 1)

 ( - )+

=   large small · E large,+ small

 ( ) d
=( - -+ )+

change

of

measure

for



and

+,


independence of  , + , and 

   large small · E large,+ small

 ( - )+

- 
max

d

=

(

-

-


+

)

+

-  =   large small ·  

· maxE

  min(,small+large)

-   min(,large)

.

by Lemma 3.1 and the

fact

that 

  FCFS


(11)

Similarly, we compute P , :

P , = P swap-,  (- - - +    < - - - +  + - )

= P{(-  - )  (- - - +    < - - - +  + - )  ( < 1)  (2  - < 3)}

= P - + ( -  - - )+  -  - + ( -  )+  ( < 1)  (2  - < 3)

 - +( - )+

=   small large · E small,- large,- Exp()

- ( ) d
=- +( - -- )+

mutual independence of  , + , - , and 

   small large · E small,- large,- Exp()

 - +( - )+

- 
min

d

=- +( - -- )+

by Lemma 3.1 and the

fact

that 

  FCFS


   small large · E small,- large

   +(- )+

- 
min

·

-


d

d

=0 =+( - -- )+

-  =   small large ·  

 · min  +   E




min ( ,small +large )

-




min ( ,small )

.

[-  Exp()] (12)

Combining the bounds (11) and (12), we find that P , < P , holds if

maxE  min(,small+large) - min(,large)

 < min  +  E

 min(,small+large) - min(,small)

. (13)



Having proven Lemma 5.2, we have a sufficient condition, namely (10), for Nudge to improve
upon FCFS at a specific value of . But our goal is to improve upon FCFS for all values of . We therefore seek a condition which implies that (10) holds for all .
We start by simplifying (10). Let  = small ,  = large , and  =  . Then (10) becomes

max  +   E[min(, ) - min(, )]

<

.

(14)

min 

E[min(, ) - min(, )]

Here the only appearance of the specific value of  is via . Our strategy is to lower-bound the right-hand side of (14) by a quantity that does not include . The following lemma, which we prove

in Appendix A, helps accomplish this under an additional assumption.

14

Isaac Grosof et al.

Lemma 5.3. Let ,  be two independent real-valued random variables and  be a fixed constant. Sup-

pose 1     and  < . Under these assumptions, if P{ > } > 0 and E[]  E[] E[| > ],

then

E[min(, ) - min(, )]

E[min(, ) - ]

E[ - ]

=



.

E[min(, ) - min(, )] E[min(, ) - min(, )] E[ - ]

5.2 Main Proof

Theorem 4.1. Suppose  is a continuous class I job size distribution. Then Nudge(1, 2, 3) stochastically improves upon FCFS for any min < 1  2  3 satisfying

·

max  +  

<

1 - large (- )-1 ,

(15)

min 

1 - small (- )-1

· 1 + 3  22.

(16)

Proof. We prove Theorem 4.1 by verifying the condition in Lemma 5.2. For every  > min, we will show that Inequalities (15) and (16) together imply (10).

(i) When min <   2, the denominator of the right hand side of (10) becomes

E






min ( , small + large )

-






min

( , large

)

=

E




-




= 0.

Thus (10) is not well defined, but (13) holds trivially, which is sufficient. (ii) When 2 <  < 3, we let  = small,  = large and  =  . Then clearly 1     and
 < . By (16), we know that

E[]

=






E




large

   (22)    (1+3)

 E   (small+large)



E






min

(small

+large,

)

 E[] E[| > ] .

We can therefore apply Lemma 5.3 to obtain

E






min ( small + large,

)

-  small

E






min

(small

+large,

)

-






min

(large,

)

E   (small+large) -  small



E

  (small+large)

-




large

.

(17)

Moreover, condition (15) implies that

max  +   min 

<

1 - large (- )-1 1 - small (- )-1

=

E E

  (small+large)

-




small

  (small+large) -  large

(18)

Combining (17) with (18) establishes (10).

(iii) When   3, we have min(, small) = small and min(,  ) large =  . large Therefore, condition (15) is equivalent to (10).

Therefore, for every  > min, we have proven that P  Nudge >  < P  FCFS >  .



6 PROOF OF THEOREM 4.2: EXISTENCE OF STOCHASTIC IMPROVEMENT
Theorem 4.2. For any continuous class I job size distribution  with min = 0 and any load 0 <  < 1, there exist 1, 2, 3 satisfying (15) and (16), implying that Nudge(1, 2, 3) stochastically improves upon FCFS.

Proof. We start by constructing 1, 2, 3 that satisfy both Inequality (15) and (16). For notational

convenience, let 

=

max min

+  

.

First

fix

an

arbitrary

3

>

0 and let 2

=

3 4

3,

then

compute

Nudge: Stochastically Improving upon FCFS

15

large (- ) and choose a small enough 1 such that

1 < min

1 -

ln

1-

1 - large (- )-1 

1 , 23

.

(19)

Clearly, such 1 > min = 0 in (19) exists because  > 1, so we have

3

· 1 + 3 < 23 = 22,

(20)

·

1 - large (- )-1 1 - small (- )-1

=

1 - large (- )-1 1 - E  small -1



1 - large (- )-1 1 - - 1

>  = max  +   . min 

(21)

By Theorem 4.1, (20) and (21) together imply that P  Nudge   < P  FCFS    > min = 0. Therefore,
 > 0, P  Nudge >  < P  FCFS >  .

for every 

7 PROOF OF THEOREM 4.5: TRANSFORM OF RESPONSE TIME

In this section we compute an exact formula for  Nudge (). The formula holds for arbitrary job size

distributions, not just those of class I.

At a high level, our analysis works by considering two systems experiencing identical arrivals:

one using Nudge, and one using FCFS. We consider a tagged job arriving to this pair of systems in

equilibrium and determine how its Nudge queueing time relates to its FCFS queueing time.

· Small jobs: Nudge queueing time is FCFS queueing time, possibly minus a large job's size. · Large jobs: Nudge queueing time is FCFS queueing time, possibly plus a small job's size. · Other jobs: Nudge queueing time is identical to FCFS queueing time.

We

will

determine

Nudge
,small

(

)

and

Nudge
,large

(

)

,

from

which



Nudge ()

easily

follows.

7.1 Probabilistic Interpretation of the Laplace-Stieltjes Transform

Before jumping into the Nudge queueing time analysis, we recall a probabilistic interpretation of

the Laplace-Stieltjes transform.

Let  be a nonnegative random variable. Consider a time interval of length  and a Poisson

process of rate  that is independent of  . We call the increments of the Poisson process "interruptions". Let NoPoisson( , ) be the event that there are no interruptions during the time interval.

Then [16, Exercise 25.7]

 () = P{NoPoisson( , )} .

(22)

The interpretation in (22) necessarily requires   0. Fortunately, formulas we derive using (22) are still valid for  < 0 because Laplace transforms are uniquely defined by their value on any

bounded interval on the real line [7].

7.2 Transform for Large Jobs Lemma 7.1. The queueing time of large jobs under Nudge has Laplace-Stieltjes transform

Nudge
,large

(

)

=

1

-

small (1

-

small ())

 FCFS ()


+ small (1

-



small

(

)

) FCFS


(

+ ).

Proof. Consider a large tagged job arriving to the pair of systems, one using Nudge and the
other using FCFS, in equilibrium. We can think of the job's Nudge queueing time as the time it
takes to do the following two steps: (a) We first wait for its FCFS queueing time, namely  FCFS.


16

Isaac Grosof et al.

(b) If during that  FCFS time there has been at least one arrival, and if the first such arrival is

a small job, we then wait for that small job's service, which takes small time. Note that the
small job's size is independent of the FCFS queueing time.

We

will

use

(22)

to

compute

Nudge
,large

( ) .

To

that

end,

we

associate

each

of

the

Nudge

and

FCFS

systems with a Poisson "interruption" process of rate . The interruption processes are independent

of the arrival times and job sizes of each system, but they are coupled to each other in the following

way. At any moment in time when the systems are busy, some job  has been in service for some

amount of time . We couple the interruption processes such that interruptions occur at the same ( , ) pairs in both systems.

By

(22),

Nudge
,large

(

)

is

the

probability

that

no

interruptions

occur

during

steps

(a)

and

(b).

We

compute this probability by conditioning on the following event:

the next arrival after the tagged job is small, =
and an interruption occurs during its service

Note that  does not consider whether the next arrival occurs before the tagged job exits the queue. Therefore, it is independent of the length  FCFS of step (a).

If  does not occur, then there are no interruptions during step (b). Therefore, there are no

interruptions if and only if there are no interruptions during step (a). By (22), this happens with

probability  FCFS ().

If  does occur, then an interruption will occur during step (b) if and only if a new job arrives

during step (a). That is, by conditioning on , we have predetermined that the next arrival will

be small and, if it swaps with the tagged job, will cause an interruption. Therefore, to avoid

interruptions, we need to avoid interruptions and arrivals during step (a). Merging the arrival and interruption processes yields a Poisson process of rate  + , so avoiding interruptions corresponds

to the event NoPoisson( FCFS,  + ). By (22), this happens with probability  FCFS ( + ).





Conditioning on whether  occurs and using (22) to compute P{} = small (1 - small ()), we

obtain the desired expression.



7.3 Transform for Small Jobs Lemma 7.2. The queueing time of small jobs under Nudge has Laplace-Stieltjes transform

Nudge
,small

(

)

=

 FCFS ()


1 + large (1 - large ())  ()

/ () - / ()

- large (1 - large ()) (1 - ) ·

 -

.

The analysis of small jobs is more involved than the analysis of large jobs. We therefore state and prove several more intermediate results before proving Lemma 7.2.
Consider a small tagged job arriving to the pair of systems, one using Nudge and the other using FCFS, in equilibrium. The main question we need to answer is whether the tagged job will swap with a large job in the Nudge system. Our main insight is that we can tell whether the swap will occur by examining just the FCFS system. Because we understand FCFS well, this makes it relatively simple to tell whether a swap will occur.

Lemma 7.3. The small tagged job swaps with a large job in the Nudge system if and only if, when it arrives, the FCFS system has a nonempty queue whose last job is large.

The proof of Lemma 7.3 follows very similar reasoning to our analysis at the start of Section 5.1. For completeness, we provide a proof in Appendix B.

Nudge: Stochastically Improving upon FCFS

17

Thanks to Lemma 7.3, we can determine the queueing time of the small tagged job by looking at

the state of the FCFS system when it arrives. We describe the equilibrium state of the FCFS system

with the following quantities:

·  : the amount of work in the system.

·  : the number of jobs in the queue. · most: the amount of work in the system, excluding the last job in the queue if   1. · last: the size of the last job in the queue, or 0 if  = 0.

Note that these quantities are not independent. In particular,  = most + last. However, most

and last are conditionally independent given   1.

Armed

with

Lemma

7.3

and

the

system

state

notation,

we

are

ready

to

compute

Nudge
,small

( ) ,

thus

proving Lemma 7.2. Our computation will make use of an additional lemma which we state after

the proof and prove in Appendix B.

Proof of Lemma 7.2. Consider the small tagged job arriving to the pair of systems in equilibrium. By Lemma 7.3, its Nudge queueing time is

Nudge
,small

=

most most + last1(¬(2  last < 3))

if  = 0 if   1.

Applying (22) and the conditional independence of most and last yields

Nudge
,small

(

)

=P

NoPoisson(most, )





=0

+ P NoPoisson(most, )    1  (NoPoisson(last, )  2  last < 3)

= P NoPoisson(most, )   = 0

+ P NoPoisson(most, )    1 ·  () + large (1 - large ()) .

(23)

It remains only to compute the two probabilities in (23). Let

  P NoPoisson( , )   = 0 = P NoPoisson(most, )   = 0 ,

(24)

making  the first probability in (23). We now compute the second probability in (23) in terms of . First, note that  FCFS and  are identically distributed. Recalling the conditional independence of

most and last, we have, using (22) throughout,

 FCFS () - 


=  () - 

=P

NoPoisson( , )







1

= P NoPoisson(most, )    1  NoPoisson(last, )

= P NoPoisson(most, )    1 ·  ().

(25)

Plugging (24) and (25) into (23) yields

Nudge
,small

(

)

=



+

 FCFS () - 


1 + large (1 - large ()) .  ()

Lemma 7.4 below, proven in Appendix B, computes the value of , yielding the desired result. 

Lemma 7.4. Let   P NoPoisson( , )   = 0 . We have



=  FCFS ()

·

 ()

-  ()

=

1-



·

 ()

-  () .



 -

 ()

 -

18

Isaac Grosof et al.

7.4 Overall Response Time Transform Theorem 4.5. The response time of Nudge has Laplace-Stieltjes transform

 Nudge () =  FCFS () +   small large

large () (1 - small ())

 FCFS ( + ) -  FCFS ()





+ small () (1 - large ())

 FCFS ()


-

(1

-

/ () )

- / ()

 ()

 -

.

Proof. The expression follows by plugging the results of Lemmas 7.1 and 7.2 into

 Nudge ()

=

small

·

Nudge
,small

(

)

·

small ()

+

large

·

Nudge
,large

(

)

·

large ()

+

(1

-

small

-

 large )

·

 FCFS ()


·



( )

-

  small small () -   large large () 1 - small - large

and simplifying the resulting expression. One key step is recognizing  FCFS () =  FCFS () · ().




8 PROOF OF THEOREM 4.3: ASYMPTOTIC IMPROVEMENT

Theorem 4.3. Suppose  is a continuous class I job size distribution. For any min < 1  2  3, the asymptotic tail improvement ratio of Nudge(1, 2, 3) compared to FCFS is

 AsymTIR =   small large  +  

large (- )

-



 +



small

(-

)

-



 +





large

(-

)

small

(-



)

.

Furthermore, AsymTIR is positive, meaning Nudge < FCFS, if

 +   1 - large (- )-1

<

.



1 - small (- )-1

Below we give a high-level overview of the proof. We provide full computations in Appendix B.

Proof sketch. Using the Final Value Theorem, one can show that for Alg  {Nudge, FCFS},

Alg

=

1 

lim  Alg (
 0

-

).

Combining this with Theorem 4.5, which relates  Nudge () to  FCFS (), will relate Nudge to FCFS.

To obtain AsymTIR = 1 - Nudge/FCFS, we compute lim0 ( FCFS ( -  ) -  Nudge ( -  ))

via Theorem 4.5. Each non-vanishing term has an  FCFS ( -  ) factor. Because  FCFS () =





 FCFS ()/ (), we can express FCFS -Nudge as a constant times FCFS; this constant is AsymTIR.



9 EMPIRICAL LESSONS This paper proves that Nudge stochastically improves upon FCFS under the correct choice of parameters, and achieves multiplicative improvement in the asymptotic tail. However, there are a few practical questions remaining. These questions center around finding Nudge parameters in practice. In this section, we demonstrate several practical lessons on choosing Nudge parameters.
(1) (Section 9.1) We find that Nudge typically achieves its greatest improvement over FCFS when the Nudge parameters specify that all jobs are either large or small (i.e. 1 = 2, 3 = ).

Nudge: Stochastically Improving upon FCFS

19

Tail improvement ratio

0.05 0.04 0.03 0.02 0.01 0.00
t=0

x1 = 1, x2 = 1, x3 = 1 x1 = 2, x2 = 2, x3 = 1 x1 = 1, x2 = 2, x3 = 1 x1 = 2, x2 = 4, x3 = 1 x1 = 2, x2 = 2, x3 = 8 x1 = 1, x2 = 1, x3 = 4 x1 = 2, x2 = 4, x3 = 8 x1 = 1, x2 = 2, x3 = 4

t=5

t = 10

t = 15

t = 20

Fig. 3. Empirical tail improvement of Nudge over FCFS under a variety of Nudge parameter choices. Highest
improvement occurs when 1 = 2, 3 = . Job size distribution is hyperexponential with branches drawn from Exp(2) and Exp(1/3), where the first branch has probability 0.8. E[] = 1, 2 = 3. Simulations run
with 10 billion arrivals. Load  = 0.8. Parameter choices are listed in order of asymptotic improvement.

(2) (Section 9.2) We find that when load is low, Nudge can dramatically improve upon FCFS (10-20%) in the common case where job size variability is relatively high (i.e. 2 > 1). When job size variability is lower and load is low, improvement is smaller.
(3) (Section 9.3) We find that the space of parameters that lead Nudge to asymptotically improve upon FCFS typically also cause Nudge to stochastically improve upon FCFS. This is serendipitous, because Theorem 4.3 provides a simple, exact method to check whether given Nudge parameters will achieve asymptotic improvement over FCFS.
9.1 All Jobs Should Be Either Large or Small
When evaluating Nudge on common job size distributions, we have found that the greatest improvement over FCFS is achieved by setting the Nudge parameters such that all jobs are either large or small (i.e. 1 = 2, 3 = ), with no medium or very large jobs. This is a pattern we have seen with great consistency across a variety of job size distributions.
In Fig. 3, we show one instance of this pattern, for the case of a particular hyperexponential distribution. We see that the two choices of Nudge parameters that display the least improvement over FCFS are those where both medium and very large jobs exist, i.e. 1  2 and 3  .
To explain this phenomenon, note that when we remove medium and very large jobs, we end up with more swaps. Empirically, we have found that the quantity of swaps is more important than the quality of those swaps, and thus maximizing the number of swaps leads to the largest improvement. While empirically removing medium and very large jobs improves performance, our analytical result in Theorem 4.2 requires medium and very large jobs.
Setting the Nudge parameters so that all jobs are either large or small dramatically simplifies the problem of choosing Nudge parameters, in addition to achieving consistently strong performance. Now, only one free parameter remains: the cutoff between small and large jobs.
9.2 Low Load: Dramatic Improvement when Variability is High
At low load, Nudge has the potential for dramatic improvement over FCFS (>10% throughout the tail), in the common case where the job size distribution is more variable than an exponential distribution, i.e. 2 > 1. On the other hand, under low-variability job size distributions (2 < 1), we find that Nudge's improvement shrinks at lower loads; here it helps to set the 1 cutoff close to 0.

20

Isaac Grosof et al.

Tail improvement ratio

0.16 0.12

0.03 0.02

Triangle Uniform

Erlang Beta

0.08 0.04 0.00
t=0

t=7

Mixed Uniform Hyperexponential Chi Squared Inverse Gaussian
t = 14 t = 21 t = 28

0.01 0.00
t=0

t=3

t=6

t = 9 t = 12

(a) High variance: 2 > 1; 1 = 2 = 1, 3 =  (b) Low variance: 2 < 1; 1 = 2 = 0.2, 3 = 
Fig. 4. Empirical tail improvement of Nudge over FCFS at low load ( = 0.4) under a variety of job size distributions with E[] = 1. (a) Higher variance distributions show dramatic improvement. (b) Lower variance distributions show modest improvement. Specific distributions: In (a), Mixed Uniform: Uniform(0, 1) w/prob. 0.9, else Uniform(0, 11), 2 = 3.33; Hyperexponential: Exp(2) w/ prob. 0.8, else Exp(1/3), 2 = 3; ChiSquared(1), 2 = 2; InverseGaussian( = 1,  = 1/2), 2 = 2. In (b), Triangle w/ min = 0, mode = 0, max = 3, 2 = 1/2; Uniform(0, 2), 2 = 1/3; Erlang( = 3,  = 1/3, 2 = 1/3; Beta( = 2,  = 2) scaled by a factor of 2, 2 = 1/5. Distributions listed in order of asymptotic improvement. Simulations run with 10 billion arrivals.

In Fig. 4 we show these patterns for a wide variety of distributions at relatively low load  = 0.4. In Fig. 4(a), we have four high-variance job size distributions, each with 2  [2, 3.33]. In every case, Nudge dramatically improves upon FCFS, with TIR in the range of 10-15%. In Fig. 4(b), we have four low-variance job size distributions, each with 2  [1/5, 1/2]. In these cases, we reduce the cutoff 1 to 0.2 for best performance, and Nudge's improvement over FCFS is under 3%.
Intuitively, when load is low, each job waits behind fewer other jobs on average, so Nudge's one swap per job has a greater relative impact. When those swaps are broadly beneficial for the tail, as occurs when job size variance is high, Nudge achieves the most dramatic improvement over FCFS. When job size variance is low, swaps involving small jobs that are near the mean job size cause the response time of the large jobs to suffer too much. To alleviate this, we reduce the small job cutoff 1 to maintain stochastic improvement over FCFS.
9.3 Asymptotic Improvement Means Stochastic Improvement After extensively simulating Nudge under different loads and job size distributions, we have found that the space of parameters under which Nudge asymptotically improves upon FCFS typically matches the space under which Nudge stochastically improves upon FCFS.
In Table 1, we show the consistency of this relationship across a wide variety of job size distributions and choices of Nudge parameters. The distributions range from a low-variance Beta distribution with 2 = 1/5 to a hyperexponential distribution with 2 = 3. Across the spectrum, Nudge stochastically improves over FCFS whenever it asymptotically improves over FCFS.
This connection between asymptotic and stochastic improvement is surprising given that the conditions that we need to prove stochastic improvement (Theorem 4.1) are much more stringent than what we need to prove asymptotic improvement (Theorem 4.3). Nonetheless, the connection is highly useful because we have provided a simple analytical formula for determining when Nudge asymptotically improves upon FCFS (Theorem 4.3).

Nudge: Stochastically Improving upon FCFS

21

Job size dist. 1 Asym. Stoc. 1 Asym. Stoc. 1 Asym. Stoc. 1 Asym. Stoc. 1 Asym. Stoc. Exponential 0.5   1   2 × × 4 × × 8 × ×

Hyperexponential 0.5   1   2   4   8  

Bounded Lomax 0.5   1   1.5 × × 2 × × 3 × ×

Uniform 0.1   0.2   0.5 × × 0.75 × × 1 × ×

Beta

0.1   0.2   0.3 × × 0.4 × × 0.5 × ×

Table 1. Presence or absence of asymptotic and stochastic improvement of Nudge over FCFS under a variety

of job size distributions and Nudge parameter choices. Stochastic improvement occurs whenever asymptotic

improvement occurs. Each row gives a distinct job size distribution, and each cell gives a distinct Nudge

parameter setting. In every case, 2 = 1 and 3 = , so only 1 is specified. Load  = 0.4. Specific job size distributions, each with mean 1: Exponential with mean 1, Uniform(0, 2), Hyperexponential drawn from

Exp(2) w/ prob. 0.8 and Exp(1/3) with prob. 0.2, BoundedLomax( = 2, max = 4,  = 2), Beta( = 2,  = 2)

scaled by a factor of 2.

10 NUDGE IN PRACTICE Nudge can be used in practice even if some of the assumptions made in this paper are not perfectly satisfied.
In this paper, we assume that exact job size information is known to the scheduler. However, such information is only used to determine which size class (small, large, etc.) a job should be placed in. In practice, only estimates of job size may be known. In such a setting, the scheduler could assign jobs that are clearly above or below a size threshold to the large and small classes, while placing ambiguous jobs in the medium class. If the estimates are reasonably accurate, we would expect such a Nudge policy to stochastically improve upon FCFS.
We also assume that the exact job size distribution is known to the scheduler. This assumption is needed to choose the Nudge parameters for our proofs in Section 4. However, our empirical results in Section 9 show that much less information is needed in practice to choose good Nudge parameters. For instance, as we saw in Section 9.2, the following choice of parameters works well empirically: By default, set 1 = 2 =  [], 3 = . However, if load is low and job size variability (2) is low, set 1 = 2 =  []/5, 3 = .
11 VARIANTS ON NUDGE As Nudge is such a simple policy, there are many interesting variants of Nudge that one could investigate. We now discuss the advisability of several such variants.
Recall that Nudge only ever swaps a job at most once. One might consider allowing a job to swap a second or third time with new arrivals, or even an unlimited number of times. Unfortunately, this change could ruin Nudge's stochastic improvement over FCFS, if implemented poorly. In particular, under a Nudge variant where large jobs can be swapped with an unlimited number of small arrivals, such highly-swapped large jobs will typically dominate the response time tail, dramatically worsening the variant's tail performance. A wiser variant might be to allow large jobs to be swapped with a bounded number of small jobs, or to allow only the small jobs to be swapped an unlimited number of times.
Another interesting variant of Nudge would only swap in a probabilistic fashion, such as with an i.i.d. coin flip. We believe such a policy could achieve stochastic improvement over FCFS. However, proving such a result would be no simpler than for Nudge, because probabilistic swapping does not change the shape of the distribution of swaps. Moreover, the variant's tail improvement ratios

22

Isaac Grosof et al.

would likely be smaller than those of Nudge, because a smaller fraction of jobs are involved in swaps.
Finally, one could design a more complicated variant of Nudge which would consider a job's exact size when deciding whether to swap, rather than simply comparing the job's size to a threshold. For instance, one might decide to swap all pairs of jobs whose sizes differ by a factor of 2, as long as neither job has yet been swapped. These more complicated Nudge variants might achieve even larger stochastic improvements over FCFS than Nudge. Beyond FCFS, such Nudge variants might be able to stochastically improve upon some or even all Nudge policies. We leave this possibility as an open question.
12 CONCLUSION We introduce Nudge, the first scheduling policy whose response time distribution stochastically improves upon that of FCFS. Specifically, we prove that with appropriately chosen parameters, Nudge stochastically improves upon FCFS for light-tailed job size distributions6. From an asymptotic viewpoint, we prove that Nudge achieves a multiplicative improvement over FCFS, disproving the strong asymptotic optimality conjecture for FCFS. Finally, we derive the Laplace-Stieltjes transform of response time under Nudge, using a novel technique. Nudge is simple to implement and is a practical drop-in replacement for FCFS when job sizes are known.
One of the major insights of this paper is that improving the tail does not follow the same intuitions that we use in improving the mean. While improving mean response time is often a matter of helping small jobs jump ahead of large ones, when it comes to the tail, this has to be done in a very measured way. Too much help to the small jobs causes the tail to get a lot worse. Nudge finds the exactly appropriate way to do this.
One direction for future work is further exploring the stochastic improvement frontier. Can we stochastically improve upon other commonly used scheduling policies? Can we improve upon Nudge itself, such as with a more complicated variant of Nudge (see Section 11)? One policy which cannot be stochastically improved upon is SRPT, due to its optimal mean response time. Can we prove that other policies are unimprovable?
Another direction is simplifying the definition of Nudge. Our empirical results in Section 9 indicate that in practice, Nudge can always stochastically improve upon FCFS with only two classes of jobs: small and large. It would be of practical importance to figure out how to extend the theorems in this paper to hold for this simplified definition of Nudge.
ACKNOWLEDGEMENTS We thank Sem Borst and the anonymous referees for their helpful comments. This research was supported by NSF-CMMI-1938909, NSF-CSR-1763701, and a Google 2020 Faculty Research Award.
REFERENCES
[1] Joseph Abate, Gagan L Choudhury, and Ward Whitt. 1994. Waiting-time tail probabilities in queues with long-tail service-time distributions. Queueing systems 16, 3-4 (1994), 311­338.
[2] Joseph Abate, Gagan L. Choudhury, and Ward Whitt. 1995. Exponential Approximations for Tail Probabilities in Queues, I: Waiting Times. 43, 5 (1995), 885­901.
[3] Joseph Abate and Ward Whitt. 1997. Asymptotics for M/G/1 low-priority waiting-time tail probabilities. Queueing Systems 25, 1-4 (1997), 173­233.
[4] John T. Blake and Michael W. Carter. 1996. An analysis of emergency room wait time issues via computer simulation. INFOR 34, 4 (November 1996), 263­273.
[5] Onno Boxma and Bert Zwart. 2007. Tails in Scheduling. ACM SIGMETRICS Performance Evaluation Review 34, 4 (March 2007), 13­20.
6More specifically, continuous class I job size distributions with positive density at 0.

Nudge: Stochastically Improving upon FCFS

23

[6] Percy H Brill. 2000. A brief outline of the level crossing method in stochastic models. CORS Bulletin 34, 4 (2000), 9­21. [7] Patrick Chareka. 2007. A Finite-Interval Uniqueness Theorem for Bilateral Laplace Transforms. International Journal
of Mathematics and Mathematical Sciences 2007 (2007), 6 pages. [8] Y. Chen, S. Iyer, X. Liu, D. Milojicic, and A. Sahai. 2007. SLA Decomposition: Translating Service Level Objectives to
System Level Thresholds. In Fourth International Conference on Autonomic Computing (ICAC'07). 10 pages. [9] Mark E. Crovella, Murad S. Taqqu, and Azer Bestavros. 1998. Heavy-Tailed Probability Distributions in the World
Wide Web. In A Practical Guide To Heavy Tails. Chapman & Hall, New York, Chapter 1, 1­23. [10] Mark M. Davis. 1991. How Long Should a Customer Wait for Service? Decision Sciences 22, 2 (1991), 421­434. [11] Eric J. Friedman and Shane G. Henderson. 2003. Fairness and Efficiency in Web Server Protocols. In Proceedings of the
2003 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems (San Diego, CA, USA) (SIGMETRICS '03). Association for Computing Machinery, New York, NY, USA, 229­237. [12] Eric J Friedman and Gavin Hurley. 2003. Protective scheduling. Technical Report. Cornell University Operations Research and Industrial Engineering.
[13] S. W. Fuhrmann and Robert B. Cooper. 1985. Stochastic Decompositions in the M/G/1 Queue with Generalized Vacations. Operations Research 33, 5 (Oct. 1985), 1117­1129.
[14] Mor Harchol-Balter. 1999. The Effect of Heavy-Tailed Job Size Distributions on Computer System Design. In Proceedings of the ASA-IMS Conference on Applications of Heavy Tailed Distributions in Economics, Engineering and Statistics. Washington, DC.
[15] Mor Harchol-Balter. 2002. Task Assignment with Unknown Duration. J. ACM 49, 2 (March 2002), 260­288. [16] Mor Harchol-Balter. 2013. Performance Modeling and Design of Computer Systems: Queueing Theory in Action. Cambridge
University Press, Cambridge. [17] Mor Harchol-Balter. 2021. Open poblems in queueing theory inspired by datacenter computing. Queueing Systems:
Theory and Applications 97, 1 (2021), 3­37. [18] Mor Harchol-Balter, Mark Crovella, and Cristina Murta. 1999. On Choosing a Task Assignment Policy for a Distributed
Server System. IEEE Journal of Parallel and Distributed Computing 59 (1999), 204­228. [19] Leora I. Horwitz, Jeremy Green, and Elizabeth H. Bradley. 2010. US Emergency Department Performance on Wait
Time and Length of Visit. Annals of Emergency Medicine 55, 2 (2010), 133 ­ 141. [20] John F. C. Kingman. 1962. On Queues in Which Customers Are Served in Random Order. Mathematical Proceedings of
the Cambridge Philosophical Society 58, 1 (Jan. 1962), 79­91. [21] J. F. C. Kingman. 1964. A martingale inequality in the theory of queues. Mathematical Proceedings of the Cambridge
Philosophical Society 60, 2 (1964), 359­361. [22] J. F. C. Kingman. 1970. Inequalities in the Theory of Queues. Journal of the Royal Statistical Society: Series B
(Methodological) 32, 1 (1970), 102­110. [23] Leonard Kleinrock. 1976. Queueing Systems, Volume 2: Computer Applications. Wiley, New York, NY. [24] Jeffrey C. Mogul and John Wilkes. 2019. Nines are not enough: Meaningful metrics for clouds. In Proceedings of the
Workshop on Hot Topics in Operating Systems (HotOS19). USA, 136 ­ 141. [25] Jayakrishnan Nair, Adam Wierman, and Bert Zwart. 2010. Tail-robust scheduling via limited processor sharing.
Performance Evaluation 67, 11 (2010), 978 ­ 995. [26] Misja Nuyens, Adam Wierman, and Bert Zwart. 2008. Preventing Large Sojourn Times Using SMART Scheduling.
Operations Research 56, 1 (2008), 88­101. [27] Natalia Osipova, Urtzi Ayesta, and Konstantin Avrachenkov. 2009. Optimal Policy for Multi-Class Scheduling in a
Single Server Queue. In 2009 21st International Teletraffic Congress. IEEE, Paris, France, 1­8. [28] T. Sakurai. 2004. Approximating M/G/1 Waiting Time Tail Probabilities. Stochastic Models 20, 2 (2004), 173­191. [29] Linus Schrage. 1968. A proof of the optimality of the shortest remaining processing time discipline. Operations Research
16 (1968), 687­690. [30] Linus E. Schrage. 1967. The Queue M/G/1 with Feedback to Lower Priority Queues. Management Science 13, 7 (March
1967), 466­474.
[31] Linus E. Schrage and Louis W. Miller. 1966. The Queue M/G/1 with the Shortest Remaining Processing Time Discipline. Operations Research 14, 4 (Aug. 1966), 670­684.
[32] Ziv Scully, Mor Harchol-Balter, and Alan Scheller-Wolf. 2018. SOAP: One Clean Analysis of All Age-Based Scheduling Policies. Proc. ACM Meas. Anal. Comput. Syst. 2, 1, Article 16 (April 2018), 30 pages.
[33] Ziv Scully, Lucas van Kreveld, Onno J. Boxma, Jan-Pieter Dorsman, and Adam Wierman. 2020. Characterizing Policies with Optimal Response Time Tails under Heavy-Tailed Job Sizes. Proceedings of the ACM on Measurement and Analysis of Computing Systems 4, 2, Article 30 (June 2020), 33 pages.
[34] Kut C. So and Jing-Sheng Song. 1998. Price, delivery time guarantees and capacity selection. European Journal of Operational Research 111, 1 (1998), 28 ­ 49.

24

Isaac Grosof et al.

[35] David A Stanford, Peter Taylor, and Ilze Ziedins. 2014. Waiting time distributions in the accumulating priority queue. Queueing Systems 77, 3 (2014), 297­330.
[36] Alexander L. Stolyar and Kavita Ramanan. 2001. Largest Weighted Delay First Scheduling: Large Deviations and Optimality. Annals of Applied Probability 11, 1 (2001), 1­48.
[37] Muhammad Tirmazi, Adam Barker, Nan Deng, MD E. Haque, Zhijing Gene Qin, Steven Hand, Mor Harchol-Balter, and John Wilkes. 2020. Borg: The next generation. In Proceedings of the Fifteenth European Conference on Computer Systems (EuroSys '20). Greece, 1­14.
[38] Timothy L. Urban. 2009. Establishing delivery guarantee policies. European Journal of Operational Research 196, 3 (2009), 959 ­ 967.
[39] Peter D. Welch. 1964. On a Generalized M/G/1 Queuing Process in Which the First Customer of Each Busy Period Receives Exceptional Service. Operations Research 12, 5 (Oct. 1964), 736­752.
[40] Adam Wierman and Bert Zwart. 2012. Is Tail-Optimal Scheduling Possible? Operations Research 60, 5 (Oct. 2012), 1249­1257.
[41] Ronald W. Wolff. 1982. Poisson Arrivals See Time Averages. Operations Research 30, 2 (1982), 223­231.

A PROOFS FOR STOCHASTIC IMPROVEMENT
Lemma 3.1. Suppose  is a continuous class I job size distribution. For any load , the normalized p.d.f. () is bounded above and below by positive constants, and lim () exists.

Proof. First we show (following prior work [1, 3, 28]) that  FCFS has a simple pole -  as its

rightmost singularity.

We let -  be the root of the denominator of  FCFS (), which is


 -  () -  +  = 0   () = .


Since the left hand  () is convex in 7, and the right hand - is only linear in , their intersection

 = -  must be a simple root. Moreover, such an intersection exists for  < 0 because

·  (0) = -0 = 1;



·  (0) = - 1 > - 1 ;





·  ()   when  approaches the rightmost singularity of  (since  is a class I distribution).

Now we use final value theorem to establish the limit of the ratio between the p.d.f.  FCFS and



the

exponential

function

-  .

Recall

the

function

 ( )

=




FCFS

(

)



and

consider

its

Laplace



transform  () =  FCFS ( - ). Since the poles of  () map one-to-one to the poles of  FCFS ( - ),





the above arguments show that every pole of  () is either in the open left half plane or at the

origin, and the origin is a simple pole. Therefore, the Final Value Theorem for () tells us

lim  FCFS ( )
  

= lim ()
 

= lim  ()
 0

=

(1 - ) - (- ) - 1






>

0.

(26)

Since

the

limit 

exists,

for



=


2,

there

exists



<



such

that





 ,

| ( )

-




|








 -  



 FCFS ( )



3 -  .

2

2



2

Next, we want to show that

min () > 0 and max () < .

(27)

0 <

0 <

7We

have

 ()

=




 =0



2

-



(

)

d

>

0

for

every



in

the

convergence

region

of

 ( ·).

Nudge: Stochastically Improving upon FCFS

25

First, note that  FCFS satisfies the following level-crossing differential equations [6] (we abbrevi-

ate  FCFS to  ):


 (0) = (1 - );



 ( )

=



( )

-

(1

-

 ) 

( )

-




 =0



(

-

) 

()

d.

To begin with,  () is continuous because  () is continuous. If  () = 0 for some  <  ,
we let 0 = inf { <  :  () = 0}. Clearly 0 > 0 because  (0) = (1 - ) > 0. Note also that  (0) = 0, because  is continuous. Since  (0) <  (0), 0 < 0 < 0 s.t.  (0) > 0. Then ,  where 0   < 0 <   0, s.t.  () > 0 for all   [, ]. Now we have

 0  (0) = -(1 - ) (0) -   (0 - )  ( ) d < 0
 =0

because the first term -(1 - ) (0)  0 and the second term

 0



-  (0 - )  ( ) d  -  (0 - )  ( ) d < 0.

 =0

 =

But  (0) < 0 is impossible, because we assumed that  (0) = 0. The implication that  (0) < 0

contradicts the fact that  is a non-negative probability density function. Therefore,

min ()  min () > 0.

0 <

0 <

On the other hand, since  ()   () everywhere, we have  ()  (1 - ) . Note that this

bound holds even if  has infinite density at one or more points. As a result,

max ( )  max  FCFS ( )  (1 - )  < .

0 <

0 < 

Finally, note that



inf ( )  min  min
  [0,)

inf
0 <

 FCFS ( )


 ,
2

>0

sup ( )  max  max
  [0,)

sup
0 <

 FCFS ( )


3 ,
2

<

which indicates both min and max are well-defined and nonzero. This completes the proof. 

Lemma 5.3. Let ,  be two independent real-valued random variables and  be a fixed constant. Suppose 1     and  < . Under these assumptions, if P{ > } > 0 and

E[]  E[] E[| > ] ,

(28)

then

E[min(, ) - min(, )] =

E[min(, ) - ]



E[ - ] .

(29)

E[min(, ) - min(, )] E[min(, ) - min(, )] E[ - ]

Proof. First we observe E[min(, ) - ] > E[min(, ) - min(, )] because  < min(, ).

Based on this, we can shrink the left hand side of inequality (29) by adding the same positive term

to both the denominator and numerator. We compute

E[min(, ) - ] =

E[ - ] - E[( - )1> ]

. (30)

E[min(, ) - min(, )] E[ - ] - E[( - )1> ] + E[( - )1> ]

Since   1 and  > 0, we have   . Therefore,

0  1> - 1>  1> = 1->0.

26

Isaac Grosof et al.

We proceed by adding a positive term, E[( - ) (1> - 1> )], to both the denominator and numerator of the right hand side of (30) and obtain

E[min(, ) - ]



E[ - ]

- E[(

- )1> ] .

E[min(, ) - min(, )] E[ - ] - E[( - )1> ]

Hence, to establish inequality (29), it suffices to show

E[( - )1> ]  E[ - ] E[( - )1> ] E[ - ]  E[( - )1> ] E[ - ]  E[( - )1> ] E[ - ]  (E[] E[| > ] - ) P{ > } E[ - ]  (E[] - 1) E[| > ] P{ > } E[ - ]

 E[] (E[] - 1)  E[] E[| > ] (E[] - 1)

 E[]  E[] E[| > ] ,

which is precisely the condition provided in (28).



B PROOFS FOR TRANSFORM ANALYSIS
Lemma 7.3. The small tagged job swaps with a large job in the Nudge system if and only if, when it arrives, the FCFS system has a nonempty queue whose last job is large.

Proof. By definition of Nudge, the tagged job swaps if and only if, when it arrives, the Nudge

system has a nonempty queue whose last job is a large job that has not been swapped. It therefore

suffices to show that at any moment in time, the FCFS system has a nonempty queue whose last

job is large if and only if the Nudge system has a nonempty queue whose last job is a large job that

has not been swapped.

We first note that the total amount of work in both systems is the same at every moment in time,

because both FCFS and Nudge are work conserving.

Suppose the FCFS system has a nonempty queue whose last job  is large. Because it is the last

job in the FCFS queue, there have been no new arrivals after . In the Nudge system, this means

 has not been swapped, so either  is the last job in the Nudge queue or has entered service. By

work conservation, both systems had the same amount of work when  arrived, so  must still be

in the Nudge queue, as desired.

Suppose the Nudge system has a nonempty queue whose last job  is a large job that has not

been swapped. We argue similarly to the previous direction: there have been no arrivals since 

because it is at the end of the Nudge queue without being swapped, and  cannot have entered

service in the FCFS system by work conservation, so  must be the last job in the FCFS queue, as

desired.



Lemma 7.4. Let   P NoPoisson( , )   = 0 . We have



=  FCFS ()

·

 ()

-  ()

=

1-



·

 ()

-  () .



 -

 ()

 -

To prove Lemma 7.4, we require an additional lemma.

Lemma B.1. Let  be a nonnegative random variable, and let Exp( ) and Exp() be exponentially distributed random variables of rates  and , respectively. Suppose  , Exp( ), and Exp() are mutually independent. Then
 () -  ( ) P{ < Exp( ) + Exp()} =  -  .

Nudge: Stochastically Improving upon FCFS

27

Proof. We compute



P{ < Exp( ) + Exp()} = P{ < Exp( ) + Exp()}  () d

=0

    

=

1(

<



+

)

·

- 


·

-


d

d

 () d

=0 =0  =0

  -  - -

=
=0

 -

 () d

 () -  ( )

=

.

 -



Proof of Lemma 7.4. Consider a FCFS system in equilibrium along with an independent Poisson "interruption" process of rate . Call a job lucky if it enters the system while  = 0 and experiences no interruptions during its queueing time. Because Poisson arrivals see time averages [41],  is
probability an arriving job is lucky. We compute  in an unusual way. Let a job's departure period be the time interval starting when
the job enters service and ending when the next job enters service. Jobs enter service at average
rate , so  is the average number of lucky jobs that arrive a departure period. More formally, by
renewal-reward theorem,
 = P{arrival is lucky}
average rate of lucky arrivals =
 average rate of lucky arrivals = average rate of departure periods = E[number of lucky arrivals during a departure period] .
Moreover, because a job is lucky only if  = 0, only the first arrival in a departure period can possibly be lucky, so
 = P{first arrival in a departure period is lucky} .

Consider a job . The first arrival in 's departure period is lucky if both of the following events occur:

1 = there are no arrivals during 's queueing time 2 =  completes before the first interruption after the first arrival of 's departure period.

By

(22),

P{1}

=  FCFS ().


We

compute

P{2

|

1}

below.

Conditioned on 1, the queue is empty when  enters service, so the first arrival during 's

departure period is simply the first arrival after  enters service. Let Exp() be the amount of time

between when  enters service and the next arrival, and let Exp() be the amount of time between

that next arrival and the first interruption after it. Both Exp() and Exp() are exponentially

distributed with rates  and , respectively, and they and 's size are mutually independent. Because

's size is distributed as , we have

 () -  ()

P{2 | 1} = P{ < Exp() + Exp()} =

,  -

where the latter equality follows from Lemma B.1 below.

28

Isaac Grosof et al.

It remains only to show  FCFS () = (1 - )/ (). Because response time  FCFS is a sum of


independent random variables with distributions  FCFS and , we have  FCFS () =  FCFS ()/ ().





By (22),  FCFS () is the probability that no arrivals occur during a job's response time. But this is

simply the probability that a job leaves an empty system when it departs, which is 1 - .



Theorem 4.3. Suppose  is a continuous class I job size distribution. For any min < 1  2  3, the asymptotic tail improvement ratio of Nudge(1, 2, 3) compared to FCFS is

 AsymTIR =   small large  +  

large (- )

-



 +



small

(-

)

-



 +





large

(-

)

small

(-



)

.

Furthermore, AsymTIR is positive, meaning Nudge < FCFS, if

 +   1 - large (- )-1

<

.



1 - small (- )-1

Proof. We prove this theorem using the Laplace-Stieltjes transform derived in Theorem 4.5. The transform of the tail of  Nudge can be calculated as



- P

Nudge


>



 =0



d = -

P

Nudge


>

d

 -

 =0



=-

P

Nudge


>



 -

 +

 -

dP

Nudge
 >

 0 =0 

1 =



1-



-




Nudge

(

)

d



 =0

1 -  Nudge ()

=

.

(31)



Then the transform of  P  Nudge >  is obtained by translating (31) horizontally through  

units:



-


 P  Nudge > 

 =0

1 -  Nudge ( -  )

d =

 -

.

Now, we are ready to calculate Nudge using this transform. From Final Value Theorem,

Nudge

=

lim






P

 

Nudge


>

1 -  Nudge ( -  )

= lim 
 0

 -

=

1 

lim  Nudge (
 0

- )

Now, we substitute the expression from Theorem 4.5, and drop terms that are negligible in   0

limit.

1 

lim  Nudge (
 0

-

)

1 = FCFS +   smalllarge

large (-

) (small (-

)

-

1),FCFS

+

small

(- ) (1

-

large

(- ))

,FCFS  (- )

,

(32)

Nudge: Stochastically Improving upon FCFS

29

where

,FCFS

= lim  FCFS (
0 

- )

 FCFS ( -  ) = lim 
0  ( -  )

=

 FCFS .
 (- )

(33)

We recall that -  is the rightmost singularity of  FCFS () = (1-) , which indicates that  



 ()-+

is the smallest positive value that satisfies



(- )

-



-




=

0

and

 (- ) =  +   .

(34)



Using (33) and (34) to simplify (32), we obtain

Nudge

= FCFS

 1 -   small large  +  

large (- )

-



 +





small

(

-



)

-



 +



large

(

-



)small

(

-



)

.

This gives us

AsymTIR = 1 - Nudge

FCFS

 =   small large  +  

large (- )

-



 +



small

(-

)

-



 +





large

(-

)

small

(-



)

.

By assumption,

 +   1 - large (- )-1

<

,



1 - small (- )-1

so we have

AsymTIR

=

  small large



 + 

large (- )small (- )

small (- )-1

-



 +



large

(

-



)

-1

-



 + 

=

  small large



 +



large (- )small (- )

  + 

1-large (- )-1 - 1-small (- )-1

> 0.

Hence Nudge < FCFS.



