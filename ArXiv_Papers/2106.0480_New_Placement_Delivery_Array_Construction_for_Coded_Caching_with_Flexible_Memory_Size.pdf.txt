arXiv:2106.00480v1 [cs.IT] 1 Jun 2021

1
New Placement Delivery Array Construction for Coded Caching with Flexible Memory Size
Xianzhang Wu, Minquan Cheng, Li Chen, Senior Member, IEEE, and Congduan Li, Member, IEEE
Abstract
Coded caching is an emerging technique to alleviate the network pressure in data transmissions. In such a scheme, each file in the data center or library is usually divided into a number of packets to pursue a low broadcasting rate based on the designed placements at each user's cache. However, the implementation complexity of this scheme increases as the number of packets increases. Therefore, it is crucial to design a scheme with a small subpacketization, while maintaining a relatively low transmission rate. In this paper, a placement delivery array (PDA) scheme that works with flexible memory sizes is proposed, and then it is generalized to fit more scenarios. It is shown that the subpacketization level can be decreased while maintaining the same number of users, memory ratio and transmission rate.
Index Terms
Coded caching scheme, placement delivery array, proper orthogonal array, subpacketization, transmission rate
I. INTRODUCTION
T HE fast growing demands of video streaming services can easily cause severe network congestions during Internet peak hours. One possible solution is to exploit the off-peak network resources, such as to cache some of the possibly demanded contents in users' local memories, i.e., caches. This is a natural way to utilize each user's own cache to decrease the network traffic when the cached files are requested. The gain offered by this approach, which is called local gain, depends on the local cache size. A more effective way of caching, namely the coded caching, proposed by Maddah-Ali and Niesen in [1], further reduces the network pressure during the peak hours by strategically designing the contents cached into network users to obtain the global gain.
The renowned model proposed in [1] is called the centralized coded caching system, as shown in Fig. 1, where a central server contains N files with equal size. It is connected to K users over a shared link and each user has a cache memory size of M files. A coded caching scheme consists of two phases: the placement phase during the off-peak hours and the delivery phase during the peak hours. In the placement phase, the server sends contents to each user's cache without knowledge of the demands. In the delivery phase, each user requires one file randomly and the server will then send at most R coded files, where R is referred as the transmission rate, i.e., the maximal transmission load in the delivery phase. Each user is able to recover its requested file from the signal received in the delivery phase with the assistance of its own cache content. A coded caching scheme is called F -division scheme if each of its files can be equally split into F packets. If the packets of all files are cached directly in the placement phase, it is called the uncoded placement; otherwise, it is called the coded placement.
Since this model is characterized by (K, M, N ), it is also called the MN scheme [1]. When K  N , it was shown to be optimal under uncoded placement [2]. Furthermore, Yu et al. [3] showed that the ratio between the transmission rate of the MN scheme and the lower bound of coded caching transmission rate is less than two. However, subpacketization of the scheme increases rapidly with the number of users K. When K becomes large, it will be impractical. Therefore, in this centralized coded caching scheme, it is important to reduce the subpacketization level.
It is well known that with a fixed number of users and memory ratio, there exists a tradeoff between the transmission rate and the subpacketization level. There exist several investigations focusing on the construction of the coded caching schemes with lower subpacketization levels at the cost of mildly increasing transmission rate [4]­[13]. In [9], Shanmugam et al. pointed out that all the deterministic F -division coded caching schemes can be recast into an F × K combinatoric structure, which is called placement delivery array (PDA) [12]. Later, Cheng et al. [14] showed that given the minimum rate, the MN scheme achieves the minimum supacketization. However, the subpacketization remains too large in practice. Based on the MN scheme, two schemes, each of which has the minimum subpacketization for a fixed transmission rate and memory size, were proposed
Xianzhang Wu and Congduan Li are with School of Electronics and Communication Engineering, Sun Yat-sen University, Guangzhou 510006, China, (e-mail: wuxzh7@mail2.sysu.edu.cn, licongd@mail.sysu.edu.cn).
Minquan Cheng is with Guangxi Key Lab of Multi-source Information Mining & Security, Guangxi Normal University, Guilin 541004, China, (e-mail: chengqinshi@hotmail.com).
Li Chen is with School of Electronics and Information Technology, Sun Yat-sen University, Guangzhou 510006, China, (e-mail: chenli55@mail.sysu.edu.cn).

2

Fig. 1: Coded caching system.

in [14]. Shangguan et al. [7] reduced the subpacketization of the MN scheme by increasing the transmission rate based on hypergraphs and partitions, respectively. Cheng et al. [15] expanded the construction of [7] and obtained the coded caching scheme with a flexible memory size. They [16] further improved the subpacketization of [7] with the same number of users, memory ratio and transmission rate based on the orthogonal arrays (OAs). Zhang et al. [17] improved the schemes in [12] by considering the scenario in which some packets cached by users do not generate multicasting opportunities in the delivery phase. There are other characterizations of the coded caching schemes, such as concatenating construction [10], [18], [19], bounded subsets [20], combinations of strong edge colorings [21] and etc. The following Table I summarizes some of the known deterministic schemes with advantages in the subpacketization or the transmission rate.

TABLE I: Summary of Some Known Schemes

Schemes and parameters MN scheme in [1], any k, t  N+ with t < k Scheme in [7], any m, q, t  N+ with t < m and q  2
Scheme in [15], any m, t, z, q  N+ with t < m, z < q and q  2 Scheme in [15], any m, z, q  N+ with t = 1, m > 1, z < q and q  2
Scheme in [16], any m, t and q  N+ with t < m and q  2

User number K

k

m t

qt

m t

qt

m t

qt

(m + 1)q

m t

qt

Caching

ratio

M N

t

k

1

-

(

q-1 q

)t

1

-

1 qt

1

-

(

q-z q

)t

z q

1

-

(

q-1 q

)t

Rate R
k-t 1+t
(q - 1)t
1 (q-1)t (q-z)t
q-1 t q-z (q-z) q-1 q-z
(q - 1)t

Packet number F
k t
qm
(q - 1)tqm

q-1 q-z

tqm

q-1 q-z

qm

qm-1

It remains challenging to reduce the subpacketization level while maintaining a large coding gain (the frequency of a non-star entry in a PDA). The combinatorial structure of PDAs is equivalent to the strong edge colorings of bipartite graphs or regular graphs, which is an NP-complete problem in graph theory. This implies that the PDA schemes with a smaller subpacketization level have a stronger combinatorial structure with the same number of users, memory ratio and transmission rate. Therefore, it is worth to expand the construction of [16] with a flexible memory size, significantly decreased subpacketization, while maintaining the same number of users, memory ratio and transmission rate as that in [15].
This paper follows the steps of [16]. We find that the special OAs, i.e., the proper OAs, can be utilized to design a PDA scheme with a flexible memory size. It will be shown that designing such coded caching schemes can be converted to finding the appropriate row indices of array under the PDA constraints. From this point of view, we present two classes of PDA schemes by using the proper OAs, one from expanding the construction of [16], and the other from some "  "s of the proposed PDAs without generating multicasting opportunities in the delivery phase. By analyzing our schemes, it is further shown that the new PDA schemes can significantly reduce the subpacketization level over the existing scheme in [15]. The new PDA schemes can also yield a more flexible memory size, providing a wider range of applications.
The remaining of the paper is organized as follows. In Section II, we state the preliminaries for this work, including the centralized coded caching system and the known PDA constructions based on OAs. The new PDA schemes and their sketch proofs are presented in Section III. Performance analysis of the proposed PDA schemes is given in Section IV. Finally, Section V concludes the paper.

II. PRELIMINARIES
This section presents the preliminaries of the work, including the caching system and the PDA. Note that arrays, vectors and sets are represented by bolded capital letters, bolded lower-case letters and curlicue letters, respectively. Let N+ denote the positive integer set, while [x, y) = {x, x + 1, · · · , y - 1} and [x, y] = {x, x + 1, · · · , y} denote the intervals of integers

3

between two integers x and y (x < y) with different boundary elements. Given m, t  N+ with t < m, we denote

[0,m) t

=

{S | S  [0, m), |S| = t}. For a length-m vector a and a set S  [0, m), a|S is a vector obtained by deleting the coordinates

j  [0, m) \ S. Moreover, vectors are considered as strings, e.g., (1, 0, 1, 0) is written as (1010).

A. Centralized Coded Caching System

In a (K, M, N ) caching system, the N files and K users can be denoted by W = {W0, W1, · · · , WN-1} and K = {0, 1, · · · , K - 1}, respectively. A coded caching scheme consists of two phases as follows.

· Placement Phase: Each file is divided into F equal packets1, i.e., Wn = {Wn,j|j  [0, F )}, n  [0, N ). Each user can access the files set W. Let Zk denote the packet subset of W cached by user k, where k  K. The size of Zk cannot be greater than each user's cache memory size M .

· Delivery Phase: Each user randomly and independently requests one file from W. The request is denoted by d = (d0, d1, · · · , dK-1), i.e., user k requests file Wdk , where k  K and dk  {0, 1, · · · , N - 1}. Once the server receives the request d, it broadcasts a signal of at most RF packets such that each user can recover its requested file together with the
contents in its own cache.

The above two phases can be described by using the PDA.

Definition 1 [12]. Given K, F, Z, S  N+, an F × K array P = (pi,j) (i  [0, F - 1] and j  [0, K - 1]), which consists of a special symbol "  " and S nonnegative integers 0, 1, · · · , S - 1, is called a (K, F, Z, S) PDA if it satisfies the following conditions:

C1. The symbol "  " appears exactly Z times in each column;

C2. Each integer of {0, 1, · · · , S - 1} appears at least once in the array;

C3. For any two distinct entries pi1,j1 and pi2,j2 , pi1,j1 = pi2,j2 = s is an integer only if (a). i1 = i2, j1 = j2, i.e., they lie in distinct rows and distinct columns; and

(b). pi1,j2 = pi2,j1 = , i.e., the corresponding 2 × 2 subarray formed by rows i1, i2 and columns j1, j2 must be in one of

the following forms

s s ,

s s

.

For example, it can be seen that the following array is a (4, 4, 2, 4) PDA.

0  2 

 0  2

 



1



3

 

(1)

13

Algorithm 1 has been introduced to realize the PDA coded caching schemes [12]. Given a (K, F, Z, S) PDA, denoted by

P, if pj,k = , user k has cached the jth packet of all the files. If pj,k = s where s  {0, 1, · · · , S - 1}, the jth packet of all the files is not stored by user k. The XOR of the requested packets indicated by s will be broadcast by the server at time

slot s. C2 of Definition 1 implies that the number of signals transmitted by the server is exactly S and the transmission rate

is

R

=

S F

.

Finally,

C3

guarantees

that

user

k

can

get

its

required

packet,

since

it

has

cached

all

the

other

packets

in

the

coded

packet except its requested one. Furthermore, the coding gain in each time slot s  [0, S) equals to the frequency of integer s

in P. Building upon Algorithm 1, the following lemma can be obtained.

Lemma 1 [12]. An F -division coded caching scheme for a (K, M, N ) caching system can be realized by a (K, F, Z, S)

PDA

with

a

memory

ratio

of

M N

=

Z F

and

a

transmission

rate

of

R=

S F

.

Based on Algorithm 1, the PDA of (1) can realize a 4-division (4, 2, 4) coded caching scheme as follows.

· Placement Phase: We have Wn = {Wn,0, Wn,1, Wn,2, Wn,3}, where n  [0, 4). The contents cached by each user are

Z0 = {Wn,1, Wn,2 | n  [0, 4)}; Z1 = {Wn,0, Wn,3 | n  [0, 4)}; Z2 = {Wn,1, Wn,2 | n  [0, 4)}; Z3 = {Wn,0, Wn,3 | n  [0, 4)}.

1Memory sharing technique may lead to non equally divided packets [1], in this paper, we will not discuss this case.

4

Algorithm 1 Coded Caching Scheme based on PDA

1: Procedure Placement (P, W)

2: Split each file Wn  W into F packets as Wn = {Wn,j | j  [0, F )}. 3: For k  K do

4:

Zk  {Wn,j | pj,k = , n  [0, N )};

5: Procedure Delivery (P, W, d)

6: For s = 0, 1, · · · , S - 1 do

7:

Server sends  W . pj,k=s,j[0,F ),k[0,K) dk,j

· Delivery Phase: Assume that the request vector is d = (0, 1, 2, 3). The signals sent by the server at four time slots are listed in the following Table II.

TABLE II: Delivery Steps in (1)

Time Slot Transmitted Signal

0

W0,0  W1,1

1

W0,3  W1,2

2

W2,0  W3,1

3

W2,3  W3,2

In this paper, we focus on the coded caching schemes with K  N . In fact, based on Lemma 1, in order to obtain an F -division (K, M, N ) coded caching scheme, we could construct an appropriate PDA.

B. The PDA Schemes via Orthogonal Arrays

It has been shown that the row indices of the PDAs can be represented by some orthogonal arrays (OAs) [16]. Its definition is introduced as follows.

Definition 2 [22]. Given m, q, t  N+ with q  2 and t  m, let

 f0   a00 a01 · · · a0m-1 

 f1   a10

F=  

...

=  

...

a11 · · · alm-1 

... · · ·

...

  

fl-1

al-10 al-11 · · · al-1m-1

denote an l × m matrix over [0, q). It is called an orthogonal array with a strength of t, denoted by OA(l, m, q, t), if for each

t-sized subset S 

[0,m) t

,

every

1×t

(t  m)

row

vector

appears

exactly

=

l qt

times

in

 f0|S 

 f1|S 

F|S

=

 



...

.  

fl-1|S

It is known that l = qt for any OA(l, m, q, t), and thus it can be simplified into OA(m, q, t), where  is the index of

the orthogonal array. Note that if  = 1, it can be omitted. E.g., with m = 3, q = 2, and t = 2, let us consider the following

matrix.

f0 1 1 0

F

=

f1 f2

=

0 1

0 0

0 1

(2)

f3

011

For each S 

[0,3) 2

,

we

have

1 1

1 0

1 0

F|{0,1}

=

0 1

0 0

,

F|{1,2}

=

0 0

0 1

,

F|{0,2}

=

0 1

0 1

.

01

11

01

It can be seen that F in (2) satisfies Definition 2. Hence, it is an OA(3, 2, 2).

Based on the definition of OA, we also need a particular type of OA, which will enable us to design new PDAs.

5

Definition 3. Call an OA(m, q, m - 1) proper if the sum of each row is a constant, where the computations are performed in modulo q.
Note that for any qm-1 × m matrix F over q with the set of all rows given as

m-2

{(as0, as1, · · · , asm-2, x - asi) | as0, as1, · · · , asm-2  [0, q)},
i=0

where x  [0, q), then F is a proper OA(m, q, m - 1). Let us reconsider the matrix of (2), it can be seen that it is a proper OA(3, 2, 2) since the sum of each row is 0. It is worth pointing out that an OA(m, q, m - 1) is not always a proper OA(m, q, m - 1), e.g., with m = 3, q = 3, and t = 2, the following F is an OA(3, 3, 2), and it is not a proper OA(3, 3, 2).

0 0 0

0 1 1

0 2 2

1 0 1

F = 1 1 2

(3)

1 2 0

2 0 2

2 1 0

221

In this paper, we only consider the OAs with all rows being different, and thus there will be no need to specifically distinguish an OA and the set of its row vectors. Based on OAs, we will introduce the constructions of the PDAs of [7], [15] and [16].

Given q, m, t  N+ with t < m and q  2, let F =OA(m, q, m) and K = {b = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1)) | {0,

1, · · · , t-1} 

[0,m) t

, 0

<

1

<

···

<

t-1, ci



[0, q), i



[0, t)}.

Then,

a

qm

×

m t

qt

array

P

=

(pa,b)

such

that

a = (a0, a1, · · · , am-1)  F and b = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1))  K can be constructed with entries pa,b defined

as

pa,b =

(a0, · · · , ch, · · · , am-1, a0 - c0 - 1, · · · , at-1 - ct-1 - 1), if ah = ch for h  [0, t)

,

otherwise.

(4)

Note that the computations are performed in modulo q. Based on the construction above, the following result can be obtained.

Lemma

2

[7].

Given

q, m, t 

N+

with

q



2

and

t

<

m,

there

always

exists

a

(

m t

qt,

qm,

qm - qm-t(q - 1)t,

qm(q - 1)t)

PDA

which

gives

a

qm-division

(

m t

qt, M, N)

coded

caching

scheme

with

a

memory

ratio

of

M N

=

1

-

(

q-1 q

)t

and

a

transmission rate of R = (q - 1)t.

The PDA construction of [7] was later generalized in [15] through changing its entry rule. Given q, z, m, t  N+ with z < q,

q  2 and t < m, let F = {a = (f, g) = ((a0, a1, · · · , am-1), (0, 1, · · · , m-1)) | (f, g)  OA(m, q, m)×[0,

q-1 q-z

)t} and

K = {b Then, a

= ({0, 1, · ·

q-1 q-z

tqm ×

· , t-1}, (c0, c1, · · · , ct-1)) | {0, 1, · · · ,

m t

qt

array

P

=

(pa,b)

can

be

constructed

t-1} 

[0,m) t

, 0

<

1

with entries pa,b defined

< as

·

·

·

<

t-1,

ci



[0,

q),

i



[0, t)}.



 

(a0,

·

·

·

,

ch

-

h(q

-

z),

·

·

·

,

am-1,

a0

-

c0

-

1,

if ah / {ch, ch - 1, · · · , ch

pa,b = · · · , at-1 - ct-1 - 1),

-(z - 1)} for h  [0, t)

(5)

 

,

otherwise.

This construction leads to the following result with a flexible memory size.

Lemma

3

[15].

Given

q, z, m, t  N+

with

q



2, z

<

q

and

t

<

m,

there

always

exists

a

(

m t

qt,

q-1 q-z

tqm,

q-1 q-z

t[qm -

qm-t(q - z)t], qm(q - z)t) PDA which gives a

q-1 q-z

tqm-division (

m t

qt, M, N ) coded caching scheme with a memory ratio

of

M N

=

1

-

(

q-z q

)t

and

a

transmission

rate

of

R=

. (q-z)t q-1 t

q-z

The above PDA constructions were further improved in yielding a smaller subpacketization level in [16]. Given q, m, t  N+

with q  2 and t < m, let F = OA(m, q, m - 1) and K = {({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1)) | {0, 1, · · · , t-1} 

[0,m) t

, 0

<

1

< ···

<

t-1, ci



[0, q), i

 [0, t)}.

Then, an

|F|×|K| array P

=

(pa,b) such that a

=

(a0, a1, · · ·

, am-1)



F

and b = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1))  K can be constructed with entries pa,b defined as

pa,b =

(v, o(v)), if ah = ch for h  [0, t)

,

otherwise

(6)

6

where v = (v0, v1, · · · , vm-1)  [0, q)m such that

vi =

ch, if i = h, h  [0, t) ai, otherwise.

Note that o(v) is the occurrence order of the vector v in column b. The construction gives the following improved result.

Lemma

4

[16].

Given

q, m, t



N+

with

q



2

and

t

<

m,

there

always

exists

a

(

m t

qt,

qm-1,

qm-1

- qm-t-1(q

- 1)t,

qm-1(q-1)t) PDA which gives a qm-1-division (

m t

qt, M, N ) coded caching scheme with a memory ratio of

M N

=

1

-

(

q-1 q

)t

and a transmission rate of R = (q - 1)t.

III. THE NEW PDA SCHEMES
In this section, a general framework for centralized coded caching schemes will be proposed. The designs can improve upon some known schemes in subpacketization. Firstly, we will give a baseline array by expanding the construction in [16], i.e., Construction 1 in Section III.A and also introduce some combinatorial properties of this baseline array. Secondly, based on combinatorial structure of the baseline array, we utilize the proper OAs to generate the row indices of such array and obtain our PDA scheme that can achieve a large coding gain and a lower subpacketization level. Finally, due to the fact that some "  "s of a PDA without generating multicasting opportunities in the delivery phase, we can delete such "  "s and also obtain a new scheme with good performance.

A. Construction of the Baseline Array

Given q, z, m, t  N+ with z < q and t < m, the packet indices and users can be represented as follows.

· Let E = {(0, 1, · · · , t-1) | i  [0,

q-1 q-z

), i  [0, t)} and let Mg denote a subset of A = {(a0, a1, · · · , am-1) | ai 

[0, q), i  [0, m)} for any g  E. Each file is split into F packets of equal size, which are labelled by Wn = {Wn,(f,g) | f 

Mg, g  E}, where n  [0, N ).

· Let I = {{0, 1, · · · , t-1} | {0, 1, · · · , t-1} 

[0,m) t

,

0



0

<

1

<

···

<

t-1

<

m} and

C = {(c0, c1, · · · , ct-1) | ci  [0, q), i  [0, t)}. Each user can be represented by a unique set system (I, c), where I  I and

c  C. The collection of all the t-sized subsets which are used to represent users is denoted by H = {I |  c  C, (I, c)  K}.

Hence, H  I . For any I  I , denote the collection of all the t-tuple vectors which are used to represent users by CI, i.e., CI = {c | (I, c)  K}.

Based on the previously known PDA constructions via OAs and the definitions above, we propose a new construction as follows.

Construction 1. Given q, z, m, t  N+ with z < q and t < m, let

K = {(I, c) = ({0, 1, · · · , t-1}, (c0, · · · , ct-1)) | I  H , c  CI }

and F = {(f, g) = ((a0, · · · , am-1), (0, · · · , t-1)) | f  Mg}.
gE

An F × K array P = (p(f,g),(I,c))(f,g)F,(I,c)K can be obtained with entries defined as



 (v, o(v)), 

if ah / {ch, ch - 1, · · · , ch

p(f,g),(I,c) =

-(z - 1)} for h  [0, t)

(7)

 

,

otherwise,

where v = (v0, v1, · · · , vm-1)  [0, q)m such that

vi =

ch - h(q - z), if i = h, h  [0, t)

ai,

otherwise.

(8)

Note that o(v) is the occurrence order of vector v in column (I, c) and the computations are performed in modulo q.

The following example illustrates the above construction.

7

Example 1. Consider m = 2, q = 3 and t = 1. When z = 2, we have

q-1 q-z

= 2. Let H = {{0}, {1}}, CI = {(0), (1),

(2)} for each I  H , E = {(0), (1)} and M(0) = M(1) = {(10), (20), (01), (21), (02)}. Then

F=

{((a0, a1), (0)) | (a0, a1)  M(0)},

(0 ){(0),(1)}

K = {({0}, (c0)) | 0  [0, 1], c0  [0, 3)}.

Given ({0}, (c0)) = ({0}, (0))  K, we have {c0, c0 -1, · · · , c0 -(z-1)} = {0, 2}. Based on (8), for any ((a0, a1), (0))  F ,
we have p((a0,a1),(0)),({0},(0)) =  if a0  {0, 2} and p((a0,a1),(0)),({0},(0)) = (-0, a1) if a0 / {0, 2}. Further based on (7), if a0 / {0, 2}, p((a0,a1),(0)),({0},(0)) = (-0, a1, o((-0, a1)). For instance, p((10),(0)),({0},(0)) = (000) since (00) first occurs in column ({0}, (0)) and we assume that the occurrence order starts from 0. Similarly, we can obtain p((a0,a1),(0)),({0},(c0)) for any ((a0, a1), (0))  F , ({0}, (c0))  K. Consequently, the following 10 × 6 array can be obtained.

Note that the PDAs constructed by the approach of [15] inherit F =

q-1 q-z

tqm and K =

m t

qt.

The

entries

are

vectors

of

size m + t. This new construction can lead to a more flexible F and K with a simpler entry rule. The following shows the

combinatorial structure of the above construction.

B. Combinatorial Structure of the Baseline Array
The above example shows that in each row and each column, there is no vector entry occurring more than once. Moreover, if a vector entry (v, o(v)) occurs in two distinct rows and columns, i.e., p(f,g),(I,c) = p(f ,g ),(I ,c ) = (v, o(v)), then p(f,g),(I ,c ) = p(f ,g ),(I,c) = . As an example, the subarray formed by rows ((10), (0)), ((02), (1)) and columns ({0}, (0)), ({1}, (1)) is as follows.

The following proposition shows the combinatorial property of the baseline array, whose proof can be found in Appendix A.

Proposition 1. Let P denote an array generated by above construction. If two entries are the same, i.e., p(f,g),(I,c) = p(f ,g ),(I ,c ) = (v, o(v)), the following two properties hold:

(a). Vector entry (v, o(v)) occurs in different rows and different columns.

(b). The subarray formed by different rows (f, g), (f , g ) and different columns (I, c), (I , c ) must be in one of the following

forms

(v, o(v))   (v, o(v))

,

 (v, o(v)) (v, o(v)) 

.

Note that they satisfy C3 of Definition 1.

Next we will give a condition such that the number of "  "s in each column of P will be a constant, i.e., P is a PDA, whose

proof can be found in Appendix B. For any j  [0,

q-1 q-z

t), let

 f(0j) 

Fj

=

 

f(1j)

  

...

    

f(l-j)1

8

denote an l×m matrix over [0, q) with all rows being different. Therefore, these rows can be viewed as a set of vectors, denoted

by

Fj

= {f(ij)

| i  [0, l)}  A.

For

clarity,

the

set

E

defined

in

Section

III.A

is

written

as

E

= {g0, g1, · · ·

,g

q-1 q-z

t-1}.

Lemma 5. Given q, m, z, t  N+ with q  2, z < q and t < m, let H = I and CI = C for each I  H . Let

 P0 

 

...

 

P

=

 

Pj

 

  

...

  

P q-1
q-z

t -1

denote the array generated by Construction 1 with row indices set F = {(f(ij), gj) | i  [0, l), j  [0,

q-1 q-z

t)}. All columns

of each Pj have the same number of "  "s, i.e., P is a PDA if and only if Fj is an OA with a strength of t, i.e., Fj

OA(m, q, t)

and

=

l(1-

M N

)

(q-z)t

.

The

memory

ratio

of

the

(

m t

qt, M, N)

caching

system

realized

by

P

is

M N

=

1

-

(

q-z q

)t.

Remark 1. It can be seen that an OA(m, q, m - 1) is also an OAqm-t-1 (m, q, t). Based on Lemma 5, we can see that



=

l(1-

M N

)

(q-z)t

=

q m-1 (1-

M N

)

(q-z)t

=

qm-t-1.

This

implies

that

the

memory

ratio

of

the

(

m t

qt, M, N)

caching

system

realized

by

P

is

M N

=

1

-

(

q-z q

)t

when

Fj

is

an

OA(m, q, m - 1).

In practical applications, with a fixed number of users, subpacketization and memory size, a larger coding gain will be

preferable. In the following we will give a new class of PDAs with a coding gain of

m t

q-1 q-z

t

by

using the rows

of Fj

to

generate the row indices of Pj in Construction 1, where

 f(0j)   a(0j0) a(0j1) · · · a(0jm) -1 

Fj

=

 

f(1j)

 

  

...

  

=

    

a(1j0) ...

a(1j1)

···

a(lmj)-1

 

... · · ·

...

  

(9)

f(l-j)1

a(l-j)10 al(-j)11 · · · a(l-j)1m-1

is

a

proper

OA(m, q, m

-

1)

such

that

m-1 a(sjr)

=

x(q

-

z)

for

s



[0, l)

with

x

=

t-1
i

and

gj

=

(0, 1, · · ·

, t-1)



E.

In

r=0

i=0

order to obtain the new PDA schemes, we first introduce the following lemma whose proof can be found in Appendix C.

Lemma 6. Given m, q, z, t  N+ with t  m, z < q and H = I , CI = C for each I  H , let

 P0 

 

...

 

P

=

 

Pj

 

  

...

  

P q-1
q-z

t -1

denote a qm-1

q-1 q-z

t×

m t

qt array obtained from Construction 1 such that the row indices are generated from F = {(f(ij), gj) |

i  [0, qm-1), j  [0,

q-1 q-z

t)} and Fj is a proper OA(m, q, m - 1) of (9). There exists Pj in P satisfying

(a). Each vector v in Pj occurs in exactly

m t

columns with the same number;

(b). Each vector v occurring in Pi must occur in Pj for any i, j  [0,

q-1 q-z

t).

The following example demonstrates Lemma 6.

Example 2. Consider q = 3, m = 3, t = 1 and z = 2. We have the following two proper OA(3, 3, 2)

f(00) f(10) f(20)

0 0 0
0 1 2 0 2 1

f(30) 1 0 2

F0

=

f(40) f(50) f(60) f(70)
f(80)

=

1 1 2 2
2

1 2 0 1 2

1 0 1 0
2

9

and

f(01) f(11) f(21)

0 0 1
0 1 0 0 2 2

f(31) 1 0 0

F1

=

f(41) f(51) f(61) f(71)
f(81)

=

1 1 2 2
2

1 2 0 1 2

2 . 1 2 1
0

It can be seen that 2 a(s0r) = 0 and 2 a(s1r) = q - z = 1 for s  [0, 8]. With g0 = (0) and g1 = (1), we have the following

array.

r=0

r=0

It can be observed that the above array satisfies Lemma 6.

C. Construction of the New PDA Scheme

Building upon Construction 1 and Lemma 6, the following theorem demonstrates a new class of PDAs which is capable of yielding a smaller subpacketization than the PDAs of [15].

Theorem

1.

Given

q, z, m, t



N+

with

q



2, z

<

q

and

t

<

m,

there

always

exists

a

(

m t

qt,

q-1 q-z

tqm-1,

q-1 q-z

t[qm-1 -

qm-t-1(q -z)t], qm-1(q -z)t) PDA which gives a

q-1 q-z

tqm-1-division (

m t

qt, M, N ) coded caching scheme with a memory

ratio

of

M N

=

1

-

(

q-z q

)t

and

a

transmission

rate

of

R

=

. (q-z)t q-1 t

q-z

Proof. Let H = I and CI = C for each I  H . We denote the array generated in Lemma 6 by P. It can be observed

that the vector v occurring in the column (I, c) of Pj does not appear in the column (I, c) of Pj for j = j and j, j 

[0,

q-1 q-z

t).

Let

us

assume

that

the

vector

v

occurring

in

the

column

(I, c)

of

Pj

appears

in

the

column

(I, c)

of

Pj

for

j = j. Let gj = (0, 1, · · · , t-1), gj = (0, 1, · · · , t-1) and c = (c0, c1, · · · , ct-1) be the vectors defined in Section

III.A. Without loss of generality, we can assume that i = i for some integer i  [0, t). Based on Construction 1, we

have ci - i(q - z) = ci - i(q - z). This is impossible since i(q - z), i(q - z)  [0, z - 1]. Based on Lemma 6,

we also have that each vector entry in P occurs in exactly

m t

q-1 q-z

t

columns,

and

v

occurs

the

same

number

of

times

in each column that contains v, i.e., array P is a PDA with a coding gain of

m t

q-1 q-z

t.

Further

based

on

Lemma

5,

it

10

can be seen that each column of P has

q-1 q-z

t[qm-1 - qm-t-1(q - z)t] "  "s and

the

number

of

non-star entries in

P is

q-1 q-z

t

m t

qm-1(q - z)t.

This

implies

that

the

number

of

distinct

vector

entries

in

P

is

qm-1(q - z)t.

Therefore,

P

is

a

(

m t

qt,

q-1 q-z

tqm-1,

q-1 q-z

t[qm-1 - qm-t-1(q - z)t], qm-1(q - z)t)

PDA

with

a

memory

ratio

of

M N

=

1

-

(

q-z q

)t

and

a

transmission

rate

of

R=

. (q-z)t q-1 t

q-z

Based on Theorem 1, it can be seen that the array in Example 2 is a (9, 18, 12, 9) PDA which realizes an 18-division

(9, M, N )

coded

caching

scheme

with

a

memory

ratio

of

M N

=

2 3

and

a

transmission

rate

of

R=

1 2

.

Remark 2. It can be seen that the PDA scheme in [15] has a more flexible memory size than the scheme in [7], while

the row indices of the PDA of [15] are obtained by just reusing

q-1 q-z

t

times of the row indices of the PDA of [7] and the

entry rule of the PDA of [15] can be regarded as a generalization of the PDA of [7]. Moreover, the PDA scheme in [16] has

a lower subpacketization than that of the scheme in [7] with the same number of users, memory ratio and transmission rate.

Unfortunately it is hard to obtain a similar result as that of [15] but smaller subpacketization by simply changing the entry

rule or reusing the same OA(m, q, m - 1) which is used in the construction of [16], i.e., it is hard to use the similar method

in the construction of [15] based on the construction of [16]. Furthermore, the entry rule defined in the construction of [16] is

different from that of the PDA generated in the construction of [15]. This implies that it is impossible to obtain our PDAs by

just deleting some rows of the PDA generated by the construction of [15]. So in order to obtain the result of this paper, we

use the different method in the construction of [15], i.e., by means of using

q-1 q-z

t

times of the proper OA(m, q, m - 1).

D. New PDA Scheme under Coded Placement

Finally we will give a new coded caching scheme based on the above PDAs with the coded placement. In a PDA, a "  " is called useless, if it is not contained in any subarray shown in C3-(b) of Definition 1. This indicates the useless "  "s cannot generate multicasting opportunities in the delivery phase, i.e., these "  "s have no advantage in reducing the transmission rate of a coded caching scheme realized by that PDA and result in a large memory ratio and a high subpacketization level. Therefore, if each column of a (K, F, Z, S) PDA has Z useless "  "s, one can obtain a new coded caching scheme with a smaller memory ratio and subpacketization level by deleting these useless "  "s and using an [F, F - Z ]q maximum distance separable code in the placement phase, where F and F - Z denote the code length and the dimension of such code over the finite field Fq , respectively. For the detailed realization method, the interested readers can refer to [17].

When q  2z, there exist some useless "  "s in each column of the array P generated from Lemma 6. Therefore, we can obtain a coded caching scheme with a smaller memory ratio and subpacketization level, compared with Theorem 1 by using the following lemma.

Lemma 7 [17]. For any (K, F, Z, S) PDA P, if there exist Z useless "  "s in each column, then we can obtain an (F - Z )-

division

(K, M, N )

coded caching scheme

with

a

memory ratio of

M N

=

Z -Z F -Z

and

a

transmission

rate

of

R

=

S F -Z

,

in

which

the coding gain at each time slot is the same as the original scheme realized by P and Algorithm 1.

Remark 3. Note that the operation field q of Lemma 7 must be O(F ). Therefore, the size of each packet of files must

approximate to log2 F bits. This implies that the size of files in the server must be more than (F - Z ) log2 F so that the

transmission

rate

of

S F -Z

can

be

maintained.

Given

a

(K, F, Z, S)

PDA,

Z F

>

Z-Z F -Z

and F > F - Z

always hold for any

Z, F, Z  N+. This also implies that we can obtain a coded caching scheme with a smaller subpacketization and memory

ratio by using Lemma 7.

Theorem

2.

Given

q, z, m, t



N+

with

q



2, 2z



q

and

t

<

m,

there

exists

(

m t

qt, M, N)

coded

caching

scheme

with a memory ratio of

M N



, 1-(

q-1 q

)t

1-(

q-1 q

)t

+(

q-z q

)t

a

transmission

rate

of

R



(q-z)t

1-(

q-1 q

)t

+(

q-z q

)t

and subpacketization F



qm-1[1

+

(

q-z q

)t

-

(

q-1 q

)t].

Proof. Let P denote the PDA generated from Lemma 6. When z > 1 and 2z  q, array P can be considered as replacing

some

vector

entries

by

"



"s

from

the

case

z

=

1.

This

implies

that

there

exist

at

least

qm-1[(

q-1 q

)t

-

(

q-z q

)t]

useless

"



"s

in each column of P. Furthermore, based on Theorem 1, the number of distinct vector entries in P is qm-1(q - z)t. Therefore,

the desired result holds by using Lemma 7.

IV. ANALYSES OF THE NEW PDA SCHEMES
In order to compare our new schemes with the existing ones, Table III summarizes the main properties of our new PDA schemes that were characterized in Theorems 1 and 2.

11

Schemes and parameters
Our scheme in Theorem 1, any q, z, m, t  N+ with q  2, z < q and t < m
Our scheme in Theorem 2, any q, z, m, t  N+ with q  2, 2z  q and t < m

TABLE III: New PDA Schemes

User number K

m t

qt

m t

qt

Caching

ratio

M N

1

-

(

q-z q

)t



1-(

q-1 q

)t

1-(

q-1 q

)t +(

q-z q

)t

Rate R

(q-z)t
q-1 t q-z



(q-z)t

1-(

q-1 q

)t

+(

q-z q

)t

Packet number F

q-1 q-z

tqm-1



qm-1[1

+

(

q-z q

)t

-

(

q-1 q

)t]

Remark 4. · Given q, z, m, t  N+ with q  2, z < q and t < m, our scheme in Theorem 1 has the same number of users,

memory

ratio

and

transmission

rate

as

the

first

scheme

in

[15].

However,

our

subpacketization

is

only

1 q

of

the

first

scheme

in

[15]. Moreover, when t = 1, our scheme in Theorem 1 is the same as the second scheme in [15].

· When z = 1, our scheme in Theorem 1 is the same as the scheme in [16]. However, our scheme generalizes the scheme in [16] with a wider range of applications than the original one due to a more flexible memory size.

We conclude this section with some numerical evaluations to compare the proposed schemes in Theorems 1 and 2 with the existing one from [15]. We take the parameters with m = 3, t = 2, q = 9 and z  [1, 9). Fig.2 shows our proposed scheme in Theorems 1 has a smaller subpacketization level over the first scheme in [15] with the same number of users, memory ratio and transmission rate. Moreover, when the memory ratio is small (the smaller memory ratio is preferable in practice), the subpacketization of our scheme in Theorem 2 is much smaller than the first scheme in [15] while maintaining approximately the same transmission rate. Furthermore, for the small memory ratio, the scheme in Theorem 2 has better performance than the scheme in Theorem 1 in subpacketization.

(a)

(b)

Fig. 2: (a) The packet number of schemes from Theorem 1, Theorem 2 and [15] when K = 243; (b) The transmission rate of schemes from Theorem 1, Theorem 2 and [15] when K = 243.

V. CONCLUSION
This paper has proposed two new coded caching schemes. The first one is given with an improved subpacketization level with the same number of users, memory ratio and transmission rate, compared with the existing one, and the second one has better performance than the first one in subpacketization when the memory ratio is small. Our new schemes can also yield a more flexible memory size, providing a wider range of applications. In our framework, we use the proper OAs to generate the row indices of arrays in Construction 1. The proposed schemes have better performance than the existing ones in the literature. A possible direction for further research is to find more other OAs that can be utilized to design appropriate coded caching schemes.

12

APPENDIX A PROOF OF PROPOSITION 1

Proof. (a). Suppose that p(f,g),(I,c) = p(f ,g ),(I ,c ) = (v, o(v)), where

f = (a0, a1, · · · , am-1), f = (a0, a1, · · · , am-1), I = (0, 1, · · · , t-1),

I = (0, 1, · · · , t-1), g = (0, 1, · · · , t-1), g = (0, 1, · · · , t-1),

c = (c0, c1, · · · , ct-1), c = (c0, c1, · · · , ct-1), v = (v0, v1, · · · , vm-1).

In order to prove that the vector entry (v, o(v)) occurs in different rows and different columns, it is sufficient to prove that there is no vector v occurring more than once in some row. Assume that vector v appears at least twice in some row, then we consider the following cases under the condition (f, g) = (f , g ).

Case 1: I = I . If c = c , without loss of generality, assume that c0 = c0. It follows from Construction 1 that v0 = c0 - 0(q - z) = c0 - 0(q - z), which contradicts our hypothesis. This implies that c = c , i.e., (I, c) = (I , c ).
Case 2: I = I . There must exist two distinct integers, say ,   [0, m), satisfying   I,  / I and   I ,  / I, without loss of generality, assume that  = 0,  = 0. Based on Construction 1, we have v0 = c0 - 0(q - z) = a0 and v0 = c0 - 0(q - z) = a0 . This implies that p(f,g),(I,c) =  since a0 = c0 - 0(q - z)  {c0, c0 - 1, · · · , c0 - (z - 1)}. Similarly, we can also show that p(f,g),(I ,c ) = , which contradicts p(f,g),(I,c) = p(f,g),(I ,c ) = (v, o(v)).
(b). Suppose that vector v occurs in different rows and columns, i.e., rows (f, g), (f , g ) and columns (I, c), (I , c ). If I = I , with the similar argument of Case 2, it can be seen that the statement of (b) holds. In the following, we will show that statement of (b) also holds when I = I .

In order to prove this case, we just need to consider g = g since vector v occurring in entries p(f,g),(I,c) and p(f ,g ),(I,c ) will not happen when g = g . Assume that p(f,g),(I,c ) = , then we have ai  {ci + 1, ci + 2, · · · , ci + (q - z)} for any i  [0, t). So there exists an integer   [1, q - z] satisfying ai = ci + . Based on Construction 1, we have ci = ci + (q - z)(i - i). Hence, we obtain the following equation

ai - ci = (q - z)(i - i) + .

(10)

This is impossible for i < i due to q - z + 1 < (q - z)(i - i) +  < q and 0 < ai - ci < q - z + 1 by the fact

0  i, i 

q-1 q-z

- 1 and q < 2z. If i > i, the equation (10) can be written as ai - ci + (q - z)(i - i) = , which is

also impossible since q - z < ai - ci + (q - z)(i - i) < q and 1    q - z. Therefore, we have p(f,g),(I,c ) = . Similarly,

we can also show that p(f ,g ),(I,c) = .

APPENDIX B PROOF OF LEMMA 5

Proof. Let H = I and CI = C for each I  H . We first consider j = 0. Let hI,d,0 denote the occurrence number of vector
d in F0|I. Given positive integers z, q and t with z < q and t = 1, we consider the users corresponding to I represented
by (I, (0)), (I, (1)), · · · , (I, (q - 1)). Based on Construction 1, we can define the following q × q binary matrix D with rows and columns indexed from X = {(I, (0)), (I, (1)), · · · , (I, (q - 1))} and X = {f(i0)|I | i  [0, l)} = {(0), (1), · · · , (q - 1)}, respectively. If an entry at row (I, c) and column d is 0, it indicates the user (I, c) has cached the packets of all the files indexed in R = {(f(i0), g0) | f(i0)|I = d, i  [0, l)}. If an entry at row (I, c) and column d is 1, it indicates the packets of all the files indexed from R = {(f(i0), g0) | f(i0)|I = d, i  [0, l)} are not cached by user (I, c).

users (I, c) (0) (1) · · · (q - 1)

(I, (0))  0

···



(I, (1)) 

0 ···

D = ...

  

...

... · · ·



...

  

(I, (q - 1))

··· 0

The symbol " " in the matrix D can be equal to 0 or 1, which is determined by integer z. It can be seen that entry 1 appears q - z times in each row and all the row vectors are linear independence since D is a circulant matrix and it is invertible.
When D(10) = D and t > 1, a qt × qt binary matrix D(t0) can be recursively defined as

13

 0

D(t-0)1 · · · D(t-0)1

D(t0)

=

D(t-0)1

  

...

0 ...

··· ···

D(t-0)1 ...

    

.

D(t-0)1 D(t-0)1 · · ·

0

If we consider the matrix D(t0) with rows indexed from Y = {(I, (0, 0, · · · , 0)), (I, (0, 0, · · · , 1)), · · · , (I, (q -1, q -1, · · · , q - 1))} in the lexicographic order and the columns are vectors in Y = {(0, 0, · · · , 0), (0, 0, · · · , 1), · · · , (q - 1, q - 1, · · · , q - 1)},
we have

where

C0

C1 · · · Cq-1

R0  0 D(t-0)1 · · · D(t-0)1 

D(t0) =

R1 ...

   

D(t-0)1 ...

0 ...

··· ···

D(t-0)1 ...

 ,  

Rq-1 D(t-0)1 D(t-0)1 · · ·

0

R0 = {(I, (0, c1, c2, · · · , ct-1)) | ci  [0, q), i  [1, t)}; R1 = {(I, (1, c1, c2, · · · , ct-1)) | ci  [0, q), i  [1, t)}; ... Rq-1 = {(I, (q - 1, c1, c2, · · · , ct-1)) | ci  [0, q), i  [1, t)}; C0 = {(0, c1, c2, · · · , ct-1) | ci  [0, q), i  [1, t)}; C1 = {(1, c1, c2, · · · , ct-1) | ci  [0, q), i  [1, t)}; ... Cq-1 = {(q - 1, c1, c2, · · · , ct-1) | ci  [0, q), i  [1, t)}.

With the same analysis, we can also obtain a qt × qt

binary matrix D(tj)

= D(t0)

for j



[1,

q-1 q-z

t). Let hI,d,j

=

(hI,(0,0,··· ,0),j , hI,(0,0,··· ,1),j , · · · , hI,(q-1,q-1,··· ,q-1),j ). If the number of "  "s in each column of array P is a constant, i.e.,

the number of packets not cached by each user is l

q-1 q-z

t(1

-

M N

),

we

have

 hTI,d,0 



D(t0)

D(t1)

···

D(

q-1 q-z

t -1)

t

  

hTI,d,1 ...



 

=

l

q-1

t(1 - M )

 q-z

N

hTI,d,

q-1 q-z


t -1

where hTI,d,j represents the transpose of hI,d,j. Note that the number of "  "s in each column of Pj is a fixed constant for

j  [0,

q-1 q-z

t). This implies

D(tj)

·

hTI,d,j

=

l(1

-

M N

)

·

1qt×1,

where 1qt×1 is a qt × 1 vector with all entries to be 1s. It can be seen that the unique solution of above equations is

hI,(0,0,··· ,0),j

=

···

=

hI,(q-1,q-1,··· ,q-1),j

=

l(1-

M N

)

(q-z)t

,

since entry 1 appears (q - z)t times in each row of matrix D(tj) and the determinant of D(tj) is (q - 1)(-1)q-1(D(t-j)1)q, i.e.,

D(tj) is invertible. This implies Fj

OA(m, q, t)

and



=

l(1-

M N

)

(q-z)t

.

Conversely,

if

hI,(0,0,··· ,0),j

=

hI,(0,0,··· ,1),j

=

···

=

hI,(q-1,q-1,··· ,q-1),j, it is easy to verify that the number of "  "s in each column of Pj is a fixed constant, i.e., the number

of

"  "s

in

each

column

of

P

is

a

constant.

So,

by

using

the

property

of

OAs,

we

have

l

q-1 q-z

t (1-

M N

)qt

(q-z)t

=

l

q-1 q-z

t,

i.e.,

M N

=

1

-

(

q-z q

)t.

14

APPENDIX C PROOF OF LEMMA 6

In order to prove Lemma 6, the following result is useful.

Proposition 2 [16]. Given m, q, z, t  N+ with t  m, z = 1 and H = I , CI = C for each I  H , let P0 denote a

qm-1 ×

m t

qt

OA(m, q, m -

array obtained 1). Then, each

from (6) such that the row indices are generated from F = {f(i0) | i 

vector v in P0 occurs in exactly

m t

columns with the same number.

[0, qm-1)}

and

F0

is

an

Now let us prove Lemma 6.

Proof. (a). We first consider P0 with row indices generated from F0(0) = {(f(s0), g0) | s  [0, qm-1)} where g0 = (0, 0, · · · , 0) and m-1 a(s0r) = 0 for s  [0, qm-1). Based on Proposition 2, It can be seen that P0 satisfies the statement of (a) when z = 1.
r=0
If z > 1, P0 can be viewed as replacing some vector entries by "  "s from the case z = 1. Therefore, in order to prove that P0 satisfies the statement of (a) for any z  [2, q), we just need to prove such vector entries that contain v are replaced by "  "s uniformly in the column where they occur.

Given any v = (v0, v1, · · · , vm-1) in P0 and fixed column (I, c) = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1)), we denote the collection of rows in which v occurs by

Similarly, let

FI(0,v) = {(f(s0), g0) = ((a(s00), a(s01), · · · , a(s0m)-1), g0) | p(f(s0),g0),(I,c) = (v, o(v)), s  [0, qm-1)}.

FI(0,)v = {(f(s0), g0) = ((a(s00), a(s01), · · · , a(s0m)-1), g0) | p(f(s0),g0),(I,c) = (v, o(v)), s  [0, qm-1)} denote the collection of rows in which v occurs corresponding to column (I , c ) = ({0, 1 · · · , t}, (c0, c1, · · · , ct-1)), where |I  I | = t - 1. Note that when z = 1, there exists a one to one mapping from FI(0,v) to FI(0,)v:

((f(s0), g0)) = (f(s0), g0), (f(s0), g0)  FI(0,v), (fs(0), g0)  FI(0,)v,

where a(s0i) = a(s0i) for i  (I  I )  ([0, m)\(I  I )). Assume that vector v occurs in row (f(s0), g0) = ((a(s00), a(s01), · · · , a(s0m)-1), (0, 0, · · · , 0)) and column (I, c), then vector v must appear in column (I , c ) and a unique row (f(s0), g0) = ((a(s00), a(s01), · · · , a(s0m) -1), (0, 0, · · · , 0)) since  is a one to one mapping. Furthermore, assume that there exist two different integers w and w such that I\I = {w} and I \I = {w }. Based on Construction 1, there exist two integers ,  such that

a(s0)w

=

cw

+ , a(s0) w

= cw ;

a(s0)w

=

cw, a(s0) w

= cw

+ .

Then, we obtain

cw +  + cw

=

a(s0)w

+

a(s0) w

=

a(s0)w

+

a(s0) w

= cw

+

+ cw

due to m-1 a(s0r) = 0 for s  [0, qm-1), i.e.,  =  holds.
r=0

Now let us consider z > 1 for P0. Without loss of generality, suppose that a vector entry that contains v is replaced by

"  " in row (f(s0), g0) and column (I, c), then there must exist one vector entry that contains v converting into "  " in row

(f(s0), g0) and column (I , c ) since  =  / {1, 2, · · · , q - z}. This implies that vector entries that contain v are replaced by

"  "s uniformly in the column where they occur, i.e., array P0 satisfies the statement of (a). In the following we will show

that there always exist array Pj satisfying the statement of (a) for j  [1,

q-1 q-z

t).

When q < 2z, 1 < z and j  [1, t], we consider Pj with row indices generated from Fj(j) = {(f(sj), gj) | s  [0, qm-1)} where gj = (0, · · · , 1, · · · , 0) is a length-t vector with (j -1)th entry equaling to 1 and others to be 0s, Fj = F1 and m-1 a(sjr) -
r=0
m-1 a(s0r) = q - z for s, s  [0, qm-1). For any v in P0 and fixed column (I, c) = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1)), we
r=0
also denote the collection of rows in which v occurs by

15

FI(0,v) = {(f(s0), g0) = ((a(s00), a(s01), · · · , a(s0m)-1), g0) | p(f(s0),g0),(I,c) = (v, o(v)), s  [0, qm-1)}.

Similarly, suppose that such vector v appears in Pj, then the collection of rows in which v occurs in column (I, c ) = ({0, 1, · · · , t-1}, (c0, c1, · · · , ct-1)) can be written as

FI(j,v)

=

{(f(sj), gj )

=

((a(sj0) , a(sj1) , · · ·

, a(sjm) -1), gj )

|

p(f(j) s

,gj

),(I,c

)

=

(v, o(v)), s

 [0, qm-1)}.

Since Fj is a proper OA(m, q, m - 1) such that m-1 a(sjr) = q - z, we can define a mapping  from FI(0,v) to FI(j,v) as
r=0

((f(s0), g0)) = (f(sj), gj ), (f(s0), g0)  FI(0,v), (f(sj), gj )  FI(j,v),

where

a(s0i)

=

a(sji)

for

i



[0, m)\{j-1}

and

a(0)
sj-1

+

(q

-

z

)

=

a(sj)j-1 .

Assume

that

a(0)
sj-1

=

cj-1 +

for





{1, 2, · · ·

, q-z}

and

a(j)
s j-1

=

cj-1

+



.

Based

on

Construction

1,

we

have

cj-1

=

cj-1

-

(q

-

z)

and

ci

=

ci

for

i



[0, t)

\

{j

-

1}.

This

implies that cj-1 + 

=

a(j)
s j-1

=

a(0)
sj-1

+ (q - z)

=

cj-1 +  + (q - z)

=

cj-1 - (q - z) +  + (q - z)

=

cj-1 + ,

i.e.,



=



holds. Hence, given any (f(s0), g0)  FI(0,v), we can find a unique row (f(sj), gj)  FI(j,v) such that ((f(s0), g0)) = (fs(j), gj). This

means that  is indeed a mapping from FI(0,v) to FI(j,v). Further based on the definition of , it can be seen that  is an injective

mapping from FI(0,v) to FI(j,v). Then we have |FI(0,v)|  |FI(j,v)|. Also, we can define a mapping  from FI(j,v) to FI(0,v) as

 ((f(sj)), gj ) = (f(s0), g0), (f(sj), gj )  FI(j,v), (f(s0), g0)  FI(0,v),

where

a(s0i)

=

a(sji)

for

i



[0, m)

\

{j-1}

and

a(0)
sj-1

+

(q

-

z)

=

a(j)
s j-1

.

With

the

same

analysis,

we

have

|FI(0,v)|



|FI(j,v)|.

Hence, we have |FI(0,v)| = |FI(j,v)|. For any I = I, we also have |FI(0,)v| = |FI(j,)v| with the similar argument above. Therefore,

array Pj satisfies the statement of (a).

Similarly, based on P1, P2, · · · Pt, we can obtain other Pt+1, Pt+2, · · · Pt+u satisfying the statement of (a) with row indices generated from Ft(+t+uu ) = {(f(st+u ), gt+u ) | s  [0, qm-1)} where Ft+u = F2, m-1 a(s2r) = 2(q - z) for s  [0, qm-1),
r=0
gt+u  {gj + x | j  [1, t] and x is unit vector with length t}, u  [1, u] and u is the cardinality of {gj + x | j  [1, t] and x is unit vector with length t}. Also, we can perform the above operation as many times as possible until we obtain
any array Pj in P satisfying the statement of (a). This completes the proof of (a).

(b). According to the proof of (a), the statement of (b) is clear.

REFERENCES
[1] M. A. Maddah-Ali and U. Niesen, "Fundamental limits of caching," IEEE Trans. Inf. Theory, vol. 60, no. 5, pp. 2856-2867, May 2014. [2] K. Wan, D. Tuninetti, and P. Piantanida, "An index coding approach to caching with uncoded cache placement," IEEE Trans. Inf. Theory , vol. 66, no.
3, pp. 1318-1332, Mar. 2020. [3] Q. Yu, M. A. Maddah-Ali, and A. S. Avestimehr, "Characterizing the rate-memory tradeoff in cache networks within a factor of 2," IEEE Trans. Inf.
Theory , vol. 65, no. 1, pp. 647-663, Jan. 2019. [4] S. Agrawal, K. V. Sushena Sree, and P. Krishnan,"Coded caching based on combinatorial designs," in Proc. IEEE Int. Symp. Inf. Theory (ISIT), Paris,
France, Jul. 2019, pp. 1227-1231. [5] H. H. S. Chittoor, M. Bhavana, and P. Krishnan, "Coded caching via projective geometry: A new low subpacketization scheme," in Proc. IEEE Int. Symp.
Inf. Theory (ISIT), Paris, France, Jul. 2019, pp. 682-686. [6] P. Krishnan, "Coded caching via line graphs of bipartite graphs," in Proc. IEEE Inf. Theory Workshop (ITW), Guangzhou, Nov. 2018, pp. 1-5. [7] C. Shangguan, Y. Zhang, and G. Ge, "Centralized coded caching schemes: A hypergraph theoretical approach," IEEE Trans. Inf. Theory, vol. 64, no. 8,
pp. 5755-5766, Aug. 2018. [8] K. Shanmugam, A. M. Tulino, and A. G. Dimakis, "Coded caching with linear subpacketization is possible using Ruzsa-Szeme´redi graphs," in Proc.
IEEE Int. Symp. Inf. Theory (ISIT), Aachen, Germany, Jun. 2017, pp. 1237-1241. [9] K. Shanmugam, A. G. Dimakis, J. Llorca, and A. M. Tulino, "A unified Ruzsa-Szemere´di framework for finite-length coded caching," in Proc. The 51st
ACSSC, Pacific Grove, CA, Oct. 2017, pp. 631-635. [10] K. Shanmugam, M. Ji, A. M. Tulino, J. Llorca, and A. G. Dimakis, "Finite length analysis of caching-aided coded multicasting,"IEEE Trans. Inf. Theory,
vol. 62, no. 10, pp. 5524-5537, Oct. 2016. [11] Q. Yan, M. Cheng, X. Tang, and Q. Chen, "On the placement delivery array design for centralized coded caching scheme," IEEE Trans. Inf. Theory,
vol. 63, no. 9, pp. 5821-5833, Sep. 2017. [12] Q. Yan, X. Tang, Q. Chen, and M. Cheng, "Placement delivery array design through strong edge coloring of bipartite graphs," IEEE Commun. Lett.,
vol.22, no. 2, pp. 236-239, Feb. 2018. [13] L. Tang and A. Ramamoorthy, "Coded caching schemes with reduced subpacketization from linear block codes," IEEE Trans. Inf. Theory, vol. 64, no.
4, pp. 3099-3120, Apr. 2018. [14] M. Cheng, J. Jiang, X. Tang, and Q. Yan, "Some variant of known coded caching schemes with good performance," IEEE Trans. Commun., vol. 68,
no.3, pp. 1370-1377, Mar., 2020. [15] M. Cheng, J. Jiang, Q. Yan, and X. Tang, "Coded caching schemes for flexible memory sizes," IEEE Trans. Commun., vol. 67, no. 6, pp. 4166-4176,
Jun. 2019.

16
[16] M. Cheng, J. Wang, X. Zhong, and Q. Wang, (Mar. 2020), "A unified framework for constructing centralized coded caching schemes," [Online]. Available: https://arxiv:1908.05865v2.
[17] M. Zhang, M. Cheng, J. Wang, and X. Zhong, "Improving placement delivery array coded caching schemes with coded placement," IEEE Access, vol. 8, pp. 217456-217462, Dec. 2020.
[18] M. Cheng ,J. Jiang, Q. Wang, and Y. Yao, "A generalized grouping scheme in coded caching," IEEE Trans. Commun., vol. 67, no. 5, pp. 3422-3430, May 2019.
[19] X. Zhong, M. Cheng, and J. Jiang, "Placement delivery array based on concatenating construction," IEEE Commun. Lett., vol. 24, no. 6, pp. 1216-1220, Jun. 2020.
[20] W. Song, K. Cui, and L. Shi, (Oct. 2019), "Some new constructions of coded caching schemes with reduced subpacketization," [Online]. Available: https://arXiv:1908.06570v2.
[21] J. Michel and Q. Wang, "Placement delivery arrays from combinations of strong edge colorings," IEEE Trans. Commun., vol. 68, no. 10, pp. 5953-5964, Oct. 2020.
[22] D. R. Stinson, Combinatorial Designs: Construction and Analysis, Springer, 2003, New York.

