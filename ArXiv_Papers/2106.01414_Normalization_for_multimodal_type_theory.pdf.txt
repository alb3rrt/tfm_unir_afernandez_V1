NORMALIZATION FOR MULTIMODAL TYPE THEORY
DANIEL GRATZER
Abstract. We consider the conversion problem for multimodal type theory (MTT) [Gra+20a] by characterizing the normal forms of the type theory and proving normalization (Theorem 8.5). Normalization follows from a novel adaptation of Sterling's Synthetic Tait Computability [Ste21; SH20] which generalizes the framework to accommodate a type theory with modalities and multiple modes. As a corollary of our main result, we reduce the conversion problem of MTT to the conversion problem of its mode theory (Corollary 8.8) and show the injectivity of type constructors (Corollary 8.9).

arXiv:2106.01414v1 [cs.LO] 2 Jun 2021

Contents

1. Introduction

1

2. Normalization via Synthetic Tait Computability

5

3. MTT Cosmoi

7

4. Foundations of multimodal Synthetic Tait Computability

10

5. The category of renamings for MTT

15

6. Prerequisites for the normalization model

17

7. The normalization model

20

8. The normalization function

25

Acknowledgments

28

Appendix A. Neutral and normal forms

28

Appendix B. A full definition of an internal MTT cosmos

31

Appendix C. Neutral and normal forms, internally

33

References

36

1. Introduction
The last twenty years of development of type theory has seen many different extensions of type theories to account for different modalities. Most of these type theories are specialized--accounting for a specific collection of modalities--and intended for a particular model. This specialization has allowed for concise and practicable syntax in some cases, but has also created a tremendous amount of churn where even the smallest change to the modal situation requires substantial work to produce a new type theory.
In response to this situation, several "frameworks" for modal type theory have been put forward. A framework for modal type theory should enjoy the following:
(1) sufficient generality to accommodate a large class of modalities, (2) practicable syntax in specific applications,
Date: Friday 4th June, 2021. 1

2

DANIEL GRATZER

(3) a wide variety of theorems which hold for instantiations.
There is a degree of tension between these three goals: a framework which is more general often admits more cumbersome syntax, and wider classes of type theories typically enjoy fewer shared properties. Recently, Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20b] introduced MTT, a type theory parameterized by a collection of modalities. MTT aims to support a highly usable syntax for any collection of modalities which behave like (dependent) right adjoints [Bir+20]. This proves to be a rich class of modalities, allowing encodings of type theories for guarded recursion, internal parametricity, axiomatic cohesion, etc.

1.1. MTT. We briefly recall some of details of MTT. For a full account, see the extended submission on MTT [Gra+20a]. As mentioned, MTT is parameterized by a collection of modalities. Formally, MTT is defined over a mode theory [LS16]: a strict 2-category whose objects represent modes, while 1-cells determine modalities and 2-cells natural transformations between them.
Given a mode theory M, each mode m : M determines a mode in MTT. Each mode behaves somewhat like its own type theory. There are separate judgments for each mode  cx @ m,  A @ m, and  M : A @ m and types in mode m are closed under the standard connectives in Martin-L¨of type theory (dependent products, sums, booleans, an intensional identity type, and a universe).
Different modes only interact through modalities. Given a morphism µ : n m, there is an induced modality µ | - in MTT which sends types from mode n to mode m. This modality behaves like a right adjoint [Bir+20], whose left adjoint is given an action only on contexts -.{µ}.1 This operation is a proper functor between context categories, with an induced action on substitutions .{µ}. As the left adjoint, -.{µ} sends context from mode m to mode n. This left adjoint is used to give the formation and introduction rules for MTT by transposition:

.{µ} A @ n  µ | A @m

.{µ} M : A @ n  modµ(M ) : µ | A @ m

Two questions remain: how does one eliminate an element of µ | A and how can one use a context of the form .{µ}. While related modal type theories solve both issues through defining the elimination rule to be transposition in the opposite direction, this causes issues for the substitution property. Instead, MTT employs an alternative approach. First, variables in the context is annotated with a modality:

 cx @ m .{µ} A @ n .(µ | A) cx @ m

These modal annotations are used to determine when a variable can be accessed; a variable annotated with µ can be accessed precisely when it is behind -.{µ}:

.(µ | A).{µ} v0 : A[.{µ}] @ m
Next, the elimination rule for µ | - is used to bridge the gap between a variable annotated with µ of type A and a variable annotated with  of type µ | A . There is a canonical substitution .(  µ | A) .( | µ | A ), but a priori no map in the reverse direction. While we do not provide an inverse outright, the elimination
1Other presentations of MTT and Fitch-style modal type theories write -. µ for this action, but we find -.{µ} more uniform and less cumbersome.

NORMALIZATION FOR MULTIMODAL TYPE THEORY

3

rule ensures that these two contexts are isomorphic "from the perspective of a type". Semantically, one ensures that display maps are weakly right orthogonal to this map, but more concretely we add the following elimination principle:
:o n µ:n m  cx @ m .{µ}.{} A @ o .(µ |  | A ) B @ m .{µ} M0 :  | A @ n .(µ   | A) M1 : B[.mod(v0)] @ m
 letµ mod ( )  M0 in M1 : B[id.M0] @ m
Finally, the interactions between modalities are codified by organizing the collection of functors -.{-} into a single 2-functor out of Mcoop. Concretely, this ensures that there is a substitution .{µ} {} : .{} @ m for each 2-cell  :  µ and that a variety of functoriality equations hold e.g.:
.{µ  } = .{µ}.{} cx @ o .{idm} =  cx @ m
2-functoriality is sufficient to ensure that the modal types organize into a weak 2-functor, with type-theoretic equivalences between e.g., idm | A and A.
1.2. Normalization for MTT. Returning to the criterion for a framework for modal dependent type theories, Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20a] showed that MTT enjoys substantial metatheoretic properties. In particular, every instantiation of MTT is sound and enjoys a canonicity result. Both of these results are proven semantically, taking advantage of the fact that an instantiation of MTT comes equipped with a well-behaved class of models in which syntax is initial. Notably, however, they stopped short of showing that MTT enjoys a normalization result, and the lack of such a result precludes a general approach to implementing instantiations of MTT.
Here, we rectify the situation and show that MTT admits a normalization result. As a corollary, conversion in MTT is decidable when equality of modalities and 2cells is decidable. This result paves the way for an implementation of MTT which does not necessitate a full reimplementation for each tweak of the modalities.
Normalization results for dependent type theories are typically involved affairs, requiring the construction of a sophisticated PER model, families of logical relations, and other technical constructions. For this proof, however, we adapt recent gluing arguments for normalization to give a concise and detailed proof [AHS95; AK16; Coq19; Fio02; Ste21].
While the literature contains a large number of modal dependent type theories, very few are proven to enjoy normalization. Of these, the most closely related is MLTT [GSB19a]. This is a type theory extending MLTT with an idempotent comonad. However, compared to the normalization proof of MLTT given by Gratzer, Sterling, and Birkedal [GSB19a], this result is significantly shorter and more conceptual.2 Furthermore, the result for MTT applies to a wide variety of modal situations, including modal type theory with an idempotent comonad.
1.3. Proof outline. In broad strokes, the proof of normalization for MTT proceeds in several stages. First, we introduce the technical device of MTT cosmoi in Section 3. An MTT cosmos is a more flexible version of the models of MTT originally described. In particular, cosmoi are only required to be locally Cartesian closed, so
2As a crude measurement, the proof of normalization for MLTT occupies the bulk of the accompanying 90 page technical report [GSB19b]. The proof of normalization for MTT, by contrast, takes approximately 25 pages to present with more detail.

4

DANIEL GRATZER

that there is no `fiberwise representability' requirement, and morphisms between models are only required to preserve several structures up to isomorphism. This definition of model is more closely related to the presentations of type theories as representable map categories [Uem19] or locally Cartesian closed categories [GS20]. This flexibility is essential for the application of synthetic Tait computability and allows us to avoid tedious calculations.
Remark 1. We emphasize, however, this change of categories is a technical detail of the proof: the normalization function is defined on the stricter syntax constituting an initial object of the CwF models as originally defined rather than the initial object of the category of cosmoi. While it is more work to obtain a normalization result of this form, it ensures that one does not need to accept the initial MTT cosmos as syntax; such acceptance would require a leap of faith, because there is no adequacy result for MTT cosmoi corresponding those proven by Uemura [Uem19] and Gratzer and Sterling [GS20]. Such an adequacy result is difficult to formulate for MTT cosmoi because of the lack of established modal logical frameworks.
In Section 4 we introduce the necessary mathematics to generalize synthetic Tait computability (STC) from working internally to a single gluing category to applying to a collection of gluing categories interconnected by functors and natural transformations. In particular, we show that one may work internally to this network of categories in MTT, using MTT modalities to pass between gluing categories. We also show that the fibered modalities available in each gluing category commute with modalities already present in MTT, a crucial result for constructing the normalization model.
With this framework in place, Section 5 and Section 6 define the basic objects of the normalization model: renamings, normal and neutral forms, etc. In particular, Section 6 defines the gluing categories used for normalization, along with the functors between them. This portion of the proof proceeds with minimal alternations from a standard proof of normalization for MLTT. The only changes are to account for multiple modalities, and this change is mostly one of book-keeping. One novelty of Section 5 is the usage of a non-free presentation of renamings. By allowing renamings to enjoy non-trivial equations, we vastly simplify the development. As a consequence of this decision, we only must show that the action of a renaming on a normal form respects these equations -- a straightforward calculation.
The actual construction of the normalization model, and the heart of the proof, takes place in Section 7. In particular, we define an MTT cosmos of glued categories together with the reify and reflect maps needed to define the normalization function. Those familiar with proofs of normalization by gluing, and in particular with those given by STC will find much of the construction familiar. The central challenge is the construction of modal types in the normalization model (Lemma 7.6), and in particular the construction of the modal elimination law. Other connectives which do not interact with modalities (booleans, universes, dependent sums, etc.) can be constructed in this multimodal setting with no alteration.
Finally, the normalization function is extracted from this model in Section 8. Taking advantage of the fact that this proof is constructive, we also observe that the normalization function is effective. This uses a novel approach to derive a normalization result for strict syntax, rather than the initial MTT cosmos. Using these results, we establish several other corollaries such as the decidability of equality and the injectivity of type-constructors.

NORMALIZATION FOR MULTIMODAL TYPE THEORY

5

2. Normalization via Synthetic Tait Computability
The proof of normalization for MTT follows from a systematic generalization of Synthetic Tait Computability (STC) to multimodal type theories. While a full introduction of the theory of STC is beyond the scope of this work, given that a comprehensive account has not yet emerged3 we give a short summary of the key ideas here. We focus in particular on proving normalization via STC. Other descriptions of STC are given by Sterling and Harper [SH20], Sterling and Gratzer [SG20], and Sterling and Angiuli [SA21].
Prior to discussing STC, we remark that in the process of embracing STC we are naturally led to a number of ideas which are not intrinsically categorical but still crucial to the concision of the proof.
· Our normalization proof is reduction-free, and · the algorithm works only over equivalences classes of well-typed terms.
More explicitly, our proof is reduction-free in that it does not proceed by fixing a rewriting system presenting the equational theory which we then prove to be confluent and strongly normalizing. This avoids the thorny issue of finding an rewriting system which faithfully presents the equational theory of MTT--the inclusion of -laws for dependent sums greatly complicates such a task.
To the second point, working with terms only up to definitional equality obviates the need for a separate proof of completeness of the normalization algorithm. More than this, it is also a necessary step to treating MTT categorically; without this quotienting, the category of contexts is not even a category. Similarly, the universal properties of various connectives of MTT are crucially leveraged to simplify aspects of the normalization proof, but these universal properties only come into being after taking terms up to definitional equality.
2.1. Normalization by gluing. Proving normalization via STC involves working internally to a particular glued category. This idea branches off the observation that that logical relations arguments could be systematically recast as the construction of a model of type theory in a Freyd cover or Sierpinski cone (scone) [MS93]. This is a special case of the more general gluing construction:
Definition 2.1. Given a functor F : C D, the gluing category Gl(F ) is the comma category (idD  F ). Explicitly, objects are triples (D, C, f : D F (C)) and commuting squares between them.
Definition 2.2. Given a category C, The Sierpinski cone S(C) is Gl([1C, -]C).
To a rough approximation, a logical relation can be seen as an assignment of types to predicates on their closed terms. Taking T to be the category of contexts and substitutions between them and blurring the distinction between contexts and types as is often done in the simply-typed case, this is more or less the content of an object of S(T); a triple (S, A, f : S [1, A]) can be viewed as a predicate on the closed elements of A with P (a) = f -1(a). Notice that the correspondence is imperfect because there may be multiple distinct elements in the fiber P (a). In fact, f -1(-) determines a proof-relevant predicate on closed elements of A. This can be fixed by cutting S(T) down to consist of objects (S, A, f : S [1, A]), but this is both less categorically natural and, as we shall see in later, counterproductive.
3We hope that the forthcoming work of Sterling [Ste21] will serve this role

6

DANIEL GRATZER

What makes this shift in perspective so useful is the remarkable ability of S(C) to seemingly inherit all the structure of C in such a way that the projection S(C) C preserves this structure. For instance, if C is Cartesian closed, then so too is S(C) and the projection preserves all this structure. In fact, an explicit construction of e.g., the exponential in S(C) yields almost precisely the standard construction of the logical relation at function type. The benefit of relying on such technology, however, is that one can typically avoid these explicit calculations; once it is known that S(C) is Cartesian closed, canonicity at ground type can be proven without ever needing to explicitly calculate the construction of exponentials.
The correspondence between logical relations and gluing was pushed further in multiple directions [Alt+01; AHS95; Fio02; Str98]. In particular, the insistence of logical relations of closed terms of a type can be relaxed by switching to a different comma category. We are interested in proving normalization, emphatically not a result solely concerned with closed terms.
Accordingly, rather than considering a model in S(C), we will consider a glued category valued in presheaves over renamings. It is perhaps more natural to expect one to examine presheaves over contexts: after all, terms organize into a presheaf over arbitrary contexts and substitutions, with substitution giving rise to the reindexing action of the presheaf. One would then consider a model in Gl(y); the category given by gluing along the Yoneda embedding.
The first attempts at categorical proofs of normalization constructed models in Gl(y), so that one considered predicates not on the closed terms of type A, but over the family ([, A]). The presheaf condition corresponds to the monotonicity conditions familiar to all Kripke logical relations, but in particular those for normalization. Unfortunately, these presheaf conditions are too onerous to view normal forms as a presheaf on contexts -- normal forms are never stable under all substitutions -- so that the resultant normalization function is given as a map from terms to terms and indistinguishable from the identity function on terms.
This can be rectified taking presheaves over the wide subcategory of renamings R  T. By cutting down the substitutions allowed between contexts, normal forms may be organized into an object of PSh(R) [AHS95; Fio02]. Accordingly, normalization proceeds not by gluing along the Yoneda lemma as still repeated in literature, but by gluing along a restriction of the Yoneda lemma, the nerve n : T PSh(R). Unlike canonicity, it is insufficient to simply construct a model of T in Gl(n), extra structure is required which `sandwiches' the predicate for a type A between the neutral and normal forms of A, so that the following commutative diagram exists in PSh(R):

(1)

NeA A PA A NfA

n(A)
The top two maps of this diagram are categorical realizations of the reflect and reify maps found in normalization-by-evaluation [Abe13] and are used to extract the normalization function. In the simply-typed case, these maps can be constructed by induction after the fact, but in the dependently-typed setting this approach does not scale and the two must be constructed simultaneously. Accordingly, we require

NORMALIZATION FOR MULTIMODAL TYPE THEORY

7

a type in our glued model to be not just a proof-relevant predicate PA over n(A), but a triple of (PA, A, A) [AHS95; Fio02].
One final remark is needed prior to the introduction of STC. Thus far we have limited consideration to simply-typed languages. The full utility of proof-relevance only becomes apparent when considering dependent type theory with universes. In these cases, it becomes necessary to associate with an element of a universe not merely a proposition (computable or not computable) but to instead pair an element with the computability data of a type again. This is beautifully handled by the proof-relevance of predicates: the predicate on universes at A : U contains choices of computability data over El(A) as witnesses [Coq19; Shu15].
2.2. Synthetic Tait Computability. Finally, we now turn to Synthetic Tait Computability. STC builds on the idea of working with glued categories, but instead of gluing together locally Cartesian closed categories presenting dependent type theories [GS20], STC is concerned with topoi. Suppose T presents a type theory, and R  T is the subcategory of renamings. Rather than gluing together the locally Cartesian closed categories T and PSh(R) along n, we instead glue together PSh(T) and PSh(R) along the inverse image of the essentially geometric morphism induced by the inclusion i : R T. As topoi are closed under gluing, the resultant glued category Gl(i) is a topos. In fact, by a standard result [AGV72; CJ95] it is a presheaf topos.
As a result, Gl(i) supports a model of extensional Martin-L¨of type theory with a hierarchy of cumulative universes. Inside this type theory, two fibered modalities,
and , allow us to recover PSh(T) and PSh(R) inside of Gl(i). By relaxing the definition of a model of Martin-L¨of type theory to non-representability universes moreover, we may specify and construct the glued model purely internally to Gl(i).
This internal approach offers a significant improvement over previous proofs of gluing for dependent type theory [Coq19; KHS19] which work externally and incur what Sterling [Ste21] has referred to as an `avalanche' of naturality obligations. As we shall see in Section 7, these tedious calculations are replaced with programming exercises in extensional type theory (or MTT in our case). In particular, a model lying over the model in PSh(T) corresponds to a series of constants subject to the requirement that they are sent by to the constants defining the model in PSh(T).
We refer to the internal type theory of Gl(i)--extensional type theory with cumulative universes, two fibered modalities, and a few axioms governing their behavior--as the language of Synthetic Tait Computability.
3. MTT Cosmoi
While the basic theory of models of MTT is detailed by Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20a], we generalize to locally Cartesian closed categories. This change, inspired by Gratzer and Sterling [GS20], is crucial to actually carrying out the normalization theorem as it removes representability requirements from the universes of types and terms. These prove superfluous for the theorem, and forcing the glued model to satisfy them is both unnatural and surprisingly challenging.
Remark 2. Henceforth, we shall consider MTT over a fixed mode theory M.
Definition 3.1 (Definition 18 [Awo18]). An internal lifting structure s : i  between a pair of morphisms i : A B and  : X Y is a section of canonical map XB Y B ×Y A XA.

8

DANIEL GRATZER

Definition 3.2. The 2-category Catg consists of small categories, functors between them, and invertible natural transformations.

Definition 3.3. The locally full 2-subcategory V of [M, Catg] is spanned by pseudofunctors F enjoying the following two properties:
· For each m : M, F (m) is a locally Cartesian closed category. · For each µ : n m, F (µ) is a right adjoint.
Note that we do not require that F (µ) preserves the locally Cartesian closed structure of F (m). We write F (µ)! for the left adjoint of F (µ).
Definition 3.4. An object F : V is an MTT cosmos when equipped with the following structure:
(1) In F (m), there is a universe m : Tm Tm with a choice of codes witnessing its closure under dependent sums, and booleans. Additionally, there is a choice of code making m closed under modal dependent products: a code for Pfµ(n)(m) for each µ : n m.
(2) For each µ, there exists a chosen commuting square

F (µ)(Tn)

Tm

(2)

F (µ)(Tn)

Tm

Mod

(3) For each µ : n m and  : o n, there is a chosen lifting structure F (µ)(m) F (µ  )(To) × m, where m : F ()(To) F ()(To) ×Tn Tn is the comparison map induced by Diagram 2.
(4) µ contains a subuniverse also closed under all these connectives.
To a first approximation, an MTT cosmos is a standard model of MTT formulated in the language in natural models without the requirements that the universes be legitimate representable natural transformations. By expanding the class of models in this way, we make it far easier to construct the glued model in Section 7.
Remark 3. In order to simplify matters, we assume MTT has only a weak universe `a la Tarski. Concretely, there exists a universe U and a decoding operation El(-) just as in Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20a]. Unlike the original presentation of MTT however, we only obtain a chosen isomorphism between each connective and its decoded code e.g. dec (-) : El((µ | A)  B) = (µ | El(A))  El(B).
Recent unpublished work by Gratzer and Sterling has shown that Synthetic Tait Computability [Ste21] can be strengthened to accommodate stricter universes, and can be applied to the following without issue. We remark, however, that there is experimental evidence that elaboration can be used to alleviate the tedium of these weaker universes in practice [Red20].
Definition 3.5. A morphism between MTT-structured cosmoi  : F G is a 2-natural transformation  such that m is an LCCC functor and preserves all connectives strictly. Furthermore, we require that there is a natural isomorphism

NORMALIZATION FOR MULTIMODAL TYPE THEORY

9

µ : n  F (µ)! = G(µ)!  m such that the transposition of µ  m(a) is m(a)  µ when a : X F (µ)(Y ) : F (m).

Theorem 3.6. Any strict model of MTT induces a cosmos. In particular, the initial model of MTT S - induces a cosmos.

Theorem 3.7 (Quasi-initiality). Given an arbitrary MTT cosmos G and a map  : G S - , the following holds:
(1) For every context  cx @ m, there exists an object  : G(m), together with a canonical isomorphism  : (  ) = y().
(2) For every type  A @ m, there is a morphism A :  Tm such that ( A )   = A .
(3) For every term  M : A @ m, there is a morphism M : G M Tm lying over A such that ( M )   = M .

Remark 4. We have used `syntactic' notation ( cx @ m,  M : A @ m, etc.) to denote the components of the initial model S - . This is a mere notational convenience: we do not rely on the fact that S - may be constructed out of `traditional' syntax.

Proof. For clarity, we write Elm, Tym and Tmm instead of m, Tm, and m in the syntactic model, reserving the latter exclusively for G. We write µ for the functor

sending  to .{µ}. We may replace G by an equivalent strict 2-functor such that

 becomes strictly 2-natural, so we work under this assumption.

We construct a displayed model of MTT [KKA19] which lies over the syntactic

model.

· Contexts in mode m are interpreted by triples (X : G(m), ,  : (X) =

y()). · A type in a context (X, , ) is a pair of (A¯ : X
that (A¯) = A  .

Tm,  A @ m) such

· A term in a context (X, , ) of type (A, A) is a pair of M  : X Tm and  M : A @ m such that m  M  = A and (M ) = M  .

· A substitution between (X, , ) and (Y, , ) is a pair of f : X Y and

  :  @ m such that   (f ) = y()  

Once this model is constructed, the result is a direct consequence of the initiality

of (strict) syntax. In fact, the construction of contexts, substitutions, terms, and

types is relatively routine owing to the fact that  is a 2-natural transformation,

preserves finite limits, and strictly commutes with all connectives. We show a few

cases to give a flavor for the procedure.

The action of a modality on a context. Given a triple (X, , ) at mode n and a modality µ : n m, we define the `locked' context to be the following:
(G(µ)!(X), .{µ},   µ !  ) Here,  : (G(µ)!(X)) = µ !((X)) while  : µ !(y()) = y(.{µ}).
Context extension. Given a context (X, , ) at mode m, a modality µ : n m and a type (A, A) in the context (G(µ)!(X), .{µ}, ), we form the context extension as the triple (X ×G(µ)(Tm) G(Tm), .(µ | A), ), where  is the composite:
(X ×G(µ)(Tm) G(µ)(Tm)) = (X) × µ (Tym) µ (Tmm) = y(.(µ | A))

10

DANIEL GRATZER

The first isomorphism follows from the fact that  preserves finite limits, is strictly 2-natural, and strictly preserves m while the second isomorphism is the universal property of y(.(µ | A)).

Modal types. Suppose we are given a context (X, , ) and a type (A, A) in the context (G(µ)!(µ)(X), .{µ},   µ ()  ). We form the modal type as
(Modµ(A), µ | A )
It remains to check that these types are coherent. That is, that
(Modµ(A)) = µ | A   By assumption, (A) = A    µ ()  . By our assumption that  commutes with transposition, (A) = A    . The result follows from the fact that  preserves Mod.

3.1. An initial cosmos. While the following material is not strictly necessary for our proof of normalization, we record it for general interest.
Theorem 3.8. The category of MTT cosmoi can be sketched over V.
Proof. First we show that V is 2-monadic over [|M|, Catg]. This follows directly from the fact that locally Cartesian closure can be realized as a finitary 2-monad on Catg [Lac09, Section 5.9] and pseudofunctors whose 1-cells are right adjoints are finitarily 2-monadic over [|M|, Catg] [Lac09, Section 5.9]. Combining the operations and equations shows V is finitarily 2-monadic over [|M|, Catg].
The constants and equations of MTT-cosmoi are sketchable over this 2-monad following the work of Kinoshita, Power, and Takeyama [KPT99].

Corollary 3.9. The category of MTT-cosmoi has a bi-initial object I - .

4. Foundations of multimodal Synthetic Tait Computability
Eventually, we will wish to work with a collection of models of Synthetic Tait Computability (STC), connected by a variety of adjunctions. In order for this to work, however, we need to show that adjunctions between various categories lift to adjunctions between glued categories. The main result of this section is Theorem 4.13, which states that a collection of glued categories interconnected by right adjoints supports a model of "multimodal" STC.

Theorem 4.1. Suppose we are given lex functors i : Sh(Xi) Sh(Yi) and a 2-cell  witnessing the weak commutativity of the following diagram:

0

Sh(X0)

Sh(Y0)

f

g

Sh(X1)

1

Sh(Y1)

NORMALIZATION FOR MULTIMODAL TYPE THEORY

11

Then there is an induced morphism [f, g] : Gl(1) into the following diagram:

X1

Gl(1)

Gl(0) such that [f, g] fits Y1

X0

Gl(0)

Y0

Moreover, if both fringe functors i are continuous and f and g are essential, then [f, g] is also essential.
Proof. Explicitly, [f, g] sends F 0(E) to g(F ) 1(f (E)). The 2-cell  is used to obtain this morphism by correcting g F 0(E) .
Colimits and finite limits are determined pointwise in Sh(Gl(i)), so [f, g] preserves them because f  and g both do. If both i are continuous, then all limits are determined pointwise, so [f, g] is essential if both f and g are.

Theorem 4.2. Suppose that f and g are essential, then [f, g]! is a pointwise application of f! and g!.
Proof. Explicitly, fix a morphism x : Y 0(X). We then define [f, g]!x to be x~ : g!(Y ) 1(g!(X)), where x~ =   g!(x) and  is the canonical natural transformation determined by the following series of transposes:
  [g!  1, 0  f!] = [1, g  1  f!] = [1, 1  f   f!] 1()
It remains to show that this defines an adjoint. We show that there is a bijection [[f, g]!(x), x ] = [x, [f, g](x )]. Given that [f, g]! and [f, g] are defined pointwise, it suffices to show that the transpose operators for f! f  and g! g lift.
Fix b : X f X and a : Y g(Y ) such that   g(x )  a = 1(b)  x. We wish to show that x  a = 0(b)  x~.
0(b)  x~ = 0(b)    g!(x)
= 0(b)   g!(-1  1())  g!(x)
= 0(b)   g!(-1  1()  x)
=  g!(g(0(b))  -1  1()  x)
=  g!(-1  1(f (b))  1()  x) =  g!(-1  1(b)  x) =  g!(g(x )  a)
=x a

Next, b : f!(X) X and a : g!(Y ) Y such that x  a = 0(b)  x~. We wish to show that   g(x )  a = 1(b)  x.
  g(x )  a =   g(x )  g(a)   =   g(x  a)   =   g(0(b)  x~)  

12

DANIEL GRATZER

= 1(f (b))    g(  g!(-1  1()  x))   = 1(f (b))    g( )    -1  1()  x = 1(f (b))  1()  x
= 1(b)  x
It is natural to view Gl(i) as a topos with a subterminal object syni such that the open subtopos corresponding to syni is equivalent to Xi, while the closed subtopos is equivalent to Yi. For the sake of easy of readability, we will identify these subtopoi with Xi and Yi in what follows. Recall that the inverse image of the inclusion Xi Gl(i) is given by -syni . The inverse image of Yi Gl(i) is given by - syni, where A syni is the pushout A A×syni syni.
4.1. Open and closed subtopoi. We now devote substantial effort to showing that the decomposition of Gl(i) is preserved by [f, g].
Lemma 4.3. If A : Gl(0) is contained in Sh(X0), then [f, g](A) : Sh(X1).
Proof. Observe that A is in the open subtopos Sh(X0) if A = 0(E) 0(E), in which case [f, g](A) = 1(f (E)) 1(f (E)) which then lies in the open subtopos.

Lemma 4.4. If A : Sh(Gl(0)) is contained in Sh(Y0), then [f, g](A) : Sh(Y1). Proof. Again, observe that A : Sh(Y0) if A = F 0(1Sh(X0)), in which case
[f, g](A) = g(F ) 1(f (1Sh(X0))) = g(F ) 1(1Sh(X1)) This then lies in the closed subtopos of Gl(1).

In fact, a more general theorem is true. Reflecting an object into either subtopos and applying [f, g] is (naturally) isomorphic to applying [f, g] and then reflecting.

Lemma 4.5. There is an isomorphism syn1 [f, g](syn0).

Proof. Unfolding definitions:

syn0 = 0Sh(Y0) syn1 = 0Sh(Y1) The result is immediate by computation.

0(1Sh(X0)) 1(1Sh(X1))

Corollary 4.6. (1) [f, g](syn0) = syn1 (2) [f, g](-syn0 ) = ([f, g](-))syn1 (3) [f, g](syn0 -) = syn1 [f, g](-)
Remark 5. The last fact of Corollary 4.6 is a consequence of the first; is preserved by [f, g] because as this functor is lex and cocontinuous and is defined by finite products and pushouts. Exponentiation, however, is not generally preserved by [f, g]. It is a special fact of syn0 that exponentiation by syn0 is preserved.
As idempotent lex modalities, both of these actions internalize into the internal type theory of the topoi. In particular, they have actions on a family given by applying the operation to the entire family, then pulling back along the unit. This is automatically preserved by [f, g], as [f, g] preserves each step in this construction.

NORMALIZATION FOR MULTIMODAL TYPE THEORY

13

We write for the action of -syn0 on families, and for - syn0. We will abusively use the same notation for -syn0 and -syn1 as well as - syn0 and - syn1. Theorem 4.7. Both and are preserved by [f, g]

We would like to show a slightly stronger result, namely that the dependent versions of these modalities are preserved [RSS20]. Prior to this, we must address the question of universes and models of type theory in this situation.
As a morphism of logoi, we know that [f, g] is a cocontinuous left exact functor. We would like to show that it induces a dependent right adjoint [Bir+20], but this is complicated by the murky definition of a model of dependent type theory with universes in an arbitrary logos. Accordingly, prove a theorem which is sufficient for the case we have in mind.

Definition 4.8. A functor F : PSh(C) PSh(D) between presheaf categories is said to preserve a Grothendieck universe U when it sends U-small families in PSh(C) to U-small families in PSh(D).

Theorem 4.9. A right adjoint F : PSh(C) PSh(D) which preserves Grothendieck universes larger than |C| and |D| induces a dependent right adjoint.

Remark 6. To be precise, we must specify the particular models of dependent type theory we consider in PSh(C) and PSh(D). We take the model of type theory which a type to be an element of the universe of small presheaves [HS97].

Proof. Fix a Grothendieck universe V which is large enough to contain both C and

D. We wish to show that F induces a weak CwF morphism. A type in PSh(C)

is given by a generalized element of TC, the Hofmann-Streicher universe of V-small presheaves, so it suffices to show that there is a pullback square of the following

shape:

F (TC)

TD

F (C)

D

F (TC)

TD

Proving this is equivalent to showing that F (C) is U -small because D is generic for such maps. This immediately defines a weak CwF morphism using the observation that context extension in these models is defined by pullback.

Theorem 4.10. A cocontinuous lex functor F : PSh(C) PSh(D) preserves a Grothendieck universe U if and only if it restricts to a functor PShU (C) PShU (D).
Proof. The only if direction is clear, so it remains to show that preserving U-objects ensures that F preserves U-families. Fix a U-small family f : X Y : PSh(C).
First, we observe that F (Y ) = colimi F (y(Ci)) using the canonical decomposition of Y into colimits. By Yoneda, a morphism y(D) F (Y ) then factors through some F (y(Ci)), followed by F ( yi ) : F (y(Ci)) F (Y ), so it suffices to show that the pullback of F (f ) to F (y(Ci)) is a small family.
As F (f ) and F ( yi ) are both in the image of F , this pullback can be computed in PSh(C). Therefore, we must show that F (X ×Y y(Ci)) F (y(Ci)) is a small family. Using the assumption that f was a small family, we observe that X ×Y y(Ci)

14

DANIEL GRATZER

is a small object, so F (X ×Y y(Ci)) is U -small. Therefore, this family is a small family, completing the proof.

While these results are limited to presheaf topoi, they are sufficient for our purposes; we are interested in gluing together presheaf topoi along a continuous functor. The following result shows that the resultant topos is of presheaf type:
Theorem 4.11 (Artin, Grothendieck, and Verdier [AGV72] and Carboni and Johnstone [CJ95]). Gluing together presheaf topoi along a continuous functor results in a presheaf topos.
Motivated by this, we now assume that Ei and Fi are all presheaf logoi, and all morphisms involved preserve all Grothendieck universes larger than U. In this case, we may then pick a Grothendieck universe U large enough to be preserved by both f and g and so the bases of Gl(1) and Gl(1) are small for this universe. In this case, [f, g] is a DRA which preserves all universes larger than U.
We now show that [f, g] preserves the dependent version of and .
Theorem 4.12. [f, g] preserves ^ and ^ on any universe preserved by [f, g].
Proof. We will show this for ^ , though the proof is identical for ^ and indeed for any lex modality preserved by [f, g].
Let us pick some universe U large enough to be preserved by [f, g] and write 0 : T0 T0 for the Hofmann-Streicher universe it induces in Sh(Gl(0)) and 1 : T1 T1 for the Hofmann-Streicher universe in Sh(Gl(1)). By assumption, we have a pullback squares

[f, g]T0

T1

[f, g]0

1

[f, g]T0 i T1

Ti

Ti

i

i

Ti

Ti

^

Finally, we note that [f, g] preserves , meaning that there is a natural isomor-

phism  : [f, g] 

 [f, g].

We may now rephrase: our goal is to show that i  [f, g]( ^ ) and ^  i  

represent the same type. First, compute the type represented by ^  i  :

[f, g] T0

T1

T1

[f, g] T0

i

T1

T1

^

NORMALIZATION FOR MULTIMODAL TYPE THEORY

15

The left-hand square is a pullback because is lex. Next, we compute i[f, g]( ^ ):

[f, g] T0

[f, g]T1

T1

[f, g] T0

[f, g]T1

T1

[f, g] ^

i

The left-hand square is now a pullback because [f, g] is lex.

4.2. Interpreting MTT in glued topoi. The results of the previous subsection show that [f, g] preserves the open and closed modalities of a glued topos. As a dependent right adjoint, moreover, [f, g] can be internalized into a model of MTT. It is this model of MTT that we use to substantiate the language of `multimodal' synthetic Tait computability.
Theorem 4.13. Fix a 2-category M and a 2-functor - : Mop × 1 Cat which assigns 0-cells to presheaf topoi and 1-cells to essential geometric morphisms between them. There exists a model of MTT with M such that mode m is given by Gl( m × 0 m × 1 ) and the modality µ is interpreted by [ µ × 0 , µ × 1 ].
Furthermore, each mode has an open and closed modality preserved by the MTT modalities such that the open (resp. closed) subtopos of mode m is equivalent to m × 0 , (resp. m × 1 ).

In this model, each mode supports a model of synthetic Tait computability and the extra structure of this language (the open and closed modalities) is preserved by the modalities between modes.

5. The category of renamings for MTT
We now isolate a class of renamings: Renm. We also define the neutral and normal forms of terms in MTT. Unlike the syntax of MTT, neutral and normal forms are not taken up to a complex equivalence relation, and so their conversion problem is immediately reducible to conversion in the mode theory.
The judgments for these are slightly atypical, in that the typing judgments for both neutral and normal forms are defined (1) with formal telescopes as contexts and (2) inductive-recursively with the inclusion of neutral and normals into terms, and renamings into contexts and substitutions. This dependence of the unquotiented raw syntax on actual terms is necessary in order to ensure that the typing relation can be sensibly defined.
The full collection of neutral and normal forms is given in Appendix A. We present a few representative cases below.
 tele @ m    :  @ m 

 tele @ m  .{µ} tele @ m .{n}

,  tele @ m ,   r :  @ m  .{µ} r.{µ} : .{µ} @ n .{µ}

 tele @ m  µ,  : n m  :  µ .{µ} {} : .{} @ n {}

16

DANIEL GRATZER

 nf  @ m A

 nf  @ n A .(idm | A) nf  @ m B  nf  ×  @ m A × B

.{µ} nf  @ n A  nf µ |  @ m µ | A

 tele @ m   nf u : U @ m A  nf El(u) @ m A

 ne e : A @ m M  nf u : A @ m M

 tele @ m  (k) = (µ | A) mods(, k) =   : µ   ne vk : A[{}  (.{k-1}) · · ·  (.{0})] @ m v0[{}  (.{k-1}) · · ·  (.{0})]

 tele @ m  .{µ} A @ n .(µ | A) .(µ | A) nf u : B @ m M
 nf (u) : (µ | A)  B @ m (M )

B@m

 tele @ m  .{µ} A @ n .(µ | A) B @ m  ne e : (µ | A)  B @ m M  nf u : A @ m N
 ne e(u) : B[id.N ] @ m M (N )

 tele @ m  .{µ} A @ n .{µ} nf u : A @ n M  nf modµ(u) : µ | A @ m modµ(M )
 tele @ m  .{µ} A @ n  ne e : µ | A @ m M  nf up(e) : µ | A @ m M

:o n µ:n m  tele @ m  .{µ}.{} A @ o .{µ} ne u :  | A @ n M .(µ |  | A ) nf  @ m B .(µ   | A) nf u : B[.mod (v0)] @ m
 ne letmod(µ; ;  ; e; u) : B[id.M ] @ m let modµ( )  M in N

 tele @ m   ne e : El(bool) @ m M  ne dec (e) : bool @ m dec (M )

 tele @ m   nf u : bool @ m M  nf dec (u) : El(bool) @ m dec (M )
There are no equations imposed on any of these generators, except for renamings which have the necessary equations to organize them into a 2-functor into Cat. We further define a substitution action applying a renaming to a normal or neutral form, which must show respects these equations. This operation and its pertinent proofs are largely standard, with the exception being the case for variables. We reproduce the definition of the substitution action on variables here:
vk[id] = vk

NORMALIZATION FOR MULTIMODAL TYPE THEORY

17

vk[.{µ}] = vk+1

vk[r.vj.{µ}] =

vj( idµ) vk-1[r.{µ}]

k=0 otherwise

vk[(r  s).{µ}] = vk[r.{µ}][s.{µ}]

vk[{}] = vk

Remark 7. Note that these normal forms do not necessarily enjoy decidable equality. Rather, the problem of deciding when two normal forms are convertible is precisely the problem of deciding whether certain 1- and 2-cells of the mode theory M are equal. Accordingly, it is possible that MTT may enjoy normalization, but not decidable type-checking. The mode theories used in instantiations of MTT thus far are evidently decidable, so we do not expect this to be an issue for practical usage.

6. Prerequisites for the normalization model
6.1. Key syntactic categories. Recall from Section 5 that for each mode there is a category Renm of telescopes and renamings, together with a functor i[m] : Renm Cxm which sends a telescope the corresponding context and formal renaming to substitution. The collection of these functors induces a natural transformation between the 2-functors Cx-, Ren- : Mcoop Cat.
The functor i[m] induces a functor i[m] : PSh(Cxm) PSh(Renm). Moreover, because PSh(-) preserves strict equalities, this gives rise to a 2-functor M × 1 Cat. As a morphism defined by precomposition each i[m] has a left adjoint and a right adjoint: i[m]! i[m] i[m]. The left adjoint extends i[m] in the sense that i[m]!(y()) = y(i[m]()). We may now apply Theorem 4.13.
Theorem 6.1. There exist a model G - of MTT with a hierarchy of cumulative universes in Gl(i[m]).
In this model, G m is Gl(i[m]), and G µ is interpreted by precomposition with µ in both components. Furthermore, there is a (dependent) open and closed modality in G m , preserved by all modalities.
In what follows, we will freely use MTT to work with this model. As the interpretation of identity types in this model supports equality reflection, we will work with extensional equality when reasoning with MTT.
6.2. Basic properties of G m . The MTT modalities in this model are particularly well-behaved because the arise from the inverse image of essential geometric morphisms. In particular, they preserve colimits internally to the theory.
Theorem 6.2. For each µ there is an equivalence µ | A + B µ | A + µ | B .
Proof. Recall that each modality in this model is interpreted by a morphism which is simultaneously a left and right adjoint. Therefore, this model can be extended to the mode theory Madj, which extends M by adding a right adjoint µ¯ for each µ from M [Gra+20a, Section 10.2].
The crisp induction principles derived in Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20a, Section 10.5] now show that µ | - preserves coproducts internally with this extended mode theory, so the equivalence is validated by the model from Theorem 6.1 (though is no longer internally derivable).

18

DANIEL GRATZER

Remark 8. We note that this model of MTT enjoys .(µ   | A) = .(µ |  | A ): the modalities are interpreted by proper dependent right adjoints. We therefore blur the distinction between a variable (µ | x : A) and a variable (id | x : µ | A ).
Notation 6.3. It's convenient to recall that is defined by exponentiation with a subterminal (a proposition) syn. We accordingly write z:synA(z).
Remark 9. Strictly speaking, syn should contain a mode annotation. However, µ | synn = synm, and as both are subterminal we identify synm and µ | synn .
Finally, we note also that and enjoy two important properties:
Theorem 6.4 (Fracture [AGV72]). For any type A we have A = A × A A.
Theorem 6.5 (Internal realignment [OP18; SH20]). Let us denote the type of types isomorphic to A as Iso(A):
Iso(A) = B:U (A = B) There is a section re to  : Iso(A) Iso(A).
Remark 10. The following constructive proof is due to Christian Sattler.
Proof. This follows directly from the argument given by Orton and Pitts [OP18, Theorem 8.4]. It suffices to show that syn is levelwise decidable externally. This is immediate when we unfold the presentation of G m as a presheaf topos.
Explicitly, Carboni and Johnstone [CJ95] show that G m can be presented as PSh(Coll([-, i[m](-)])). While the precise definition of Coll([-, i[m](-)]) is given by Carboni and Johnstone [CJ95], for our purposes it suffices to recall that the collection of objects of this collage is the disjoint union of the objects of Cxm and Renm. Under this presentation moreover, syn can be defined as follows:
syn() =  syn() = { }
The levelwise decidability of syn is then immediate.
In anticipation of using this model of MTT to construct the normalization model in the next section, we also introduce several constants interpreted by specific presheaves in G m .
Definition 6.6. There is a constant Tym : U @ m in G m given by Tm.
Definition 6.7. There is a type z : syn, Tym(z) Tmm : U in G m whose total space is given by m : Tm Tm.
Definition 6.8. There is pair of types zTym(z) Nfm and zTym(z) Nem in G m given by normal and neutral forms viewed as a presheaf over i[m](Tm). Similarly, there is a closed type NfTym of normal types lying over i[m](Tm).
Definition 6.9. There is a type zTym(z) Vm given by viewing the presheaf of variables as lying over i[m](Tm). There is an induced inclusion Vm(A) Nem(A) which we shall treat as silent.
Using realignment if necessary, we choose Nfm, Nem, Vm such that under the assumptions z : syn and A : zTym(z), we have the following equations:
Vm(A) = Nem(A) = Nfm(A) = Tmm(z, A(z))
Similarly, under just the assumption of z, we have NfTym = Tym(z).

NORMALIZATION FOR MULTIMODAL TYPE THEORY

19

6.3. An MTT cosmos, internally. In Section 7 we will construct a model of MTT in G - lying over the syntactic model. To that end, we recast the existence of a model of MTT into a structure we can express in the internal language of G - . Explicitly, we rephrase Definition 3.3 as a sequence of constants in the internal type theory e.g., a pair Tym and Tym Tmm, combinators for all the type codes, etc. The full list of constants is described in Appendix B.
Remark 11. There is potential for confusion here: we are using the internal language of G - (extensional MTT) as a framework to express the structure of an MTT cosmos. This is not a circularity; the interpretation of extensional MTT into G - is formulated in terms of the models and metatheory developed already in Gratzer, Kavvos, Nuyts, and Birkedal [Gra+20a].
Already, we can immediately obtain an MTT cosmos internal to G - by restricting to the open subtopos: S - . In this cosmos, types are interpreted as elements of the constant Tym(z) while terms are elements of Tmm(z, -). This the syntactic MTT cosmos. Externally, this is the MTT cosmos S - where universes are interpreted by the traditional representable natural transformations [Awo18]. Eventually, we will construct the normalization model as a second cosmos in G - which lies strictly over the syntactic cosmos.
We will use the "unqualified" names such as Prod(z) to refer to elements of this syntactic cosmos. So, for instance, under the assumption z : syn we the following:
Mod[µ] : (µ | A : Tyn(z))  Tym(z) m[µ] : (µ | A : Tyn(z))(µ | a : Tmn(z, A))  Tmm(Mod[µ](A))
letmod[µ; ] : (  µ | A : Tyn(z)) B : µ | Tmn(z, Mod[µ](A))  Tyo(z)  (  µ | x : Tmn(z, A))  Tmo(z, B(m[µ](A, x)))  ( | a : Tmm(z, Mod[µ](A)))  Tmo(z, B(a))
: (  µ | A : Tyn(z)) B : µ | Tmn(z, Mod[µ](A))  Tyo(z)  b : (  µ | x : Tmn(z, A))  B(m[µ](A, x))  (  µ | a : Tmn(z, A))  letmod[µ; ](A, B, b, m[µ](A, a)) = b(a)
Now, because commutes with dependent products, sums, and modalities, we may equivalently view, e.g. Prod as a constant with the following type:

A: µ| zTyn(z) µ | zTmn(z, A)  zTym(z)  zTym(z) Similarly, we will abusively write Prod(A, B) for z. Prod(A(z), B(-, z)).

6.4. Higher-order abstract syntax for neutral and normal forms. The types Nem, Nfm can be used to encode a form of HOAS inside of G m [Hof99]. We record the constants that result from this in Appendix C.
In the proof of normalization we will take advantage of the fact that under an open modality, a normal and neutral form decode to the appropriate terms. Therefore, under the open modality proj0(pair(M, N )) is well-typed and equal to M along with other expected equations.

20

DANIEL GRATZER

7. The normalization model
We now construct a model of MTT in G - which lies over the over the syntactic model of MTT built around Tym and Tmm introduced in Section 6.3. Concretely, this means that we must construct a series of constants (Tym, Tmm, Prod, etc.) in G - such that under z : syn these constants are equal to their corresponding syntactic components (Tym(z), Tmm(z, -), Prod(z), etc.). This family of constants will define a model in G - and the `alignment' condition ensures that there is a morphism of models (Theorem 7.9). See Appendix B for the full list of constants. Throughout this section we will use extensional MTT as an internal language for G - (Theorem 6.1) to define these constants. The strict equations will follow from repeated applications of the realignment theorem (Theorem 6.5). Many of these computations will be familiar to readers experienced with STC. The main novelties are modal connectives Lemmas 7.5 and 7.6.
Definition 7.1. We define Tym as the realignment of the following over Tym:
record T : {U2 | z : syn  Tym} where A : NfTym  : {U1 | z : syn  Tmm(z, A)}  : {Nem( A)   | z : syn  id}  : {  Nfm( A) | z : syn  id}
Taking advantage of the isomorphism Tym = T , we construct elements of Tym by specifying A, , , and . By realignment, ({A; ; ; }) = (A).
Definition 7.2. We define A : Tym Tmm(A) @ m by Tmm({ ; ; ; }) = .
Lemma 7.3. Tmm lies strictly over Tmm. Explicitly for each A : Tym = Tym(z), Tmm(A) = Tmm(z, A).
Proof. Using the boundary condition on , we compute Tmm(A) = A = Tmm(z, AA). Under the hypothesis z : syn, we obtain an equality A = AA because (A) = (AA) by definition. The conclusion now follows.

Lemma 7.4. Fixing T0 : Tym and T1 : Tmm(T0)  Tym, there exists a pair of constants:

Sig : {Tym | z : syn  Sig(z, T0, T1)} Sig : Tmm(Sig(T0, T1)) = t:Tmm(T0) Tmm(T1(t)) z : syn  Sig(z, T0, T1)

Proof.  : U1

Let us start by apply Theorem 6.5 to such that z : syn  = Sig(z, T0, T1)

Sig(z) and and Sig :



t=0:T0t0:TT10(t0)Tt1o(t0p)rwodhuicche

restricts to Sig under z : syn.

We now define Sig(T0, T1) as follows:

ASig(T0,T1) = Sum(AT0 , v. AT1(T0 v)) Sig(T0,T1) =  Sig(T0,T1) = e. S-ig1 T0 (proj0(e)), T1(T0 (proj0(e)))(proj1(e)) Sig(T0,T1) = t. pair(T0 (Sig (t)0), T1(Sig (t)0)(Sig (t)1))

NORMALIZATION FOR MULTIMODAL TYPE THEORY

21

The fact that  and  lie over the identity follows directly from the  and  laws of dependent sums in MTT. We show the calculations for . Fix z : syn:
Sig(T0,T1)(e) = S-ig1 T0 (proj0(e)), T1(T0 (proj0(e)))(proj1(e)) = S-ig1 proj0(e), proj1(e) = S-ig1 Sig(T0,T1)(e)0, Sig(T0,T1)(e)1 =e

The fact that ASig(T0,T1) and Sig(T0,T1) lie over Sig(T0, T1) and Tmm(z, Sig(z, T0, T1)) respectively follows from definition and realignment.

Lemma 7.5. Fixing T0 : (µ | Tyn) and T1 : (µ | Tmn(T0))  Tym, there exists a pair of constants:
Prod : {Tym | z : syn  Prod(z, T0, T1)}
Prod : Tmm(Prod(T0, T1)) = t: µ|Tmn(T0) Tmm(T1(t)) z : syn  Prod(z, T0, T1)

Proof. Apply such that z :

Theorem syn 

6.5 to Prod(z) = Prod(z, T0,

and (µ | T1) and

t0 : T0 Prod :

)=(Tµ1(t|0t)0t:opTro0 )duce

 : U1 T1 (t0 )

which restricts to Prod under z : syn. We now define Prod(T0, T1) as follows:

AProd(T0,T1) = Prod(AT0 , v. AT1(T0 v)) Prod(T0,T1) =  Prod(T0,T1) = e. P-r1od(t. T1(t)(app(e)(T0 (t)))) Prod(T0,T1) = t. lam(v. T1(T0 (v))(Prod(t)(T0 (v))))
Once again, the fact that everything lies over the correct terms follows from the  and  laws for dependent products, as well as the conclusions of realignment.

Lemma 7.6. Fixing T : (µ | Tyn), the following constants exist:
Mod[µ] : {Tym | z : syn  Mod[µ](z, T )} m[µ] : (µ | a : Tmn(T ))  {Tmm(Mod[µ](T )) | z : syn  m[µ](z, T, a)}
letmod[µ; ] : B :  | Tmn(Mod[µ](T ))  Tyo  b : (  µ | x : Tmn(T ))  B(m[µ](T, x))  ( | a : Tmm(Mod[µ](T )))  {Tmo(B(a)) | z : syn  letmod[µ; ](z, T, B, b, a)} : B :  | Tmn(Mod[µ](T ))  Tyo  b : (  µ | x : Tmn(T ))  Tmo(B(m[µ](T, x)))  (  µ | a : Tmn(T ))  letmod[µ; ](B, b, m[µ](a)) = b(a)

Proof. As is typical now, we will proceed by realigment. We define  to be the realignment of the following type along the subsequent isomorphism:

 = m:Nfm(Mod[µ](T ))

e:Nem(Mod[µ](T )) up(e) = m +

 :  = m: Nfm(Mod[µ](T )) 1 = zTmm(z, Mod[µ](z, T ))

a: µ|T modµ(T a) = m)

22

DANIEL GRATZER

This gives a type  and an isomorphism  :  =  such that -1( m, . . . ) = m
in a context with z : syn. We now use this to define Mod[µ](T ):

AMod[µ](T ) = Modµ(AT )
Mod[µ](T ) =  Mod[µ](T ) = e.-1 up(e), (in0( e, )) Mod[µ](T ) = 0  
Unlike with dependent sums and products, however, this is not the end of the story. We must also define the introduction and elimination forms for this type. First, the intro form:
m[µ](T, m) = -1 modµ(T (m)), (in1(m, ))
In order to define the elimination form, we need the elimination principle for A. Recall A = syn A so we may use the induction principle of a pushout on A.
With this in mind, we define the elimination rule letmod[µ; ](T, Tm, b, s) as follows. First, recall that s :  | Tmm(Mod[µ](T )) . We use the fact that  | - preserves dependent sums, the closed modality (Theorem 6.1), and coproducts (Theorem 6.2) to decompose s into two terms:

m :  | Nfn(Mod[µ](T ))

q:

e: |Nem(Mod[µ](T ))  | up(e) = m + a: µ|T  | modµ(T a) = m )

We may now perform induction on q:

 letmod[µ; ](z, T, Tm, b, s) 
Tm(s) letmodµ; (T, Tm, x. Tm(m[µ](T x))b(T x), e) b(a)

q = in0(z) q = in1(in0(mod (e), )) q = in1(in1(mod (a), ))

The fact that these agree on overlaps follows from the  rule for modal types from MTT. By construction, the elimination and introduction forms lie over their syntactic counterparts, and calculation shows that the  equation holds.

Lemma 7.7. The following constants exist:
Bool : {Tym | z : syn  Bool(z)} true : {Tmm(Bool) | z : syn  true} false : {Tmm(Bool) | z : syn  false}
if : (T : Tmm(Bool(z))  Tym)  Tmm(T (true))  Tmm(T (false))  (b : Tmm(Bool))  {Tmm(T (b)) | z : syn  if(T, t, f, b)}
: (T : Tmm(Bool)  Tym)(t : Tmm(T (true)))(f : Tmm(T (false)))  (if(T, t, f, true) = t) × (if(T, t, f, false) = f )

Proof. The proof proceeds much as Lemma 7.6, so we present the relevant definitions without much commentary. First, we realign  along  :

 = m:Nfm(Bool)

e:Nem(Bool) up(e) = m +

 : z = m:Nfm(Bool) 1 = Tmm(z, Bool(z))

b:2 m = rec2(b; tt; ff))

NORMALIZATION FOR MULTIMODAL TYPE THEORY

23

As a result, we obtain  along with  :  =  such that z : syn -1 m, . . . = m. We may now define Bool:

ABool = Bool Bool =  Bool = e.-1 up(e), (in0(e, )) Bool = 0  
The true and false constants are defined as follows:
true = tt, (in1(0, )) false = ff , (in1(1, ))

Again, the elimination principle is defined using the induction principle for A.

if(Tm, t0, t1, s = -1 b, q ) =
 if(z, Tm, t0, t1, m) 
Tm(s)if (Tm, Tm(true)t0, Tm(false)t1, e) ti

q = in0(z) q = in1(in0(e, )), up(e) = b q = in1(in1(i, )), rec(i; tt; ff) = b

The boundary conditions and the computation rule follow from computation.

Lemma 7.8. The glued model supports a universe. Specifically, this means that the following constants exist:

Uni : {Tym | z : syn  Uni} El : (T : Tmm(Uni))  {Tym | z : syn  El(T )}
Moreover, Uni is closed under various type-formers:


Sig :

A:Tmm(Uni) Tmm(El(A))  Tmm(Uni)  Tmm(Uni) z : syn  Sig


Prod :

A: µ|Tmn(Uni) [ µ | Tmn(El(A))  Tym]  Tmm(Uni) z : syn  Prod


Bool

:

{Tmm(Uni)

|

z

:

syn



Bool}


Mod

:

{

µ

|

Tmn(Uni)

 Tmm(Uni) | z : syn  Mod}

decSig : (A : Tmm(Uni))(B : Tmm(El(A))  Tmm(Uni)) 

Tmm

(El


(Sig (A,

B)))

=

Tmm(Sig(El(A),

El



B))

decProd : (µ | A : Tmm(Uni))(B : (µ | Tmn(El(A)))  Tmm(Uni)) 

Tmm

(El


(Prod

(A,

B)))

=

Tmm(Prod(El(A),

El



B))

decBool : Tmm(El(Bool)) = Tmm(Bool)

dec
Mod

:

(µ

|

A

:

Tmm(Uni))



Tmm(El


(Mod

(A)))

=

Tmm(Mod[µ](El(A)))

Furthermore, when given z : syn we require the following equations:

decSig = decSig(z) decProd = decProd(z) decBool = decBool(z) decMod = decMod(z)

Proof. At this point we take advantage of the fact that Tym is an element of U1; in particular, we use the fact that is a universe U0 small enough to fit inside U1.

24

DANIEL GRATZER

The universe and El(-) constant. We may then define  by realigning the following element of U1 along the evident isomorphism to Tmm(z, Uni(z)):

(3)

record T : U1 where

A : Nfm(Uni)

 : {U0 | z : syn  Tmm(z, El(z, A))}

 : {Nem( zEl(z, A))   | z : syn  id}

 : {  Nfm( zEl(z, A)) | z : syn  id}

As a result, we obtain  : U1 and  :  = T such that -1({A; . . . }) = A given z : syn. With  in hand, we may define Uni:

AUni = Uni Uni =  Uni = e. -1 up(e); Nem; id; e. up(e) Uni = 0   The definition of El is essentially "just" cumulativity:

El(-1 A; ; ;  ) =  El(A); ; ; 

Here we have used both the isomorphism realigning Uni and the isomorphism realigning Tym. When restricting with z : syn, El restricts to A  El(A).
It remains to show that the universe is closed under the various codes for depen-

dent sums, products, etc. For the sake of space, we show only two of these cases:

dependent products and modal types.

Let us fix t0 : (µ | Tmn(Uni)) and t1 : (µ | Tmn(El(t0)))  Tmm(Uni). First

we realign Tmm(Prod(El(A), El  B)) along over Tmm(z, Prod(z, El(z, t0), El(z)  t1)).

decProd

to

obtain



which

lies

strictly

We

also

get

an

isomorphism

dec
Prod

:



=

Tmm(Prod(El(A), El

 B))

lying

over dec. Note that by the uniqueness of inverses, (dec)-1 lies over dec-1.


We use this now to define Prod (t0, t1):

AProd(t0,t1) = (µ | At0 )  x. At1(t0 (x))

Prod(t0,t1) = 

Prod (t0 ,t1 )

=

e.

(dec
Prod

)-1

(Prod

(El

(t0

),El

t1

)

dec

(e))

Prod(t0,t1) = f. dec

(Prod

(El

(t0

),El

t1

)

dec
Prod

(f

))

The procedure for modal types is similar. Let us fix t : (µ | Tmn(Uni)). Again,

we realign Tmm(Mod[µ](El(t))) along the isomorphism decMod

decMod[µ].

The

actual

construction

of


Mod

is

almost

identical

to

to obtain

Prod :



and

AMod(t) = µ | At

Mod(t) = 

Mod (t)

=

e.

(dec
Mod

)-1

(Mod

[µ](El

(t))

dec

(e))

Mod(t) = m. dec (Prod(El(t))decMod(m))

The checks that all constructions lie over their syntactic counterparts follow immediately from the conclusions of realignment.

NORMALIZATION FOR MULTIMODAL TYPE THEORY

25

Theorem 7.9. There exists an MTT cosmos built around Tym and Tmm which lies strictly over the syntactic MTT cosmos. Externally, there is an MTT cosmos G - : M Gl(i[-]) together with a morphism of cosmoi  : G - S - .
Proof. This is combination of Definitions 7.1 and 7.2 and Lemmas 7.3 to 7.8. That  is 2-natural is immediate from Theorem 4.1 and that it commutes with transposition is precisely Theorem 4.2.

8. The normalization function
8.1. Initiality, revisited. As formulated, the cosmos based around the generalized algebraic syntax of MTT S - is not initial. By Corollary 3.9, there is an initial cosmos I - but it is a distinct object and I m is not even cocomplete, let alone a presheaf topos.
Despite this, S - enjoys a certain distinguished place among MTT cosmoi owing to Theorem 3.7. In particular, we have the following
(1) For every context  cx @ m, there exists an object G  : G m , together with a canonical isomorphism  : (G  ) = y().
(2) For every type  A @ m, there is a morphism G A : G  Tym such that (G A )   = A .
(3) For every term  M : A @ m, there is a morphism G M : G M Tmm lying over G A such that (G M )   = M .

8.2. The proof of the normalization theorem. Prior to the proof of the normalization theorem (Theorem 8.5), we require several preliminary results.
Recall that there is a closed immersion of topoi i : PSh(Renm) G m . In fact, this closed immersion is essential because the morphism PSh(Renm) PSh(Cxm) is essential. Accordingly, for each X : PSh(Renm) there is an object i!(X) : G m . This functor has a familiar result when applied to a representable in PSh(Renm). Consider a telescope  tele @ m , we then have the following:
(||) i!(y()) = y() i[m](y())
Lemma 8.1. For an arbitrary X : G m , we have [(||), X] = i(X)().
By the previous discussion, for a telescope  tele @ m , there is also the object G  , which lies over  in G m . While this object is different than (||), there is a canonical natural transformation between them.

Lemma 8.2. Given  tele @ m , there is a morphism atoms : (||) G  . Moreover, up to the canonical isomorphism jG  = y(), jatoms = idy().
Proof. By applying Lemma 8.1, this proof is equivalent to constructing an element of g  iG  () such that the image of g under the canonical map to i[m](y())() is the identity. This morphism is constructed by induction on .
Case:

1 tele @ m 1

In this case these two are isomorphic.

Case:

µ : n m  tele @ m 

.{µ} tele @ n .{µ}

26

DANIEL GRATZER

In this case we choose atoms.{µ} = G µ !(atoms0 ) and correcting by the canonical isomorphisms (|0.{µ}|) = G µ !((||)) which exists by Theorem 4.2 and G .{µ} = G µ !(G  ) which exists by construction. Case:
 tele @ m  .{µ} A @ n
.(µ | A) tele @ m .(µ | A)
We construct this morphism using the characterization from Lemma 8.1.
Our induction hypothesis gives us an element g  G  0() lying over -1(id), whence g  G .(µ | A) (.(µ | A)) lying over  using reindexing.
Moreover, we have an element of Nem(S A )(.(µ | A).{µ}) lying over v0, whence an element of Tmm(G A )(.(µ | A).{µ}) lying over v0. This gives us an element of G .(µ | A) 0(.(µ | A)) which lies over id = .v0 by the universal property of the pullback.

Lemma 8.3. Given  M, N : A @ m, if there exists a normal form u such that  nf u : A @ m M and  nf u : A @ m N , then  M = N : A @ m.
Lemma 8.4. If  nf u @ m A and  nf u @ m B, then  A = B @ m.
We are now in a position to prove normalization. We note that one of the conditions of the normalization algorithm (respect for definitional equivalence) is automatic: we have defined the algorithm to operate only on equivalence classes of terms, so it must always respect definitional equivalence.

Theorem 8.5. There exists a pair of functions nf (M, A) and nfty(A) such that (1) If  A @ m and  tele @ m  then  nf nfty(A) @ m A. (2) If  M : A @ m and  tele @ m  then  nf nf (M, A) : A @ m M .
Proof. We may package this in the language of PSh(Renm). From this viewpoint, nfty(A) is an element of (NfTym)0 fitting into the following triangle:
(NfTym)0

NfTym

i[m](y())

i[m](y())

A

Similarly, nf (M, A) is a section to the inclusion Nfm i[m](Tm) over M .
Observe from the initiality of syntax that for any  A @ m, there exists G A : G  Tym, and bi-universality ensures that G A = A, up to an isomorphism of contexts. In particular, there exists Anf : G  (NfTym)0 such that Anf = A. Unfolding to PSh(Renm), we have the following commuting square:

Anf

G0

(NfTym)0

G i[m](y())

i[m]( A )

NfTym i[m](Tm)

By Lemma 8.2, atoms  G  1() lies over id. We then define nfty(A) = Anf (atoms), which satisfies the required properties.

NORMALIZATION FOR MULTIMODAL TYPE THEORY

27

The procedure is identical for nf (M, A). Given  M : A @ m, we use initiality to obtain the following square:

G0

M nf

(Nf m )0

G

Nf m

i[m](y()) i[m]( M ) i[m](Tm)

We set nf (M, A) = M nf (atoms).

Theorem 8.6. Given a telescope  tele @ m  then the following two facts hold:
(1) If  nf u : A @ m M , then nf (M, A) = u. (2) If  nf  @ m A, then nfty(A) =  .

Proof. In order to prove these results, we show three related facts. Recall that G -
is the function sending a piece of syntax to its interpretation in the normalization
model. Furthermore, recall that by Lemma 8.2 (||) element atoms : G  .
(1) If  ne e : A @ m M , then G M (atoms) = G A (atoms)e (2) If  nf u : A @ m M , then G A (atoms)G M (atoms) = u. (3) If  nf  @ m A, then AG A (atoms) =  .
Here we have identified a code u (resp. e) as an (||) element of NfA (resp. NeA), an abuse justified by unfolding the definition of NfA into PSh(Renm).
Assuming these facts hold, the result immediately follows by unfolding the defi-
nition of nf (M, A) and nfty(A). We prove these facts by mutual induction. All cases follow from induction except the case of variables, so we show this here.

Case:

 tele @ m   = 0.(µ | A)

 ne v0idµ : A[{}  .{µ}] @ m v0[{}]
(Note that the case for a general vk follows by straightforward induction on k, but is notationally heavy.)

First, we recall that G v0 defined by projection from the context. There-

fore, G v0 (atoms) = G A (atoms)v0idµ by unfolding the construction of atoms in Lemma 8.2.

Case:

.{µ} nf  @ n A

 nf µ |  @ m µ | A

In this case, by unfolding the definitions we have

AG µ|A (atoms.{µ}) = Modµ(AA(atoms))
By induction hypothesis, we have AA(atoms) =  , so the conclusion follows. Case:
.{µ} nf u : A @ n M  nf modµ(u) : µ | A @ m modµ(M ) In this case, by unfolding the definitions we have

G µ|A G (atoms.{µ}) modµ(M ) (atomsT heta.{µ}) = modµG A (atoms)G M (atoms)

28

DANIEL GRATZER

= modµ(u)
The last step follows from the induction hypothesis.
Corollary 8.7. Each term and type in MTT has a unique normal form.
Corollary 8.8. The conversion problem in MTT is equivalent the conversion problem of normal forms.
Proof. Theorem 8.5 and Lemma 8.3 imply that  M = N : A @ m is equivalent to nf (M, A) = nf (N, A). Similarly, Theorem 8.5 and Lemma 8.4 reduce  A = B @ m to nfty(A) = nfty(B). As the proof given is constructively valid, these reductions are effective.
Corollary 8.9. If  (µ | A0)  B0 = (µ | A1)  B1 @ m, then .{µ} A0 = A1 @ m and .(µ | A0) B0 = B1 @ m.
Proof. By inspection on the definition of nfty((µ | Ai)  Bi), we observe that both are interpreted using Lemma 7.5. Accordingly, we have the following:
nfty((µ | A0)  B0) = u = (µ | nfty.{µ}(A0))  nfty.(µ|A0)(B0) nfty((µ | A1)  B1) = v = (µ | nfty.{µ}(A1))  nfty.(µ|A1)(B1) From  (µ | A0)  B0 = (µ | A1)  B1 @ m and Corollary 8.8, we obtain u = v. From this, we use inversion to conclude that nfty.{µ}(A0) = nfty.{µ}(A1) and nfty.(µ|A0)(B0) = nfty.(µ|A1)(B1). The result now follows from Corollary 8.8.
Corollary 8.10. If modalities and 2-cells enjoy decidable equality, typechecking MTT is decidable.

Acknowledgments
I am thankful for discussions with Carlo Angiuli, Martin Bidlingmaier, Lars Birkedal, Thierry Coquand, Alex Kavvos, Christian Sattler, and Jonathan Sterling. I would like to express particular gratitude to Jonathan Sterling conversations about Synthetic Tait Computability and to Lars Birkedal and Alex Kavvos for feedback on this proof.

Appendix A. Neutral and normal forms  tele @ m 

1 tele @ m 1

 tele @ m  .{µ} A @ n .(µ | A) tele @ m .(µ | A)

 tele @ m  .{µ} tele @ m .{n}

  : @m 

 ! : 1@m !

 tele @ n  .{µ} A @ n .(µ | A)  :  @ m 

 tele @ m   id :  @ m id

, ,  tele @ m , ,   r :  @ m   sr : @m 

 s : @m 

NORMALIZATION FOR MULTIMODAL TYPE THEORY

29

,  tele @ m ,   r :  @ m  .{µ} r.{µ} : .{µ} @ n .{µ}

 tele @ m  µ,  : n m  :  µ .{µ} {} : .{} @ n {}

,  tele @ m ,   r :  @ m  .{µ} A @ n .{µ} ne vk : A[.{µ}] @ n M
 r.vk : .(µ | A) @ m .M

 nf  @ m A

 nf bool @ m bool  nf U @ m U

.{µ} nf  @ n A .(µ | A) nf  @ m B  nf (µ |  )   @ m (µ | A)  B

 nf  @ n A .(idm | A) nf  @ m B  nf  ×  @ m A × B

.{µ} nf  @ n A  nf µ |  @ m µ | A

 tele @ m   nf u : U @ m A  nf El(u) @ m A

 ne e : A @ m M  nf u : A @ m M

 tele @ m  (k) = (µ | A) mods(, k) =   : µ   ne vk : A[{}  (.{k-1}) · · ·  (.{0})] @ m v0[{}  (.{k-1}) · · ·  (.{0})]

 nf tt : bool @ m tt  nf ff : bool @ m ff

 ne e : bool @ m M  nf up(e) : bool @ m M

 tele @ m  .(idm | bool) nf  @ m A  ne u : bool @ m M  nf v1 : A[id.tt] @ m N1  nf v2 : A[id.ff] @ m N2
 ne if( ; u; v1; v2) : A[id.M ] @ m if(A; M ; N1; N2)

 tele @ m  .{µ} A @ n .(µ | A) .(µ | A) nf u : B @ m M
 nf (u) : (µ | A)  B @ m (M )

B@m

 tele @ m  .{µ} A @ n .(µ | A) B @ m  ne e : (µ | A)  B @ m M  nf u : A @ m N
 ne e(u) : B[id.N ] @ m M (N )

30

DANIEL GRATZER

 tele @ m  .{µ} A @ n .(µ | A) B @ m  nf u : A @ m M  nf v : B[id.M ] @ m N
 nf (u, v) : A × B @ m (M, N )

 tele @ m  ne pr1(u) : A @ m

 .{µ} A @ n .(µ | A) B @ m  ne u : A × B @ m M
pr1(M )  ne pr2(u) : B[id.pr1(M )] @ m pr2(M )

 tele @ m  .{µ} A @ n .{µ} nf u : A @ n M  nf modµ(u) : µ | A @ m modµ(M )

 tele @ m  .{µ} A @ n  ne e : µ | A @ m M  nf up(e) : µ | A @ m M

:o n µ:n m  tele @ m  .{µ}.{} A @ o .{µ} ne u :  | A @ n M .(µ |  | A ) nf  @ m B .(µ   | A) nf u : B[.mod (v0)] @ m
 ne letmod(µ; ;  ; e; u) : B[id.M ] @ m let modµ( )  M in N
 tele @ m   ne e : U @ m A  nf up(e) : U @ m A

 tele @ m  .{µ} nf u : U @ n A .(µ | El(A)) nf v : U @ m B  nf (µ | u)  v : U @ m (µ | A)  B

 tele @ m 

 nf u : U @ m A .(idm | El(A)) nf v : U @ m B  nf u × v : U @ m (µ | A)  B

 tele @ m  .{µ} nf u : U @ m A  nf µ | u : U @ m µ | A

 tele @ m   nf bool : U @ m bool

 tele @ m   ne e : El(bool) @ m M  ne dec (e) : bool @ m dec (M )

 tele @ m   nf u : bool @ m M  nf dec (u) : El(bool) @ m dec (M )

 tele @ m 

 ne e : U @ m A  ne f : El(e) @ m M  nf up(f ) : El(e) @ m M

 tele @ m   nf u : U @ m A .(idm | El(A)) nf v : U @ m B  ne e : El(A × B)) @ m M
 ne dec (e) : El(A) × El(B) @ m dec (M )

NORMALIZATION FOR MULTIMODAL TYPE THEORY

31

 tele @ m   nf u : U @ m A .(idm | El(A)) nf v : U @ m B  nf w : El(A) × El(B) @ m M
 nf dec (w) : El(A × B) @ m dec (M )

 tele @ m  .(µ | El(A)) nf v : U @ m B

 nf u : U @ n A  ne e : El((µ | A)  B)) @ m M

 ne dec (e) : (µ | El(A))  El(B) @ m dec (M )

 tele @ m   nf u : U @ n A .(µ | El(A)) nf v : U @ m B  nf w : (µ | El(A))  El(B) @ m M
 nf dec (w) : El((µ | A)  B) @ m dec (M )

 tele @ m  .{µ} A : U @ n  ne e : El( µ | A ) @ m M  ne dec (e) : µ | El(A) @ m dec (M )
 tele @ m  .{µ} A : U @ n  nf u : µ | El(A) @ m M  nf dec (u) : El( µ | A ) @ m dec (M )

Appendix B. A full definition of an internal MTT cosmos
We present the full definition of an internal MTT cosmos. The fact that these constants correspond to the exist in e.g. the syntactic MTT cosmos follows from unfolding the internal language this signature is presented in and observing that it is identical to Definition 3.4 in cosmoi rich enough to use MTT as an internal language.

B.1. Term and type sorts.
Tym : U Tmm : Tym  U

B.2. Dependent sums.

Sig : A:Tym Tmm(A)  Tym  Tym Sig : (A : Tym)(B : Tmm(A)  Tym)  Tmm(Sig(A, B)) =

a:Tmm(A) Tmm(B(a))

B.3. Dependent products.
Prod : A: µ|Tyn let modµ(A)  A in [ µ | Tmn(A)  Tym]  Tym Prod : (µ | A : Tyn)  (B : µ | Tmn(A)  Tym) 
Tmm(Prod(modµ(A), B)) = a: µ|Tmn(A) Tmm(B(a))

32

DANIEL GRATZER

B.4. Booleans.
Bool : Tym true, false : Tmm(Bool)
if : (A : Tmm(Bool)  Tym)  Tmm(A(true))  Tmm(A(false))  (b : Tmm(Bool))  Tmm(A(b))
: (A : Tmm(Bool)  Tym)(t : Tmm(A(true)))(f : Tmm(A(false)))  (if(A, t, f, true) = t) × (if(A, t, f, false) = f )
B.5. Modal types.
Mod[µ] : (µ | A : Tyn)  Tym m[µ] : (µ | A : Tyn)(µ | a : Tmn(A))  Tmm(Mod[µ](A))
letmod[µ; ] : (  µ | A : Tyn) B : µ | Tmn(Mod[µ](A))  Tyo  (  µ | x : Tmn(A))  Tmo(B(m[µ](A, x)))  ( | a : Tmm(Mod[µ](A)))  Tmo(B(a))
: (  µ | A : Tyn) B : µ | Tmn(Mod[µ](A))  Tyo  b : (  µ | x : Tmn(A))  B(m[µ](A, x))  (  µ | a : Tmn(A))  letmod[µ; ](A, B, b, m[µ](A, a)) = b(a)
B.6. Universe ´a la Tarski.
Uni : Tym El : Tmm(Uni)  Tym
Sig : A:Tmm(Uni) Tmm(El(A))  Tmm(Uni)  Tmm(Uni)
Prod : A: µ|Tmn(Uni) let modµ(A)  A in [ µ | Tmn(El(A))  Tym]  Tmm(Uni)
Bool : Tmm(Uni)
Mod : µ | Tmn(Uni)  Tmm(Uni) decSig : (A : Tmm(Uni))(B : Tmm(El(A))  Tmm(Uni)) 
Tmm(El(Sig(A, B, ))) = Tmm(Sig(El(A), El  B)) decProd : (µ | A : Tmm(Uni))(B : (µ | Tmn(El(A)))  Tmm(Uni)) 
Tmm(El(Prod(A, B))) = Tmm(Prod(El(A), El  B)) decBool : Tmm(El(Bool)) = Tmm(Bool) decMod : (µ | A : Tmm(Uni))  Tmm(El(Mod(A))) = Tmm(Mod[µ](El(A)))
B.7. Internal and external MTT cosmoi coincide. Let us fix a cosmos F : V (see Definition 3.3) such that F supports a model of MTT where types are interpreted (up to equivalence) by families of objects and a µ | - is interpreted by F (µ). For instance, the syntactic MTT cosmos defined by F (m) = PSh(Cxm).

NORMALIZATION FOR MULTIMODAL TYPE THEORY

33

Theorem B.1. The cosmos F is an MTT cosmos (see Definition 3.4) precisely when the internal language of F supports the constants of an internal MTT cosmos.
Proof. First, observe that unfolding the constants Tym and Tmm into the model in F gives an object Tm = Tym and a family over Tm given by m = Tmm . We call write Tm for the domain of m. Moreover, this transformation is a bijection: every family m gives rise to a pair of Tym and Tmm.
Showing that the remain constants induce the structure of an MTT cosmos is a standard exercise in unfolding the interpretation of MTT into a presheaf topos. We show only the representative case of modalities.
First, observe that the constant Mod[µ] : (µ | A : Tyn)  Tym is precisely determined by a morphism M : F (µ)(Tn) Tm, using the fact that modalities in the model of MTT are interpreted by F (µ). Similarly, m[µ] : (µ | A : Tyn)(µ | a : Tmn(A))  Tmm(Mod[µ](A)) is precisely equivalent to a map m : F (µ)(Tn) Tm such that m  m = M  F (µ)(n).
The final equivalence between the elimination constant letmod[µ; ] and the lifting structure from Definition 3.4 is identical similar: unfolding letmod[µ; ] and its equation amounts to an internal lifting structure.

Appendix C. Neutral and normal forms, internally
We require that all normal and neutral forms become equal to their counterparts in the syntactic internal MTT cosmos (Appendix B and Section 6) under the assumption z : syn. We avoid repeatedly stating this in the specifications of normals and neutrals that follows.

C.1. Normal types.

Prod : (µ | A : NfTyn)(B : (µ | Vn(A))  NfTym)  NfTym Sum : (A : NfTym)(B : Vm(A)  NfTym)  NfTym Bool : NfTym Modµ : µ | NfTyn  NfTym

C.2. Dependent products.

lam : (µ | A : zTyn(z))(B : (µ | zTmn(z, A(z)))   ((µ | a : Vn(A))  Nfm(B(a)))  Nfm(Prod(A, B))
app : (µ | A : zTyn(z))(B : (µ | zTmn(z, A(z)))   Nem(Prod(A, B))  (a : Nfm(A))  Nem(B((a)))

z Tym z ) Tym)

C.3. Dependent sums.

pair : (A : zTym(z))(B : zTmm(z, A(z))   (a : Nfm(A))  Nfm(B((a)))  Nfm(Sig(A, B))
proj0 : (A : zTym(z))(B : zTmm(z, A(z)) 

z Tym (z )) z Tym (z ))

34

DANIEL GRATZER

 Nem(Sig(A, B))  Nem(A) proj1 : (A : zTym(z))(B : zTmm(z, A(z))   (p : Nem(Sig(A, B)))  Nem(B((proj0(p))))

z Tym (z ))

C.4. Booleans.

up : Nem(Bool)  Nfm(Bool) tt, ff : Nfm(Bool)
if : (A : zTmm(z, Bool(z))  zTym(z))  Nfm(A(true))  Nfm(A(false))  (b : Nem(Bool))  Nem(A((b)))

C.5. Modal types.

up : (µ | A : zTyn(z))  Nem(Mod[µ]A)  Nfm(Mod[µ]A) modµ : (µ | A : zTyn(z))  µ | Nfn(A)  NfMod[µ]A letmodµ; : (  µ | A : zTyn(z))(B : ( | a : zTmm(z, Mod[µ](z, A(z)))) 
 ((µ   | a : Vn(A))  Nfo(B(m[µ](A, (a)))))  ( | a : Nem(Mod[µ](A)))  Neo(B((a)))

z Tyo (z ))

C.6. Universe ´a la Tarski.

Uni : NfTym El : Nfm(Uni)  NfTym up : Nem(Uni)  Nfm(Uni)

Prod : (µ | A : Nfn(Uni))(B : (µ | Vn(El(A)))  Nfm(Uni))  Nfm(Uni)

Sum : (A : Nfm(Uni))(B : Vm(El(A))  Nfm(Uni))  Nfm(Uni)

Bool : Nfm(Uni)

Modµ : µ | Nfn(Uni)  Nfm(Uni)

dec
Prod

:

(µ

|

A

:

Nf n (Uni))(B

:

(µ

|

Vn(El(A)))



Nf m (Uni))

 Nfm(Prod(El(A), El(B)))  Nfm(El(Prod(A, B)))

dec
Sum

:

(A

:

Nf m (Uni))(B

:

Vm(El(A))



Nf m (Uni))

 Nfm(Sum(El(A), El(B)))  Nfm(El(Sum(A, B)))

dec
Prod

:

(µ

|

A

:

Nf n (Uni))(B

:

(µ

|

Vn(El(A)))



Nf m (Uni))

 Nem(El(Prod(A, B)))  Nem(Prod(El(A), El(B)))

dec
Sum

:

(A

:

Nf m (Uni))(B

:

Vm(El(A))



Nf m (Uni))

 Nem(El(Sum(A, B)))  Nem(Sum(El(A), El(B)))

dec
Bool

:

Nf m (Bool)



Nf m (El(Bool))

dec
Modµ

:

(µ

|

A

:

Nf n (Uni))



Nf m (Mod[µ](A))



Nf m (El(Mod(A)))

dec
Bool

:

Nem(El(Bool))



Nem(Bool)

NORMALIZATION FOR MULTIMODAL TYPE THEORY

35

dec
Modµ

:

(µ

|

A

:

Nf n (Uni))



Nem(El(Mod(A)))



Nem(Mod[µ](A))

C.7. Interpreting neutral and normal forms in the glued model. Substantiating these constants in the glued model (see Theorem 6.1) relies on unfolding the constants described above into this model and showing that the expected normal or neutral form from Section 5 can be used. These proofs follow Hofmann [Hof99], and again the main subtlety is showing that binders in constants such as Prod are correctly interpreted.
For each normal and neutral form, the requirement that constant lie over the appropriate constant from the syntactic cosmos forces the "syntactic portion" of each constant. More precisely, consider again Prod and set I = (µ | A : NfTyn) × Vn(A) and I = (µ | A : Tyn) × Tmn(A). The definition of Prod is a commuting square of the following shape in PSh(Renm):

Prod 1

I1

NfTym 1

I

NfTym

i[m]( I )

Prod 0

i[m]( Tym )

The bottom map of this square Prod 0, moreover, must be i[m](Prod) in order to ensure that Prod = Prod(z) with z : U . It remains to define the top arrow of
this diagram. This is complicated by the difference between the interpretation of dependent products in G m and PSh(Renm). In particular, while the "downstairs" portion of a dependent product in G m is a dependent product in PSh(Cxm), the upstairs portion is not a dependent product in PSh(Renm).
In order to define Prod 1, it suffices to fix a morphism x : y() NfTym 1 and define the action of Prod 1 on it. First, observe that we can extend x to the
following commuting square:

x y()

I0

I

i[m](y(i[m]()))

i[m](x~)

i[m]( I )

By universal property, therefore, we can decompose x into a pair:

y(.{µ})

x0

NfTyn 1

NfTyn

i[n](y((i[m]()).{µ})) i[n](x~0) i[n]( Tyn )

36

DANIEL GRATZER

y(.x0)

x1

NfTym 1

NfTyn

i[m](y(i[m](.(µ | x~0)))) i[m](x~1) i[m]( Tym )
We may now define Prod(x) = (µ | x0)  x1. The naturality of this assignment, as well as the fact that it commutes appropriately, are direct computations.

[Abe13] [Alt+01] [AHS95] [AK16]
[AGV72] [Awo18]

References
Andreas Abel. "Normalization by Evaluation: Dependent Types and Impredicativity". Habilitation. Ludwig-Maximilians-Universit¨at Mu¨nchen, 2013 (cit. on p. 6). T. Altenkirch, P. Dybjer, M. Hofmann, and P. Scott. "Normalization by Evaluation for Typed Lambda Calculus with Coproducts". In: Proceedings of the 16th Annual IEEE Symposium on Logic in Computer Science. LICS '01. Washington, DC, USA: IEEE Computer Society, 2001, pp. 303­. url: http://dl.acm.org/citation.cfm?id=871816. 871869 (cit. on p. 6). Thorsten Altenkirch, Martin Hofmann, and Thomas Streicher. "Categorical reconstruction of a reduction free normalization proof". In: Category Theory and Computer Science. Ed. by David Pitt, David E. Rydeheard, and Peter Johnstone. Berlin, Heidelberg: Springer Berlin Heidelberg, 1995, pp. 182­199. isbn: 978-3-540-44661-3 (cit. on pp. 3, 6, 7). Thorsten Altenkirch and Ambrus Kaposi. "Normalisation by Evaluation for Dependent Types". In: 1st International Conference on Formal Structures for Computation and Deduction (FSCD 2016). Ed. by Delia Kesner and Brigitte Pientka. Vol. 52. Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl­LeibnizZentrum fuer Informatik, 2016, 6:1­6:16. isbn: 978-3-95977-010-1. doi: 10.4230/LIPIcs.FSCD.2016.6. url: http://drops.dagstuhl.de/ opus/volltexte/2016/5972 (cit. on p. 3). Michael Artin, Alexander Grothendieck, and Jean-Louis Verdier. Th´eorie des topos et cohomologie ´etale des sch´emas. S´eminaire de G´eom´etrie Alg´ebrique du Bois-Marie 1963­1964 (SGA 4), Dirig´e par M. Artin, A. Grothendieck, et J.-L. Verdier. Avec la collaboration de N. Bourbaki, P. Deligne et B. Saint-Donat, Lecture Notes in Mathematics, Vol. 269, 270, 305. Berlin: Springer-Verlag, 1972 (cit. on pp. 7, 14, 18). Steve Awodey. "Natural models of homotopy type theory". In: Mathematical Structures in Computer Science 28.2 (2018), pp. 241­286. issn: 09601295. doi: 10.1017/S0960129516000268. eprint: 1406.3219 (cit. on pp. 7, 19).

REFERENCES

37

[Bir+20]
[CJ95] [Coq19] [Fio02]
[Gra+20a] [Gra+20b] [GS20] [GSB19a] [GSB19b]
[Hof99]
[HS97] [KHS19]

Lars Birkedal, Ranald Clouston, Bassel Mannaa, Rasmus Ejlers Møgelberg, Andrew M. Pitts, and Bas Spitters. "Modal dependent type theory and dependent right adjoints". In: Mathematical Structures in Computer Science 30.2 (2020), pp. 118­138. doi: 10.1017/S0960129519000197. eprint: 1804.05236 (cit. on pp. 2, 13). Aurelio Carboni and Peter Johnstone. "Connected limits, familial representability and Artin glueing". In: Mathematical Structures in Computer Science 5.4 (1995), pp. 441­459. doi: 10.1017/S0960129500001183 (cit. on pp. 7, 14, 18). Thierry Coquand. "Canonicity and normalization for dependent type theory". In: Theoretical Computer Science 777 (2019), pp. 184­191. doi: 10.1016/j.tcs.2019.01.015 (cit. on pp. 3, 7). Marcelo Fiore. "Semantic Analysis of Normalisation by Evaluation for Typed Lambda Calculus". In: Proceedings of the 4th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming. PPDP '02. Pittsburgh, PA, USA: ACM, 2002, pp. 26­ 37. isbn: 1-58113-528-9. doi: 10.1145/571157.571161 (cit. on pp. 3, 6, 7). Daniel Gratzer, G.A. Kavvos, Andreas Nuyts, and Lars Birkedal. Multimodal Dependent Type Theory. Extended version of the LICS paper by the same name. 2020 (cit. on pp. 1­3, 7, 8, 17, 19). Daniel Gratzer, G.A. Kavvos, Andreas Nuyts, and Lars Birkedal. "Multimodal Dependent Type Theory". In: Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science. LICS '20. ACM, 2020. doi: 10.1145/3373718.3394736 (cit. on p. 2). Daniel Gratzer and Jonathan Sterling. Syntactic categories for dependent type theory: sketching and adequacy. 2020. arXiv: 2012 . 10783 [cs.LO] (cit. on pp. 4, 7). Daniel Gratzer, Jonathan Sterling, and Lars Birkedal. "Implementing a Modal Dependent Type Theory". In: Proc. ACM Program. Lang. 3 (ICFP 2019). doi: 10.1145/3341711 (cit. on p. 3). Daniel Gratzer, Jonathan Sterling, and Lars Birkedal. Normalizationby-Evaluation for Modal Dependent Type Theory. Technical Report for the ICFP paper by the same name. 2019. url: https://jozefg. github.io/papers/2019- implementing- modal- dependent- typetheory-tech-report.pdf (cit. on p. 3). Martin Hofmann. "Semantical Analysis of Higher-Order Abstract Syntax". In: Proceedings of the 14th Annual IEEE Symposium on Logic in Computer Science. LICS '99. Washington, DC, USA: IEEE Computer Society, 1999, pp. 204­. isbn: 0-7695-0158-3. url: http://dl.acm. org/citation.cfm?id=788021.788940 (cit. on pp. 19, 35). Martin Hofmann and Thomas Streicher. "Lifting Grothendieck Universes". Unpublished note. 1997. url: https://www2.mathematik. tu-darmstadt.de/~streicher/NOTES/lift.pdf (cit. on p. 13). Ambrus Kaposi, Simon Huber, and Christian Sattler. "Gluing for type theory". In: Proceedings of the 4th International Conference on Formal Structures for Computation and Deduction (FSCD 2019). Ed. by Herman Geuvers. Vol. 131. 2019 (cit. on p. 7).

38

REFERENCES

[KKA19]
[KPT99] [Lac09] [LS16]
[MS93]
[OP18]
[Red20] [RSS20] [Shu15]
[Ste21] [SA21] [SG20] [SH20]
[Str98]

Ambrus Kaposi, Andr´as Kov´acs, and Thorsten Altenkirch. "Constructing Quotient Inductive-inductive Types". In: Proc. ACM Program. Lang. 3.POPL (Jan. 2019), 2:1­2:24. issn: 2475-1421. doi: 10.1145/ 3290315 (cit. on p. 9). Yoshiki Kinoshita, John Power, and Makoto Takeyama. "Sketches". In: Journal of Pure and Applied Algebra 143.1 (1999), pp. 275­291. issn: 0022-4049. doi: 10.1016/S0022-4049(98)00114-5 (cit. on p. 10). Stephen Lack. "A 2-Categories Companion". In: The IMA Volumes in Mathematics and its Applications (Sept. 2009), pp. 105­191. issn: 0940-6573. doi: 10.1007/978-1-4419-1524-5_4 (cit. on p. 10). Daniel R. Licata and Michael Shulman. "Adjoint Logic with a 2Category of Modes". In: Logical Foundations of Computer Science. Ed. by Sergei Artemov and Anil Nerode. Springer International Publishing, 2016, pp. 219­235. doi: 10.1007/978- 3- 319- 27683- 0_16 (cit. on p. 2). John C. Mitchell and Andre Scedrov. "Notes on sconing and relators". In: Computer Science Logic. Ed. by E. B¨orger, G. J¨ager, H. Kleine Bu¨ning, S. Martini, and M. M. Richter. Springer Berlin Heidelberg, 1993, pp. 352­378. doi: 10.1007/3-540-56992-8_21 (cit. on p. 5). Ian Orton and Andrew M. Pitts. "Axioms for Modelling Cubical Type Theory in a Topos". In: Logical Methods in Computer Science 14.4 (2018). doi: 10.23638/LMCS-14(4:23)2018. arXiv: 1712.04864 (cit. on p. 18). The RedPRL Development Team. cooltt. 2020. url: http://www. github.com/RedPRL/cooltt (cit. on p. 8). Egbert Rijke, Michael Shulman, and Bas Spitters. "Modalities in homotopy type theory". In: Logical Methods in Computer Science 16.1 (2020). eprint: 1706.07526 (cit. on p. 13). Michael Shulman. "Univalence for inverse diagrams and homotopy canonicity". In: Mathematical Structures in Computer Science 25.5 (2015), pp. 1203­1277. doi: 10 . 1017 / S0960129514000565. eprint: 1203.3253 (cit. on p. 7). Jonathan Sterling. "First Steps in Synthetic Tait Computability". Thesis draft. 2021 (cit. on pp. 1, 3, 5, 7, 8). Jonathan Sterling and Carlo Angiuli. Normalization for Cubical Type Theory. 2021. arXiv: 2101.11479 [cs.LO] (cit. on p. 5). Jonathan Sterling and Daniel Gratzer. Lecture Notes on Synthetic Tait Computability. Subsumed by Sterling's forthcoming thesis. 2020 (cit. on p. 5). Jonathan Sterling and Robert Harper. "Logical Relations As Types: Proof-Relevant Parametricity for Program Modules". Draft paper. 2020. arXiv: 2010.08599. url: https://arxiv.org/abs/2010.08599 (cit. on pp. 1, 5, 18). Thomas Streicher. "Categorical intuitions underlying semantic normalisation proofs". In: Preliminary Proceedings of the APPSEM Workshop on Normalisation by Evaluation. Ed. by O. Danvy and P. Dybjer. Department of Computer Science, Aarhus University, 1998 (cit. on p. 6).

[Uem19]

REFERENCES

39

Taichi Uemura. "A General Framework for the Semantics of Type Theory". In: (Apr. 2019). eprint: 1904.04097 (math.CT). url: https: //arxiv.org/abs/1904.04097 (cit. on p. 4).

