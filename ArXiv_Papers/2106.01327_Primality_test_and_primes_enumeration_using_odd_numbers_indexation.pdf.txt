Primality test and primes enumeration using odd numbers indexation
WOLF Marc, https://orcid.org/0000-0002-6518-9882 WOLF François, https://orcid.org/0000-0002-3330-6087
Independent researchers; marc.wolf3@wanadoo.fr ; francois.wolf@dbmail.com
April 5th, 2020
ABSTRACT
Odd numbers can be indexed by the map () = ( - 3)/2 ,   2 + 3. We first propose a basic primality test using this index function that was first introduced in [8]. Input size of operations is reduced which improves computational time by a constant. We then apply similar techniques to Atkin's prime-numbers sieve which uses modulus operations and finally to Pritchard's wheel sieve, in both case yielding similar results.
Keywords: odd number index, primality test, primes enumeration, Atkin sieve, composite odd numbers, wheel sieve.
CONTENTS
1 INTRODUCTION.............................................................................................................................................2 1.1 PRIMALITY TEST AND PRIME ENUMERATION ............................................................................................................ 2 1.2 NOTATION ....................................................................................................................................................... 2
2 BASIC PRIMALITY TEST AND PRIMES ENUMERATION....................................................................................3 2.1 TWO FAMILIES OF INFINITE SEQUENCES WITH ARITHMETIC DIFFERENCE......................................................................... 3 2.2 BASIC PRIMALITY TEST ........................................................................................................................................ 4 2.3 PRIMALITY TEST WITH INDICES.............................................................................................................................. 5 2.4 FIRST ALGORITHMS OF PRIME ENUMERATION .......................................................................................................... 5 2.4.1 Primality test using numbers ................................................................................................................ 5 2.4.2 Primality test using infinite sequences and indices ............................................................................... 8 2.5 PERFOMANCE OF THE ALGORITHMS ..................................................................................................................... 11
3 THE SIEVE OF ATKIN ....................................................................................................................................13 3.1 ATKIN ALGORITHM........................................................................................................................................... 13 3.2 ATKIN ALGORITHM WITH INDICES ........................................................................................................................ 16 3.3 PERFORMANCE OF ALGORITHMS ......................................................................................................................... 19
4 WHEEL SIEVE WITH INDICES........................................................................................................................20 4.1 DESCRIPTION OF PRITCHARD'S WHEEL SIEVE ......................................................................................................... 20 4.2 INDEX WHEEL SIEVE.......................................................................................................................................... 21
1

4.3 WHEEL SIEVE ALGORITHMS................................................................................................................................ 24 4.4 PERFORMANCE OF ALGORITHMS ......................................................................................................................... 25 5 CONCLUSION ..............................................................................................................................................26 6 REFERENCES................................................................................................................................................26 7 APPENDIX: ALGORITHM OF THE INDEX WHEEL SIEVE .................................................................................27 8 APPENDIXES: MAPLE REGRESSIONS ............................................................................................................31
1 Introduction
1.1 Primality test and prime enumeration An odd number  is prime when it is not divisble by any prime  lower than or equal to .
This basic primality test requires too much computational time for large integers. Faster and more efficient deterministic and probabilistic primality tests have been designed for large numbers [1]. A deterministic polynomial primality test was proposed by M. Agrawal, N. Kayal and N. Saxena in 2002 [2].
Enumeration of primes up to a given limit can be done by using a primality test but prime number sieves are preferred from a performance point of view. A sieve is a type of fast algorithm to find all primes up to a given number. There exists many such algorithms, from the simple Erastosthenes' sieve (invented more than 2000 years ago), to the wheel sieves of Paul Pritchard ([3], [4], [5]) and the sieve of Atkin [6]. In [7], Gabriel Paillard, Felipe Franca and Christian Lavault present another version of the wheel sieve and give an overview of all the existing prime-numbers sieves.
In theory, indices are a way to represent odd numbers. By adapting results from [8], we show how odd number indices may be used in applied mathematics. In the last part, we apply [8] to Pritchard's wheel sieve, which leads to a  wheel sieve. Using the linear diophantine equation resolution method first introduced in [9], we introduce an original way of "turning the wheel".
1.2 Notation
We will use the following notations: 1.  designates the set of odd integers greater than 1, i.e.:
 = { = 2 + 3|  }; 2.  the set of prime numbers,  the set of prime numbers not greater than ; 3.  the set of composite odd integers, i.e.:
 = \ = {  |(, )  ,  = } The function :        is bijective. The inverse function is -1:      = 2-3.  = -1() is the index of . The preimage of  is denoted by :
2

 = -1() = {  |   }
4. For  and  two integers, we denote by  mod  the remainder of the Euclidean division of  by , which belongs to 0,  - 1.

5. 1 and 2 are the subsets of  given by: 1 = {  | mod 4 = 1} 2 = {  | mod 4 = 3}
Similarly:
1 = 1   2 = 2   Finally, 1 and 2 designate the set of indices corresponding to elements of 1 and 2 respectively, i.e. 1 = -1(1) and 2 = -1(2).

2 Basic primality test and primes enumeration

2.1 Two families of infinite sequences with arithmetic difference

[8] shows that  is the union of two families of finite sequences with arithmetic difference.
Actually proposition 2-5 says that any composite odd number    can be written as a difference of two squares, and more precisely that there exists    and   0,  such that:

{(())

 

 

1 2

 

 

= =

(2 (2

+ +

3)2 4)2

- -

(2)2, (2 + 1)2

Corollary 2-1: Let () = (2 + 3) + . One has:
 = 1  2
and:
1 = {() = ( + 1) + 2(2 + 3);   ,   } 2 = {() = ( + 2) + 2(2 + 3);   ,   }
Thus  is the union of two families of infinite arithmetic sequences. The indices ( + 1) of first type reference points (or remarkable points, see[8]) are the initial terms of sequences ranging in 1. Similarly, the indices ( + 2) of second type reference points are the initial terms of sequences ranging in 2.
Proof: We substitute  by  +  in relations (1) and (2):
(2 + 3)2 - (2)2 = (2 + 2 + 3)2 - (2)2 = (2 + 3)(2 + 4 + 3) = 2[( + 1) + 2(2 + 3)] + 3
and similarly:

3

(2 + 4)2 - (2 + 1)2 = (2 + 2 + 4)2 - (2 + 1)2 = (2 + 3)(2 + 4 + 5) = 2(2 + 3)( + 2 + 2) + 2 + 3 = 2[( + 2) + 2(2 + 3)] + 3

Proposition 2-1: For any    there exists   ,    and    such that:

  1   = ( + 4)

  2   = ( + 4 + 2)

Thus, writing  = 2 + 3, we get:

 = 1  2

where:

1 = {() = ( + 1) + 2(2 + 3);     ,   } 2 = {() = ( + 2) + 2(2 + 3);     ,   }

Proof:

Take



the

smallest

prime

dividing





.

Thus







and

if



=

 

then







and



-



is even, and we can write it either 4 or 4 + 2. These two cases clearly correspond respectively to

  1 and   2. Thus the index  can be decomposed as in corollary 2-1, but with  the index of a prime number, hence in   .

2.2 Basic primality test In this section, we describe a basic primality test using the previous infinite sequences. Definition 2-2: For any  = 2 + 3   and    we let:
1- (, ) =  - 2 and () = 2.
2- (, ) =  - ( + 2) and () = ( + 2).
Proposition 2-2:   1 is a prime number when: (, )
 = 2 + 3   , 4 mod   0   2 is a prime number when:
(, )  = 2 + 3   , 4 mod   0 Proof: This follows from the fact that (, ) mod  =  mod  and likewise for (, ).

Remark 2-2: In order to reduce computation of (, ) and (, ) for two consecutive prime numbers, we only decrement the value.

More precisely, if  <  are two primes, we let (, ) =  -  and we compute:

{((,,

, ,

) )

= =

(, (,

) )

- -

(, ) (, )

= =

( + (,

2) , )

+

2

4

These two expressions are independent of .

2.3 Primality test with indices We adapt here the results of the previous section with indices. Definition 2-3: For any  index of a prime number    and   , we let:
1- (, ) = ( - 3)/2 - ( + 3), () = ( + 3),  () = ( - 3)/2

2- (, ) = ( - 6)/2 - ( + 4) and () = ( + 4),  () = ( - 6)/2

Proposition 2-3:   1 is a prime number index when:

 = 2 + 3  2+3 , (, ) mod   0

  2 is a prime number index when:

 = 2 + 3  2+3 , (, ) mod   0

Proof: This follows from proposition 2-2 and definition 2-2 because if we let  = 2 + 3 then

(,

)

=

(,) 4

and

(,

)

=

(4,).

Remark 2-3: In order to reduce computation of (, ) and (, ) for two consecutive prime number indices, we only decrement their values. More precisely, if  <  are two prime indices we let (, ) =  -  and we compute:
(, , ) = (, ) - (, ) = ( + 2 + 3) (, , ) = (, ) - (, ) = (, , ) +  These two expressions are independent of .

2.4 First algorithms of prime enumeration
In this section, we present prime enumeration algorithms based on propostion 2-2 and 2-3. The first one manipulates numbers and the second one indices.

2.4.1 Primality test using numbers
This first algorithm named PrimeEnumeration consists in two functions:
 The main function which determines primes in up to  and returns them in a list, along with its size.
 An auxiliary function which returns whether a number  is prime, based on precomputed list of primes and values of  and . It is called LocalTest. It is also in charge of updating the lists  and  if needed.

5

Three zero-based lists are used and built recursively in this algorithm: the list of primes itself , and the lists of values for  and  respective to  (remember it is independent from ). Only numbers which are not multiples of 2 and 3 are tested. Thus we restrict to  = 6 + 1 and  = 6 + 5. The congruence of  modulo 4 depends on the parity of , i.e. when  is even,  mod 4 = 1 and when  is odd,  mod 4 = 3.

Algorithm 2-4-1a Function PrimeEnumeration():  is an odd integer such that   7. This function returns the list of primes up to  and its size.

First step : intialisation of variables   {5}   1
  {16}   {20} 1  0 1  25 2  0 2  35

 List of primes from 5, initialized with one element  Size of the list   About the next two lists, see the remark 2-2  (, 3,5) = 2 × (2 + 6) = 16  (, 3,5) = (, 3,5) + 2 × 2 = 20

Second step : iteration

(, )  (1,7)

  False

  = 1 so (6 + 1) mod 4 = 3

While    Do

 Loop to get odd primes in range 5, 

If LocalTest(, , , , 1, 1, 2, 2, ) Do

()  

   + 1 End If

  6 + 5

If    And LocalTest(, , , , 1, 1, 2, 2, ) Do

()  

   + 1 End If

  +1

6

  6 + 1   !   Switch the boolean value End While Return ({2,3} + ,  + 2)  Return the list of primes and the number of primes.

Algorithm 2-4-1b Function LocalTest (, , , , 1, 1, 2, 2, ):  is an odd integer.  stands for 1 or 2 depending on . This function decides whether for all   [0 ... ], (, )/4 or (, )/4 is not divisible by . It will also potentially update , , 1, 2, 1 and 2 which must be passed by reference.

First step : intialisation of variables

9   15 If  Do

 stands for (3) = 32  stands for (3) = 3 × 5  initiate references that might be updated

  1   1

  

Else

  2   2

 = 

End If

If  =  Do

Return False

 The cap is a composite number

End If

If  >  Do

 update references because we always want   

   + 1

  (() - ( - 1))

If  Do

()  ( + 2( - 1))  

Else

()  () + 2

 , using  which must already be updated

7

End If    + () End If

Second step : iteration

If  Do

  -

Else

  -

End If

0

While    Do    - ()

 Iteration at most up to  = 

If (/4) mod () = 0 Do   is a multiple of 4, division by 4 can be done bitwise

Return False

 Test is negative

End If

 +1

End While

Return True

 Test is positive

2.4.2 Primality test using infinite sequences and indices
This second algorithm IndexPrimeEnumeration also consists in two functions, mirroring the previous algorithm:
 The main function which determines primes up to  and returns them in a list along with its size.
 An auxiliary function which returns whether a number  is prime based on precomputed list of primes and values of  and . It is called LocalTest.
Four zero-based lists are used and built recursively: the list of primes , the corresponding indices  (indices of primes), and the lists  and  respective to .
Only numbers which are not multiple of 2 and 3 are tested, i.e. indices of the form  = 3 - 1 and  = 3 + 1.

8

Remark 2-4-2: To avoid any division in the computation of  and  we will write  = 2 + 1 or 2 + 2.

Algorithm 2-4-2a Function IndexPrimeEnumeration():  is an odd integer such that   7. This function returns the list of primes up to  and its size.

First step : intialisation of variables

  {5}

 List of primes from 5, initialized with one element

  {1}

 List of index of primes

  1

 Size of the two lists  and 

 About the next two lists, see the remark 2-3

  {4}

 (, 0,1) = 1 × (1 + 3) = 4

  {5}

 (, 0,1) = (, 0,1) + 1 = 5

  ( - 3)/2 1  0 1  11

2  0 2  16

Second step : iteration

(, , )  (0, 2, -2)

  starts at 3(2 + 1) - 1,  stands for  () or  ()

While    Do

 Loop to get odd prime indices in range 1, 

If LocalTest(, , , , , , 2, 2,False) Do

()  

()  2 + 3

   + 1 End If

  +2

  = 3(2 + 1) + 1

   + 1

If    And LocalTest(, , , , , , 2, 2,False) Do

()  

()  2 + 3

9

   + 1 End If

  +1

  = 3(2 + 2) - 1

   + 2

If    And LocalTest(, , , , , , 1, 1,True) Do

()  

()  2 + 3

   + 1 End If

  +2

  = 3(2 + 2) + 1

   + 1 If    And LocalTest(, , , , , , 1, 1,True) Do

()   ()  2 + 3

   + 1 End If

  +1

 We do not use  but keep it for the sake of readability

  +1    - 1

  = 3(2 + 1) - 1

End While

Return ({2,3} + ,  + 2)  Return the list of primes and the number of primes.

Algorithm 2-4-2b Function LocalTest(, , , , , , , , ):  stands for  () or  () depending on . This function decides whether for all   [0 ... ], (, ) or (, ) is coprime with .

First step : intialisation of variables If  Do    Else  =  End If

 initiate references that might be updated

10

If  =  Do

Return False

 The cap is the index of a composite number

End If

If  >  Do

 update references because we always want   

   + 1

  (() - ( - 1))

If  Do

()  ( + ( - 1))  

Else

()  () +  End If

 , using  which must already be updated

   + () End If

Second step : iteration    0 While    Do    - () If  mod () = 0 Do
Return False End If  +1 End While Return True

 Iteration at most up to  =   Test is negative  Test is positive

2.5 Perfomance of the algorithms
In this section, we present the performance of the previous two algorithms of prime enumeration. We first give a theoretical complexity, followed by empirical results. Proposition 2-5: Time complexity (in terms of number of arithmetic operations) and space complexity are the same for both PrimeEnumeration and IndexPrimeEnumeration algorithms.
11

Time complexity is:

3
 (l(n()2)).

Space complexity is:

 (ln())

Proof: Any number 's primality is tested with primes in 5, , in (1) operations. There are

()

-

2



 ln()

=



(ln())

such

primes.

We

loop

over

range

7,

 ,

time

complexity

is

thus

3
=7  (ln()) =  (l(n()2)) (actually we skip two thirds of the terms in this sum by not testing

3
multiples of 2 and 3, but complexity remains  (l(n()2)) albeit with smaller constant.

The space complexity is related to the lists we keep in memory, which are at most of size (). This space complexity is  (ln()).

Both algorithms have been implemented in Visual Studio C++ 2012. We measured execution time for various values of  and produced a regression using Maple 2017.3. Details of the Maple options used to get the regression are given in appendix 8.1.
On the graph 2-5 below, we represent the computation time in seconds for both algorithms. Curve 1 corresponds to the algorithm PrimeEnumeration and curve 2 to IndexPrimeEnumeration. The correlation coefficient R of each curve is given on the graph. We observe that computation time of both algorithms is consistent with theoretical complexity, although exponent is a bit smaller than 1.5.

Graph 2-5: computation time  () in seconds for both algorithms (Prime enumeration)

1() 

5.79 × 10-9 × 1.410 ln( )

R =0.9996

2() 

6.11 × 10-9 × 1.406 ln( )

R =0.9996

12

Both algorithms PrimeEnumeration and IndexPrimeEnumeration have the same number of modulo operations. But the computation of the input of modulus operations is done with larger inputs for the former than for the latter, which allows to marginally save time for large values of .

3 The sieve of Atkin

The sieve of Atkin [6] is a modern and efficient algorithm for primes enumeration. We present two

algorithms based on it, one using numbers and the other indices. Both are based on the version which

has

a

complexity

(

)

in

time

and

space.

Modified

versions

achieve

up

to



(
ln

 ln(

))

in

time

and  (12+(1)) in space.

3.1 Atkin algorithm
This algorithm is based on the following three results from [6].
Proposition 3-1 Let  > 3 be a square-free integer. Then  is prime if and only if one of the three following conditions is true:
a.   1 + 4 and there is an odd number of solutions to  = 42 + 2, (, )  2, b.   7 + 12 and there is an odd number of solutions to  = 32 + 2, (, )  2, c.   11 + 12 and there is an odd number of solutions to  = 32 - 2,  > , (, )  2.

We observe that the first congruence condition on  can also be replaced by   1 + 12 or   5 + 12. We also observe the following for an odd integer :
· If  = 42 + 2,  must be odd. · If  = 32 + 2 or  = 32 - 2,  and  must have opposite parity. Furthermore if  is square-free,  and  must be in , with  < /2 and  < .
Remark 3-1 We can compute the remainder modulo 12 of 2 + 2 depending on remainders modulo 12 of  and . This gives us the different cases to check in Atkin sieve. We present them in table 3-1, noting that there is no case for  mod 12 = 0 and  mod 12 = 6.

Table 3-1: Atkin sieve cases depending on remainders modulo  of  and .

\

1

2

3

4

5

7

8

9

10

11

42 + 2
0
32 - 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2 32 - 2

32 + 2

32 + 2

32 + 2

32 + 2

1 42 + 2

42 + 2

42 + 2 42 + 2

42 + 2

42 + 2

32 - 2

32 - 2

32 - 2

32 - 2

42 + 2
2
32 - 2

42 + 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2

42 + 2 32 - 2

32 + 2
3 42 + 2
32 - 2

32 + 2 32 - 2

42 + 2

42 + 2

32 + 2 32 - 2

32 + 2 32 - 2

42 + 2

42 + 2
4
32 - 2

42 + 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2

42 + 2 32 - 2

13

32 + 2

32 + 2

32 + 2

32 + 2

5 42 + 2

42 + 2

42 + 2 42 + 2

42 + 2

42 + 2

32 - 2

32 - 2

32 - 2

32 - 2

42 + 2
6
32 - 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2 32 - 2

32 + 2

32 + 2

32 + 2

32 + 2

7 42 + 2

42 + 2

42 + 2 42 + 2

42 + 2

42 + 2

32 - 2

32 - 2

32 - 2

32 - 2

42 + 2
8
32 - 2

42 + 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2

42 + 2 32 - 2

32 + 2
9 42 + 2
32 - 2

32 + 2 32 - 2

42 + 2

42 + 2

32 + 2 32 - 2

32 + 2 32 - 2

42 + 2

42 + 2
10
32 - 2

42 + 2

42 + 2 32 - 2

42 + 2 32 - 2

42 + 2

42 + 2 32 - 2

32 + 2

32 + 2

32 + 2

32 + 2

11 42 + 2

42 + 2

42 + 2 42 + 2

42 + 2

42 + 2

32 - 2

32 - 2

32 - 2

32 - 2

We could run the sieve looping through 12x12 blocks of (, ) according to this table, but for readability we do not implement this optimization in the algorithms below. We note however that this would save all the modulo operations.

Algorithm 3-1 SieveOfAtkin():  > 3 is an integer. This function returns the list of all prime numbers less than .

First step : intialisation of variables

  {2, 3}

 Dynamic list of odd primes

  2

 Number of primes in the list

Sieve[]  {False, ...,False}  Array of  entries all initialized to False

  /2 - 1    - 1

 Bound for   Bound for 

Second step : iteration for first case

For  = 1 To 

For y = 1 To  Step 2   42 + 2

  must be odd

If  <  And ( mod 12 = 1 Or  mod 12 = 5) Do

Sieve[]  !Sieve[]

 Switch the boolean value Sieve[]

14

End If

End For

End For

Third step : iteration for second and third cases

For  = 1 To  Step 2 For  = 2 To  Step 2   32 + 2

 case where  is odd and  even

If  <  And ( mod 12 = 7) Do Sieve[]  !Sieve[]

End If

If  >  Do

  32 - 2

If  <  And ( mod 12 = 11) Do Sieve[]  !Sieve[]

End If

End If

End For

End For

For  = 2 To  Step 2 For y = 1 To  Step 2   32 + 2

 case where  is even and  is odd

If  <  And ( mod 12 = 7) Do Sieve[]  !Sieve[]

End If

If  >  Do

  32 - 2

If  <  And ( mod 12 = 11) Do Sieve[]  !Sieve[]

End If

End If

End For

End For

15

Fourth step : remove multiples of prime squares

For  = 5 To  Step 2 If Sieve[] Do

 multiples of 2 and 3 are ignored by the previous iterations

For  = 2 To  - 1 Step 22 Sieve[]  False

End For

End If

End For

Last step : return list of primes from the sieve

For  = 5 To  - 1 Step 2 If Sieve[] Do

()  

   + 1 End If

End For

Return (, )

3.2 Atkin algorithm with indices

We can rewrite proposition 3-1 as:

Corollary 3-2:  is the index of a prime number if and only if 2 + 3 is square-free and one of the three following conditions is true:

a.   (1 + 6)  (5 + 6) and there is an odd number of solutions to  = 22 + 22-3,

b.   2 + 6 and there is an odd number of solutions to  = 32+22-3,

c.





4

+

6

and

there

is

an

odd

number

of

solutions

to



=

32-2-3 2

with



<

.

The relationships presented in the following remark are used in the next algorithm.
Remark 3-2: For the fourth step (square multiples elimination), we note that if  = 2 + 3, the index of 2 is 22 + 6 + 3 and that the step of 22 translates into a step of 2 = (2 + 3)2 for indices.

Algorithm 3-2 IndexSieveOfAtkin():  > 3 is an odd integer. This function returns the list of all prime numbers less than .
First step : intialisation of variables 16

  {2, 3}   2   ( - 3)/2 Sieve[]  {False, ...,False}

 Dynamic list of primes  Number of primes in the list  Index of   Array of  entries all initialized to False

  /2 - 1    - 1

 Bound for   Bound for 

Second step : iteration for first case

For  = 1 To 

For y = 1 To  Step 2

  must be odd

  22 + 2-3
2

If  <  And ( mod 6 = 1 Or  mod 6 = 5) Do

Sieve[]  !Sieve[]

 Switch the boolean value Sieve[]

End If

End For

End For

Third step : iteration for second and third cases

For  = 1 To  Step 2 For  = 2 To  Step 2   32+2-3
2
If  <  And ( mod 6 = 2) Do Sieve[]  !Sieve[]

 case where  is odd and  even

End If

If  >  Do

  32-2-3
2
If  <  And ( mod 6 = 4) Do Sieve[]  !Sieve[]

End If

End If

End For

17

End For

For  = 2 To  Step 2 For y = 1 To  Step 2   32+2-3
2
If  <  And ( mod 6 = 2) Do Sieve[]  !Sieve[]

 case where  is even and  is odd

End If

If  >  Do

  32-2-3
2
If  <  And ( mod 6 = 4) Do Sieve[]  !Sieve[]

End If

End If

End For

End For

Fourth step : remove multiples of prime squares

For



=

1

To

- 

 multiples of 3 are ignored by the previous iterations

If Sieve[] Do

For  = 22 + 6 + 3 To  - 1 Step (2 + 3)2

Sieve[]  False

End For

End If

End For

Last step : return list of primes from the sieve

For  = 1 To  - 1 If Sieve[] Do

()  2 + 3    + 1 End If

End For

Return (, )

18

3.3 Performance of algorithms
In this section, we discuss theoretical complexity and present our results with the two algorithms implementing the sieve of Atkin.
The reference algorithm SieveOfAtkin has less operations index-based IndexSieveOfAtkin, which juggles between numbers and indices. But on the other hand SieveOfAtkin performs Euclidian divisions by 12, whereas IndexSieveOfAtkin does divisions by 6. This is due to the conversion of number  into its index  = ( - 3)/2. Furthermore, the latter only performs the sieve on odd numbers, which means effectively the memory space for the sieve is twice smaller.
On the graph 3-3 below, we plot the computation time in seconds for both algorithms. The curve 3 corresponds to SieveOfAtkin and the curve 4 to IndexSieveOfAtkin. We observe empirically that computation time of both algorithms looks slightly higher than linear, even though theoretically the number of operations appears to be linear in . Details of the Maple options used to get the regression are given in appendix 8.2.
Graph 3-3: computation time  () in seconds for both algorithms (Sieve of Atkin)
3 ()  4.90 × 10-19 × 2 + 8.55 × 10-9 × 
R =0.9996
4 ()  3.79 × 10-19 × 2 + 7.40 × 10-9 × 
R =0.9999
The second algorithm is faster for larger values of , roughly for  > 109. For such values the cost of encoding numbers to indices is offset by the gain on modulo operations and halving the size of the sieve. We note also that memory size is halved for the second algorithm.
19

4 Wheel sieve with indices
We first describe Pritchard's wheel sieve. Then we adapt it to indices and discuss a way to generate the integers of the turning wheel.
4.1 Description of Pritchard's wheel sieve This description is based on [7] and [4]. The wheel sieve operates by generating a set of numbers that are coprime with the first  prime numbers. The second of these is the next prime, multiples of which are then eliminated (by turning the wheel). More precisely, let 0 = 2, 1 = 3 ... the sequence of prime numbers and let:

 =  
=0
() = {  1,  - 1| gcd(, ) = 1}  = ()
The following proposition describes a "turn of the wheel". Proposition 4-1-1: We have the following inductive formula for :
0 = {1}, 1 = {1,5}, 2 = {1,7,11,13,17,19,23,29}
+1-1
  , +1 = (  ( + ))  +11,  - 1
=0
Proof: The Chinese theorem ensures that   +1 if and only if  mod    and   +1. This gives the desired set equality.
Furthermore, induction formula for  can also be used to recursively build the sequence of prime numbers: Proposition 4-1-2: The second smallest element of  (  1) is the next prime +1. Proof: The first element is 1, which is obviously not prime. For   1,   3 and from proposition 41-1 we can show (see corollary 4-2-2 later on) that  has at least 2 elements. The second one must then be the smallest integer coprime with 0 ... , and thus must be +1.
The elements of  are called pseudo-primes (at order ). Some of them are primes and others are not. However, we have a boundary condition to identify some of the primes: Proposition 4-1-3: All integers in  and less than 2 are sure to be primes. Proof: Any integer less than 2 is either prime or has a divisor among 0 ... . The latter is impossible by definition of .
20

To enumerate primes up to , we thus have to keep turning the wheel as long as 2+1 < .

As  grows exponentially (in particular it can be easily proven from Bertrand's postulate that  > 2 from  = 2), while we are only interested in pseudo-primes up to , we may replace in practice  by  =   1, .

Proposition 4-1-4: The following inductive formula (or wheel turn) is true for all :

max(+1 -1, )

  , +1 =


=0

( + )  +1 1, +1  1, .

[ (

)

]

Furthermore, if  > 9, then as soon as 2  ,  = {0 ... }  (  {1}).

Proof: By double inclusion (cf. proof of proposition 4-2-3). The second identity comes from the fact that if  > 9, 2   implies   2.

Thus, when we turn the wheel, we remove integers that are, for a given   , and ,  integers, of the form:
 +  = +1
One way to do that is to remove all multiples of +1. We will show however in section 4.2 that there is a relationship between the value of , the multiples of  which are added to , and the composite numbers +1 which must be removed of the wheel +1, so that the index  to remove can be predicted from  or conversely.

4.2 Index wheel sieve Definition 4-2: We note  the product of all odd primes up to , i.e.  = 2 . We also note:

(, , ) =  + 

and, with  the index of :

(,

,

)

=

(,

2

+ 2

3,

)

-

3

=



+



the index of (, , ).

We let  be the set of indices corresponding to , with 1 replaced by  + 1 (which index is  - 1):



=

 {

- 2

3

,









{1}}



{

-

1}

In this section, we describe how we adapt the wheel sieve to work with indices of odd integers. The limit  is supposed to be an odd integer of index .

21

Recurrence relation verified by the index wheel sieve:

The initial index wheels are 0 = {0}, 1 = {1,2}, 2 = {2,4,5,7,8,10,13,14}.

Remark 4-2-1: The first element of  is the index of the prime number +1.  is included in

+1-3
2

,



-

1.

Proof: Since we remapped 1 to  + 1 in  to define , and because the indexing map is increasing, the first element of  is the index of prime +1 from proposition 4-1-2 (we note that it works even for  = 0), and its last element is  - 1.

Proposition 4-2-1: The index wheel sieve is the only sequence of sets verifying:

0 = {0}
+1-1
  , +1 = (  ( +  ))  {+12- 3 + +1,   0,  - 1}
=0

Furthermore, indices in the wheel  up to  correspond to all remaining prime numbers up to  (on top of 0 ... ) as soon as:

2 - 2

3





Proof: This comes from the definition 4-2 of the index wheel sieve, the proposition 4-1-1 and from observing that the index of any odd multiple  of  is of the form:

 - 2

3

=



- 2

3

+

   ,



=



- 2

1

If we let  = 2 + 3, this corresponds to the definition of (, ) in [8]: (, ) =  + (2 + 3).

Eliminating multiples of the next prime by solving a Diophantine equation:

Proposition 4-2-2: For a given   0,  - 1, there exists a unique (, )  0, +1 - 1 ×  such that  +  = +1. Furthermore,  only depends of  mod +1, 0 = 0 and for 1 = (- ) mod +1,

1 = 1. For all    one has  mod +1 = 1 mod +1

Remark 4-2-2: Using indices, we must solve (, ) in the following equations for   :



+



=

+1 - 2

3

+

+1

so we will let  =  - +1-3.
2

22

Proof: Because  and +1 are coprime, existence and unicity of the solution are well-known. In [9] we introduced the concept of normalizer of such a Diophantine equation, and have shown its additive and multiplicative property.
Clearly if    [+1] then ( - )  0 [+1] and as  and +1 are coprime,    [+1]. Also, because 0 + 0.  = 0. +1 we deduce that 0 = 0. Then from the fact that 1 +   +1 we get that 1 = 1. Furthermore, for all , by multiplicative property:
1  . 1   [+1] Thus,   -  -1  1 [+1].

This proposition gives us an effective way of building all couples (, ) modulo +1: start from (1, 1) and add it to itself (modulo +1) up to +1 - 1 times (the last time we will get the couple (0,0 = 0)).

Corollary 4-2-2:  and  have =1( - 1) elements.

Proof: Let us proceed by induction on . The property is true for  = 0. Assume it is true for a given   . From proposition 4-2-1,

+1-1
+1 = (  ( +  ))  {+12- 3 + +1,   0,  - 1}.
=0

Thus =+01-1( +  ) = ( +  0, +1 - 1) has exactly +1 =1( - 1) elements, from which we must remove the indices of multiples of +1. For a given   , from
proposition 4-2-2 there is exactly one couple (, ) such that:



+



=

+1 - 2

3

+

+1

i.e. there is only one element of  +  0, +1 - 1 in {+21-3 + +1,   0,  - 1}. So in total there are exactly =1( - 1) elements in (=+01-1( +  ))  {+21-3 + +1,  
0,  - 1}, thus (+1 - 1) =1( - 1) = +=11( - 1) elements in +1.

Proposition 4-2-3:  =   0,  verifies the following induction property.

For all   , +1 is equal to:

min(+1-1,)



( +  )

=0



{+12-

3

+

+1,





0,

min

(

-

1,

22++1

3

-

1 2)}

 0, 

( (

)

)

23

Proof: Let   +1. From proposition 4-2-1, there exists   ,   0, +1 - 1 such that



=



+

 .

But







so





/ .

Furthermore,





{+1-3
2

+

+1,





0,



-

1} so a fortiori:





{+12-

3

+

+1,





0,

min

(

-

1,

22++1

3

-

1 2)}.

Conversely, let   (mi=n0(+1-1,/ )( +  ))  0,  such that



{+1-3
2

+

+1,





0,

min

(

-

1,

2-3
2+1

-

12)}.

The

first

condition

means

that





 +1

if





{+1-3
2

+

+1,





0,



-

1}.

But

if

that

were

the

case,

there

would

be





1,



-

1

such

that



=

+1-3 2

+

+1.

Thus





-(+1-3)/2 +1

=

2+3 2+1

-

12,

which

cannot

happen

because





{+1-3
2

+

+1,





0, min (

-

1,

2+3
2+1

-

12)}.

4.3 Wheel sieve algorithms

As per sections 4.1 and 4.2, the wheel sieve algorithms will consist in two steps:

(A) A first step where the wheel will always grow, as long as  < , or:  - 1 < ,

(B) A second step where we will no longer grow the wheel, but will have to keep eliminating

composite numbers, as long as 2 < , or:

2 - 2

3

<

.

This is equivalent to saying that we replace +1 by +1 and similarly +1 by +1. During

step (B) we do not add new pseudo-primes, only remove those that we rule out as multiples of the

next prime. Because  grows exponentially, there will generally be more iterations in step (B) than

in step (A).

Quick description of the steps of the index wheel sieve algorithm (see appendix for full algorithm):
As for the previous algorithms, we note  the list of primes and  its number of elements.  represents the list of indices of odd primes, and  the list of indices of squared odd primes. At step ,  will contain all primes up to 2, coming from the wheel ,  and  being filled with the corresponding indices.
1- Intialisation of the sieve for  = 1:  = {2,3,5,7},  = 4  = {0,1,2},  = {3,11,23} and 1 = {1, 2} with 1 = 3.
2- While  <  (step A): a. We take +1 from  (or equivalently the first element of ). The list of pairs (, ) such that  +  has to be eliminated is then computed, according to proposition 4-2-2. Then we build the wheel +1. b. Once this is done primes in the interval -1 + 2, 2+1 - 2 are added to  and ,  and  are updated accordingly. Indices of the primes to add are those in
24

+1  ( - 2) + 1, () - 1.
3- While () <  (step B): a. Remove indices of multiples of +1 from  to get +1. b. Once this is done primes in the interval -1 + 2, 2+1 - 2 are added to  and ,  and  are updated accordingly. Indices of the primes to add are those in +1  ( - 2) + 1, () - 1.

Remark 4-3-1: Let 1 and 2 be the indices of two odd numbers, respectively 1 and 2, such as 2 - 1 > 0. Let  = 2 - 1. The difference between the indices 12 and 22 is:
 = 22 + 21.
Furthermore, if  is another integer, the difference between the indices of 1 and 2 is:

 = .

Proof: Note that 2 - 1 = 2 and thus:

22

- 2

3

-

12

- 2

3

=

1 2

(2

-

1)(2

+

1)

=

(2

+

1)

=

(21

+

2)

=

.

Similarly:

2 - 2

3

-

1 - 2

3

=



=

.

This last remark is used in steps 2-b. and 3-b. to fill  and to perform step 3-a.
Remark 4-3-2: The index wheel sieve involves operations with reduced input size compared with the number version. This is clear from remark 4-3-1 where  is exactly half of 22 - 12, for instance. Similarly  is half of  so modulo operation input is also reduced.

4.4 Performance of algorithms
In this section, we present results from the previous algorithm of index wheel sieve, which we compare with a similar one on numbers (unspecified for to avoid a lengthy duplication). These results are similar to those obtained in the previous sections. As for the sieve of Atkin, we did not go for refinements that give a better time complexity, so theoretical complexity in terms of number of operations is () for both algorithms.
On the graph 4-4 below, we plot the computation time in seconds for both algorithms, for  up to 6.109. The curve 5 corresponds to the the algorithm WheelSieveReference and the curve 6 corresponds to the the algorithm IndexWheelSieve. The correlation coefficient  of each regression is given on the graph. Details of the Maple options used to get the regression are given in appendix 8.3. We notice that complexity of both algorithms again seems empirically slightly higher than linear.

25

Graph 4-4: computation time  () in seconds for both algorithms (Wheel sieve)
5 ()  5.25 × 10-10 × 1.11
 = 0.9998
6 ()  1.33 × 10-9 × 1.06
 = 0.9999
Complexity is reduced by using indices, due to reduction of input size in the modulo and the multiplication operations (see Remark 4-3-2) and despite a higher number of operations with the algorithm IndexWheelSieve. Moreover, the amount of memory space used with indices is halved, due to the fact that we avoid even numbers completely.
5 Conclusion
In theory, indices are a way to work with odd numbers only by not representing even numbers. Most mathematical relations must be reformulated for indices, which lead to a higher number of (conversion) operations, but in return the input size of other operations is reduced. In this article, we have shown how this indexing translates into optimized algorithms in applied mathematics. From a basic primality test implementation, to the sieve of Atkin and Pritchard's wheel sieve, indices speeded up these algorithms, not by changing their complexity but by reducing the time cost by a constant factor, and generally also made them more efficient from a memory point of view.
Acknowledgments: We would like to thank François-Xavier VILLEMIN for his attentive comments and suggestions.
6 REFERENCES
[1]. René SCHOOF (2008), Four primality testing algorithms. Algorithmic Number Theory, MSRI Publications, Volume 44. http://www.math.leidenuniv.nl/~psh/ANTproc/05rene.pdf.
[2]. Manindra AGRAWAL, Neeraj KAYAL, Nitin SAXENA (2004), PRIMES is in P. Ann. of Math. (2) 160, No. 2, pp. 781-793. MR2123939 (2006a:11170). http://annals.math.princeton.edu/wp-content/uploads/annals-v160n2-p12.pdf.
26

[3]. Paul PRITCHARD (1981), A sublinear additive sieve for finding prime numbers. Communications of the ACM 24(1), pp. 18-23. https://dl.acm.org/doi/pdf/10.1145/358527.358540?download=true.

[4]. Paul PRITCHARD (1982), Explaining the Wheel Sieve. Acta Informatica 17, pp. 477-485. http://fuuu.be/polytech/INFOF404/Doc/Explaining%20the%20wheel%20sieve.pdf.

[5]. Paul PRITCHARD (1994), Improved Incremental Prime Number Sieves. Algorithmic Number Theory

Symposium.

pp.

280­288.

CiteSeerX

10.1.1.52.835.

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.52.835&rep=rep1&type=pdf.

[6]. Arthur ATKIN AND Daniel BERNSTEIN (2003), Prime sieves using binary quadratic forms. Mathematics of Computation Volume 73, Number 246, pp. 1023-1030. https://www.ams.org/journals/mcom/2004-73246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf.

[7]. Gabriel PAILLARD, Felipe FRANCA, Christian LAVAULT (2013), A distributed wheel sieve algorithm using Scheduling by Multiple Edge Reversal. HAL-00794389. https://hal.archives-ouvertes.fr/hal-00794389.

[8]. Marc WOLF, François WOLF (2018), Representation theorem of composite odd numbers indices. SCIREA Journal of Mathematics, Vol. 3, pp. 106-117. http://article.scirea.org/pdf/11066.pdf.

[9]. Marc WOLF, François WOLF, Corentin LE COZ (2018), Calculation of extended gcd by normalization. SCIREA Journal of Mathematics. Vol. 3, pp. 118-131. http://article.scirea.org/pdf/11067.pdf.

7 APPENDIX: ALGORITHM OF THE INDEX WHEEL SIEVE
This algorithm enumerates odd primes up to the limit . It is composed of a main function that is called IndexWheelSieve and the following auxilliary other functions:
7-2- DiophantineSolutions(, ) 7-3- WheelTurn(, , , ,  , ) 7-4- RemoveMultiples(, , ) 7-5- GetNewPrimes(, , , , , )
Some marginal optimizations can still be performed, for instance modulo operations inside a loop can be replaced by substractions, and memory can be managed better. For the sake of readability we leave these optimizations out of scope.

Algorithm 7-1 IndexWheelSieve():  > 9 is an odd integer. This function returns the list of all prime numbers up to .

First step : intialisation of variables

  {2, 3,5,7}

 Dynamic list of primes

  4   ( - 3)/2

 Number of primes in the list  Index of 

  {0,1,2}

27

  {3,11,23}   {1, 2}   3 1
Second step : Wheel inflation. Do   ( + 1)   ()  +1   ×   Compute values of the new wheel from the previous one  WheelTurn(, , , ,  , ) GetNewPrimes(, , , , , )    +1   +1 While  > 
Third step : Wheel deflation. While ( - 1) <    ( + 1)   ()  RemoveMultiples(, , ) GetNewPrimes (, , , , , )   +1 End While
Return (, )

Algorithm 7-2 DiophantineSolutions(, )

1   - ( mod )

 Solution such that  = 1

28

0   {0 ... 0}
For  = 1 To  - 1 Do   ( + 1) mod  ()   End For Return 

 Array of size 

Algorithm 7-3 WheelTurn(, , , ,  , ) This function computes +1 by duplicating the wheel  and removing indices of multiples of  = +1.
First step : Compute all the pairs (, ) in the function DiophantineSolutions   DiophantineSolutions(, )
Second step : Iteration   Size()   Range({}, ) For  = 0 To  - 1 Do   ()   ( - ) mod    () For  = 0 To  - 1 Do
   +  If  >  Do Break End If If    Do Append((),) End If End For
29

End For
Third step : Build +1 by concatenation +1  {} For  = 0 To  - 1 Do Concatenate(+1,()) End For Return +1
Algorithm 7-4 RemoveMultiples(, , )
+1  {}    For  = 1 To Size()-1 Do If  () >  Do
   +    -1 Else If  () =  Do    +  Else Append(+1, ()) End If End For Return +1
Algorithm 7-5 GetNewPrimes(, , , , , ) This function adds new primes to the list  and updates  and the other lists  and  (all passed by reference).
  ( + 1)
30

   -  - 2   ()

 Offset to take into account already known primes

While  <  Do

( - 1)  

  ( - 1) - ( - 2) ( - 1)  ( - 2) + 22 + 2( - 1)

()  ( - 1) + 2

   + 1   +1

  ()

End While

8 APPENDIXES: MAPLE REGRESSIONS
Here are numeric values obtained from our implementation (Visual Studio C++ 2012) of the algorithms presented in this article.

8.1 BASIC PRIMALITY TEST AND PRIMES ENUMERATION

In table 8.1, numeric values of 1() and 2() are obtained respectively from the PrimeEnumeration and IndexPrimeEnumeration algorithms.

 1 ( ) 2 ( )

Table 8.1: numeric values of () and () in seconds.

107

108

5 × 108

109

2 × 109

3 × 109

2.403

56.031 493.163 1306.884 3414.713 6271.249

2.375

54.725 487.568 1275.921 3329.573 6105.386

4 × 109 8908.814 8664.438

To fit these observations, Maple's NonlinearFit function is used with the parameters below. Initial values for  and  were determined empirically. NonlinearFit( × / ln(), X, Y, n, initialvalues = [ = 5.9 × 10-9,  = 1.41],
output = [leastsquaresfunction, residuals])

We get the following mathematical relationships:

1 ( )



5.79409775129480

×

10-9

×

, 1.40966993452829
ln()



= .99962000

2 ( )



6.10602965467609

×

10-9

×

, 1.406040046365699
()



=

.99962009

31

8.2 THE SIEVE OF ATKIN

In table 8.2, numeric values of 3() and 4() are obtained respectively from the SieveOfAtkin and IndexSieveOfAtkin algorithms.

 3 ( ) 4 ( )

Table 8.2: numeric values of () and () in seconds.

108

5 × 108

109

1.5 × 109

1.6 × 109

2 × 109

0.719

3.797

8.033

12.48

13.967

18.843

0.727

3.921

8.225

12.152

12.953

16.507

3 × 109 28.217 25.342

 3 ( ) 4 ( )

4 × 109 41.534 35.27

5 × 109 54.871 46.261

6 × 109 72.044 57.418

7 × 109 84.511 70.311

8 × 109 100.727 84.291

9 × 109 116.093 98.047

1010 133.184 110.96

This time we used Maple's function Fit as below: Fit( × 2 +  × , X, Y, , summarize = embed)
We get the following mathematical relationships:
3()  4.90268369826396 × 10-19 × 2 + 8.54576412559177 × 10-9 × ,  =
.999647
4()  3.78795281632082 × 10-19 × 2 + 7.39595089422000 × 10-9 × ,
 = .999926

8.3 WHEEL SIEVE WITH INDICES

In table 8.3, numeric values of 5() and 6() are obtained respectively from the WheelSieveReference and IndexWheelSieve algorithms.

 5 ( ) 6 ( )

107
0.071 0.064

Table 8.3: numeric values of () and () in seconds.
108 5 × 108 109 2 × 109 3 × 109 4 × 109 5 × 109
0.496 2.783 5.407 10.931 17.070 23.944 31.150 0.457 2.657 4.936 9.995 15.121 20.995 26.260

6 × 109
37.501 32.351

We used again NonlinearFit with empirically determined initial values  and : NonlinearFit( × , X, Y, n, initialvalues = [ = 1.97461115539853 × 10-6,  = 1.1], output = [leastsquaresfunction, residuals]).
We get the following mathematical relationships:
5()  5.25118782575365 × 10-10 × 1.11016647384427,  = .99982444 6()  1.33020583039257 × 10-9 × 1.06187203820827,  = .99986693

32

