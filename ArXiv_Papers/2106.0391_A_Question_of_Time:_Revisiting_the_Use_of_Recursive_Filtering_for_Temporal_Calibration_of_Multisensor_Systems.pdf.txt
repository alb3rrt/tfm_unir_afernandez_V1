A Question of Time: Revisiting the Use of Recursive Filtering for Temporal Calibration of Multisensor Systems
Jonathan Kelly, Christopher Grebe, and Matthew Giamou

arXiv:2106.00391v1 [eess.SY] 1 Jun 2021

Abstract-- We examine the problem of time delay estimation, or temporal calibration, in the context of multisensor data fusion. Differences in processing intervals and other factors typically lead to a relative delay between measurement from two disparate sensors. Correct (optimal) data fusion demands that the relative delay must either be known in advance or identified online. There have been several recent proposals in the literature to determine the delay parameter using recursive, causal filters such as the extended Kalman filter (EKF). We carefully review this formulation and show that there are fundamental issues with the structure of the EKF (and related algorithms) when the delay is included in the filter state vector as a value to be estimated. These structural issues, in turn, leave recursive filters prone to bias and inconsistency. Our theoretical analysis is supported by simulation studies that demonstrate the implications in terms of filter performance; although tuning of the filter noise variances may reduce the chance of inconsistency or divergence, the underlying structural concerns remain. We offer brief suggestions for ways to maintain the computational efficiency of recursive filtering for temporal calibration while avoiding the drawbacks of the standard algorithms.
I. INTRODUCTION
Time delays are inherent in all sensor data processing due to, for example, signal conditioning, integration, and transmission latency. Optimal data fusion from multiple sources requires that the relative delays between sensor data streams must either be determined offline in advance or identified online, when possible.
In this paper, we consider the task of estimating a single delay in a multisensor system. A variety of systematic time delay identification, or temporal calibration, methods have been published in the literature--there are bespoke, offline estimators for specific sensor pairs [1]­[3], more general batch programs [4], [5], and online, sliding-window implementations [6], for example. Our focus herein is on recent proposals to determine the delay parameter through recursive, causal filtering, using variants of the extended Kalman filter (EKF). In particular, Nilsson, Skog, and Ha¨ndel [7], [8] have applied the EKF to state and delay estimation for GPS-aided inertial navigation, while Li and Mourikis have devised a similar approach for vision-aided inertial navigation [9], [10]. The delay parameter is added to the filter state vector and the measurement update step is modified to
All authors are with the Space & Terrestrial Autonomous Robotic Systems (STARS) Laboratory at the University of Toronto Institute for Aerospace Studies (UTIAS), Toronto, Canada. <firstname>.<lastname>@robotics.utias.utoronto.ca
Jonathan Kelly is a Vector Institute Faculty Affiliate. This research was supported in part by the Canada Research Chairs program.
Matthew Giamou is a Vector Institute Postgraduate Affiliate and an RBC Fellow.

Discrete <latexitsha1_base64="s1+b+fmkcJAbhXT1BHb9Wt7s3Hk=">AAACDHicbVC7SgNBFJ317fqKWtoMBsEq7FqojShqYSNENImQhDA7uZsMzs4uM3fFsOQDbPwJP8DGQhFb7W3Ev3HyKDR6qsO553DvPUEihUHP+3LGxicmp6ZnZt25+YXFpdzyStnEqeZQ4rGM9WXADEihoIQCJVwmGlgUSKgEV0e9eeUatBGxusBOAvWItZQIBWdopUYuX0O4wexYGK4BgZ6DMrGmp8BMqiEChaZrXV7B64P+Jf6Q5Pff3b3k/tMtNnIftWbM016aS2ZM1fcSrGdMo+ASum4tNZAwfsVaULVUsQhMPes/06UbVmnS0B4RxgppX/2ZyFhkTCcKrDNi2Dajs57436yaYrhbz4RKUgTFB4vCVFKMaa8Z2hQaOMqOJYxrYW+lvM0042j7c20J/ujLf0l5q+BvF/wzL39wSAaYIWtknWwSn+yQA3JCiqREOLklD+SJPDt3zqPz4rwOrGPOMLNKfsF5+wYaYp9L</latexit>

Sensor

Measurements

<latexit sha1_base64="oqFiogjvdwZ0zHv/Ss4F92haIts=">AAAB7XicbVBNS8NAEJ34WetX1aOXxSLUS0lE1GPRi8cK9gPaUDbbTbt2kw27E6GE/gcvHhTx6v/x5r9x2+agrQ8GHu/NMDMvSKQw6Lrfzsrq2vrGZmGruL2zu7dfOjhsGpVqxhtMSaXbATVcipg3UKDk7URzGgWSt4LR7dRvPXFthIofcJxwP6KDWISCUbRSM61gb3TWK5XdqjsDWSZeTsqQo94rfXX7iqURj5FJakzHcxP0M6pRMMknxW5qeELZiA54x9KYRtz42ezaCTm1Sp+EStuKkczU3xMZjYwZR4HtjCgOzaI3Ff/zOimG134m4iRFHrP5ojCVBBWZvk76QnOGcmwJZVrYWwkbUk0Z2oCKNgRv8eVl0jyvepdV7/6iXLvJ4yjAMZxABTy4ghrcQR0awOARnuEV3hzlvDjvzse8dcXJZ47gD5zPH/6EjsA=</latexit>
u(tk

)

<latexit sha1_base64="MveNohcq0PvJ4yAD7sUwAJs/DF4=">AAAB/3icbZDLSsNAFIYn9VbrLSq4cTNYhLopiYi6LLpxWcFeoA1hMp20QycXZk7EULvwVdy4UMStr+HOt3GSZqGtPwx8/OcczpnfiwVXYFnfRmlpeWV1rbxe2djc2t4xd/faKkokZS0aiUh2PaKY4CFrAQfBurFkJPAE63jj66zeuWdS8Si8gzRmTkCGIfc5JaAt1zxIanCC+/ihBu44gzQH16xadSsXXgS7gCoq1HTNr/4goknAQqCCKNWzrRicCZHAqWDTSj9RLCZ0TIaspzEkAVPOJL9/io+1M8B+JPULAefu74kJCZRKA093BgRGar6Wmf/Vegn4l86Eh3ECLKSzRX4iMEQ4CwMPuGQURKqBUMn1rZiOiCQUdGQVHYI9/+VFaJ/W7fO6fXtWbVwVcZTRITpCNWSjC9RAN6iJWoiiR/SMXtGb8WS8GO/Gx6y1ZBQz++iPjM8f0veUDg==</latexit>
<latexit sha1_base64="Lu5C20U21pldVGDxWHeBs42SYQA=">AAAB9HicbVDLSgNBEOyNrxhfUY9eBoMQEcKuiHoMevEYwTwgWcLsZDYZMvtwpjcYlnyHFw+KePVjvPk3TpI9aGJBQ1HVTXeXF0uh0ba/rdzK6tr6Rn6zsLW9s7tX3D9o6ChRjNdZJCPV8qjmUoS8jgIlb8WK08CTvOkNb6d+c8SVFlH4gOOYuwHth8IXjKKR3KcydofkjHSQJqfdYsmu2DOQZeJkpAQZat3iV6cXsSTgITJJtW47doxuShUKJvmk0Ek0jykb0j5vGxrSgGs3nR09ISdG6RE/UqZCJDP190RKA63HgWc6A4oDvehNxf+8doL+tZuKME6Qh2y+yE8kwYhMEyA9oThDOTaEMiXMrYQNqKIMTU4FE4Kz+PIyaZxXnMuKc39Rqt5kceThCI6hDA5cQRXuoAZ1YPAIz/AKb9bIerHerY95a87KZg7hD6zPHztxkRo=</latexit>
xu(t(kt)+x(t)k

)

y (tk )

<latexitsha1_base64="Nhskf9Qbocj6QdZOrMvJezV2ptw=">AAAB73icbZA9SwNBEIbn/IzxK2ppsxgEq3BnoRaCQRvLCOYDkiPsbfaSJXt75+6cEI78CRsLRWz9O3b+FDs3lxSa+MLCw/vOsDMTJFIYdN0vZ2l5ZXVtvbBR3Nza3tkt7e03TJxqxusslrFuBdRwKRSvo0DJW4nmNAokbwbDm0nefOTaiFjd4yjhfkT7SoSCUbRWq4M0JZfE7ZbKbsXNRRbBm0H56jvMVeuWPju9mKURV8gkNabtuQn6GdUomOTjYic1PKFsSPu8bVHRiBs/y+cdk2Pr9EgYa/sUktz93ZHRyJhRFNjKiOLAzGcT87+snWJ44WdCJSlyxaYfhakkGJPJ8qQnNGcoRxYo08LOStiAasrQnqhoj+DNr7wIjdOKd1bx7txy9RqmKsAhHMEJeHAOVbiFGtSBgYQneIFX58F5dt6c92npkjPrOYA/cj5+AJ6Ikro=</latexit>

<0

^1 <latexitsha1_base64="aiQDRchcTVfeq0HmhnlvKfTrzmc=">AAAB83icbVDJSgNBEO1xjXGLCl68NAbBU5jxoB5DvHhMwCyQGUJNp5M06VnorhbCkN/w4kERr/kLv8CbF7/FznLQxAcFj/eqqKoXplJodN0vZ219Y3NrO7eT393bPzgsHB03dGIU43WWyES1QtBcipjXUaDkrVRxiELJm+Hwbuo3H7nSIokfcJTyIIJ+LHqCAVrJ9weAmY9gxh2vUyi6JXcGukq8BSmWT2vfYlL5qHYKn343YSbiMTIJWrc9N8UgA4WCST7O+0bzFNgQ+rxtaQwR10E2u3lML6zSpb1E2YqRztTfExlEWo+i0HZGgAO97E3F/7y2wd5tkIk4NchjNl/UM5JiQqcB0K5QnKEcWQJMCXsrZQNQwNDGlLcheMsvr5LGVcm7Lnk1m0aFzJEjZ+ScXBKP3JAyuSdVUieMpOSJvJBXxzjPzpvzPm9dcxYzJ+QPnMkPAGiVXA==</latexit>

Underlying <latexitsha1_base64="/F8QHHdSlkB6Yog3lafTAaL/SEM=">AAACEXicbVA9SwNBEN3zM8avqKXNYhBsDHciahlMY6loNJCEsLeZxMX9OHbnxOPIX7Dxr9hYKGJrZ+e/cRNTqPHBwOO9GWbmxYkUDsPwM5ianpmdmy8sFBeXlldWS2vrl86klkOdG2lsI2YOpNBQR4ESGokFpmIJV/FNbehf3YJ1wugLzBJoK9bXoic4Qy91SjsthDvM67oLVmZC92nNaBQ6NanbvRAK6HnmENSgUyqHlXAEOkmiMSmTMU47pY9W1/BUgUYumXPNKEywnTOLgksYFFupg4TxG9aHpqeaKXDtfPTRgG57pUt7xvrSSEfqz4mcKecyFftOxfDa/fWG4n9eM8XeUTsXOkkRNP9e1EslRUOH8dCusMBRZp4wboW/lfJrZhlHH2LRhxD9fXmSXO5VooNKdLZfrh6P4yiQTbJFdkhEDkmVnJBTUiec3JNH8kxegofgKXgN3r5bp4LxzAb5heD9C7hTnjM=</latexit>

Continuous-Time

System

<latexit sha1_base64="J+JZu/oa0sEXAotSfcIO0lyJwEk=">AAACVnicbVFNb9QwEHVSSkv4aIAjF6sVaKtWq4QDICSkFb1wLIJtK22W1cSZTa06TrDHaKNo/0V/WbnQn9ILwrtbELSMZOnpvTfj8XPeKGkpSS6DcO3O+t2NzXvR/QcPH23Fj58c2doZgUNRq9qc5GBRSY1DkqTwpDEIVa7wOD87WOjH39BYWevP1DY4rqDUcioFkKcmcZV9kmUF/C3PvjoooizHUuoOlCw1FvMoK2rqZvMe7fIX/B13HuxHSyuf9ZJdT82+dMl8P8ui9rdp1iO+xzMCt/CiLv6Mm8Q7ST9ZFr8N0muwM9jO9s4vB+3hJL7wCwhXoSahwNpRmjQ07sCQFAr9es5iA+IMShx5qKFCO+6Wscz5c88UfFobfzTxJft3RweVtW2Ve2cFdGpvagvyf9rI0fTNuJO6cYRarC6aOsWp5ouMeSENClKtByCM9LtycQoGBPmfiHwI6c0n3wZHL/vpq3760afxnq1qkz1j26zHUvaaDdgHdsiGTLDv7CoIg7XgR/AzXA83VtYwuO55yv6pMP4Fvgaxig==</latexit>
:

x (t) = u(t), x(0) = x0, y(t) = x(t +  ),

<latexit sha1_base64="jdrKcZIrTf2a1SAiu4UsvXphI1c=">AAACIHicbZDLSsNAFIYn9VbrLepSkcEiuCpJBetGKLpx2YK9QBvKZDppx04mYWYilJClj+HGp+jejQtFdKev4Es4aQtq6w8DH/85hzPnd0NGpbKsDyOzsLi0vJJdza2tb2xumds7dRlEApMaDlggmi6ShFFOaooqRpqhIMh3GWm4g8u03rglQtKAX6thSBwf9Tj1KEZKWx2zFN8k8XkS20kbTrGY4uDHHcy6Jxo7Zt4qWGPBebCnkC/vj6pfdwejSsd8b3cDHPmEK8yQlC3bCpUTI6EoZiTJtSNJQoQHqEdaGjnyiXTi8YEJPNJOF3qB0I8rOHZ/T8TIl3Lou7rTR6ovZ2up+V+tFSnvzIkpDyNFOJ4s8iIGVQDTtGCXCoIVG2pAWFD9V4j7SCCsdKY5HYI9e/I81IsF+7RgV3UaF2CiLNgDh+AY2KAEyuAKVEANYHAPHsEzeDEejCfj1XibtGaM6cwu+CPj8xvapqex</latexit>

j

=1

j=2

k=1

k=2

k=3

<latexit sha1_base64="jdrKcZIrTf2a1SAiu4UsvXphI1c=">AAACIHicbZDLSsNAFIYn9VbrLepSkcEiuCpJBetGKLpx2YK9QBvKZDppx04mYWYilJClj+HGp+jejQtFdKev4Es4aQtq6w8DH/85hzPnd0NGpbKsDyOzsLi0vJJdza2tb2xumds7dRlEApMaDlggmi6ShFFOaooqRpqhIMh3GWm4g8u03rglQtKAX6thSBwf9Tj1KEZKWx2zFN8k8XkS20kbTrGY4uDHHcy6Jxo7Zt4qWGPBebCnkC/vj6pfdwejSsd8b3cDHPmEK8yQlC3bCpUTI6EoZiTJtSNJQoQHqEdaGjnyiXTi8YEJPNJOF3qB0I8rOHZ/T8TIl3Lou7rTR6ovZ2up+V+tFSnvzIkpDyNFOJ4s8iIGVQDTtGCXCoIVG2pAWFD9V4j7SCCsdKY5HYI9e/I81IsF+7RgV3UaF2CiLNgDh+AY2KAEyuAKVEANYHAPHsEzeDEejCfj1XibtGaM6cwu+CPj8xvapqex</latexit>

j

=1

j=2

k=1

k=2

k=3

^k <latexitsha1_base64="3hUbZDIzb81sO/5Hf1fejN2H/EU=">AAACDnicbVC7SgNBFJ31GeNr1VKRwRCwkLBroZZBG8sEzAOSEGYns8mQ2dll5q4YlpRWNv6KjQRFbK3t/AZ/wkk2hSYeGDj3nHuZe48XCa7Bcb6shcWl5ZXVzFp2fWNza9ve2a3qMFaUVWgoQlX3iGaCS1YBDoLVI8VI4AlW8/pXY792y5TmobyBQcRaAelK7nNKwEhtO9/sEUiaQOJhu3+CJ9VdSgMCPc9PSqZq2zmn4EyA54k7Jbniwaj8fX84KrXtz2YnpHHAJFBBtG64TgSthCjgVLBhthlrFhHaJ13WMFSSgOlWMjlniPNG6WA/VOZJwBP190RCAq0HgWc6xzvqWW8s/uc1YvAvWgmXUQxM0vQjPxYYQjzOBne4YhTEwBBCFTe7YtojilAwCWZNCO7syfOkelpwzwpu2aRxiVJk0D46QsfIReeoiK5RCVUQRQ/oCb2gV+vRerberPe0dcGazuyhP7A+fgB9daAW</latexit>

,

x^k ,

Pk

<latexit sha1_base64="vV5/hqkcqi9dhmtPSIcZLHvcuRQ=">AAACXXicdVFNS8QwEE3r565fqx48eAkugiIurYh6EUQvHhVcFbalpNmpGzZNSzIVl9I/6U0v/hXT3T34OSHw5s08ZvIS51IY9Lw3x52ZnZtfWGw0l5ZXVtda6xv3Jis0hy7PZKYfY2ZACgVdFCjhMdfA0ljCQzy8qusPz6CNyNQdjnIIU/akRCI4Q0tFLQxShoM4Ka+rqBxW9Jz2fBqAMjnjQIP69DMsgwHD8qWq9jAa0gM6TgNkRS069Kv98A9h8W9z1Gp7HW8c9Dfwp6BNpnETtV7tFrxIQSGXzJie7+UYlkyj4BKqZlAYsHOH7Al6FiqWggnLsTsV3bVMnyaZtlchHbNfFSVLjRmlse2svTA/azX5V61XYHIWlkLlBYLik0FJISlmtLaa9oUGjnJkAeNa2F0pHzDNONoPaVoT/J9P/g3ujzr+Sce/PW5fXE7tWCTbZIfsEZ+ckgtyTW5Il3Dy7hCn4TSdD3fOXXZXJ62uM9Vskm/hbn0CxSayfQ==</latexit>
Hk

= [1

x^ (tk + ^k

<latexit sha1_base64="jdrKcZIrTf2a1SAiu4UsvXphI1c=">AAACIHicbZDLSsNAFIYn9VbrLepSkcEiuCpJBetGKLpx2YK9QBvKZDppx04mYWYilJClj+HGp+jejQtFdKev4Es4aQtq6w8DH/85hzPnd0NGpbKsDyOzsLi0vJJdza2tb2xumds7dRlEApMaDlggmi6ShFFOaooqRpqhIMh3GWm4g8u03rglQtKAX6thSBwf9Tj1KEZKWx2zFN8k8XkS20kbTrGY4uDHHcy6Jxo7Zt4qWGPBebCnkC/vj6pfdwejSsd8b3cDHPmEK8yQlC3bCpUTI6EoZiTJtSNJQoQHqEdaGjnyiXTi8YEJPNJOF3qB0I8rOHZ/T8TIl3Lou7rTR6ovZ2up+V+tFSnvzIkpDyNFOJ4s8iIGVQDTtGCXCoIVG2pAWFD9V4j7SCCsdKY5HYI9e/I81IsF+7RgV3UaF2CiLNgDh+AY2KAEyuAKVEANYHAPHsEzeDEejCfj1XibtGaM6cwu+CPj8xvapqex</latexit>

j

=1

j=2

k=1

k=2

k=3

1)] = [1 u(tk + ^k

t<latexitsha1_base64="eOcWiN4nwZICHGR4ApYPAMSz1J8=">AAAB6HicbZC7SgNBFIZn4y2ut6ilzWIQrMKuhdqIQRvLBMwFkiXMTs4mY2Znl5mzQljyBDYWitjqw9jbiG/j5FJo4g8DH/9/DnPOCRLBNbrut5VbWl5ZXcuv2xubW9s7hd29uo5TxaDGYhGrZkA1CC6hhhwFNBMFNAoENILB9Thv3IPSPJa3OEzAj2hP8pAzisaqYqdQdEvuRM4ieDMoXn7YF8n7l13pFD7b3ZilEUhkgmrd8twE/Ywq5EzAyG6nGhLKBrQHLYOSRqD9bDLoyDkyTtcJY2WeRGfi/u7IaKT1MApMZUSxr+ezsflf1koxPPczLpMUQbLpR2EqHIyd8dZOlytgKIYGKFPczOqwPlWUobmNbY7gza+8CPWTknda8qpusXxFpsqTA3JIjolHzkiZ3JAKqRFGgDyQJ/Js3VmP1ov1Oi3NWbOeffJH1tsPQbeQOw==</latexit> 1)]

Extended <latexitsha1_base64="7zXkt+w697M+6d7NDLHdu8iy0Tc=">AAACBnicbVA9SwNBFNzz2/MrainCYhCswp2F2oiiKIKNgjGBJIS9vZe4uLd37L4Tw5HKxv9hZWOhiK2dvY34b9x8FJo4sDDMvMfbmSCRwqDnfTsjo2PjE5NT0+7M7Nz8Qm5x6dLEqeZQ5LGMdTlgBqRQUESBEsqJBhYFEkrB9WHHL92ANiJWF9hKoBaxphINwRlaqZ5brSLcYnZ0i6BCCOkpkxFT9FhIBN2u5/JeweuCDhO/T/J7H+5u8vDlntVzn9Uw5mkECrlkxlR8L8FaxjQKLqHtVlMDCePXrAkVSxWLwNSybow2XbdKSBuxtk8h7aq/NzIWGdOKAjsZMbwyg15H/M+rpNjYqWVCJalNyXuHGqmkGNNOJzQUGjjKliWMa2H/SvkV04zbDoxrS/AHIw+Ty82Cv1Xwz738/gHpYYqskDWyQXyyTfbJCTkjRcLJHXkkz+TFuXeenFfnrTc64vR3lskfOO8/y0ScVA==</latexit>

Kalman

Filter

^k <latexitsha1_base64="mhXXK0ghlh1x/u90NFM/L484SwE=">AAACGnicbVC7SgNBFJ31GeNr1dJmNAgRJexaqGXQxjKCeUA2hNnJbDJk9sHMXTEs+QZLG3/FJoUidmLjh9g7uwmoiQcGzpxzL/fe40aCK7CsT2NufmFxaTm3kl9dW9/YNLe2ayqMJWVVGopQNlyimOABqwIHwRqRZMR3Bau7/cvUr98yqXgY3MAgYi2fdAPucUpAS23TdnoEEgdIPGwn/SN7eIwz5e7n6xPouV5SmShts2CVrAx4ltgTUijvFb9G985hpW2+O52Qxj4LgAqiVNO2ImglRAKngg3zTqxYRGifdFlT04D4TLWS7LQhPtBKB3uh1C8AnKm/OxLiKzXwXV2Z7qmmvVT8z2vG4J23Eh5EMbCAjgd5scAQ4jQn3OGSURADTQiVXO+KaY9IQkGnmdch2NMnz5LaSck+LdnXOo0LNEYO7aJ9VEQ2OkNldIUqqIooekBP6Bm9GI/GyHg13salc8akZwf9gfHxDY8/pDM=</latexit>

+1

,

x^k+1,

Pk+1

Fig. 1. An overview of our formulation of sensor-to-sensor temporal calibration. We analyze the simple time-delay system  where the (fixed) delay,  , is an unknown parameter. Sensors such as cameras and inertial measurement units discretely sample the underlying continuous-time system. We prove that  is unidentifiable over intervals shorter than | | and reveal several cracks in the foundations of recursive filtering solutions to this problem. Our simulation experiments confirm that the EKF, in particular, is prone to bias and inconsistency, even when noise terms are tuned.
account for the delay uncertainty. Filtering has several potential advantages when implemented successfully, including simplicity and computational efficiency.
Although recursive filtering is appealing for time delay estimation, we show that there are several problems with this formulation. Our exposition is based upon the analysis of a simplified aided navigation system, where measurements from one sensor are treated as control inputs to drive the filter process model while updates are provided by a second, complementary sensor. An overview of the model is provided in Figure 1.
We begin by proving that the delay parameter requires a finite time for identification and establishing that the point estimate computed by the EKF does not properly account for this requirement. We then examine how filter process noise is coupled to a shifting delay estimate. Modifications to the delay value change the interval between measurement updates, altering the way in which process noise is incorporated within the EKF. We demonstrate experimentally that, because of these structural issues, recursive filters such as the EKF are prone to bias and inconsistency (and potentially to divergence). Critically, these fundamental problems exists due to the structure of the estimator--although they can be `covered up' to some extent by tuning of the filter noise variances, the underlying structural concerns remain. Our contributions are as follows:
1) we make explicit the requirements for delay identifiability and explain how these requirements are not satisfied by the EKF, leading to the erroneous computation of the filter innovation sequence;

2) we establish that the calculated uncertainty of the filter measurement update does not represent the true (underlying) uncertainty in general, making the filter prone to bias and inconsistency;
3) we show that `discontinuous' jumps (in time) occur at each filter update step, due to changes in the delay estimate, and that these jumps adversely affect the way in which process noise is incorporated into the algorithm; and
4) we demonstrate through extensive simulations that the issues above manifest in practice and can easily compromise the performance of an EKF-type estimator.
We confine our analysis to the simplified system model for clarity and brevity, but we emphasize that the same shortcomings exist for more complex models, including those used for aided inertial navigation, and for other recursive filters (e.g., the unscented Kalman filter). While we do not prescribe a full remedy in this short paper, we close by offering several directions to explore that may lead to a structurally sound, recursive algorithm for simultaneous state and delay estimation.
II. BACKGROUND
There is a vast body of work on estimation and control under time delays; we give only a very brief synopsis of material that lies within our scope. A broad overview and discussion of some open problems is provided in [11].
Recursive filtering with delayed and out-of-sequence measurements is a well-studied problem that can be solved optimally (for linear systems) if the delays are known [12]. In the case where measurements arrive out of sequence, the additional complication of correlated noise terms must be dealt with, as shown by [13]. Handling retrodicted measurements in these situations is computationally expensive; an alternative, proposed in [14], is to extrapolate measurements forward in time, sacrificing optimality for computational tractability.
The problem of recursive state (and parameter) estimation becomes substantially more difficult when the measurement delays are unknown and constant or subject to random variation. Assuming that the delays are random but quantized and bounded by some known value, Julier and Uhlmann [15] show that the method of covariance union can be applied to produce consistent, filtered estimates. Covariance union is a necessarily conservative algorithm, however, that achieves consistency at the expense of estimator efficiency when the delays can be better characterized. If the delays are random but the delay distribution is available a priori, Choi et al. describe a state augmentation technique in [16] to produce consistent estimates. Past states are added to the state vector (increasing the computational complexity) and measurements are then `allocated' across the past and current state estimates according to the delay distribution.
When possible, proper delay identification, carried out either offline or online, can improve the performance of recursive estimators. Identification of systematic delays is typically a challenging task, particularly in the nonlinear

setting. Xia et al. [17] and Zhang, Xia, and Moog [18] have characterized parameter and state identifiability for nonlinear time-delay systems using the theory of non-commutative rings. Anguelova and Wennberg extend this framework in [19], [20] by providing linear-algebraic criteria to determine whether multiple delays are identifiable. Importantly, the results in [20] reveal that the identifiability of delays is not directly related to the identifiability or observability of other system parameters or states, respectively.
There is relevant prior work on deterministic and stochastic observer design for a variety of time-delay systems [21]. For certain classes of systems, observers with desirable convergence properties, such as global exponential convergence, can be built. Many of these observers are so called `chain observers' (see, e.g., [22] and [23]) that attempt to reconstruct the state at a series of points within the delay window. The treatment of stochastic time-delay systems is substantially more involved and fewer convergence results are available. We return to the topic of stochastic observer design in Section VI.

III. IDENTIFIABILITY OF TIME DELAYS

In the remainder of the paper, we examine a very simple control-affine system,

x (t) = u(t), x(0) = x0,

:

(1)

y(t) = x(t +  ),

where x(t)  R is the system state at time t, u(t)   = [-1, 1] is the applied control, y(t)  R is the system output, and   R is the delay parameter. Our notation roughly follows that in [24]. We label specific points on the manifold
R using superscripts (this avoids a clash with subscripted time indices in Section IV). The state of the system at t = 0 is x(0) = x0. If  is negative, the output is delayed relative to the state (or lags the state); if  is positive, the output is advanced relative to the state (or leads the state). We use the term delay whether  is positive or negative, when there is no risk of ambiguity, and indicate the absolute value of the delay by +. Throughout this paper we consider  to be fixed but unknown. Note that, when no delay is present (i.e., for  = 0 exactly), the system (1) is trivially observable.
Our goal in this section is to show clearly that the delay
parameter of (1) requires a finite time for identification. This
is an intuitive and straightforward result that is implicit in
much of the prior and proximal work. We make the result
explicit in order to connect it to difficulties involved in
recursive filtering later in Section IV.

A. An Identifiability Criterion
We take the standard approach to determining identifiability (also sometimes called structural identifiability in this context [25]) based on output distinguishability, as defined in [26]. The definitions below have been adjusted to fit our problem instance where necessary.
We denote an admissible control input on the closed interval [t0, t1] by the pair u(t), [t0, t1] and the set of all admissible controls on the interval (-, ) by U. With a

slight abuse of set notation, we denote the concatenation of two sequential controls that share an endpoint in time with the union operator, for example, (u(t), [t0, t1])  (0, (t1, t2]).
We assume that the system exists for all time but that its output can only be observed for a finite duration, starting arbitrarily at t = 0, when information about the control input u(t) is also available. In certain cases, the state of the system, x(0), at t = 0 may also be known. To determine the delay parameter, we may perform any number of experiments, where an `experiment' involves observing the output y(t) given knowledge of u(t) and that x(0) = x0. We use y(t,  ) to denote the output of (1) at time t when the system has delay  . The requisite definitions follow.
Definition 1 (Indistinguishability). The pair of delay parameter values ( ,  ) are said to be indistinguishable if

y(t,  ) = y(t,  )

(2)

for all x(0) = x0 and for any admissible control u(t) over the interval 0  t  T . Otherwise, the two delay values are said to be distinguishable over the interval.

Definition 2 (Identifiability). The delay parameter value  is identifiable if the pair (,  ) is distinguishable for all  such that  =  .

It is important to recognize, in the definitions above, that although the outputs are observed over the same interval [0, T ], those outputs correspond to different times for the underlying system (due to differing delays).

B. Limits on Identifiability
We first define the time-limited forward and backward reachable sets [27], [28] of (1) from a given state.1
Lemma 1. For the system , the time-limited forward reachable set from state x0 in time T  0 is the closed interval F (x0, U , T ) = x0 - T, x0 + T . The time-limited backward reachable set from state x0 in time T is B(x0, U , T ) = x0 - T, x0 + T .
Proof. The results follow directly from the definition of the set of available controls, , and the time, T .

We now state an important theorem that will be central to our discussion of recursive filtering in Section IV. An illustration of the main argument of the theorem is given by Figure 2.
Theorem 1. The delay parameter,  , of the system  cannot be identified in a time less than or equal to +.
Proof. The proof is by construction. We show that there always exist two instances of (1), with different delays, that share the same input-output map for any admissible control (u(t), [0, +]). Denote these two instances by  and  .2

1In the control literature, these are usually called the reachable tubes; we use the name sets in our context, following [27].
2We apply the `primed' notation throughout this section to differentiate between the two systems that have differing delay values.

Fig. 2. An illustration of the main argument in the proof of Theorem 1 for  = -1 and  = -2. The control u(t) on interval [0, +] (shaded red) does not affect the output y(t) (shaded blue) on [0, +]. Therefore, for the inputs u(t) and u (t) illustrated here,  and  are indistinguishable on [0, +] and the time delay is unidentifiable.

Consider delays ,   R<0 such that  <  . Let the state of the system  with delay  be x(0) = x0. Likewise, let the state of the system  with delay  be x (0) = x0.
An arbitrary control (u(t), [0, +]) applied to both systems results in trajectories that are identical on [0, +]. However, the applied control does not affect the outputs, y(t) and y (t),
of  and  , respectively, over the interval [0, +], because
the measured outputs are of past states. Let B = B(x0, U , +) = x0 + , x0 -  and B =
B(x0, U , +) = x0 +  , x0 -  be the time-limited backward reachable sets from x0 for  and  , respectively, by
Lemma 1. Since the time-limited backward reachable set from x0 is not a singleton for either  or  , knowledge of x0 fails to distinguish  from  .3
Let the outputs be y(0) = x( ) = y (0) = x ( ) = x-1, where x-1  B  B . This is always possible because B 
B . Apply a control u(t) to  that is a solution to x (t) = u(t) with x( ) = x-1 and x(0) = x0, and apply the control
(u (t), [ , 0]) = (u(t +  -  ), [ ,  -  ])  (0, ( - , 0]) to  with x ( ) = x-1 (see the inputs in Figure 2). We
have

0
x-1 + u(t) dt =



 -

0

x-1 +

u(t +  -  ) dt +

(0) dt = x0. (3)



 -

The trajectories of  and  are identical over the intervals [, 0] and [ ,  -  ], hence the outputs are also identical over [0, +] and  and  cannot be distinguished.

Similarly, consider delays ,   R>0 such that  >  . As above, let x(0) = x (0) = x0 and let an arbitrary
control (u(t), [0, +]) be applied to both systems, resulting in trajectories that are identical on [0, +]. The applied control does not affect the outputs, y(t) and y (t), of  and  ,

3If the system admits only one possible trajectory, then knowledge of the state at any time uniquely determines the state at all past and future times.

respectively, over the interval [0, +], because the measured
outputs are of future states. Let F = F (x0, U ,  ) = x0 - , x0 +  and F =
F (x0, U ,  ) = x0 -  , x0 +  be the time-limited forward reachable sets from x0 for  and  , respectively, by
Lemma 1. Let the outputs be y(0) = x( ) = y (0) = x ( ) = x1,
where x1  F F . This is always possible because F  F .
Apply a control u(t) to  that is a solution to x (t) = u(t) with x( ) = x1 and x(2 ) = x2, and apply the control
(u (t), [ -,  + ]) = (0, [ -,  ))(u(t+ - ), [ - ,  ]) to  with x ( ) = x1. We have

2
x1 + u(t) dt =





 +

x1 +

(0) dt +

u(t +  -  ) dt = x2. (4)

 -



The trajectories of  and  are identical over the intervals

[, 2 ] and [ ,  +  ], hence the outputs are again identical

over the interval [0,  ] and  and  cannot be distinguished.

Our proof above involves a discontinuous control function but this is for convenience only--the result immediately generalizes to continuous controls as well.
C. Identifiability and Estimability
The proof of Theorem 1 assumes that the initial state, x0, of the system is known. It is straightforward to show (although we do not do so for brevity) that, when x0 is unknown, the system state is not observable, either. Together, these identifiability and observability results have implications for filtering-based estimators that attempt to recover the state and the time delay in a recursive, causal manner.
We note that the limits on identifiability and observability considered above are related to the time delay, and not specific to the system (1). In the context of inertial navigation, for example, the gyroscope angular rate signals are usually treated in the same way as the control u(t) in (1) [29]. The proof of the local identifiability of the delay parameter in [10], given by Lemma 6.1, relies on establishing a set of constraints between time-shifted camera and IMU angular rate measurements. However, Theorem 1 applies to this system also and a unique set of such constraints can only be defined over an interval longer than the true delay. This should not be surprising, since (for either the causal or acausal case) a known, applied control u(t) does not `overlap' with the measured system output until the delay period has elapsed.
IV. RECURSIVE FILTERING
In this section, we explore how the problem of delay identifiability (and state observability) manifests in recursive filtering. Our theoretical analysis below is supported by the experimental results in Section V. We treat (1) as a simple model of an aided navigation system and refer to the sensor whose measurements drive the process model as the reference sensor.

A. Extended Kalman Filter Formulation

We apply the modified continuous-discrete (hybrid) extended Kalman filter algorithm described in [10] to the system (1). The filter state vector is

x(t) = x(t)  T

(5)

where we call x(t) the position at time t. The state evolves in continuous time according to

x (t) = u(t) + w(t),  (t) = 0.

(6)

We take the usual approach and define the noise term w(t)  GP 0, Qx(t - t ) , that is, as a zero-mean, white noise Gaussian process with the variance function Qx(t - t ), where Qx is the power spectral density and (·) is the Dirac delta function. The state mean and state covariance
are propagated forward in time using

x^ (t) = u(t), ^ (t) = 0, P (t) = Q,

(7)

where Q is a 2 × 2 matrix with Qx in the upper left and the remaining entires set to zero.4
Measurement updates occur at discrete time steps, identified by the index variable k = 1, . . . , n, for n measurements in total. The measurement yk is

yk = h (xk) + vk = x(tk +  ) + vk,

(8)

where vk  GP 0, R jk , that is, as a zero-mean, white noise Gaussian process with the variance function R jk. The noise processes are assumed to be statistically independent at all times.
In order to compute the innovation (i.e., the measurement residual) and the Kalman gain, we require the Jacobian of (8) with respect to the state vector. This step is complicated by the fact that  is a random variable. Following [10], we integrate the state and state covariance forward in time until the next measurement arrives. In a sampled-data system, the most recent control input (i.e., from the reference sensor) drives this integration. At time step k, the best estimate of the delay is ^k-1. We therefore linearize (8) about this operating point, which gives

Hk =

h = x x^- k

1

x^ (tk + ^k-1) = 1

u(tk + ^k-1) . (9)

We use the superscript minus and plus signs to denote an

estimated quantity immediately before and immediately after

the measurement update, respectively. Unlike the standard

EKF formulation, the measurement Jacobian in this case is

a function of the most recently-sampled control value, since

the control provides the only available information about the

rate of change of the state.

As final steps in the recursive EKF measurement update,

we compute the innovation variance, the Kalman gain, the

4Following the standard notation, we use the ^· (hat) to indicate an estimated quantity.

updated filter state estimate, and the updated filter state covariance matrix,

Sk = HkP-k HTk + R,

(10)

Kk = P-k HTk Sk-1,

(11)

x^+k = x^-k + Kk yk - hk x^-k ,

(12)

P+k = I - KkHk P-k ,

(13)

where yk is the most recent measurement to arrive.

B. Time as Measured by the Filter
According to (5), the filtered state estimate is maintained at time t (defined by the reference sensor clock). Critically, however, there is an ambiguity in (12) and (13) regarding the time at which the EKF update is actually applied. At each iteration, the state is integrated forward in time to tk + ^k-1, prior to the measurement update at time step k, and ^ is then modified by the update. As a result, the estimated arrival time of incoming (future) measurements is `shifted' by some amount. In turn, the state estimate maintained by the filter is not for the time tk, rather the estimate is for the time tk + ^k (immediately after a measurement update). This distinction (and shifting behaviour) is relevant to the discussion of process noice in Section IV-D.

C. Estimation of the Delay Parameter

In Section III we established that the delay parameter

requires a finite time for identification. Here, we consider

the question of whether the innovation variance, defined by

(10), represents the true uncertainty of the innovation. The

scalar term

Ss,k = HkP-k HTk

(14)

in (10) is the projection of the state uncertainty into the
measurement space. Recall that the measurement Jacobian Hk depends on u(tk + ^k-1), the most recent control.
There is a structural concern that arises immediately in (14): the applied control at time tk + ^k-1 may be very different from the applied control at an earlier or later time,
and hence the state of the system may be very different,
also. To illustrate this, consider the case where, on filter startup, ^0 = 0 and u(0)  0. The true delay is unknown and hence when the first measurement arrives, the true position of the system, x(t +  ), might be anywhere in the forward or backward reachable set from x(0) = x0, if x(0) is known. We can write (14) as

Ss,1  1

u(0)

x2,1 0

0 2,0

1

u(0) T  x2,1, (15)

where x,1 is the standard deviation of the position uncertainty just prior to the measurement update and ,0 is the standard deviation of the time delay uncertainty. Because the
control input has a value near zero, the uncertainty in the
delay is down-weighted very significantly when computing Ss,k, leading to an innovation variance that is too small and

to a spurious Kalman gain calculation.5 Further, this situation is not confined to the first measurement update--it appears at every update step (see Section IV-E).
The innovation variance should reflect the true uncertainty at each iteration, based on the reachable sets for the system, but this is not the case in general for (14) or (10). Since the Gaussian distribution has short tails, there is a risk that the innovation variance will frequently be too small (i.e., that the Gaussian will be too `narrow') leading to an inconsistent filter estimate. We show in Section V that this situation arises in practice. It is important to emphasize that the structural problem is not the result of linearization error in the model. Rather, the problem is due to an unavoidable lack of knowledge about the state and the control inputs within the delay interval. A possible `solution' is to inflate the measurement uncertainty, but this introduces a range of other concerns.
D. Estimation of the System State and Covariance
The results from Section III also have implications for the position (state) estimate and the position uncertainty. If the delay estimate is wrong, this will tend to have detrimental effect on the state estimate (because the state and the delay become correlated as the filter operates). The usual approach to handle modelling errors is to tune the filter process noise (co)variance, inflating the filter state covariance matrix as a measure of ignorance of the true model.
While the tuning of process noise is often effective, there is a second structural concern that makes tuning difficult in the case of delay estimation: discontinuous `jumps' in the delay estimate lead to jumps in the time maintained by the filter and alter the way in which process noise is incorporated.
Since the delay estimate is never exactly correct, each measurement update is always applied at an incorrect point in time. Because every measurement update alters the value of ^, there is a change in the integration period over which process noise is added. It follows that the integration period is never exactly correct and the amount of process noise added is also never `correct,' relative to the process noise that would be added in a system where the delay was known.
Depending on the sequences of `shifts' in ^, from k-1 to k and so on, the sum of the integration periods may be too long or two short. The process noise variance can only be adjusted up or down as part of the tuning process and so both cases cannot be handled simultaneously. Here, the primary concern is that the exact sequence of `jumps' is dependent on the dynamics and the random noise--the worst outcome, again, is filter inconsistency. Once the filter estimate is inconsistent, the only recourse in general is to restart the estimator.
Another interesting consequence of the structural problem described above is the possibility of `time inversion' within the filter. Consider the estimated delay ^k-1 after the measurement update at time step k - 1 and the estimated delay ^k after the measurement update at time step k. There
5The opposite case, where the innovation variance is too large, can also occur, but this is less of a concern.

is nothing that prevents the change ^ = ^k - ^k-1 from being a (relatively large) negative quantity (this can occur due to, e.g., the effects of random measurement noise). Following the discussion in Section IV-B, if the interval between measurements is short, na¨ive application of the filter time update can require the process model to operate backwards in time. The standard implementation of the EKF (and other Bayes filters) adds process noise when the filter is run forwards in time; it is not immediately clear how to handle the paradoxical (`reverse') situation in a rigorous way.

E. Effect of Recursion
The EKF maintains an estimate at a single point in time. Since the filter model is a Markov chain, there is no `memory' beyond the state-delay cross-covariance. The estimate of the delay parameter, ^, will never be exactly correct and so the structural issues (viz. identifiability/observability and `jumps' of the state in time) described in Sections IV-C and IV-D appear at every iteration.

V. SIMULATION STUDIES
In this section, we apply the algorithm of [10] to the system (1) and evaluate the performance of the estimator through Monte Carlo simulations. We consider the setting of Section IV, where the filter process model is propagated forward in continuous time while measurements arrive at discrete time steps.

A. Experiment Design

We chose two `test' trajectories with different characteristics for our evaluation. The equation of each trajectory has a smooth analytic form that is the sum of simple sinusoids, allowing derivatives to be computed exactly. Trajectory 1, shown at the top of Figure 3, is a `conservative' trajectory-- the rate of change of the velocity (i.e., the control input u(t) to the system) is limited. Trajectory 2, shown at the top of Figure 4, is a more aggressive trajectory with a larger maximum acceleration. Note that nonzero acceleration is a requirement in this case: if the velocity remains constant, the system state is unobservable and the delay parameter is unidentifiable regardless of the observation duration.6
Initially, we ran 1,000 Monte Carlo simulations for each trajectory, randomly varying the value of the (true) time delay on a per-trial basis. The delay value was sampled from a zero-mean Gaussian distribution with a standard deviation of 50 ms.7 Position updates occurred at a rate of 10 Hz (i.e., every 100 ms); each position measurement was corrupted by zero-mean Gaussian noise with a standard deviation of 0.25 m. The continuous-time power spectral density matrix [29] for the process noise was

Q=

1.0 m2/s2 0

0 0

,

(16)

6This requirement is easy to show. Under constant velocity u(t) = v,
an arbitrary time delay  can always be compensated for by a shift in the initial position state by x0 = -v , yielding the same output for y(t).
7Although we specify simulation quantities in metres and seconds for
convenience, this choice is arbitrary.

which was tuned for the experiments to ensure that the position estimate did not diverge.
At the start of each trial, the state vector and state covariance matrix were initialized to

x^0 = 0 m 0 s T ,

(17)

P^ 0 =

0.01 m2 0

0 0.25 s2

.

(18)

An initial choice of ^ = 0 s is reasonable if no prior information about the delay is available. Importantly, the uncertainty of the initial delay estimate was intentionally set to  = 0.5 s (i.e., 2 = 0.25 s2). This value is an order of magnitude larger than the standard deviation of the Gaussian distribution used to sample the true delays. We found that, without inflating the initial delay uncertainty, the filter would almost always become rapidly inconsistent or diverge (which is another indication of structural issues; see Section V-B); Our inflation of the delay uncertainty is in line with existing work (e.g., [30]).
Based on the initial results, we ran an additional set of 1,000 simulation trials (per trajectory) where we fixed the true delay value at  = -50 ms (i.e., a 50 ms lag in the measured position). We then evaluated the consistency of the estimator as described in the next section.

B. Performance Evaluation
We assessed the performance of the filter using a standard set of criteria intended to measure estimator accuracy and consistency. Accuracy can be determined by calculating the average root mean square position and delay errors across a series of time steps, over multiple simulation trials. To analyze estimator consistency, we compute two statistics, the normalized innovation squared (NIS) and the normalized estimation error squared (NEES). The NIS and NEES are defined by the quadratic forms
y,k eTy,k Sk-1ey,k and x,k eTx,k P+k -1 ex,k,
respectively, where ey,k = yk - hk x^-k is the innovation and ex,k = xk -x^k is the state estimate error, both calculated at time step k [31]. If the estimator is consistent, y,k and x,k should follow 2 distributions with one and two degrees of freedom, respectively. We follow the usual practice of computing the average NEES (ANEES) over multiple trials [31], [32].
Results from the Monte Carlo simulations with varying delays are summarized in Tables I and II. Several general trends are apparent: while the RMS position error remains relatively small (in part due to tuning of the process noise), the RMS error for the time delay is large on average even by time step 20. In fact, the delay error after 20 to 40 time steps is larger on average than the initial error. We also determined the number of times the error in the filter estimate of the time delay was within the computed 3 bounds after 100 time steps (i.e., 10 seconds of simulation time); this occurred for only 189 out of 1,000 trials for Trajectory 1 and for just 3 out of 1,000 trials for Trajectory 2. Although Trajectory

Fig. 3. Results from one Monte Carlo simulation. Top: Trajectory 1. Middle: Position and time delay errors (blue solid lines) and associated 3 bounds (red dashed lines) with respect to time step. Bottom: Filter NIS and NEES with respect to time step. In this case, the filter is inconsistent and displays apparent divergence. The true delay value was  = 5.9 ms.
2 is more `informative' than Trajectory 1 (i.e., has greater excitation), Table 2 indicates that the RMS delay error for Trajectory 2 is substantially larger than for Trajectory 1.
In Figure 3 and Figure 4, results from one simulation of Trajectory 1 and one simulation of Trajectory 2 are shown, respectively. Figure 3 displays the phenomenon of apparent divergence of the delay estimate, that is, convergence to an incorrect, biased value [33]. By the 10-second mark, the inconsistency is severe enough that the filter is insensitive to additional data--even if the simulation is run for 100 seconds, the delay estimate does not improve (or converge). The outcome is the same for Trajectory 2, although the delay estimate is significantly worse. In both cases, a large number of the NIS values are much greater than one (confirming the analysis in Section IV-C). Importantly, the performance suggested by these examples is better than for many of the random trials.
Results from the Monte Carlo simulations with the fixed time delay of  = -50 ms are summarized in Table III. The ANEES statistics show that the filter is frequently highly inconsistent, for both trajectories. These results support the arguments from theory in Section IV that the structure of the filter is unsound.
C. Discussion
Our experimental results verify that fundamental problems exist with the structure of the EKF as a recursive estimator for time delays. In addition to being prone to bias and inconsistency, the filter is highly sensitive to initial conditions and

Fig. 4. Results from one Monte Carlo simulation. Top: Trajectory 2. Middle: Position and time delay errors (blue solid lines) and associated 3 bounds (red dashed lines) with respect to time step. Bottom: Filter NIS and NEES with respect to time step. The delay estimate rapidly becomes inconsistent and ultimately diverges (beyond the 10-second window shown). The true delay value was  = -84.2 ms.
to random noise. There is a complex interplay between the system dynamics, the delay magnitude, and the noise terms involved that makes tuning difficult. Although we analyzed the simple system (1) only, the same structural problems exist for delay estimation in standard GNSS-aided and visionaided inertial navigation systems and in other multisensor systems. We posit that results presented in the literature to date, which show convergence of delay estimates, may not hold in the general case of varying dynamics and without careful tuning.
VI. CONCLUSION
We have examined the application of recursive, causal filtering (in particular, the EKF) to state and delay estimation, as proposed recently in the literature. Our analysis of the identifiability of the delay parameter for a simple time-delay system implies that the standard error calculation employed in the filter update step is specious. In turn, the corrected state and delay estimates are prone to being inconsistent. Further, the shift in the value of the delay parameter alters the way in which process noise is incorporated within the filtering framework. We emphasize that these issues are structural and not due to incorrect tuning of noise terms or to a lack of knowledge of the dynamics. Our experimental results confirm that the EKF formulation is very sensitive to initial conditions and generally produces inconsistent, biased delay estimates (and poorer-quality state estimates as well). Timevarying delays or measurement jitter may further degrade estimator performance.

TABLE I RMS POSITION ERROR VERSUS TIME STEP. EACH ENTRY IS THE RMS
ERROR OVER 1,000 SIMULATION TRIALS WITH VARYING DELAYS.

TABLE III AVERAGE NEES VERSUS TIME STEP. EACH ENTRY IS THE ANEES OVER
1,000 SIMULATION TRIALS WITH THE FIXED DELAY  = -50 MS.

Time Step Trajectory 1 Trajectory 2

20 0.122 0.107

RMS Position Error [m]

40

60

80

0.126 0.117

0.114 0.109

0.102 0.106

100 0.102 0.112

ANEES

Time Step

20

40

60

80

100

Trajectory 1 10.6

24.1

45.5

54.1

54.6

Trajectory 2 54.9 137.5 254.5 376.3 520.4

TABLE II RMS DELAY ERROR VERSUS TIME STEP. EACH ENTRY IS THE RMS ERROR OVER 1,000 SIMULATION TRIALS WITH VARYING DELAYS.

Time Step

RMS Delay Error [ms]

20

40

60

80

100

Trajectory 1

81

111

127

131

132

Trajectory 2

128

151

165

175

182

While we do not suggest an immediate remedy for the problems above, there are several possibilities to explore. One option is to employ a modified, sliding-window estimator (similar to [6]), where the window size is sufficient to `cover' any feasible delay interval. The price for this approach is the computational overhead of the windowed algorithm and the inherent lag in the state and parameter estimates. Another solution would be to examine the design of a stochastic observer (e.g., a chain observer) for a specific system of interest. It may be possible to derive valuable convergence results in certain cases. We are currently reviewing extensions to invariant filtering on the appropriate Lie group (e.g., SE(3) in the case of aided inertial navigation).
REFERENCES
[1] J. Kelly and G. S. Sukhatme, "A General Framework for Temporal Calibration of Multiple Proprioceptive and Exteroceptive Sensors," in Experimental Robotics: The 12th Int. Symp. Experimental Robotics. Springer, 2014, vol. 79, pp. 195­209.
[2] E. Mair, M. Fleps, M. Suppa, and D. Burschka, "Spatio-Temporal Initialization for IMU to Camera Registration," in Proc. IEEE Int. Conf. Rob. Biomimetics (ROBIO'11), Dec. 2011, pp. 557­564.
[3] J. Kelly, N. Roy, and G. S. Sukhatme, "Determining the Time Delay Between Inertial and Visual Sensor Measurements," IEEE Trans. Robotics, vol. 30, no. 6, pp. 1514­1523, Dec. 2014.
[4] P. Furgale, J. Rehder, and R. Siegwart, "Unified Temporal and Spatial Calibration for Multi-Sensor Systems," in Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems (IROS'13), Nov. 2013, pp. 1280­1286.
[5] J. Rehder, R. Siegwart, and P. Furgale, "A General Approach to Spatiotemporal Calibration in Multisensor Systems," IEEE Trans. Robotics, vol. 32, no. 2, pp. 383­398, Apr. 2016.
[6] T. Qin and S. Shen, "Online Temporal Calibration for Monocular Visual-Inertial Systems," in Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems (IROS'18), Oct. 2018, pp. 3662­3669.
[7] J.-O. Nilsson, I. Skog, and P. Ha¨ndel, "Joint State and Measurement Time-Delay Estimation of Nonlinear State Space Systems," in Proc. 10th Int. Conf. Information Science, Signal Processing and their Applications (ISSPA'10), May 2010, pp. 324­328.
[8] I. Skog and P. Ha¨ndel, "Time Synchronization Errors in Loosely Coupled GPS-Aided Inertial Navigation Systems," IEEE Trans. Intelligent Transportation Systems, vol. 12, no. 4, pp. 1014­1023, Dec. 2011.
[9] M. Li and A. I. Mourikis, "3-D Motion Estimation and Online Temporal Calibration for Camera-IMU Systems," in Proc. IEEE Int. Conf. Robotics and Automation (ICRA'13), May 2013, pp. 5709­5716.
[10] ----, "Online temporal calibration for camera-IMU systems: Theory and algorithms," Int. J. Rob. Res., vol. 33, no. 7, pp. 947­964, June 2014.

[11] J.-P. Richard, "Time-delay systems: an overview of some recent advances and open problems," Automatica, vol. 39, no. 10, pp. 1667­ 1694, Oct. 2003.
[12] D. Simon, Optimal State Estimation: Kalman, H, and Nonlinear Approaches, 1st ed. Wiley-Interscience, June 2006.
[13] S. C. A. Thomopoulos and L. Zhang, "Decentralized Filtering with Random Sampling and Delay," Information Sciences, vol. 81, no. 1-2, pp. 117­131, Nov. 1994.
[14] T. D. Larsen, N. A. Andersen, O. Ravn, and N. K. Poulsen, "Incorporation of Time Delayed Measurements in a Discrete-time Kalman Filter," in Proc. IEEE Conf. Decision and Control (CDC'98), vol. 4, Dec. 1998, pp. 3972­3977.
[15] S. J. Julier and J. K. Uhlmann, "Fusion of Time Delayed Measurements with Uncertain Time Delays," in Proc. American Control Conf. (ACC'05), vol. 6, June 2005, pp. 4028­4033.
[16] M. Choi, J. Choi, J. Park, and W. K. Chung, "State Estimation with Delayed Measurements Considering Uncertainty of Time Delay," in Proc. IEEE Int. Conf. Robotics and Automation (ICRA'09), May 2009, pp. 3987­3992.
[17] X. Xia, L. A. Ma´rquez, P. Zagalak, and C. H. Moog, "Analysis of nonlinear time-delay systems using modules over non-commutative rings," Automatica, vol. 38, no. 9, pp. 1549­1555, Sep. 2002.
[18] J. Zhang, X. Xia, and C. Moog, "Parameter Identifiability of Nonlinear systems with Time-Delay," IEEE Trans. Automatic Control, vol. 51, no. 2, pp. 371­375, Feb. 2006.
[19] M. Anguelova and B. Wennberg, "State elimination and identifiability of delay parameters for nonlinear systems with multiple time-delays," IFAC Proceedings Volumes, vol. 40, no. 23, pp. 209­214, Sep. 2007.
[20] ----, "State elimination and identifiability of the delay parameter for nonlinear time-delay systems," Automatica, vol. 44, no. 5, pp. 1373­ 1378, May 2008.
[21] O. Sename, "New trends in design of observers for time-delay systems," Kybernetika, vol. 37, no. 4, pp. 427­458, 2001.
[22] A. Germani, C. Manes, and P. Pepe, "A New Approach to State Observation of Nonlinear Systems With Delayed Output," IEEE Trans. Automatic Control, vol. 47, no. 1, pp. 96­101, Jan. 2002.
[23] N. Kazantzis and R. A. Wright, "Nonlinear observer design in the presence of delayed output measurements," Systems & Control Letters, vol. 54, no. 9, pp. 877­886, Sep. 2005.
[24] R. Hermann and A. J. Krener, "Nonlinear Controllability and Observability," IEEE Trans. Automatic Control, vol. AC­22, no. 5, pp. 728­740, Oct. 1977.
[25] R. Bellman and K. J. A° stro¨m, "On Structural Identifiability," Mathematical Biosciences, vol. 7, no. 3, pp. 329­339, Apr. 1970.
[26] M. S. Grewal and K. Glover, "Identifiability of Linear and Nonlinear Dynamical Systems," IEEE Trans. Automatic Control, vol. 21, no. 6, pp. 833­837, Dec. 1976.
[27] S. M. LaValle, Planning Algorithms. Cambridge University Press, May 2006.
[28] S. Bansal, M. Chen, S. Herbert, and C. J. Tomlin, "Hamilton-Jacobi Reachability: A Brief Overview and Recent Advances," in Proc. IEEE Int. Conf. Decision and Control (CDC'17), Dec. 2017, pp. 2242­2253.
[29] J. A. Farrell, Aided Navigation: GPS with High Rate Sensors, ser. Electronic Engineering. McGraw-Hill, Mar. 2008.
[30] P. Geneva, K. Eckenhoff, W. Lee, Y. Yang, and G. Huang, "OpenVINS: A Research Platform for Visual-Inertial Estimation," in Proc. IEEE Int. Conf. Robotics and Automation (ICRA'20), May/June 2020.
[31] Y. Bar-Shalom, X. R. Li, and T. Kirubarajan, Estimation with Applications to Tracking and Navigation. Wiley-Interscience, June 2001.
[32] Z. Chen, C. Heckman, and S. J. and, "Weak in the NEES?: AutoTuning Kalman Filters with Bayesian Optimization," in Proc. Int. Conf. Information Fusion (FUSION'18), July 2018, pp. 1072­1079.
[33] A. Gelb, Ed., Applied Optimal Estimation. MIT Press, May 1974.

