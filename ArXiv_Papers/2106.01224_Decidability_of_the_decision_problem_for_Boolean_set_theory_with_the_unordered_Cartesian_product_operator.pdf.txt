arXiv:2106.01224v1 [math.LO] 2 Jun 2021

Decidability of the decision problem for Boolean set theory with the unordered
Cartesian product operator
Domenico Cantone and Pietro Ursino Dipartimento di Matematica e Informatica, Universit`a di Catania
Viale Andrea Doria 6, I-95125 Catania, Italy. E-mail: domenico.cantone@unict.it,pietro.ursino@unict.it
June 3, 2021
Abstract The satisfiability problem for multilevel syllogistic extended with the Cartesian product operator (MLS×) is a long-standing open problem in computable set theory. For long, it was not excluded that such a problem were undecidable, due to its remarkable resemblance with the well-celebrated Hilbert's tenth problem, as it was deemed reasonable that union of disjoint sets and Cartesian product might somehow play the roles of integer addition and multiplication. To dispense with nonessential technical difficulties, we report here about a positive solution to the satisfiability problem for a slight simplified variant of MLS×, yet fully representative of the combinatorial complications due to the presence of the Cartesian product, in which membership is not present and the Cartesian product operator is replaced with its unordered variant. We are very confident that such decidability result can be generalized to full MLS×, though at the cost of considerable technicalities.
Introduction
The decision problem in set theory has been studied quite thoroughly in the last decades, giving rise to the field of Computable Set Theory [CFO89]. The
We gratefully acknowledge partial support from the projects STORAGE and MEGABIT ­ Universit`a degli Studi di Catania, PIAno di inCEntivi per la RIcerca di Ateneo 2020/2022 (PIACERI), Linea di intervento 2.
1

initial goal was the mechanical formalisation of mathematics with a proof verifier based on the set-theoretic formalism [OS02, COSU03, OCPS06, SCO11], but soon a foundational interest aimed at the identification of the boundary in set theory between the decidable and the undecidable became more and more compelling.
The precursor fragment of set theory investigated for decidability was MLS, which stands for Multi-Level Syllogistic. MLS consists of the quantifierfree formulae of set theory involving only the Boolean set operators , , \ and the relators = and , besides set variables (assumed to be existentially quantified). The satisfiability problem (s.p., briefly) for MLS has been solved in the seminal paper [FOS80], and its NP-completeness has later been proved in [COP90]. Following that, several extensions of MLS with various combinations of the set operators {·} (singleton), pow (power set), (unary union), (unary intersection), rk (rank), etc., and of the set predicates rank comparison, cardinality comparison, finiteness, etc., have been also proved decidable over the years.1
However, the s.p. for the extension MLS× of MLS with the Cartesian product ×,2 proposed by the first author since the middle 80s, soon appeared to be very challenging and resisted several efforts to find a solution, either positive or negative. As a matter of fact, for long it was not excluded that the s.p. for MLS× were undecidable (in particular, when restricted to finite models), due to its remarkable resemblance with the well-celebrated Hilbert's Tenth problem (HTP, for short), posed by David Hilbert at the beginning of last century [Hil02].3 Indeed, it was deemed reasonable that the union of disjoint sets and the Cartesian product might somehow play the roles of integer addition and multiplication in HTP, respectively, in consideration of the fact that |s  t| = |s| + |t|, for any disjoint sets s and t, and |s × t| = |s| · |t|, for any sets s and t.
Attempts to solve the s.p. for MLS× helped shaping the development of computable set theory and led to the introduction of the powerful technique of formative processes,4 which has been at the base of the highly technical
1The monographs [CFO89, COP01, SCO11, OPT17, CU18] provide a rather comprehensive account.
2For definiteness, we may assume that the Cartesian product is expressed in terms of Kuratowski's ordered pairs (u, v) := {{u}, {u, v}}.
3We recall that HTP asks for a uniform procedure that can determine in a finite number of steps whether any given Diophantine polynomial equation with integral coefficients is solvable in integers. In 1970, it was shown that no algorithmic procedure exists for HTP, as result of the combined efforts of M. Davis, H. Putnam, J. Robinson, and Y. Matiyasevich (DPRM theorem, see [Rob56, DPR61, Mat70]).
4See [CU18] for a quite friendly introduction.
2

solutions to the decision problems for the extension MLSSP of MLS with the power set and the singleton operators [COU02] and the extension MLSSPF with the finiteness predicate too [CU14].
In this paper, we provide a positive solution to the s.p., both unrestricted and restricted to (hereditarily) finite models, for the fragment of set theory dubbed BST, which is closely related to MLS×. The fragment BST (which stands for Boolean Set Theory with the unordered Cartesian product ) is obtained by dropping the membership predicate  from MLS× and by replacing the (ordered) Cartesian product operator × with its unordered variant , where s  t is the collection of all unordered pairs {u, v} such that u  s and v  t, namely s  t := {u, v} | u  s  v  t (for any sets s and t).
Notice that none of the above two changes affects the aforementioned resemblance with HTP. The reason why we chose to address here the case of BST rather than the one of MLS× is that in doing so we can get rid of irrelevant features that would only make our analysis much more technical. Nevertheless, we plan to report on the s.p. for the fragments BST× and MLS× in a future paper.5
For both variants of the s.p., we shall provide nondeterministic exponential decision procedures. These will be expressed in terms of the existence of a special graph, called -graph, enjoying a certain connectivity property of accessibility. Given a BST-formula  to be tested for satisfiability, in the case of the ordinary s.p. it will be enough to require that a candidate accessible -graph fulfills , whereas in the case of the finite s.p. it will be additionally required that the -graph admits also a kind of topological order. In both cases, it will be shown that, when satisfied, these conditions (which are also necessary) ensure that the -graph can be used as a kind of flow graph to build a model for  in denumerably many steps (in the case of the ordinary s.p.) or in a bounded finite number of steps (in the case of the (hereditarily) finite s.p.). Such construction process is a simplified form of the formative processes mentioned before.
As shown in [Schw78, CCS90], the finite s.p. for the extension of MLS with cardinality comparison, namely the two-place predicate | · | | · | for cardinality comparison, where |s| |t| holds if and only if the cardinality of s does not exceed that of t, can be reduced to purely existential Presburger arithmetic, which is known to be NP-complete (see [Sca84]). On the other hand, when BST× or BST is enriched with cardinality comparison, the s.p. for the resulting extension become undecidable, since HTP would be
5Naturally, BST× is Boolean Set Theory with Cartesian product.
3

reducible to it, much as proved in [CCP90] and [COP20] for MLS. This is clear evidence that the decision problem for both BST× and BST is very close to the border of decidability.
------------------------------ The paper is organized as follows. In Section 1 we introduce the fragment of our interest BST through its syntax and semantics. In particular, semantics is presented in terms of satisfying partitions, and it is shown that such approach leads easily to the decidability of the purely Boolean subset of BST. It is also defined a useful variant of the intersecting power set operator, in terms of which the unordered Cartesian product is easily expressible. Subsequently, in Section 2, we introduce the central notion of accessible -graphs, together with that of fullfilment of a BST-formula by an accessible -graph, and we prove that any satisfiable BST-formula is fulfilled by a suitable accessible -graph. We also prove that such condition is sufficient for the satisfiability of , by describing in details a construction process that uses an accessible -graph fulfilling  as a kind of flow graph to build a model for  in denumerably many steps. Afterward, in Section 3, we introduce the notion of ordered -graphs, and prove that the existence of an ordered -graph fulfilling a given BST-formula  is a necessary and sufficient condition for  to be (hereditarily) finitely satisfiable. Finally, in Section 4, we discuss some plans for future research.
1 The fragment BST
BST is the quantifier-free fragment of set theory consisting of the propositional closure of atoms of the following types:
x = y  z, x = y  z, x = y \ z, x = y  z, x  y
where x, y, z stand for set variables. For any BST-formula , we denote by Vars() the collection of set variables occurring in it.
1.1 Semantics of BST
The semantics of BST is defined in a very natural way in terms of set assignments.
A set assignment M is any map from a collection V of set variables (called the variables domain of M and denoted dom(M )) into the von Neumann universe V of all well-founded sets.
4

We recall that V is a cumulative hierarchy constructed in stages by transfinite recursion over the class On of all ordinals. Specifically, V :=
On V where, recursively, V := < pow(V), for every   On, with pow(·) denoting the powerset operator. Based on such construction, we can readily define the rank of any well-founded set s  V, denoted rk s, as the least ordinal  such that s  V. The collection of the sets of finite rank, hence belonging to V for some finite ordinal , forms the set HF of the hereditarily finite sets. Thus, HF = V, where  is the first limit ordinal, namely the smallest non-null ordinal with no immediate predecessor.
Given a set assignment M and a collection of variables W  dom(M ), we put M W := {M v | v  W }. The set domain of M is defined as the set
M V = vV M v. The rank of M is the rank of its set domain, namely, rk M := rk( M V ) (so that, when V is finite, rk M = maxvV rk M v). A set assignment M is finite (resp., hereditarily finite), if so is its set domain.
Operators and relators of BST are interpreted according to their usual semantics. Thus, given a set assignment M , for any x, y, z  dom(M ) we put:

M (x  y) := M x  M y,

where   {, , \}, and

M (x = y  z) = true M (x  y) = true

D-ef D-ef

M x = M (y  z), Mx  My.

Finally, we put recursively

M (¬) := ¬M ,

M (  ) := M   M ,

M (  ) := M   M , M (  ) := M   M , etc.,

for all BST-formulae  and  such that Vars(), Vars()  dom(M ). Given a BST-formula , a set assignment M over Vars() is said to
satisfy  if M  = true holds, in which case we also write M |=  and say that M is a model for . If  has a model, we say that  is satisfiable; otherwise, we say that  is unsatisfiable. If M |=  and M is finite (resp., hereditarily finite), then  is finitely satisfiable (resp., hereditarily finitely satisfiable).
Two BST-formulae  and  are equisatisfiable when  is satisfiable if and only if so is , possibly by distinct models.

5

The decision problem or satisfiability problem for BST is the problem of establishing algorithmically whether any given BST-formula is satisfiable or not by some set assignment.
By restricting to (hereditarily) finite set assignments, one can define in the obvious way the (hereditarily) finite satisfiability problem for BST.
1.2 Satisfiability by partitions
A partition is a collection of pairwise disjoint non-null sets, called the blocks of the partition. The union  of a partition  is its domain.
Let V be a finite collection of set variables and  a partition. Also, let I : V  pow() be any map. In a very natural way, the map I induces a set assignment MI over V definded by:
MIv := I(v), for v  V .
We refer to the map I (or to the pair (, I), when we want to emphasize the partition ) as a partition assignment.
Definition 1. Let  be a partition and I : V  pow() be a partition assignment over a finite collection V of set variables. Given a BST-formula  such that Vars()  V , we say that I satisfies , and write I |= , when the set assignment MI induced by I satisfies  (equivalently, one may say that  satisfies  via the map I, and write /I |= , if we want to emphasize the partition ). We say that  satisfies , and write  |= , if  satisfies  via some map I : V  pow().
The following result can be proved immediately.
Lemma 1. If a BST-formula is satisfied by a partition , then it is satisfied by any partition  that includes  as a subset, namely such that   .
Plainly, a BST-formula  satisfied by some partition is satisfied by a set assignment. Indeed, if  |= , then /I |=  for some map I : V  pow(), and therefore MI |= . The converse holds too. In fact, let us assume that M |= , for some set assignment M over the collection V = Vars() of the set variables occurring in , and let M be the Venn partition induced by M , namely
M := M V  \ M (V \ V ) |  = V   V \  .6
6

Let IM : V  pow(M ) be the map defined by
IM (v) := {  M |   M v}, for v  V .
It is an easy matter to check that the set assignment induced by IM is just M . Thus M /IM |= , and therefore M |= , proving that  is satisfied by some partition, in fact by the Venn partition induced by M , whose size is at most 2|V | - 1.
Thus, the notion of satisfiability by set assignments and that of satisfiability by partitions coincide.
As a by-product of Lemma 1 and the above considerations, we also have:
Lemma 2. Every BST-formula  with n distinct variables is satisfiable if and only if it is satisfied by some partition with 2n - 1 blocks.

1.3 Normalization of BST-formulae
By applying disjoint normal form and the simplification rules illustrated in [CU18], the satisfiability problem for BST can be reduced to the satisfiability problem for normalized conjunctions of BST, namely conjunctions of BST-literals of the following restricted types:

x = y  z, x = y \ z, x = y  z, x = y,

(1)

where x, y, z stand for set variables. Indeed, it is enough to observe that:
­ x  y is equivalent to x = x  y;
­ the terms y  z and y \ (y \ z) are equivalent, so an atom of the form x = y  z is equisatisfiable with the conjunction x = y \ y  y = y \ z, where y stands for any fresh set variable;
­ each negative literal of the form x = y  z (with   {, , \, }) is equisatisfiable with the conjunction x = y z  x = x, where x stands for any fresh set variable.
6Hence, we have: - (  M )(v  V )(  M v =     M v), - (,   M ) (v  V )(  M v    M v)   =  , and -  = MV .

7

1.4 The Boolean case
In the restricted case of BST-conjunctions, namely conjunctions of Boolean literals of the form
x = y  z, x = y \ z, x = y,
the satisfiability status by a given partition  does not depend in any way on the internal structure of its blocks, but just on their numerousness. This is proved in the following lemmas.
Lemma 3. Let  be a partition and let I : V  pow() be a partition assignment over a (finite) set of variables V . Then, for all x, y, z  V and   {, \}, we have:
(a) I |= x = y  z  I(x) = I(y)  I(z),
(b) I |= x = y  I(x) = I(y).
Proof. It is enough to observe that since  is a partition (and therefore its blocks are nonempty and mutually disjoint), then for all x, y, z  V and   {, \ } we have:
I |= x = y  z  I(x) = I(y)  I(z)  I(x) = I(y)  I(z)  I(x) = I(y)  I(z)
and I |= x = y  I(x) = I(y)  I(x) = I(y).
Satisfiability of BST-conjunction can be expressed in purely combinatorial terms by means of fulfilling maps. Definition 2. Let  be a BST-conjunction, and let F : V  pow(pow+(V )) be any map, where V := Vars() and pow+(V ) := pow(V ) \ . We say that the map F fulfills  provided that:
(a) F(x) = F(y)  F(z), for each conjunct x = y  z in , with   {, \};
(b) F(x) = F(y), for each conjunct x = y in .
A map F satisfying conditions (a) and (b) above will be called a fulfilling map for .
8

Remark 1. In Section 2.2, fulfilling maps will be defined differently, in the context of the s.p. for BST. However, such an overloading should create no problems.
Lemma 4. A BST-conjunction is satisfiable if and only if it is fulfilled by some fulfilling map.
Proof. Let  be a BST-conjunction and let V := Vars(). For the sufficiency part, let us first assume that  is satisfied by a par-
tition  via a certain map I : V  pow(). For each   , we put:

V := {v  V |   I(v)}. Then, we define the map FI : V  pow(pow+(V )) by putting

FI(x) := {V |   I(x)}, for x  V.

Preliminarily, we observe that

V  FI(x)    I(x), for    and x  V .

(2)

Indeed, if V  FI(x), then V = V , for some   I(x). But then, since   I(v)    I(v), for all v  V , we have   I(x).
Thus, for every conjunct x = y  z in  (with   {, \}), we have:

FI(x) = {V |   I(x)} = {V |   I(x)} = {V |   I(y)  I(z)} = {V |   I(y)}  {V |   I(z)} = FI(y)  FI(z).

(by Lemma 3(a)) (by (2))

Likewise, for every conjunt x = y in , by Lemma 3(b) and (2), we have:

FI(x) = {V |   I(x)} = {V |   I(y)} = FI(y).

Thus, the map FI fulfills .
Conversely, for the necessity part, let us assume that  is fulfilled by a map F : V  pow(pow+(V )). Let F be any partition of size |pow+(V )|, and let  : pow+(V )  F be any bijection from pow+(V ) onto F. Let us define the map IF : V  pow(F) by setting

IF(x) := [F(x)], for x  V.

9

But then, for every literal x = y  z in  (with   {, \}), we have:
IF(x) = [F(x)] = [F(y)]  [F(z)] = [F(y)  F(z)] = IF(y)  IF(z).
Hence, by Lemma 3(a), IF |= x = y  z. Similarly, for every conjunct x = y in , we have
IF(x) = [F(x)] = [F(y)] = IF(y),
proving that, by Lemma 3(b), IF |= x = y. Hence, in conclusion, we have IF |= , proving that  is satisfiable.
An immediate consequence of the preceding lemma is the following result.
Lemma 5. A BST-conjunction with n distinct variables is satisfiable if and only if it is satisfied by every partition of size 2n - 1.
In fact, in the light of [CU18, Lemma 2.36, p. 42] and Lemma 2, one can prove the following stronger result:
Lemma 6. A BST-conjunction involving n distinct variables is satisfiable if and only if it is satisfied by every partition of size n - 1.
In view of the preceding lemma, Lemma 4 can be so strengthened:
Lemma 7. A BST-conjunction over a set V of variables is satisfiable if and only if it is fulfilled by a map F : V  pow(pow+(V )) such that |F[V ]| |V | - 1.
Both previous two lemmas readily yield that the satisfiability problem for BST-conjunctions can be solved in nondeterministic polynomial time, namely it belongs to the class NP.
As shown in [CDMO19], the satisfiability problem for conjunctions of Boolean literals of the form t1 = t2, where t1 and t2 are set terms involving only variables and the set difference operator `\', is NP-complete. Therefore, we have:
Lemma 8. The satisfiability problem for BST-conjunctions is NP-complete.
10

1.5 Dealing also with literals of type x = y  z: the intersecting power set operator
We shall express the conditions that take also care of literals in BST of type x = y  z by means of some useful variants of the power set operator and the intersecting power set operator pow, defined by
pow(S) := t  S | t  s = , for every s  S
and introduced in [Can91] in connection with the solution of the satisfiability problem for a fragment of set theory involving the power set and the singleton operators.7 Specifically, for any set S, we put:
pow1,2(S) := t  pow(S) | 1 |t| 2 , pow1,2(S) := t  pow(S) | 1 |t| 2 .
Thus, - pow1,2(S) is the set of all the members of pow(S) of cardinality equal to either 1 or 2;
- pow1,2(S) is the collection of all the subsets of S of cardinality equal to either 1 or 2.
We state next a useful injectivity property of the operator pow1,2. Lemma 9. Let  be a partition. For all B, B  pow1,2(), we have
pow1,2[B] = pow1,2[B]  B = B. The pow1,2 operator is strictly connected with the unordered Cartesian operator , as we show next.
Lemma 10. For all sets s and t (not necessarily distinct), we have
pow1,2({s, t}) = s  t. Proof. Plainly, s  t  pow1,2({s, t}). Indeed, if u  s  t, then
1 |u| 2, u  s  t, and u  s =  = u  t,
so that u  pow1,2({s, t}).
7Several properties of the operator pow are listed in [CU18, pp. 16­20].
11

Conversely, let {u, v}  pow1,2({s, t}). Then {u, v}  s  t and {u, v}  s =  = {u, v}  t.

Without loss of generality, let us assume that u  s. If v  t, we are done. Otherwise, if v / t, then v  s (since {u, v}  s  t) and u  t (since {u, v}  t = ). Hence, {u, v}  s  t, proving that also the inverse inclusion pow1,2({s, t})  s  t holds.
The unordered Cartesian operator  enjoys the following distributive property.

Lemma 11 (Distributivity). For all sets S and T , the following identity

holds:

S  T = {s  t | s  S, t  T }.

(3)

Proof. Let u  S  T . Then u = {u, u} for some u  S and u  T . Hence, u  s and u  t for some s  S and t  T , so that u = {u, u} 
{s  t | s  S, t  T }. Thus,

S  T  {s  t | s  S, t  T }.

(4)

For the converse inclusion, let u  {st |s  S, t  T }. Then u  st, for some s  S and t  T , and therefore u = {u, u}, for some u  s and u  t. Since s  S and t  T , then u  S  T , and so

{s  t | s  S, t  T }  S  T.

Together with the converse inclusion (4), the latter yields (3), completing the proof of the lemma.

2 The ordinary satisfiability problem for BSTconjunctions
A result like those contained in Lemmas 5 and 6 cannot hold for BST, since the literals of type x = y  z force one to take into account also the internal structure of certain blocks in any partition that satisfies a given BST-conjunction. These are the -blocks, which are defined next.
Definition 3. A subset  of a partition  is a -subpartition of  if  = pow1,2[B], for some B    .

12

We denote by  the -maximal -subpartition of  and we refer to its elements as the -blocks of .8 We also denote by  the subset of    such that  = pow1,2[] and we refer to its elements as -upblocks (`upblocks' for unordered pair of blocks).9
As a consequence of Lemma 5 (resp., Lemma 6), to test whether a given conjunction  of BST-conjunctions with n distinct variables is satisfiable, it is enough to check whether a partition whatsoever with 2n - 1 (resp., n - 1) blocks satisfies .
In the case of BST-conjunctions with n distinct variables, rather than checking a single partition for satisfiability, one would have to test a whole collection of doubly exponential size of partitions with 2n - 1 blocks. Remarkably, the partitions in such collection can be conveniently described by special graphs, called -graphs, which enjoy a particular connectivity property termed accessibility.
Given a BST-conjunction  to be tested for satisfiability, in the case of the ordinary s.p. it will be enough to find an accessible -graph which fulfills , in the sense that will be soon made precise, whereas for the (hereditarily) finite s.p., besides accessibility and fulfillability, it will be additionally requested that the -graphs admit a "weak" topological order.
Both for the ordinary s.p. and for the (hereditarily) finite s.p. such an approach will yield nondeterministic exponential decision procedures in the number of distinct variables of the input formula.
Next, we provide precise definitions of the notions mentioned above. We begin with -graphs.
2.1 -graphs
Definition 4 (-graphs). A -graph G is a directed bipartite graph whose set of vertices comprises two disjoint parts: a set of places P and a set of nodes N , where N = P  P.10 The edges issuing from each place q are exactly all pairs q, B such that q  B  N: these are called membership edges. The remaining edges of G, called distribution or saturation edges, go from nodes to places. When there is an edge B, q from a node B to a place q, we say that q is a target of B. The map T over N defined by
T(B) := {q  P | q is a target of B}, for B  N,
8The definition of  is well given, since the collection of the -subpartitions of  is closed under union.
9By Lemma 9, the set  is well defined. 10Thus, it is required that P  (P  P) = .
13

is the target map of G. The size of G is defined as the cardinality of its set of places P. Plainly, a -graph G is fully characterized by its target map T, since the sets of nodes and of places of G are expressible as dom(T ) and dom(T ), respectively. When convenient, we shall explicitly write G = (P, N , T ) for a -graph with set of places P, set of nodes N , and target map T .
To better grasp the rationale behind the definition just stated of graphs, it is helpful to illustrate how to construct the -graph G induced by a given a partition .
To begin with, we select a set of places P of the same cardinality of  such that P and P  P are disjoint, and define the vertex set of G as the union P  (P  P). The members of P  P (namely the nonempty subsets of P having cardinality at most 2) will form the set of nodes N of G. Places in P are intended to be an abstract representation of the blocks of  via a bijection q  q(·) from P onto . Likewise, nodes in N are intended to represent the unordered Cartesian product of the blocks represented by their places. The disjoint sets P and N will form the parts of the bipartite graph G we are after. The bijection (·) can be naturally extended to nodes B of G by putting B(·) := {q(·) | q  B}.
Having defined the vertex set of G, next we describe its edge set. The edges issuing from each place q are exactly all pairs q, B such that q  B  N (membership edges of G). The remaining edges of G go from nodes to places (distribution or saturation edges of G). Only places q corresponding to -blocks q(·) of  (hence called -places) can have incoming edges. Likewise, only nodes B such that B(·)   (see Definition 3) can have outgoing edges. Such nodes will be called -nodes. Specifically, for a -node B and a -place q of G, there is an edge B, q exactly when
q(·)  pow1,2(B(·)) = ,
namely when there is some "flow" of unordered pairs from pow1,2(B(·)) to q(·) (through the edge B, q ). This is the sense in which a -graph can be considered a kind of flow graph in the realm of set theory. Thus, the target map T of G is defined by
T(B) := {q  P, | q(·)  pow1,2(B(·)) = }, for B  N,,
where P, and N, denote the collections of the -places and of the nodes of G, respectively.
14

Notice that each -node B of G has some target. Indeed, from  = pow1,2[] it follows that  = pow1,2(B(·))  , and therefore T(B) = .
2.1.1 Accessible -graphs
Only accessible -graphs are relevant for our decidability purposes.
Definition 5 (Accessible -graphs). A place of a -graph G = (P, N , T ) is a source place if it has no incoming edges. The remaining places, namely those with incoming edges, are called -places. We denote by P the collection of the -places of G.
A place of G is accessible (from the source places of G) if either it is a source place or, recursively, it is the target of some node of G whose places are all accessible from the source places of G. Finally, a -graph is accessible when all its places are accessible.11
The following result holds.
Lemma 12. The -graph G induced by a given partition  is accessible.
Proof. Let G = (P, N, T) be the -graph induced by the partition  via a given bijection q  q(·) from P onto .
For contradiction, let us assume that G is not accessible. Among the non-accessible places of G, we select a place q  P whose corresponding block q(·)  M contains an element s of smallest rank. Plainly, q(·) must be a -block, because otherwise q would be a source place and therefore it would be trivially accessible. Thus, q(·)  pow1,2[], so s  pow1,2[], where  is the collection of the -upblocks of . Hence, s = {s1, s2}  pow1,2(B(·)), for some -node B = {q1, q2} such that s1  q1(·) and s2  q2(·), and therefore q  T(B). Since q1(·) and q2(·) contain elements of rank strictly less than the rank of s, the places q1 and q2 must be accessible. Thus, after all, the place q would be one of the targets of a node whose places are both accessible, and therefore it would be accessible, contradicting our assumption. Hence, G is accessible.
2.2 Fulfillment by an accessible -graph
Our next task is to figure out which additional properties are enjoyed by the -graph G induced by a partition  (via a certain bijection q  q(·) from P onto ) that satisfies a given BST-conjunction .
11Thus, a -graph with no source places is trivially not accessible.
15

Thus, let us assume that  satisfies a conjunction  via a partition assignment I : Vars()  pow(). Our sought-after properties will pertain the abstraction F : Vars()  pow(P) of the map I, which is defined by
F(x) := {q  P | q(·)  I(x)}, for x  Vars().
For every literal x = yz in , with   {, \}, we have I |= x = yz and therefore, by Lemma 3, I(x) = I(y)  I(z). Hence, F(x) = F(y)  F(z).
Similarly, for every literal x = y in , we have I |= x = y, and therefore (again by Lemma 3) I(x) = I(y). Thus, we can derive F(x) = F(y).
Finally, let x = y  z be a -literal in , so that

I(x) = I(y)  I(z)

(5)

holds. We preliminarily observe that I(x)  . Indeed, by (5), I(x) =
pow1,2[I(y)  I(z)], and therefore I(x) is a -subpartition of . Let   F(y) and   F(z). Then (·)  I(y) and (·)  I(z), and
consequently, by (5), (·)  (·)  I(x). Hence,
 = q(·)   | q(·)  ((·)  (·)) =   I(x)

and therefore  = q(·)   | q(·)  ((·)  (·)) =   I(x).

Thus,

 = q  P | q(·)  ((·)  (·)) =   F(x)  P,

so that

 = T({, }) = q  P, | q(·)  ((·)  (·)) =   F(x).

Next, let q  F(x), so that q(·)  I(x). Let s  q(·). Hence, by (5), s  I(y)  I(z), and therefore s  (·)  (·), for some ,   P such that (·)  I(y) and (·)  I(z). Thus,   FM (y) and   FM (z). Since q(·)  ((·)  (·)) =  and q(·)  , we have q  T({, }) 
T[F(y)  F(z)]. Hence, from the arbitrariness of q  F(x), it follows
that

F(x)  T[F(y)  F(z)].

(6)

16

Finally, we prove that also the following identity holds:

T[N \ (F(y)  F(z))]  F(x) = .

(7)

For contradiction, let us assume that there exists some q  T[N\(F(y) F(z))]  F(x). Hence, q  T(A), for some A  N \ (F(y)  F(z)). Since q(·)  pow1,2(A(·)) =  and q(·)  I(x), by (5) pow1,2(A(·))  ( I(y) 
I(z)) = , and therefore A(·)  I(y)I(z). The latter membership implies
A  F(y)  F(z), which is a contradiction, thus proving (7).
We can summarize what we have just proved by saying that the accessible -graph induced by a partition  satisfying a given BST-conjunction 
fulfills , according to the following definition.

Definition 6 (Fulfillment by an accessible -graph). An accessible -graph G = (P, N , T ) fulfills a given BST-conjunction  provided that there exists a map F : Vars()  pow(P) (called a G-fulfilling map for ) such that the following conditions are satisfied:

(a) F(x) = F(y)  F(z), for every conjunct x = y  z in , where   {, \};

(b) F(x) = F(y), for every conjunct x = y in ;

(c) for every conjunct x = y  z in ,

(c1)  = T ({, })  F(x), for all   F(y) and   F(z); (c2) F(x)  T [F(y)  F(z)]; (c3) T [N \ (F(y)  F(z))]  F(x) = .

Thus, the results just proved can be stated as follows.
Lemma 13. The accessible -graph induced by a partition satisfying a given BST-conjunction  fulfills .
As an immediate consequence, we have:
Corollary 1. A satisfiable BST-conjunction with n variables is fulfilled by an accessible -graph of size (at most) 2n - 1.
Proof. Let  be a satisfiable BST-conjunction with n variables. As stated in Lemma 2,  is satisfied by a partition  with exactly 2n - 1 blocks. Thus, the -graph G induced by  has size 2n - 1 and, by Lemmas 12 and 13, it is accessible and fulfills .

17

2.3 Construction process
Lemma 13 can be reversed, thus yielding a decision procedure for BSTconjunctions.
Lemma 14. If a BST-conjunction is fulfilled by an accessible -graph, then it is satisfiable.
Proof. Let G = (P, N , T ) be an accessible -graph, and let us assume that G fulfills a given BST-conjunction  via the map F : Vars()  pow(P).
To each place q  P, we associate a set q(·), initially empty. Then, by suitably exploiting the -graph G as a kind of flow graph, we shall show that the sets q(·)'s can be monotonically extended by a (possibly infinite) construction process (comprising a finite initialization phase and a subsequent (possibly infinite) stabilization phase) in such a way that the following properties hold:
(P1) After each step, the sets q(·)'s are pairwise disjoint.
(P2) At the end of the initialization phase all the q(·)'s are nonempty (and pairwise disjoint). Thus, after each step in the subsequent stabilization phase, the sets q(·)'s, with q  P, form a partition equipollent with P.
(P3) After each step in the stabilization phase, the inclusion
q(·)  pow1,2(A(·)) | A  T -1(q)
holds, for each -place q  P, where we are using the notation B(·) := {p(·) | p  B} for B  N .
(P4) At the end of the construction process, we have
pow1,2(A(·))  {q(·) | q  T (A)},
for each -node A  N (namely for each node A  N such that T (A) = ).12
Subsequently, we shall prove that the properties (P1)­(P4) together with the conditions (a)­(c) of Definition 6, characterizing the fulfilling -graph
12Should the construction process involve denumerably many steps, the final values of the q(·)'s are to be intended as limit of the sequences of their values after each step in the stabilization phase.
18

G, allow one to show that the partition {q(·) | q  P} resulting from the above construction process satisfies our conjunction .
The initialization and stabilization phases of our construction process consist of the following steps.
Initialization phase:
(I1) To begin with, let {q | q  P \ P} be any partition equipollent to the set P \ P of the source places of G, where each block q, for q  P \ P, is a hereditarily finite set of cardinality (at least) max(2|P|, 1) and whose members all have cardinality strictly greater than 2,13 and put
q(·) := q if q  P \ P  if q  P.
We say that a place q  P has already been initialized when q(·) = . Likewise, a -node A  N has been initialized when its places have all been initialized. During the initialization phase, an initialized -node A  N is said to be ready if it has some target that has not been yet initialized.
(I2) While there are places in P not yet initialized, pick any ready node A  N and distribute evenly all the members of pow1,2(A(·)) among all of its targets.
The accessibility of G guarantees that the while-loop (I2) terminates in a finite number of iterations.
At the end of the initialization phase all the q(·)'s are nonempty, so property (P2) holds. Indeed, if there were no -places, then all places would be initialized just after step (I1), and so all the q(·)'s would be (nonempty) singletons. On the other hand, if |P| > 0, then at the end of the while-loop (I2) we shall have |q(·)| 2|P|, for each q  P. This follows just from the initialization step (I1), for all source places q  P \ P. Otherwise, by induction, we have |q(·)| 2|P|, for every q in a ready node A  N , and
13For the present case concerning the ordinary satisfiability problem, we could have allowed that the q's were all infinite sets, rather than hereditarily finite sets. However, we chose to enforce hereditarily finiteness of the q's even in the current case in order that the initialization phase would coincide with that for the hereditarily finite satisfiability case to be addressed in the next section.
19

therefore |p ow1,2 (A(·) )|

2|P| 2

+ 2|P| = |P| · (2|P| + 1).

Hence, each of the |T (A)| |P| sets t(·), for t  T (A), will receive at least
|P| + 1 elements by the distribution step relative to the node A.
Concerning property (P1), we observe that at each distribution step, only elements of cardinality 1 or 2 are added to the sets q(·)'s. Therefore, the disjointness of the sets q1(·) and q2(·), for any two distinct places q1, q2  P such that at least one of them is a source place, will be guaranteed. Indeed, if both q1 and q2 are source places, then q1(·)  q2(·) = q1  q2 = . On the other hand, if only one of them is a source node, say q1, then since q1(·) = q1 contains only members of cardinality strictly greater than 2 whereas, by step (I2), all the members of q2(·) have cardinality less than or equal to 2, it follows that even in this case we have q1(·)  q2(·) = . Finally, for any two distinct places q1 and q2, none of which is a source node, we observe that if
they have been initialized by a distribution step applied to the same node A  N , we trivially have q1(·) q2(·) = . On the other hand, if qi is initialized by distributing over a -node Ai, with i = 1, 2, where A1 = A2, by induction
on the number of the number of distribution steps it can easily be shown that A(1·) = A(2·), and therefore q1(·)  q2(·)  pow1,2(A(1·))  pow1,2(A(2·)) = .

Stabilization phase: During the stabilization phase, a -node A  N is ripe if
pow1,2(A(·)) \ q(·) | q  T (A) = .
We execute the following (possibly infinite) loop:
(S1) While there are ripe -nodes, pick any of them, say A  N , and distribute all the members of pow1,2(A(·)) \ q(·) | q  T (A) (namely the members of pow1,2(A(·)) that have not been distributed yet) among its targets howsoever.
The fairness condition that one must comply with is the following:
once a -node becomes ripe during the stabilization phase, it must be picked for distribution within a finite number of iterations of the while-loop (S1).
A possible way to enforce such condition consists, for instance, in maintaining all ripe -nodes in a queue Q, picking always the -node to be used in

20

a distribution step from the front of Q and adding the -nodes that have just become ripe to the back of Q, provided that they are not already in Q.
By induction on n  N, it is not hard to show that properties (P1) and (P3) will hold just after the n-th iteration of the while-loop (S1) of the stabilization phase, and that property (P4) will hold at the end of the stabilization phase, in case of termination.
Instead, when the stabilization phase runs for denumerably many steps, the final partition P(·) is to be intended as the limit of the partial partitions constructed after each step of the stabilization phase. Specifically, for each place q  P, we let q(i) be the value of q(·) just after the i-th iteration of (S1). Plainly, we have

q(i)  q(i+1), for i  N.

(8)

Then we put

q(·) := q(i), for q  P

(9)

iN

(notation overloading should not be a problem).
By way of illustration, we prove that property (P4) holds for the partition P(·) = q(·) | q  P , when the q(·)'s are defined by (9). To this purpose, let A  P be such that T (A) = , and assume for contradiction that

pow1,2(A(·))  q(·) | q  T (A) .

Let s be any element in pow1,2(A(·)) \ q(·) | q  T (A) , and let i  N be the smallest index such that s  pow1,2(A(i)), where A(i) := {q(i) | q  A}. Since s  pow1,2(A(i)) \ q(i) | q  T (A) , the node A must have been ripe just after the i-th iteration of (S1). Therefore, by the fairness condition, the
node A will be picked for distribution in a finite number of steps, say k,
after the i-th step, so that we have

pow1,2(A(i))  pow1,2(A(i+k))  q(i+k+1) | q  T (A)  q(·) | q  T (A) ,

(by (8))

and therefore s  q(·) | q  T (A) , which is a contradition. Thus, property (P4) holds also when the construction process takes a denumerable number of steps.

21

Next, we show that the final partition P(·) = {q(·) |q  P} satisfies . In

particular, we prove that the partition assignment I : Vars()  pow(P(·))

defined by

I(x) := {q(·) | q  F(x)}, for x  Vars(),

satisfies , where we recall that F is the G-fulfilling map for . Since F is a G-fulfilling map for , then

- for every literal x = y  z in , with   {, \}, we have F(x) = F(y)  F(z), so that I(x) = I(y)  I(z) holds; and

- for every literal x = y in , we have F(x) = F(y), so that I(x) = I(y) holds.

Thus, by Lemma 3, the partition assignment I satisfies all Boolean literals in  of types
x = y  z, x = y \ z, x = y.
Next, let x = y  z be a conjunt of . We prove separately that the following inclusions hold:

I(x)  I(y)  I(z)

(10)

I(y)  I(z)  I(x).

(11)

Concerning (10), let q(·)  I(x). Then q(·)  I(x), so that q  F. By (c2), q cannot be a source place. Hence, by (P3), we have:

q(·)  pow1,2(A(·)) | A  T -1(q) .

Next we show that

T -1(q)  F(y)  F(z).

(12)

Let A  T -1(q) (so that q  T (A)), and for contradiction assume that A / F(y)  F(z). Then, by (c3), we have T (A)  F(x) = , contradicting q  T (A)  F(x). Thus, A  F(y)  F(z), proving (12). Hence, we have:

q(·)   = =

pow1,2(A(·)) | A  T -1(q) pow1,2(A(·)) | A  F(y)  F(z) pow1,2(A(·)) | A(·)  I(y)  I(z) I(y)  I(z)

(by Lemma 11),

and therefore the inclusion (10) holds.

22

Concerning the inclusion (11), let s  I(y)  I(z). Hence, s  q1(·)  q2(·) = pow1,2({q1(·), q2(·)}), for some q1  F(y) and q2  F(z). From (c1), we have  = T ({q1, q2})  F(x). Thus, by (P4),

pow1,2({q1(·), q2(·)})   =

{q(·) | q  T ({q1, q2})} {q(·) | q  F(x)} I(x),

and therefore s  I(x), proving (11) by the arbitrariness of s  I(y)  I(z). Hence, the partition assignment I satisfies also all the literals in  of the
form x = y  z, and in turn the final partition P(·) satisfies the conjunction .
By combining Lemmas 13 and 14 and Corollary 1, we obtain:
Theorem 1. A BST-conjunction with n variables is satisfiable if and only if it is fulfilled by an accessible -graph of size (at most) 2n - 1.
The preceding theorem is at the base of the following trivial decision procedure for BST:

procedure BST-satisfiability-test();

1. n := |Vars()|;

2. for each -graph G with 2n - 1 places do

3. if G is accessible and fulfills  then

4.

return " is satisfiable";

5. return " is unsatisfiable";

end procedure;

Concerning the complexity of the above procedure, we observe that, given a BST-conjunction  with n distinct variables, we have:
- the size of  is O(n3) (w.l.o.g., we are assuming that literal repetitions are not admitted);
- the size of a -graph with 2n - 1 places is O(8n);
- the size of any candidate fulfilling map over a set of n variables is O(n2n) and the time needed to check whether it is actually a Gfulfilling map for , for a given -graph G with 2n - 1 places, is O(8n).

23

Hence, for a BST-conjunction  with n distinct variables the procedure BST-satisfiability-test has a nondeterministic O(8n)-time complexity. Hence, we have:
Theorem 2. The satisfiability problem for BST-conjunctions belongs to the complexity class NEXPTIME.
The above result can be easily generalized to BST-formulae that are not necessarily conjunctions.
Theorem 3. The satisfiability problem for BST-formulae belongs to the complexity class NEXPTIME.
There are satisfiable BST-formulae that admit only infinite models. This is the case, for instance, for the following conjunction 
x = x \ x  x  x  x,
which is satisfied by the assignment M such that M x = HF. In addition, for every model M of , the first conjunct x = x \ x forces M x to be nonempty, while the second conjunct x  x  x forces M x to be infinite. Indeed, whenever a set s belongs to M x, it must also be the case that its singleton {s} belongs to M x as well. Thus, iteratively, the infinitely many sets
{s}, {{s}}, {{{s}}}, . . .
must all belong to s, proving that M x must be infinite. It is therefore important to investigate the finite s.p. for BST, which
we do in the next section.
3 The finite and the hereditarily finite satisfiability problems for BST
Let  be a finitely satisfiable BST-conjunction, and let now  be a partition with finite domain  that satisfies  via some partition assignment I : Vars()  pow(). Also, let G = (P, N, T) be the -graph induced by  via a given bijection q  q(·). As argued just before Lemma 12, the graph G is -accessible and fulfills  via the map F : Vars()  pow(P) induced by I and defined by
F(x) := {q  P | q(·)  I(x)}, for x  Vars()
24

(so, F is a G-fulfilling map for ). We shall see that the finiteness of  yields a weak kind of acyclicity
for the induced -graph G, which is expressed in terms of a restricted form of topological order.
Definition 7. A topological -order of a -graph G = (P, N , T ) is any total order  over its set of places P such that

max A  max T (A),

(13)





for every -node A of G. We write G = (P, N , T , ) for a -graph (P, N , T ) endowed with a topo-
logical -order , and we refer to it as a (topologically) -ordered graph.

Notice that a -ordered graph need not be acyclic. On the other hand, any acyclic -graph admits a topological order of its vertices and therefore a topological -order, as can be easily checked. In this sense, topological -orders are less demanding than ordinary topological orders.
Later we shall also see that, together with fulfillability and accessibility, the existence of a topological -order is sufficient for a BST-conjunction to be hereditarily finitely satisfiable, thereby proving that the finite and the hereditarily finite satisfiability problems for BST are equivalent.
To start with, we show, as announced before, that the induce -graph G admits a topological -order. Thus, let  be any total order over P that refines the partial order induced by the rank function, namely such that

rk p(·) < rk q(·) = p  q, for p, q  P.

We prove that (13) holds for , namely  is a topological -order of G. So, let A be any -node of G. For each q  A, we select an sq  q(·) of maximal rank, which exists since q(·) is finite, and put sA := {sq | q  A}.
Let qA be the target if A such that sA  qA(·) (plainly, such a target exists, since sA  pow1,2(A(·))  ). Hence, for each q  A we have

rk q(·) < rk sA < rk qA(·),

so that q  qA holds. But then

max A




qA =

max T (A),


25

proving that  is a topological -order of G. Summing up, we have proved that:
Lemma 15. A finitely satisfiable BST-conjunction is fulfilled by an accessible ordered -graph.
Next, we prove that if a BST-conjunction  is fulfilled by an accessible ordered -graph, then it is satisfiable by a hereditarily finite model.
Thus, let G = (P, N , T , ) be an accessible ordered -graph that fulfills  via a map F : Vars()  pow(P), and let be the total preorder induced by  over N , defined by

A

B

D-ef

max A


=

max B,


for all A, B  N . Much the same construction process described at depth in the proof of
Lemma 14 concerning the ordinary satisfiability problem for BST will allow us to build a hereditarily finite model for .
Specifically, the initialization phase of our new construction process coincides with that of the old construction process, and therefore consists in the steps (I1) and (I2) seen previously. Instead, the old stabilization loop (S1) is replaced by the following one:

(S1) While there are ripe -nodes, pick any -minimal ripe -node, say A  N, and assign all the members of pow1,2(A(·)) \ q(·) | q 
T (A) to the block qA(·) such that qA = max T (A), namely execute the assignment

qA(·) := qA(·)  pow1,2(A(·)) \ q(·) | q  T (A) .

(As before, during the stabilization phase a -node A is ripe if the set pow1,2(A(·)) \ q(·) | q  T (A) is nonempty.)

We prove that the while-loop (S1) can be executed at most |N| times. Thus, let

A1, A2, . . . , Ak, . . .

(14)

be the sequence of the -nodes picked for distribution during the execution
of the loop (S1). It is enough to show that the -nodes in the sequence (14) are pairwise distinct. To this end, we first prove that we have

A1 A2 . . . Ak . . .

(15)

26

For contradiction, let us assume that (15) does not hold, and let   N be the least index such that we have

A A+1,

(16)

so that A+1 A must hold, since the preorder is total. Plainly, at the -th iteration of (S1), the node A+1 cannot be ripe, as otherwise it would have been chosen at step  in place of A. So, the target qA = max T (A)
of A must belong to A+1, and therefore

max


A



max


T

(A)

=

qA

=

max


A+1

must hold, yielding A A+1 which contradicts (16). In what follows, for any node A  N we shall denote by A(i) the value
of the set A(·) (associated with A) just before the i-th iteration of the loop (S1).
We are now ready to prove that the nodes in the sequence (14) are pairwise distinct. For contradiction, if Ai = Aj, with i < j, then A(ii) = A(ij), so that at least one place q in Ai must be the -maximum target of some
-node, say At (with i t j - 1), in the sequence Ai, . . . , Aj-1. But then
we would have:

max


Ai

=

max


At

 qAt

=

max


Ai,

which is a contradiction. Therefore, the while-loop (S1) must terminate in at most |N| iterations.
Thus, at the end of the construction process under consideration, all the sets q(·), for q  P, are plainly hereditarily finite, and since the loop (S1) is a particular instance (which is guaranteed to terminate) of the loop (S1), then the partition {q(·) | q  P} resulting from the above construction process
satisfies our conjunction , just as argued in the proof of Lemma 14.
In conclusion, we have:

Lemma 16. A BST-conjunction fulfilled by an accessible ordered -graph is satisfiable by a hereditarily finite model.

From Lemmas 15 and 16 and Corollary 1, we deduce:

Theorem 4. The finite and the hereditarily finite satisfiability problems for BST-conjunctions are equivalent.
In addition, any BST-conjunction with n variables is (hereditarily)

27

finitely satisfiable if and only if it is fulfilled by an accessible ordered graph of size (at most) 2n - 1.

The preceding theorem justifies the following trivial decision procedure for the (hereditarily) finite satisfiability problem for BST:

procedure BST-finite-satisfiability-test();

1. n := |Vars()|;

2. for each -graph G with 2n - 1 places do

3. if G is -ordered, accessible and fulfills  then

4.

return " is (hereditarily) finitely satisfiable";

5. return " is satisfiable by any (hereditarily) finite model";

end procedure;

Much as in the previous section, we can deduce that:

Theorem 5. The (hereditarily) finite satisfiability problem for BST-formulae belongs to the complexity class NEXPTIME.

We say that a BST-formula forces infinite models if it is satisfiable but not finitely satisfiable.
On account of Theorems 3 and 5, we may finally infer the following immediate result:

Corollary 2. The problem of deciding whether a BST-formula forces infinite models belongs to the complexity class NEXPTIME.

4 Concluding remarks
In this paper, we provided a positive solution to the s.p. for the slightly simplified variant BST of MLS×, whose decision problem has been a longstanding open problem in computable set theory. BST differs from MLS× in that membership has been dropped and the Cartesian product has been replaced by its unordered variant . Despite such simplifications, the s.p. for BST remains fully representative of the combinatorial difficulties due to the presence of the Cartesian product operator. Specifically, we proved that that both the ordinary s.p. and the (hereditarily) finite s.p. for BST are in NEXPTIME.
We conjecture that a more elaborated approach, inspired to the optimization results stated in Lemmas 6 and 7 for the s.p. of BST, will allow us to prove the NP-completeness of the s.p. for BST.
We also expect that the technique introduce in this paper, based on -graphs and fulfilling maps, may be adapted to ascertain the decidability

28

of various extensions of BSTwith operators belonging to a specific class of operators, which includes, among others, the (ordered) Cartesian product × and the power set operator pow and its variants pow and pow1,2.
Finally, we are very confident that the decidability result for BST can be generalized to MLS×, though at the cost of extra-technicalities, and we plan to report about it in a next paper.
References
[Can91] D. Cantone. Decision procedures for elementary sublanguages of set theory. X. Multilevel syllogistic extended by the singleton and powerset operators. Journal of Automated Reasoning, 7(2):193­230, 1991.
[CCP90] D. Cantone, V. Cutello, and A. Policriti. Set-theoretic reductions of Hilbert's tenth problem. In Proc. of 3rd Workshop "Computer Science Logic" 1989, pages 65­75, 1990. Lecture Notes in Computer Science, 440.
[CCS90] D. Cantone, V. Cutello, and J. T. Schwartz. Decision problems for Tarski's and Presburger's arithmetics extended with sets. In In E. B¨orger, H. Bu¨ning, M. Richter, and W. Scho¨nfeld, editors, Proceedings of 3rd Workshop Computer Science Logic - CSL 90 (Heidelberg 1990), pages 95­109 Berlin, 1990. Lecture Notes in Computer Science, 533.
[CDMO19] D. Cantone, A. De Domenico, P. Maugeri, and E.G. Omodeo. Polynomial-time satisfiability tests for Boolean fragments of set theory. In A. Casagrande and E.G. Omodeo, editors, Proceedings of the 34th Italian Conference on Computational Logic, Trieste, Italy, June 19-21, 2019, volume 2396 of CEUR Workshop Proceedings, pages 123­137. CEUR-WS.org, 2019.
[CFO89] D. Cantone, A. Ferro, and E.G. Omodeo. Computable Set Theory, vol. 6 International Series of Monographs on Computer Science. Clarendon Press, Oxford, UK, 1989.
[COP20] D. Cantone, E.G. Omodeo, and M. Panettiere. From Hilbert's 10th problem to slim, undecidable fragments of set theory. In G. Cordasco, L. Gargano, and A. A. Rescigno, editors, Proceedings of the 21st Italian Conference on Theoretical Computer Science, ICTCS 2020, volume 2756 of CEUR Workshop Proceedings, pages 47­60. CEUR-WS.org, 2020.
[COP90] D. Cantone, E.G. Omodeo, and A. Policriti. The automation of syllogistic. II: Optimization and complexity issues. Journal of Automated Reasoning, 6(2):173?187, 1990.
[COP01] D. Cantone, E.G. Omodeo, and A. Policriti. Set Theory for Computing - From decision procedures to declarative programming with sets. Monographs in Computer Science. Springer-Verlag, New York, 2001.
29

[COSU03] D. Cantone, E.G. Omodeo, J.T. Schwartz, and P. Ursino. Notes from the logbook of a proof-checker's project. In N. Dershowitz, editor, Verification: Theory and Practice (Essays Dedicated to Zohar Manna on the Occasion of His 64th Birthday), vol. 2772 of Lecture Notes in Computer Science, pp. 182­207, Springer-Verlag, Berlin, 2003.
[COU02] D. Cantone, E.G. Omodeo, and P. Ursino. Formative processes with applications to the decision problem in set theory: I. Powerset and singleton operators. Information and Computation, 172(2):165­201, 2002.
[CU14] D. Cantone and P. Ursino. Formative processes with applications to the decision problem in set theory: II. Powerset and singleton operators, finiteness predicate. Inf. Comput., 237: 215­242, 2014.
[CU18] D. Cantone and P. Ursino. An Introduction to the Technique of Formative Processes in Set Theory. Springer International Publishing, 2018.
[DPR61] M. Davis, H. Putnam, and J. Robinson. The decision problem for exponential Diophantine equations. Annals of Mathematics, 74(2): 425­436, 1961.
[FOS80] A. Ferro, E.G. Omodeo, and J.T. Schwartz. Decision procedures for elementary sublanguages of set theory. I: Multilevel syllogistic and some extensions. Comm. Pure Appl. Math., 33:599­608, 1980.
[Mat70] Yu. V. Matiyasevich. Enumerable sets are Diophantine (in Russian). Dokl. AN SSSR, 191(2), 278­282, 1970. Translated in: Soviet Math. Doklady, 11(2), 354­358. Correction Ibid 11 (6), 1970, vi. Reprinted on pp. 269­273 in: Mathematical logic in the 20th century, G. E. Sacks, (Ed.), Singapore University Press and World Scientific Publishing Co., Singapore and River Edge, NJ, 2003.
[Hil02] D. Hilbert. Mathematical Problems. Bulletin of the American Mathematical Society, 8(10), 437­479, 1902.
[OCPS06] E.G. Omodeo, D. Cantone, A. Policriti, and J.T. Schwartz. A Computerized Referee. In M. Schaerf and O. Stock, editors, Reasoning, Action and Interaction in AI Theories and Systems ­ Essays dedicated to Luigia Carlucci Aiello, vol. 4155 of Lecture Notes in Artificial Intelligence, pp. 117­139. Springer Berlin/Heidelberg, 2006.
[OPT17] E.G. Omodeo, A. Policriti, and A. Tomescu. On Sets and Graphs: Perspectives on Logic and Combinatorics. Springer International Publishing, 2017.
[OS02] E.G. Omodeo and J.T. Schwartz. A `Theory' mechanism for a proof-verifier based on first-order set theory. In A. Kakas and F. Sadri, editors, Computational Logic: Logic Programming and Beyond ­ Essays in honour of Bob Kowalski, Part II, vol. 2048 of Lecture Notes in Artificial Intelligence, pp. 214­230. Springer-Verlag, Berlin, 2002.
[Rob56] R.M. Robinson. Arithmetical representation of recursively enumerable sets. Journal of Symbolic Logic, 21(2), 162-186, 1956.
30

[Sca84] B. Scarpellini. Complexity of subcases of Presburger Arithmetic. Transactions of the American Mathematical Society, 284(I):93­119, 1984.
[Schw78] J.T. Schwartz. Instantiation and decision procedures for certain classes of quantified set-theoretic formulae. ICASE Report, 78-10, 1978.
[SCO11] J.T. Schwartz, D. Cantone, and E.G. Omodeo. Computational logic and set theory: Applying formalized logic to analysis. Springer-Verlag, 2011. Foreword by M. Davis.
[Urs06] P. Ursino. A generalized small model property for languages which force the infinity. Matematiche (Catania), LX(I):93­119, 2005.
31

