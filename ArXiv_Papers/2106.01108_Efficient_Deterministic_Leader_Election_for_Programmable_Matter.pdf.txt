arXiv:2106.01108v1 [cs.DC] 2 Jun 2021

Efficient Deterministic Leader Election for Programmable Matter
FABIEN DUFOULON, Technion - Israel Institute of Technology, Israel SHAY KUTTEN, Technion - Israel Institute of Technology, Israel WILLIAM K. MOSES JR., University of Houston, USA
It was suggested that a programmable matter system (composed of multiple computationally weak mobile particles) should remain connected at all times since otherwise, reconnection is difficult and may be impossible. At the same time, it was not clear that allowing the system to disconnect carried a significant advantage in terms of time complexity. We demonstrate for a fundamental task, that of leader election, an algorithm where the system disconnects and then reconnects automatically in a non-trivial way (particles can move far away from their former neighbors and later reconnect to others). Moreover, the runtime of the temporarily disconnecting deterministic leader election algorithm is linear in the diameter. Hence, the disconnecting ­ reconnecting algorithm is as fast as previous randomized algorithms. When comparing to previous deterministic algorithms, we note that some of the previous work assumed weaker schedulers. Still, the runtime of all the previous deterministic algorithms that did not assume special shapes of the particle system (shapes with no holes) was at least quadratic in , where  is the number of particles in the system. (Moreover, the new algorithm is even faster in some parameters than the deterministic algorithms that did assume special initial shapes.)
Since leader election is an important module in algorithms for various other tasks, the presented algorithm can be useful for speeding up other algorithms under the assumption of a strong scheduler. This leaves open the question: "can a deterministic algorithm be as fast as the randomized ones also under weaker schedulers?"
1 INTRODUCTION
The study of the interplay between movement and computation has long been an area of interest spanning multiple research fields [26]. Programmable matter, introduced by Toffoli and Margolus [31], is an attempt to use mobile computational agents to model matter that can change its physical properties, e.g., change shape. While "regular" matter is composed of "dumb" particles, each of the "smart" particles that compose programmable matter is equipped with computational power and the ability to move. Like "dumb" particles, smart particles need to be small. Thus, they are also weak in their memory size, computational power, communication ability, movement ability, etc. To accomplish significant tasks, they must cooperate.
Among the multiple concrete realizations of programmable matter, the amoebot model, first proposed by Derakhshandeh et al. [14] (also explained in detail by Daymude et al. [12]), has gained much traction in recent years. In this model, each particle can move from one grid point of a triangular grid to a neighboring grid point in a way that resembles an amoeba. Many problems of interest were addressed, including coating of materials [8, 17, 18], bridge building [1], energy distribution [13], shape formation [5, 9, 15, 16, 21, 22], and shape recovery [20]. Towards solving these problems, a dominant strategy has been to elect a unique leader among the particles, which then coordinates all the movements.
Early deterministic leader election algorithms did not use the movement ability as an aid to the computation and the communication. This resulted in algorithms that were based on assumptions on the initial shape of the particle system (intuitively, that it had no "holes") [22, 27] or elected up to 6 leaders instead of one in some cases [3]. Recently, it was shown that the particles' movements could be leveraged in order to elect a unique leader (or up to 3 leaders when actions are not atomic) without imposing a restriction on the initial shape [23, 24]. Unfortunately, the above improvements came at the cost of a considerably higher runtime, compared to the algorithms that assumed no holes.
Authors' addresses: Fabien Dufoulon, dfabien@campus.technion.ac.il, Technion - Israel Institute of Technology, Haifa, Israel; Shay Kutten, kutten@ technion.ac.il, Technion - Israel Institute of Technology, Haifa, Israel; William K. Moses Jr., wkmjr3@gmail.com, University of Houston, Houston, USA.
1

2

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

In the current paper, we present a linear time algorithm to elect a unique leader deterministically when assuming a strong scheduler, regardless of the initial shape. (We make the rather common assumption that the particles have the same chirality; see Section 2.2 and [3, 8, 10, 16, 19, 27, 30].) The runtime of all the previous deterministic algorithms that did not assume special shapes of the particle system (shapes with no holes) was at least quadratic in , where  is the number of particles in the system. One may then ask: can a deterministic algorithm be as fast as the randomized ones even when holes are present (at least when assuming a strong scheduler)? Since leader election is an important module in algorithms for various other tasks, the presented algorithm can be useful for speeding up other algorithms.
Previous literature assumed that the algorithm ensures that the system is connected at all times, although (see [12]) the amoebot model does not require that the system remains connected.1 Allowing the system another operation (i.e., to disconnect) obviously gives algorithm designers another potential tool. Still, it was not clear that such a tool was, in fact, useful. On the contrary, in [12], the opposite is implied. According to them, "If a particle system disconnects, there is little hope the resulting components could ever reconnect. Since each particle can only see and communicate with its immediate neighbors and does not have a global compass, disconnected components have no way of knowing their relative positions and thus cannot intentionally move toward one another to reconnect."
In this paper, we demonstrate that disconnecting and reconnecting again can actually be very useful. In fact, the significant improvement in runtime achieved by the algorithm presented here is obtained thanks to the disconnection and reconnection.
1.1 Related Work
The type of scheduler used affects the leader election results (which are compared with our result in Table 1). Typically in the literature [10, 19, 24, 27], the "strong" scheduler activates particles atomically. In "weaker" schedulers [3, 22, 23], where activations are non-atomic, it becomes impossible to elect a unique leader deterministically in some cases. (Recall that without particle movements, it may be the case that it is impossible to always elect a unique leader even under a strong scheduler [3].)
Leader election in the amoebot model was initially studied by Derakhshandeh et al. [19]. They assumed that particles have common chirality and proposed a randomized algorithm to solve leader election (of exactly one leader) in  ( ) rounds in expectation, where  is the length of the largest boundary in the shape. Daymude et al. [10, 11] assumed common chirality too. They improved upon the previous result by presenting a randomized algorithm that elected a unique leader (with probability 1) in  ( + ) rounds w.h.p.2, where  is the length of the outer boundary of the shape and  is the diameter of the shape.
The first deterministic leader election algorithm was presented by Di Luna et al. [22] for the natural special case that the shape did not contain holes; multiple (up to three) leaders could be elected in some cases. The runtime was  () where  is the number of particles. The paper used the elected leader(s) to perform shape transformation. Gastineau et al. [27] assumed common chirality and an initial shape with no holes.They presented a  ( +) round deterministic leader election algorithm (of exactly one leader), where  and  are terms specific to their paper. It can be shown that  +  = (). In addition to election, they also assigned local identifiers to particles. (A subsequent paper by Gastineau et al. [28] extended these results to a proposed three dimensional variant of the amoebot model and took  () time to elect a leader deterministically subject to constraints specific to their model.) The deterministic
1There are some partial exceptions. In [20], faults kill some of the particles, possibly disconnecting the non-faulty ones. In [22], the model does not allow a particle to contract to the tail; they simulate such a contraction by the particle moving to a neighboring node (possibly disconnecting) and immediately moving back (and reconnecting). 2With high probability, that is, with probability of success at least 1 - - where  is any constant equal or greater than 1.

Efficient Deterministic Leader Election for Programmable Matter

3

algorithm of Bazzi and Briones [3] also assumed common chirality. They could elect (up to six) leaders deterministically even when holes were present in the shape. However, their runtime was  (2). Emek et al. [24] addressed the use of movement for electing a leader in the ameobot model. They showed that a unique leader can be elected if movement is allowed assuming a strong scheduler even if there are holes in the shape and even if common chirality is not assumed. The runtime of their algorithm was  (2) rounds.
D'Angelo et al. [23] proposed a variant of the amoebot model, called SILBOT, where particles could not communicate the content of their variables but could "view" the position of other particles within 2-hops from them. Moreover, they could see whether another such particle was in the "process of moving" to a different grid point. In this altered model, they first presented a deterministic leader election algorithm (of up to three leaders) in  () rounds when the initial shape had no holes. Subsequently, they presented a deterministic leader election algorithm (of up to three leaders) on any initial shape when particles were empowered with yet another sense ­ the ability to determine whether an empty grid point within the 2-hop view was a part of a hole or the outer face of the shape. This assumption is stronger than the assumption that particles know initially which boundary is the outside boundary, since the extra sense could be used at any point during the execution.
1.2 Technical Challenges
To improve the runtime, we had to address the issues of particle movements, those of particles messaging each other, and the combination thereof. Previous deterministic election algorithms used an erosion process that did not require particle movements. The idea was that a particle , once it knew it was on the outer boundary, removed itself from candidacy provided  could be sure the system remained connected (even when not counting ) [22, 23, 27]. To ensure such connectivity, each particle first verified some local conditions. Intuitively, it seems that the conditions in [22, 23] were restrictive to the point that they limited parallelism and thus slowed the erosion process down. The conditions in the process of [27] seem much less restrictive and indeed allowed the authors there to prove a faster process. However, the conditions may have been too "liberal" in the sense it may have allowed the adversarial scheduler too much freedom in choosing an order of erosion that would slow the process down. The conditions we chose for a particle to erode itself allowed us to prove an existentially tighter upper bound, using some basic tools from metric graph theory [2, 6]: we prove  () for the erosion, where  is the diameter of the whole sub-grid surrounded by particles (including the holes). Note that this can be smaller than .
Initially, we assume that at the beginning of the execution, particles residing on a boundary know if that boundary borders a hole or the outer face. We remove this assumption later at the cost of  ( + ) rounds (Note that this assumption, nevertheless, is weaker than that of [23].) When this assumption is used, we manage to improve the runtime of the algorithm, even for shapes with holes, to  (). This requires particle movement (as opposed to the use of erosion only, when no holes exist). Intuitively, with no erosion, any algorithm seems to be doomed to () runtime. Moreover, without particle movement, it seems that no algorithm can guarantee the choice of a unique leader (this was shown in [3], at least for the case of a weak scheduler). However, movement can complicate the algorithm. In particular, algorithms that use particle movements can face the problem of different groups of particles standing in the way of each other. Such a phenomenon could cause the algorithm of [24] to reset many times, increasing its runtime significantly. On the other hand, careful coordination of the movement is difficult, given that no leader has been selected yet. We avoid these resets since particles move "inwards" in our algorithm.
A similar type of inward movement can be seen in D'Angelo et al. [23], where they remove holes from the shape while running the erosion process. However, their process still takes  (2) rounds. We are able to speed things up

4

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

by allowing the particle system to disconnect. Intuitively, there is less space the further one goes inwards. Hence, not all the particles could move inwards simultaneously. Arranging them in queues and moving the queues of particles inwards is, possibly, what increases the runtime to  (2). (This, at least, was the bottleneck when we designed an algorithm without disconnection, an algorithm not presented here.)
An additional challenge is a result of the shape disconnection we utilize. Due to the particles' limited memories, it is non-trivial to reconnect a shape once particles are disconnected. Not only do we need to ensure that all particles (the total number of which we cannot count) are collected, but we must do this quickly. We overcome this issue by disconnecting the shape in a careful manner; informally, we disconnect particles such that we leave "breadcrumbs", which a leader can follow to collect everyone.
Finally, the outer boundary detection primitive required quadratic time in [24]. It used a subroutine that elected up to 6 leaders on each boundary. One runtime bottleneck of that subroutine was a process of comparison between one set of particles to another. The comparison was performed in a sequential manner ­ comparing certain inputs of two particles at a time, because the memory size of a particle is constant and could not contain many inputs values. We managed to pipelines these comparisons carefully. One reason that care is needed is that each of the compared sets can be changed during the comparison. (In previous algorithms, the sets were, in essence, "frozen" for the duration of the comparison.)
Table 1. This table compares the results on leader election to those of previous papers. In column three, D & R correspond to deterministic solution and randomized solution, respectively, while S & W correspond to strong scheduler and weaker scheduler, respectively. The assumptions & relaxations used in papers include (i) assuming particles have common chirality, (ii) assuming the initial shape has no holes, (iii) assuming each particle can detect whether an empty grid point within its visibility range is part of a hole or the outer face (boundary detection), either initially or throughout the execution of the algorithm, and (iv) relaxing the solution of leader election to allow multiple leaders. The length of the largest boundary in the initial configuration is  . The length of the outer boundary in the initial configuration is  . The number of particles in the configuration is denoted by . The terms  and  are specific to the algorithm of [27].

Paper

Running Time (rounds)

[19] [10, 11]
[3] [22] [27]* [23]** [24] Current Paper Current Paper

 ( ) on expectation  ( + ) w.h.p.  (2)
 ()
 ( + )  (2)
 ( 2)
 ()
 ( + )

*Note that  +  = ().

Randomness/ Scheduler

Assumptions/Relaxations

R/S R/S D/W D/W D/S D/W D/S D/S D/S

Chirality Chirality Chirality; Multiple leaders Multiple leaders; No holes Chirality; No holes Boundary detection throughout
Boundary detection initially; Chirality
Chirality

**Their model is a bit different from the amoebot model.

1.3 Results and Paper Organization
We present the first linear time deterministic algorithm for (unique) leader election that can handle holes, under a strong scheduler. Specifically, when we assume that particles recognize the outer boundary initially, the runtime is linear in  ­ that may be smaller than . (The new algorithm is even faster in some parameters than deterministic algorithms

Efficient Deterministic Leader Election for Programmable Matter

5

that did assume special initial shapes.) Note that some of the previous algorithms did not assume common chirality. When we do not assume that particle recognize the outer boundary initially, the runtime increases to  ( + ). The presented deterministic algorithms are at least as fast as the current best randomized algorithms. These algorithms demonstrate the power of using disconnection (at least so far, it is not known how to obtain the same results without using the power of disconnection). A comparison of the results with previous ones can be found in Table 1.
The algorithm is composed of two parts, the algorithm for leader election where the system may disconnect is presented in Section 4.1 and is analysed in Section 4.2. The reconnection procedure and its analysis appear in Section 4.3. The model description and most of the definitions appear in Section 2. This includes the definition of chirality as well as the assumption that the particles initially agrees on it (similar to the assumptions, e.g., in [3, 8, 10, 16, 19, 27, 30]).

2 PRELIMINARIES
The particles of a particle system occupy points of a triangular grid as detailed later in this section. For short, we usually refer to grid points just as "points". The grid is assumed to be embedded in the plane, though the embedding is not known to the particles. In particular, we may talk about { ,  ,  , , ,  }, referring, e.g., to the West side of the embedding, or to the Northwest, but the particles do not know which direction is which. Given a subset of the (grid) points, the graph they induce includes these points as nodes. It also includes an edge between two of points iff these two points are neighbors on the grid.

2.1 Shapes
A shape is a finite set of points from the triangular grid  ­ see Figure 5. By an abuse of notation, the (finite) subgraph of the triangular grid induced by such a shape is also called a shape. In what follows, let  be an arbitrary connected shape. One may neglect mentioning  when the considered shape  is evident.

Boundaries and Holes in Shapes. The clockwise (and counter-clockwise) successor and predecessor edges are defined for every point's incident edges in the natural way. Clockwise (and counter-clockwise) cyclic intervals are defined similarly. A shape partitions the plane into faces (regions bounded by its points and edges) including exactly one unbounded face, the outer one. The set of points that lie on the outer face is called the outer boundary. An inner face containing at least one point (that is not in the shape) is said to be a hole in the shape. The set of points bounding a hole is called an inner boundary. A shape without any holes is said to be simply-connected. The length of a boundary is the number of points of that boundary. We denote by  () the length of the outer boundary of a shape  and by  () its maximum boundary length. Points on boundaries are referred to as boundary points, other points in the shape as interior points, and points in the shape's holes as hole points. See Figure 5.

Area of a Shape. The area of shape  consists of  and all of 's holes points ­ see Figure 5. For any pair of points

in

,

their

distance

with

respect

to

(w.r.t.)

some

shape








­

denoted

by



­

is

the

length

of

the

shortest

path

(within ) between these two points. Then, the eccentricity of point    w.r.t.  ­ denoted by  () ­ is the greatest

distance (w.r.t.  ) from  to any other point in . The diameter of  w.r.t.  is the greatest eccentricity (w.r.t. ) of

any

point

in

.

When




=

,

these

are

simply

said

to

be

the

distance,

eccentricity

and

diameter

of

.

Observation 1. The following holds:

(1) The diameter of  is greater than or equal to the diameter of  w.r.t. the area of .

(2)

If 

is a simply-connected

shape with 

points and diameter  , then 

=  (2).


6

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

(3) If  is simply-connected, then the length of the outer boundary of  is greater than or equal to 's diameter.

Proposition 2. For any hole point  of , there exists 1, 2   such that  is on a shortest path between 1 and 2.

Proof. Take any two opposite incident edges 1, 2 of  (i.e., separated by two edges clockwise, in the cyclic interval of 's incident edges). Consider the two straight paths (on the hole points of  as well as the points of ) starting at 

and going along the directions of 1 and 2, respectively. Intuitively, since  is a finite boundary encircling , these two

paths intersect  in two grid points. In other words, these paths reach points 1, 2  , respectively, and  is on the

shortest path between 1 and 2.



Local Boundaries in Shapes and Convex Vertices. Let  be a boundary point of  (and | |  2). The local boundary

 (w.r.t. ) of  is a clockwise cyclic interval of incident edges leading to points not in . Denote by || the size (the

number of edges) of the interval. Note that  may have up to 3 local boundaries, and these local boundaries may be a

part of the same (inner or outer) global boundary of that shape. The clockwise successor (respectively, predecessor) point

of  with respect to  is defined as the point reachable by the clockwise successor of 's final edge (resp., predecessor of

's first edge). The counter-clockwise successor and predecessor points of  are defined similarly. The boundary count

of  w.r.t.  is defined as  (, ) = || - 2, which by definition (of a local boundary) is necessarily in {-1, . . . , 3} ­ see

Figure 6.3 If  (, ) > 0, then  is said to be (strictly) convex w.r.t. . For simplicity, when  has a single local boundary




w.r.t.

,

we

say

that



has

a

boundary

count

of



(,




)

w.r.t.



and

if



(,




)

>

0,

that



is

(strictly)

convex

w.r.t.

.

Virtual Nodes and (Oriented) Rings on Global Boundaries. Each global boundary can be transformed into an (oriented)
virtual ring. These rings are used in the proof of Proposition 7 and in Section 5. Some definitions are given first. A
boundary point    is subdivided into one, two, or three virtual nodes (v-nodes), each corresponding to one of
's local boundaries. The v-node associated with 's local boundary  is denoted by  () and has boundary count  ( ()) =  (, ). The clockwise successor (resp., predecessor) v-node of  () is defined as the v-node  () satisfying (1)   is the clockwise successor (resp., predecessor) point of  w.r.t.  and (2) there exist two unique edges   ,     with a common unoccupied endpoint . Point  is said to be the common point of  () and  (). (Note that  and  
have exactly two common adjacent points and  is one of them.) Any v-node has a successor (resp., predecessor) v-node and can compute their common point, by Observation 3. Furthermore, note that  and  correspond to the same global boundary ~ ­ the one that borders the face containing the common point of  () and  (). The counter-clockwise
successor and predecessor v-nodes of  () are defined similarly. Let ~ be a global boundary. Then, the first corresponding (oriented) virtual ring consists of all v-nodes  () such
that  is part of ~, and its edges are directed from a v-node to its clockwise successor. This ring is oriented clockwise if ~ is the global outer boundary, and counter-clockwise otherwise ­ see Figure 7. The second ring is defined similarly
except that its edges go from a v-node to its counter-clockwise successor (and thus has the inverse orientation).

Observation 3. Any v-node  () has a clockwise successor (resp., predecessor) and their common point is the other endpoint of the last (resp., first) edge of .

Observation 4 ([10]). Consider any of the two (oriented) rings corresponding to the outer boundary (resp., an inner boundary). Then the sum of counts of the ring's v-nodes is 6 (resp., -6).

3Note that when a shape consists of a single point ­ which is not considered here ­ that point has boundary count 4.

Efficient Deterministic Leader Election for Programmable Matter

7

Erodable Points. A redundant point    is a point whose removal does not disconnect its 1-hop neighborhood (in ). If  is also on the outer boundary of , then  is an erodable point w.r.t.  ­ see Figure 6. In which case,  has a single local boundary  in , by Proposition 6. If, in addition,  is strictly convex w.r.t. , then  is said to be strictly convex and erodable (SCE) w.r.t. . We show below that if  is simply-connected then it is possible to remove SCE points iteratively (call this an "erosion process") until a single point remains (Observation 5 and Proposition 7 below).

Observation 5. For an arbitrary simply-connected shape  (with at least two points) and an erodable point   , the shape  \ { } is simply-connected.

Proposition 6. A point    is erodable if and only if  has a single local boundary , and  is a local outer boundary.

Proof. Assume, by contradiction, that some redundant point    has at least two local boundaries 1, 2. For

  {1, 2}, consider an arbitrary edge in  and denote its other endpoint by  (where   ). Since 1 and 2 are not adjacent, the removal of  would separate the 1-hop neighborhood of , contradicting the fact that  is redundant.

Because a point that has a single local boundary is (trivially) redundant, a point is redundant if and only if it has a

single local boundary. The statement follows from the definition of an erodable point.



Proposition 7. If  is simply-connected and has at least two points then it has at least one SCE point (w.r.t. ).

Proof. Consider the clockwise oriented ring of v-nodes on the outer boundary of . It is easy to show that there exists a point  on the outer boundary of  and a path P =  (), 1 (1), . . . ,  ( ),  () on the ring such that P is of length at least 3 (i.e.,   1) and such that for any strictly positive integer ,    and in addition, for any strictly

positive integer   ,     . (Intuitively,  is the only point this path encounters twice.) The set of points , 1, . . . ,  form a simple polygon (i.e., non-intersecting) in the Euclidean plane. (Note that not all points are vertices of the polygon,

since some of the points may be in a straight line.) Hence, the sum of this polygon's exterior angles is 360°. Assume  is

a vertex of the polygon. Since the polygon is non-intersecting,  has an exterior angle of at most 180°. After removing

's exterior angle, the remaining sum of exterior angles is at least 180° (if  is not a vertex, the sum is 360°). For every

point  that is also a vertex (for   1), the count of  ( ) is the exterior angle of  divided by 60°. Thus, there exists

  1 such that  ( ) has strictly positive count, or in other words,  is strictly convex w.r.t. one of its local (outer) boundaries. In addition, since the path only encounters  once,  has exactly one local outer boundary. Finally, since 

is simply-connected,  does not have any other local boundaries and thus is erodable by Proposition 6.



2.2 System Definitions
In the amoebot model, particles occupy (at most two) points of the triangular grid. A particle that occupies two points is expanded, whereas one which occupies a single point is contracted ­ see Figure 8. Two particles that occupy adjacent points are said to be neighboring particles. For any particle , the set of its neighboring particles is denoted by N (). To communicate, particles write to their own local memory, and read from their neighboring particles' memory. Importantly, a particle stores in its memory whether it is contracted or expanded. Due to the memory constraint, particles do not have unique identifiers. Instead, each particle  relies on a cyclical ordering of (an occupied point's) incident edges (i.e., port numbers in {0, . . . , 5}) to distinguish between neighboring points. That ordering's (clockwise or counter-clockwise) direction is referred to as the chirality of that particle. This work makes the common assumption [3, 8, 10, 16, 19, 27, 30] that particles have common chirality ­ taken to be, without loss of generality, the clockwise direction. Moreover, for any particle  occupying some point  and any point  adjacent to , let  (, , ) denote the port  assigns to  from

8

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

. This work makes the common assumption [3, 16, 20, 24] that, for any two neighboring particles  and  occupying two adjacent points, respectively  and ,  knows  (, , ).
Movements and Connectivity Assumptions. Particles can move by expanding or contracting along the edges of the triangular grid. More concretely, a contracted particle, occupying some point , can expand into any empty adjacent point . The particle now occupies both point  (said to be its tail) and point  (said to be its head) ­ see Figure 8. (If a particle occupies a single point , then  is both the tail point and the head point of the particle.) As for an expanded particle occupying two adjacent points  and , it can contract into either  or . Finally, two neighboring particles  and , where  is contracted and  is expanded, can participate in a handover (performed by either  or ) where  expands into a point previously occupied by  and  becomes contracted.
The set of occupied points (or also, by abuse of notation, the corresponding induced subgraph) is said to be the shape of the particle system. It is commonly required [4, 5, 22, 24] that the particle system maintains system-wide connectivity: that is, an algorithm must not move a particle such that the particle system's shape becomes disconnected. However, in this work, temporary disconnection is allowed: we only require that the particle system's shape is connected at the beginning and at the end of an algorithm.
Additional Definitions. The state of a particle  consists of 's local memory and whether  is contracted or not. A state from which  does nothing, when activated, is said to be a final state. The configuration of the particle system consists of the particle system's shape and of all particles' states and occupied points. A configuration is said to be connected if the particle system's shape is connected, non-empty if the particle system is non-empty, and contracted if all of the particles are contracted. A problem is defined by a set of permitted initial configurations, particle outputs (i.e., problem-specific variables in particles' memories), and a problem predicate (i.e., a predicate on the system's configuration). As is common in the literature [16, 19, 22, 24], the set of permitted initial configurations here consists exactly of connected, non-empty contracted configurations.
The particle system progresses through a sequence of atomic particle activations. An activated particle executes the following 3 actions in order: (i) it reads the memories of its neighbors, (ii) it performs some arbitrarily bounded computations, and updates its local memory as well as its neighbors' memories, and (iii) it may execute a single movement operation (described above).4 An execution fragment is a sequence 0, 1, 1, . . . of configurations alternating with activations such that configuration  is obtained by applying activation  to -1. If additionally, 0 is a permitted initial configuration, then the execution fragment is called an execution. An execution is said to be fair if each particle is activated infinitely often. An asynchronous round is a minimal execution fragment in which each particle is activated at least once. An algorithm terminates if, for any fair execution, all particles reach a final state. An algorithm solves problem P if it terminates and any fair execution reaches a configuration that satisfies P's predicate. The round complexity of an algorithm (solving some problem P) is the number of rounds needed until it terminates, in the worst-case.
Notations. For an arbitrary execution and configuration  (i.e., the configuration obtained after  activations in the execution), the particle system's shape in  is denoted by  ( ) and its area by  ( ). When evident, we omit  and use the simpler notations  and . The eccentricity of point    w.r.t.  in the initial configuration 0 is denoted by  (). The diameters of  w.r.t.  ,  , and  in 0 are respectively denoted by ,  and  (where  =  (), see (1) of Observation 1). The number of points of  and  in 0 are denoted by  and  (where  =  (2), see (2) of Observation 1).
4Note that if the activated particle is in a final state, then it performs none of the 3 steps.

Efficient Deterministic Leader Election for Programmable Matter

9

2.3 Problem Definitions
Leader Election and Disconnecting Leader Election. The output of a particle  is the variable ., which can take values in {, ,   }. The predicate of the disconnecting leader election problem (DLE) is satisfied if there exists a unique particle with the leader state, and all other particles are in the follower state. The predicate of the leader election problem is satisfied if the particle system is connected and the predicate of DLE is satisfied.

3 SOME OF THE TECHNICAL IDEAS
The main results are described in the very next section in Subsections 4.1 and 4.2. The current section is intended for an informal description of the technical ideas behind the additional results. That is, an informal description of the process by which the particle system is reconnected (if this is desired) efficiently after algorithm DLE terminates is given in Subsection 3.1. Intuition about the removal of the assumption that the outer boundary is known is given in Subsection 3.2. The much more detailed description of the assumption's removal is discussed in length later in Section 5.

3.1 Informal Description of the Reconnection Algorithm
After executing Algorithm DLE, the particle system may be disconnected. As opposed to a general disconnected particle system, we prove in Lemma 19 that Algorithm DLE leaves particles at some points at every grid distance from the eventual leader (up to the furthest distance). This allows Algorithm Collect to collect the particles in phases. Intuitively, in the first phase, the leader particle collects its neighboring particles; by the lemma it collects at least one (besides itself). Then, intuitively,  particles are enough to collect every particle at distance 2 from the leader, by rotating around the leader, not unlike a blade of a fan. By the lemma, they collect 2 particles (including themselves) unless they have reached the furthest particle already. Various technicalities are still encountered.

3.2 Intuition Regarding the Removal of the Known Outer Boundary Assumption
The algorithm to detect the outer boundary is given in this paper for completeness, to show that the known boundary assumption can be removed. This primitive is a speed-up-by-pipelining version of the similar primitives of [3, 24]. Like them, it uses mostly classical distributed computing methods in the sense that no particle moves during its execution.
Following [3], the primitive uses the sum of the boundary counts (of the points on each boundary) to decide whether this is an outer boundary. This sum is positive iff this is the outer boundary. The difficulties arise from the anonymity and from the fact that the memory of each particle is constant. For example, it is not easy to collect the sum to one particle, since some partial sums may be larger than the memory of the particle. As in [3, 24], up to 6 leaders are elected on each boundary, so that each can perform the sum starting from itself. For simplicity, assume for now that a global boundary visits each particle at most once (in other words, each particle has at most one local boundary that is part of that global boundary). During the election, sets of consecutive particles along a boundary form segments. The particles of one segment 1 may have a different collection of boundary counts than the particles of another segment 2. The counts are compared, and one of these segment loses. Each such segment has its own leader (initially, everybody is the leader of a segment including only itself). Eventually, at most 6 segments remain.
We manage to save in runtime compared to [3, 24] by using pipelining. Each particle produces a token (mobile agent) carrying its sum, and the collection of mobile agents of one segment is pipelined into the other segment. A complication arises from the fact that segments may change during the comparison. Previous algorithms "froze" the segments ­ that is, blocked any changes ­ during comparison, creating a runtime bottleneck. Here, the segment initiating the

10

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

comparison cannot grow during the comparison, while the other one can. Hence, if the initiating segment is smaller, it remains smaller even if the other segment grew in the meantime. We thus have the smaller segment win. Moreover, we show that the time for that win is proportional to the size of the smaller segment. (Additional time is used later for the winning segment to "absorb" the particles of the losing one.) After the election of leaders, careful cancellation of negative partial sums with positive ones allows the boundary leader to decide whether the boundary is an outer one. In this case, the termination is announced using flooding, to save time.

4 LEADER ELECTION
In this section, an  () round leader election algorithm is presented in two parts. The first part ­ Sections 4.1 and 4.2 ­ presents and analyzes Algorithm DLE, an  () round leader election algorithm. However, when Algorithm DLE terminates, the particle system may be disconnected. The second part ­ Section 4.3 ­ reconnects the particles system for the sake of later algorithms that may require an initial connected configuration. The runtime of the reconnecting algorithm is  ( ). When executed after the leader election algorithm, it ensures that upon termination, the particle system is connected.

4.1 Disconnecting Leader Election (DLE)

Algorithm DLE starts in a permitted initial configuration 0 and carries out an erosion process starting from the area of

the particle system in 0, denoted by  (0). Define the set  of eligible points to contain initially all the points in the area  (0). The algorithm sometimes marks a point  ineligible. Define  in the resulting configuration  to be -1

(i.e.,



before

executing

this

operation)

minus

{ }.

Neither

the

algorithm

nor

the

definition

of




include

any

operation

of adding a point into  . Henceforth, we do not mention  when it is clear from the context.

Observation 8. During the execution of Algorithm DLE, a non-eligible point does not become eligible. In particular, once a point becomes non-eligible, it remains non-eligible.

The pseudo code is given below. Informally, the algorithm proceeds by an activated particle  who occupies an SCE (w.r.t.  ) eligible point , making  ineligible. For the sake of the analysis, recall that this removes  from  ;  is said to leave  . (If possible,  expands out of  into another eligible point, otherwise,  remain in , but marks  as ineligible (using the variables of neighboring particles); Moreover, a particle keeps track of its ineligible unoccupied neighboring points.) Eventually, a single point remains in  , occupied by some particle  who becomes the leader.
Inputs and Variables. The known outer boundary assumption (removed later) is defined using an input (readonly) variable . [0..5] at every particle . Let  be the point reached via port  (for   {0, . . . , 5}) of  in the initial configuration. Specifically, the (temporary) assumption is that  [] =  iff point  is in the outer face of the particle system's shape initially. The . variable is the leader election output and takes value in {, ,   }. The . [] variable, for any   {0, . . . , 5}, indicates whether the point  reached via port  of 's head is eligible or not. Initially,  [] is set to  if the point reached via port  is either occupied or . [] =  .

Definition 9. The  variable of a particle  is said to be consistent if for any   {0, . . . , 5}, . [] =  if and only if the point  reached via port  of 's head is in  .

Efficient Deterministic Leader Election for Programmable Matter

11

Algorithm DLE. Solution for the disconnecting leader election problem

1: Input:

2: . : a boolean array of length 6

 Indicates which neighbors are initially outside the system's shape.

3:

4: Initialization:

5: . := 

6: for   {0, . . . , 5} do . [] := (. [] =  )

 True for occupied or hole neighbors

7:

8: During the atomic activation of particle :

9: if  is expanded then  contracts into its head.

10: else if .   and   N (), .   then

11:  terminates

 If  and all of its neighboring particles have decided, then  terminates.

12: else if . =  then

13: //  is contracted and occupies some point 

14: if  has no adjacent points in  then

15:

. := 

 According to . [0..5]

16: else if  is an SCE point w.r.t.  then

 And otherwise, do nothing.

17:

//  removes  from  :

18:

for every particle   N () do

19:

if 's head point  is adjacent to  then . [ (, , )] :=  

20:

// Afterward,  keeps the outer boundary of  occupied by moving if necessary.

21:

if  has an adjacent empty point  in  then

 By Claim 10, there is exactly one such point.

22:

// Set the neighborEligible flags in preparation for : only that corresponding to  is set to false.

23:

 :=  (, , ) + 3 ( 6)

24:

for   {0, . . . , 5} \ { } do . [] := 

 Once  expands,  (, , ) = .

25:

. [] :=  

26:

 expands into 

27:

else

28:

. :=  

4.2 Analysis of Algorithm DLE 4.2.1 Correctness. First we prove a geometric claim and an invariant on Algorithm DLE (see Claim 10 and Lemma 11).
Claim 10. Consider a configuration  reached by Algorithm DLE such that the boundary points of  are occupied. In , every SCE point  w.r.t.  has at most one adjacent, empty point in  . Moreover, if the SCE point  has an adjacent empty point in  , then  has a boundary count of 1 w.r.t.  .
Proof. Consider such a point , if it exists. Since  is erodable w.r.t.  ,  has a single local boundary  in  , and  is a local outer boundary (by Proposition 6). In addition,  is strictly-convex w.r.t. , and thus,  has at most 3 neighbors in  . If  has exactly one neighbor  in  ,  is trivially a boundary point of  . Thus,  is occupied and the statement follows. Otherwise, there exists two neighbors ,    of , such that ,  are respectively adjacent to some other neighbors ,    of . Since  and  are boundary points of  , they are occupied and the statement follows. 
Lemma 11. In every configuration reached during a fair execution of Algorithm DLE, the following holds: (1) For any expanded particle, its head (resp., tail) is in  (resp., not in  ). (2)  is simply-connected and non-empty. (3) The boundary points of  are occupied.

12

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

(4) The  variables of all particles are consistent.

Proof. Let us prove this statement by induction. The initial configuration 0 is contracted so (1) holds vacuously. Since  (0) is non-empty and connected, and 0 =  (0), (2) also holds. Part (2) implies that all boundary points of 0 are in the outer boundary of 0. These points are occupied, by definition of  (0), so (3) holds. Now, note that
all particles are contracted in 0 and that in the initialization of Algorithm DLE (see line 6), a (contracted) particle occupying an interior (resp., boundary) point of 0 sets all  flags to  (resp., except for those that lead to points not in 0, using the input). Since the boundary points of 0 are exactly the points that are adjacent to non-eligible points (i.e., not in 0), (4) holds.
Now, consider a configuration  of the execution that satisfies the induction hypothesis and an activated particle ,

and let us show that the statement holds for the resulting configuration +1. First, assume that  does not enter the code block from line 16 to line 28. Then,  either terminates, becomes the

leader, does nothing, or contracts to its head (when  is expanded). Since (1),(2),(3), and (4) hold for  (and for the last

case, the consistency of . depends only on 's head), (1),(2),(3), and (4) also hold for +1. Otherwise, in  ,

 is contracted and occupies some point . Since (4) holds in  , . is consistent. Therefore,  is SCE w.r.t.  .

(Note

that



has

enough

information

to

decide

the

condition

in

line

16.)

During

 's

activation,



leaves




(see

line

17):

+1 =  \ { }. Moreover, if  expands, it expands into some eligible point (see line 26). Thus, (1) holds in +1. Since

 is SCE w.r.t.  , +1 is simply-connected and non-empty, and (2) holds in +1. Let us next show that (3) holds in

 +1 .

Note

that

since



leaves




,

all

the

neighbors

of



in




are

boundary

points

in




+1.

Now,

from

the

consistency

of

. in  , particle  executes line 28 if 's neighbors in  are all occupied, and the code block from line 22 to line

26 otherwise. In the first case, (3) holds trivially in +1. In the second case, (3) holds in  , and thus, by Claim 10, 

has

exactly

one

empty

adjacent

neighbor

in




,

denoted

by

.

Since



expands

into



(see

line

26),

(3)

holds

in

 +1 .

Finally, let us show that (4) holds in +1. First, the particles in N () whose head is adjacent to  have their 

variables modified to be consistent in +1 (see lines 18-19). For all other particles, excluding , their  variables,

without any change, are consistent in +1. As for  itself, if it does not expand, then . does not change and

is consistent in +1. Otherwise,  expands into some empty adjacent neighbor  in  (defined previously). Since (2) and (3) hold in  ,  is an interior point of  : that is, all of 's neighbors are in  . Since  is the only point to become non-eligible during the activation, . is consistent in +1 (see lines 24-25). In summary, (4) holds in +1. 

Theorem 12. Algorithm DLE solves leader election.

Proof. Since  remains connected during the execution (see Lemma 11), when | | > 1, no leader is elected (see

lines 14-15 of the algorithm). Also, note that by the algorithm definition, no point joins  , so | | is non-increasing.

Therefore, consider an arbitrary configuration reached during Algorithm DLE with | | > 1, and let us show that | |

decreases eventually. By the algorithm definition (see lines 17-28), particles decrease | | when they expand. Moreover,

an expanded particle contracts upon activation (see line 9). Therefore, eventually either | | decreases, or all particles are contracted, starting from some configuration . In the latter case, the set of SCE (w.r.t.  ) points in , denoted by

 , is non-empty, by Proposition 7. A contracted particle that occupies a point in  \  does nothing when activated.

Therefore, when a (contracted) particle occupying some point    is eventually activated,  is SCE w.r.t.  . During

that activation,  leaves  so | | decreases. Finally, from the above and Lemma 11, a single point  remains in 

eventually; the particle occupying  at that point becomes the leader (see line 15).



Efficient Deterministic Leader Election for Programmable Matter

13

Remark. Since  initially contains  =  (2) points, the above proof also suggests a naive round complexity of  (2) for Algorithm DLE. In the next section, a more involved analysis leads to an  () round complexity.
Remark. An  (2) round algorithm for leader election ­ that maintains the connectivity of the particle system's shape at all times ­ can be obtained from Algorithm DLE, by translating the ideas of [23] into our work. In Algorithm DLE, particles may end up disconnected from the leader particle. Very informally, a disconnection occurs in Algorithm DLE when a particle  makes a point ineligible and simultaneously marches inwards away from the boundary of  ; to avoid disconnection,  can then also "pull" some neighboring particle  who occupies an ineligible point, if such a particle  exists; we do not follow this approach here.

4.2.2 Time Complexity. The following definitions and invariants are used in the analysis. For any given execution of

Algorithm DLE, consider , the last eligible point occupied by the leader when the algorithm terminates (see Theorem 12)

and some configuration  , reached during the execution after  activations. Then, the level sets and closed neighborhoods

of 

in 

are respectively defined as 


=

{

 

|

 (, )

= }

and  


=

{





|

 (, )

 }, for all integers





1.

(Note

that

if 

>

,




=



and




=

  .)


Moreover,

some

point








is

said

to

be

(, )-SCE-related

if

there

exists

some

SCE

(w.r.t.

)


point 






such

that  

(, )



.

As

a

finite

induced

subgraph

of

the

infinite

triangular

grid,  is 4-free. Since  is, in addition, simply-connected (see Lemma 11), it is a bridged graph [6]. Known results on

4-free bridged graphs give Lemma 13. Building upon it, the following three lemmas (Lemmas 14, 15, and 16) provide

invariants on the execution of Algorithm DLE. These invariants allow us to analyze how many rounds it takes for points in 0, excluding , to become non-eligible (see Lemma 17 and Theorem 18).

Lemma 13 ([6]). For any integer   1, the following holds:

(1)




is

convex w.r.t.  : that is, for

any

two vertices , 






and for any

vertex 

on

any of

the shortest

paths

in 

between  and ,  is also in   .


(2)  does not contain three pairwise adjacent vertices.


Lemma 14. For any integer   1, the following holds:

(1)

 +1


=




 +1

and

 +1


=








+1

,

and

thus,






=




 

and  


=




 

for any integer  

> .

(2)   is simply-connected.


(3)

For any point 

in 


and two neighbors , 



-1

of , 

and 

are

adjacent.

(4)

Any point 

in 


has

at most two

neighbors in -1

and at

most two neighbors

in  .


(5) Points in  are (outer) boundary points of   .





Proof. (1) If +1 =  , (1) holds trivially. Otherwise, by the algorithm definition,  = +1  { } for some point

   . For any two points 1, 2  +1 and some shortest path between 1 and 2, since  is SCE w.r.t.  , if the

shortest path goes through , there exists a shortest path between 1 and 2 that goes through the neighbors in +1 of

. Thus, for any integer   1, +1 =  if    , and +1 =  \ { } otherwise. As a result, (1) holds. (2) Assume, by











contradiction,

that




is

not

simply-connected.

In

other

words,

the

set

of

hole

points



of




is

non-empty.

Since 

is

simply-connected (by (2) of Lemma 11), all points of  are in  . However, for any point    ,  is on the shortest

path

between

two

points 1, 2






by

Proposition

2.

Since




is

convex

w.r.t.



(by

(1)

of

Lemma

13),

this

leads

to

a

contradiction and (2) holds.

(3) Points  and  are at distance at most 2 in  . Assume, by contradiction, that they are at distance exactly 2. Then,  is on one of the shortest paths between  and . However, by (1) of Lemma 13, -1 is convex w.r.t.  , which leads to

14

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

a contradiction. As a result, (3) holds. (4) Assume, by contradiction, that  has at least three neighbors 1, 2, 3 in -1. By (3), 1, 2, 3 are pairwise adjacent. As a result, , 1, 2, 3 form a 4-clique, which leads to a contradiction. Now,

assume,

by

contradiction,

that



has

at

least

three

neighbors

1, 2, 3

in

 .


Let

us

first

show,

by

contradiction,

that

at

least

two

points

in 1, 2, 3

are

adjacent.

Assume

that



has

exactly

three

neighbors

in





and

that

no

two

of

these

neighbors

are

adjacent

(otherwise

the

contradiction

is

trivially

obtained).

Since




is

convex

w.r.t.



(by

(1)

of

Lemma

13), the other three points 1, 2, 3 adjacent to  are not in +1. Hence, 1, 2, 3 are either in -1 or not in  . Since









and






-1

is

convex

w.r.t.




(by

(1)

of

Lemma

13),

at

least

two

points,

without

loss

of

generality 2

and 3,

are

not

in

 .

However,




is

simply-connected

by

(2).

Hence, 2

and 3

are

points

in

the

outer

face

and

removing 

from



would

have

disconnected



from

one

of 1, 2, 3,

w.l.o.g.

3.

This

contradicts

with

3



.


Then

w.l.o.g.,

, 1, 2

are pairwise adjacent, which contradicts with (2) of Lemma 13, and (4) holds. (5) By the definition of level sets, the

neighbors

of

some

point








are

either

in

-1

or  .


Thus,

by

(2)

and

(4),

(5)

holds.



Lemma 15. For any integer   1 and point    , the following holds:


(1) Point  is convex and erodable w.r.t.   (but not necessarily SCE w.r.t.   ).





(2) If  becomes SCE, it remains SCE while eligible, that is, if  is SCE w.r.t.   then for any integer   >  such that







 ,



is

SCE

w.r.t.

.


(3) Point  is (, 2)-SCE-related.

Proof. (1) If  had two (resp., three) local outer boundaries in   , then removing  would have disconnected   . As





a result,   would have been separated into two (resp., three) components (with  in one of them). Hence,  would


have

a

neighbor

in

+1,

leading

to

a

contradiction.

Thus,

by

(5)

of

Lemma

14,



has

one

local

outer

boundary

in





.

Moreover,   is simply-connected (by (2) of Lemma 14), so  does not have a local inner boundary. Thus, by Proposition


6,  is erodable w.r.t.   . It remains to show that  is convex w.r.t.   . If  = 1, this is trivial. Assume that  > 1. Since 





has

a

single

local

(outer)

boundary

in





and

at

most

four

neighbors

in





(two

neighbors

in






-1

and

two

neighbors

in

 , by (4) of Lemma 14),  is convex w.r.t.   and (1) holds.





(2)

Let








be

some

SCE

point

w.r.t.

.


Since









,









and

 's

set

of

neighbors

in





is

included

in

 's

set

of

neighbors

in

,

by

(1)

of

Lemma

14.

Since



is,

in

addition,

convex

and

erodable

w.r.t.




by

(1),



is

SCE

w.r.t.








and

(2)

holds.

(3)

Intuitively,

part

(1)

implies

that

any

level

set

consists

of

straight

line

segments

(each

consisting



of points with a boundary count of 0 w.r.t.   ) whose extremities are strictly convex points (w.r.t.   ). Since  is







contained within a hexagon of radius  centered in  (since     ), each straight line segments can consist of at most


2 points (e.g., a diagonal of the hexagon), and (3) holds.



Lemma 16.

For any integer 



1 and 



0, and (, )-SCE-related point 



 ,


all

neighbors

of



in

+1

are

( + 1,  + 1)-SCE-related points.

Proof. Consider some integer   1 and point    . Let us show the statement by induction on . In the base case,


 is erodable w.r.t.   and thus has a single local boundary  in   by Proposition 6. Recall that  is a cyclic interval of





incident edges. Consider any edge of , excluding the first and last edges, such that the other endpoint     is in


 . Let us show that  is SCE w.r.t. +1. Note that  is in +1. By definition of , and since any two neighbors of 

in  neighbor each other (by (3) of Lemma 14),  is the only neighbor of  in  . Moreover, by (4) of Lemma 14, 





has at most two neighbors in +1. Therefore,  has at most three neighbors in +1. Also,  is erodable w.r.t. +1

by (1) of Lemma 15. Therefore,  is SCE w.r.t. +1. It remains to consider the endpoints 1, 2 of the first and last

edges of . If the successor (resp., predecessor) edge's endpoint is in  , the above claim implies that 1 (resp., 2) is

Efficient Deterministic Leader Election for Programmable Matter

15

( + 1, 1)-SCE-related or not in  . Otherwise, one can show that 1 is SCE w.r.t. +1 or not in  (using (1) of Lemma 15 and (2) of Lemma 13). Hence, the base case holds.

Now, assume that the induction hypothesis holds for some   0. Let point    be an (,  + 1)-SCE-related

point. Assume that  is not (, )-SCE-related, for any 0     (otherwise, the induction hypothesis trivially implies

the induction step). Since  is convex and erodable w.r.t.   by (1) of Lemma 15,  has a single local boundary (by

Proposition 6). Moreover,  is not (, 0)-SCE-related, so by (4) of Lemma 14 and the definition of level sets,  has exactly

two

neighbors

in

-1,

two

neighbors

1, 2







and

two

neighbors 1, 2

that

are

either

in


+1

or

not

in




.

Also,

w.l.o.g., 1 is adjacent to 1 and 2 is adjacent to 2. If exactly one of 1, 2 is not in  , then one can show (using (1) of

Lemma 15 and (2) of Lemma 13) that the other point is SCE w.r.t. +1, and the induction step follows. Hence, consider that both 1, 2  +1. Since  is (,  + 1)-SCE-related, one neighbor of , w.l.o.g. 1, is (, )-SCE-related. So, by the induction hypothesis, 1 is ( + 1,  + 1)-SCE-related. Since 1 and 2 are adjacent, 2 is ( + 1,  + 2)-SCE-related, and

the induction step follows.



Lemma 17.

For any two integers 0









- 1 and 



0, any

(

-

, )-SCE-related point 



0


-



becomes

non-eligible within the first 6 + 2( + 1) rounds.

Proof. Let us prove the lemma statement by induction on , and for each , by induction on .

For the base case of  = 0, if 0 = , then the inner induction on  is vacuously correct. Otherwise, let us first



show

that

for

any

point





0 ,


there

exists

a

contracted

particle

 ,

initially

occupying ,

such

that



remains

contracted and occupies 

while 

is eligible. Since 

is a

boundary point of  0


=

0

(by (5)

of Lemma

14), 

is

occupied, respectively, by some particles  in the initial configuration 0 by (3) of Lemma 11. By the definition of

permitted initial configurations,  is contracted in 0. Assume by contradiction that  is eligible in some configuration  for  > 0 and occupied by some different particle  . Then,  must have expanded once. However, once a particle

expands, its occupied point becomes ineligible (see lines 16-26). Since ineligible points remain so (by Observation 8), a

contradiction

is

reached

and

the

claim

follows.

For



=

0,

let





0


be

some

(, 0)-SCE-related

point.

By

definition,



is

SCE

w.r.t.

0


=

0.

Therefore,

for

any

configuration 

(

>

0)

such

that





 ,



is

SCE

also

w.r.t.




=

 ,

by

(2) of Lemma 15. Moreover, by the claim shown above, for any configuration  (  0) such that    ,  is occupied

by a contracted particle . Hence, when  is first activated (within the first round of the execution),  leaves  (see

lines 16-17). Now, assume that the induction hypothesis (IH) holds for  = 0 and some   0. Let    0 be some


(,  + 1)-SCE-related point (if no such point exists, the inner induction step is satisfied). By definition, there exists

some

SCE

(w.r.t.

0)

point





0


such

that

0


( , )





+

1.

If

0


( , )

<



+

1,

then

the

inner

induction

step follows from ),  leaves  by

the

IH

on

.

Otherwise,




has

some configuration  within

a neighbor  the first 2( +

 1)

0 such

rounds. If

that  

0





,


the

(, ) = . By the inner IH (for inner induction step is satisfied.

Otherwise,

note

that

for

any

configuration 

(

>

0)

such

that





 ,









(by

(1)

of

Lemma

14),

and

thus,



is

convex

and

erodable

w.r.t.




=



by

(1)

of

Lemma

15.

Because 



 ,

for

any

configuration 

­

for 





­

such

that





 ,



is

also

strictly

convex

w.r.t.




=

 .

Moreover,

by

the

claim

shown

above,

for

any

configuration 

(  0) such that     ,   is occupied by a contracted particle . Hence, when  is activated (within one round of

 ),




leaves



(see

lines

16-17).

Next, assume that the induction hypothesis holds for some integer 0   <  - 1, for every integer   0. If

0


-

(



+1)

=

,

the

induction

step

is

vacuously

correct.

Otherwise,

let

us

prove

the

induction

for



+

1

by

induction

on

.

For



=

0,

let





0


-

(



+1)

be

some

(

-

(

+

1), 0)-SCE-related

point.

By

definition,



is

SCE

w.r.t.

0


-

(



+1)

.

16

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

By

Lemma

16,

every

neighbor

of



in

0


-



is

(

-

, 1)-SCE-related.

Therefore,

by

the

IH

(for



=

1

and

 ),

every

neighbor

of



in

0


-



,

if

there

is

any,

leave



by

some

configuration

 

within

the

first

6

+

4

rounds.

If





 ,

then

the

base

case

is

satisfied.

Otherwise,

since

for

any

integer 





such

that 



 , 

is

SCE

w.r.t.




-

(



+1)

(by

(2)

of

Lemma

15)

and

all

of

 's

neighbors

in

0


-



(if

there

are

any)

are

not

in

 .

Hence,



is

also

SCE

w.r.t.

 .

Thus,



is

an

outer boundary point in  by Proposition 6, and so  is occupied by some particle  in  (by (3) of Lemma 11). If  is

contracted in , then when  is activated (within one round of ),  leaves  (recall that  is SCE w.r.t.  , and see

lines 16-17). Otherwise ( is expanded in ),  is the head of  (by (1) of Lemma 11). Within two rounds of ,  is

activated twice. Thus,  contracts into , and  leaves  (recall that  is SCE w.r.t.  , and see lines 9 and 16-17). In both

cases,  leaves  within the first 6 + 6  6(  + 1) + 2 rounds.

Finally,

assume

that

the

IH

holds

for



+1

for

some

,

and

also

holds

for

.

Let






0


-

(



+1)

be

some

( - (



+1),

 +1) -

SCE-related point (if no such point exists, the induction step is satisfied). By definition, there exists some SCE (w.r.t.

0


-

(



+1)

)

point 



0


-

(



+1)

such

that

0


-(



+1)

( , )

=



+

1.

If

0


-(



+1)

( , )

<



+

1,

then

the

induction

step

follows

from

the

IH

on



+

1

and

.

Else,

by

Lemma

16,

every

neighbor

of




in

0


-



is

(

-

, 

+

2)-SCE-related.

By

the

IH

(for



and



+ 2),

every

neighbor

of



in

0


-



,

if

there

is

any,

leave



within

the

first

1

=

6

+ 2(

+ 3)

rounds.

Additionally,

since



0


-

(



+1)

(

,



)

=



+ 1,



has

a

neighbor 



0


-

(



+1)

such

that

0


-(



+1)

(, )

=

.

By

the IH (for  + 1 and ),  leaves  within the first 2 = 6(  + 1) + 2( + 1) rounds. (Note that 2  1.) Consequently,

there

exists

a

configuration

 

within

the

first

2

rounds

such

that



and

all

neighbors

of




in

0


-



,

if

there

are

any,

are

not

in





.

If









,

then

the

induction

step

is

satisfied.

Otherwise,

it

is

now

just

left

to

show

that

for

any







such that    ,   is SCE w.r.t.  . Because this implies, similarly to the base case (for  = 0 and ), that  leaves 

within

the

first

6( 

+ 1)

+ 2(

+ 2)

rounds.

To

prove

that,

note

that










-

(



+1)

(by

(1)

of

Lemma

14).

Thus, 

is

convex

and

erodable

w.r.t.




-

(



+1)

(by

(1)

of

Lemma

15).

Note

also

that



and

all

neighbors

of



in

0


-



,

if

there

are

any,

are not in  (by the definition of  and the IH). Hence  is SCE w.r.t.  .



Theorem 18. Algorithm DLE terminates in  () rounds.

Proof. By (3) of Lemma 15, every point is (, 2)-SCE-related. Hence, all points initially in  , excluding , leave

 in the first  () rounds by Lemma 17. Let  be the first configuration reached in which  is the last eligible point.

Hence,  is an outer boundary point of  . Thus,  is the head of some occupying particle  by (1) and (3) of Lemma 11. If  is contracted in , then when  is activated (within one round of ),  becomes the leader (see line 15). Otherwise,  is activated twice within two rounds of . During these activations,  contracts and becomes the leader

(see lines 9 and 15).



4.3 Reconnecting Leader Election
During Algorithm DLE, the particle system may become disconnected. However, the particle system, even if disconnected, satisfies an important property w.r.t. the grid distance (i.e., distance w.r.t.  ) ­ see Lemma 19 below. Leveraging this property, Algorithm Collect below collects all of the particles gradually such that eventually, the system is connected.
On the way to a connected system, let us define the notion of collected particles inductively. Intuitively, the set of collected particles may not be connected, but this set is already arranged such that it will be easy for the algorithm to connect it later. Initially, the leader  (who occupies the last eligible point  in Algorithm DLE) is the only collected particle. The algorithm executes in phases. In each phase   1, the particles within grid distance 2-1 - 1 from  are already collected, and they cooperate in order to collect particles up to grid distance 2 - 1. In steps (1) and (2) of the

Efficient Deterministic Leader Election for Programmable Matter

17

more detailed algorithm description (Section 4.3.2), we describe the collect action that turns uncollected particles into collected ones. Intuitively, such an action is applied in some of the cases that a collected particle moves and touches an uncollected one. Moreover, the algorithm now adds the newly collected particle into the structure of collected ones such that it will be easy to reconnect. Eventually, some phase is executed with no additional particles collected.
When that happens, the algorithm performs the, by now, easy operation of reconnecting the collected particles. Then the leader terminates and the particle system is connected.
Very informally, the intuition for a phase is as follows: in phase , we would have liked to arrange the collected (contracted) particles into a straight line of length 2 leading from the leader outward. Then, having the line simply rotate around  ­ just like the blade of a fan ­ would have collected every particle up to grid distance 2 - 1. After which, we would want to use Lemma 19 to show that enough particles are collected during phase  and (earlier phases) to perform phase  + 1. The actual implementation of Algorithm Collect is somewhat more involved than that. Three complications that come up in that implementation are described next. The first arises from the fact that there may not be enough collected particles to form a blade of length 2 in phase . (Luckily, Lemma 19 ensures that we have collected at least one half of that number, since we have already collected all the particles up to grid distance 2-1 - 1 from ; hence, we overcome the above mentioned shortage by having a blade of only length 2-1 ­ one half of the desired length, but letting that shorter blade rotate only over grid distances 2-1 till 2 - 1; unfortunately, this make the description of the algorithm more complex.) The second complication consists in dealing with the collected particles that are not used to form the blade. Where can we put the additional particles ­ collected in earlier phases ­ beyond the 2 particles needed for the blade? (Intuitively, the algorithm organizes these "extra" particles at points within distance 2-1 - 1 from , such that they do not impact the blade's rotation yet remain easily accessible.) Similarly, how does the algorithm handle the particles collected during phase  until the end of the phase? (Intuitively, those "extra" particles are "hung" behind the blade ­ that is, counter-clockwise from the blade ­ and rotate with it.) The last complication appears during the rotation. Indeed, the blade particles try to move in parallel; however, an uncollected particle delays the blade particle collecting it. (This is avoided, intuitively, by switching roles between the collecting particle and the collected one: the first does not proceed as a part of the blade, instead, it is hung behind the blade; the newly collected particle becomes a part of the blade.) The "hanging behind the blade" procedure hinted at above is the reason that in the description below we abandon the blade metaphor and speak, instead, of a stem of a tree, where the "hung" particles are referred to as branches.
4.3.1 Properties of the Disconnected Particle System upon Termination of Algorithm DLE. Algorithm DLE allows the particle system to disconnect. However, since  remains connected throughout Algorithm DLE, particles are left behind not arbitrarily, but in an incremental manner. Intuitively, the way particles are left behind resemble a trail of "breadcrumbs" ­ see Lemma 19 below for the precise statement.

Lemma 19. For any   {0, . . . ,  ()}, there exists a contracted particle at grid distance  of  (when algorithm DLE terminates). Moreover, there are no particles at grid distance  >  () of .

Proof. During Algorithm DLE, all eligible points are at grid distance less than or equal to  () from  (by definition of  () and Observation 8). Since particles occupy eligible points initially (by definition of 0) and only expand into eligible points (see lines 22-26), no particle occupies a point at grid distance  >  () of  when Algorithm DLE terminates.

18

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

For  = 0, the statement holds trivially. Now, assume 0 <    (). By definition of  (), there exists a point 

at grid distance  () of  in the initial configuration 0. Since 0 is connected (by (2) of Lemma 11) and   0 (by

Observation 8), there exists a point    0 on an eligible path (consisting of eligible points) between  and , such

that



(


,



)

=

.

Let 

be

the

last

configuration

reached

during

the

execution

of

Algorithm

DLE

in

which

there

exists an eligible point at grid distance     of . Since each activation removes at most one eligible point from  (see

line 17 of Algorithm DLE), there exists exactly one such point, denoted by , in  . By the definition of  ,  becomes

ineligible

between 

and

 +1 .

In

addition,

since




is

connected,




=

.

Since

the

triangular

grid



is

a

bridged

graph,

one can obtain similar results to Lemmas 13 and 14 for the sets {   |  (, ) = } and {   |  (, )  }.

Thus, one can easily show, in particular, that  has at most 2 neighbors at grid distance  - 1 from . Moreover,  has no

eligible

neighbors

at

grid

distance






,

by

the

definition

of

 .

Hence,



is

a

boundary

point

of




,

with

at

most

two

neighbors in  .

Since  is a boundary point of  , it is occupied by some particle  in  by (3) of Lemma 11. If  was expanded in  ,

then



wouldn't

leave



in  ,

which

is

a

contradiction.

Hence,



is

contracted

in

 .

Since




is

simply-connected

(by

(2) of Lemma 11),  is erodable w.r.t.  . Moreover, recall that  has at most two neighbors in  . Thus,  has a boundary

count of 2 or 3 w.r.t.  . Hence, during the activation,  stays in point  by (the contrapositive of) Claim 10 (see line 28

of Algorithm DLE). Consequently,  never moves again until Algorithm DLE terminates, and the lemma holds. 

4.3.2 Algorithm Collect. At the start (and end) of each phase, all of the collected particles are contracted, and the set

of collected particles  ­ initially the set { } ­ is organized into a collection of disjoint line segments. A part of the collected particles ­ starting at  and stretching along increasing grid distances from  ­ forms the main segment, called

the stem. All of the other particles form secondary segments, called branches. Recall that the stem has a single particle

  at distance  from . The branch of distance  contains all of the particles whose grid distance from  is , except for



.

The

branch

is

located

counter-clockwise

from

the

stem

and

one

of

the

particles,

,


of

the

branch

of

distance



is

a

neighbor of   . Sometimes, it is convenient to view the stem together with the branches as a tree directed towards its

root

 .

Particle




is

then

the

root

of

the

branch.

The

number

of

particles

in

a

segment

is

said

to

be

the

segment's

size.

A segment is contracted if all of its particles are contracted. A segment occupies points 1, . . . ,  if its particles occupy

these points.

Phase. Initially, the set of collected particles, as well as the stem, consist only of  . The branches are empty. In phase  = 1, 2, ... (except, possibly, the last two phases), the stem starts the phase with  = 2-1 particles and collects at least as many (as shown later, using Lemma 19). Those particles are thus enough for the stem to double its size before the next phase starts. The rest of the particles (if any exist, beyond those needed for the doubling) remain in the branches. Let us now provide a more precise description of one phase (accompanied by Figure 1) using movement primitives whose descriptions appear in Section 4.3.3. Let 0, . . . , -1 (where 0 = ) be the points occupied by the  particles of the stem initially (recall that the particles are initially contracted).
(1) First, the stem disconnects from its branches and moves  points away from , to occupy all of the points , . . . , 2-1 (where 0, . . . , 2-1 is a straight line of points). If any (up-to-now uncollected) particles occupy these points, a collect action is applied on each such particle and it becomes a part of the new stem. (This is described in more detail as primitive OMP in Section 4.3.3.) In exchange, some of the particles initially in the stem are left behind ­ in some of the points 0, . . . , -1 ­ during the stem's movement. When the first step ends,

Efficient Deterministic Leader Election for Programmable Matter

19

the stem is disconnected from all branches of distance    - 1. The particles left behind are not considered

parts of the stem whether they are connected to it or not. See Figures 1a and 1b.

(2) Afterward, the stem performs one complete clockwise rotation around  and returns to its original location of

points , . . . , 2-1. The rotation is composed of 6 partial (clockwise) rotations each of 60°. (For details see the description of primitive PRP in Section 4.3.3.) During these rotations, a stem particle at distance  from  remains

at distance . While executing a rotation, consider the case that an uncollected particle  at distance  from

 becomes a neighbor of one of the stem's particles, call it   , who too is at distance  from . Particle  is an

"obstacle" in the sense that   cannot continue performing the rotation in parallel to the rest of the stem. Instead,

a collect action is applied on . Particle  takes the place of   in the stem, and  becomes the first particle in the

branch

of

distance

.

If



has

already

been

a

neighbor

of

a

branch

of

distance



whose

root

was,

say,

,


then





becomes the child of   in the branch. Branches remain connected to the stem during the rotations and perform

the rotation with the stem. See Figures 1c, 1d and 1e.

(3) Finally, if no particle was collected in the first two steps, then Algorithm Collect terminates. Otherwise, the

algorithm starts enlarging the stem. (If the size of the stem is already at least  ()/2 then the following enlargement process may not end up enlarging beyond  (); we show later that by Lemma 19, this means that

all the particles are already collected; hence, no particle is collected in the next phase and the algorithm will

terminate; henceforth, for the sake of clarity, we ignore this special case in the current paragraph.) We show that

enough particles were collected in the current phase for the stem to double in size. So it does double, moving to

occupy points {, 1, . . . , 2-1}. (For details see the description of primitive SDP in Section 4.3.3.) Note that we must be careful not to grow the stem beyond doubling even if there are enough particles for that. (Otherwise,

the stem, together with the runtime, could have grown far beyond the eccentricity  () and thus the diameter

 ; avoiding extra growth is done, intuitively, by "charging" every addition of a new particle to the stem to one

expansion and extraction of an "old" stem particle.)

In the process, the stem absorbs any particle left behind in {, 1, . . . , -1} and reconnects with all branches of distance    - 1. After that, a new phase starts. See Figures 1e and 1f.

Analysis of Algorithm Collect. The proofs of Lemmas 20 and 21 appear in Section 4.3.3. Corollary 22 follows straightforwardly from Lemma 21.
Lemma 20. The set of collected particles  is connected at the beginning and end of each phase.
Lemma 21. Consider a phase in which the stem is initially of size . The phase takes  () rounds and all the particles at grid distance   {, . . . , 2 - 1} from  are collected. Moreover, the following holds:
· If    (), then the stem grows to a size of    {min{2,  ()}, . . . , 2 } at the end of the phase. · If  >  (), then no particle is collected during the phase.
Corollary 22. For   {1, . . . , log  () + 1}, the stem is of size 2-1 at the start of phase .
Theorem 23. Algorithm Collect terminates in  ( ) rounds. Upon termination, the particle system is connected.
Proof. By Lemma 19, all particles are at grid distance    () from . In phase , the algorithm collects all the particles at grid distance   {2-1, . . . , 2 - 1} by Lemma 21 and Corollary 22. Thus, at least one particle is collected in every phase   log  () + 1 by Lemma 19. Furthermore, after log  () + 1  log   + 1 phases, all particles have been collected. Hence, the algorithm executes one last phase, in which no particle is collected, and terminates.

20

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

(a) At the start of the phase, the stem of size  = 4 initially occupies point  (with a "ring") and the black points 1, . . . , -1. The points with a "stripe" pattern form two branches of already collected particles (one branch is formed by the vertically striped points and the other by the horizontally striped point). The points with a "checkered" pattern is occupied by an uncollected particle.

(b) The stem moves  points away from , thus occupying the black points , . . . , 2-1. Because two of these points are occupied at the start of the first step, two particle are left behind ­ in the points with a "wave" pattern.

(c) The stem occupies the black points , . . . , 2-1 at the start of the second step. The points with a "checkered" pattern are occupied by uncollected particles.

(d) The stem rotates by 60° clockwise around . By doing so, it sweeps all of the grey points for uncollected particles. Here, two particles are collected, forming two new branches (see the checkered points).

(e) After a full rotation around , the stem occupies the black points , . . . , 2-1 and the newly-collected particles form new branches (see the checkered points).

(f) Using the newly-collected particles, the stem moves back to  and doubles in size, thus occupying  and the black points 1, . . . , 2-1.

Fig. 1. Description of a phase's three steps in Algorithm Collect

When that happens, the particle system is connected by Lemma 20. The runtime follows directly from the number of

phases and Lemma 21.



4.3.3 Movement Primitives. Let us first give some preliminary definitions. Similarly to the above definition of the branch root, the closest stem particle to  (in grid distance) is called the stem's root and the furthest particle the leaf. Naturally, this defines for each other particle in the stem, a single parent and child neighboring particle. (Note that during most of the movement primitives described below, it is simple to maintain this tree structure while particles are moving.) The root (either that of the stem, or of a branch) is considered as the segment's first particle, and the leaf is the segment's last. Consider a contracted stem of size  and denote its particles by 1, . . . ,  starting from the root.

Efficient Deterministic Leader Election for Programmable Matter

21

When Algorithm Collect starts, the leader particle  assumes its six incident edges (in order of increasing port number) to lead, respectively, W, NW, NE, E, SE and SW. Furthermore,  chooses two opposite directions (e.g., E and W) to indicate the outwards and inwards direction for the stem. These two directions are denoted, respectively, by ì and ì. Then, whenever a particle, say , is collected,  "learns" all the above mentioned directions of the leader (including ì and ì). Indeed, recall that  is being touched by some already collected particle . In general, this would not have been enough for  to learn directions from . However,  and  also share common chirality. See primitive Redirect below.
Virtual Movement Operations and Virtual Particles. Consider the case that a contracted particle  is instructed by the algorithm to expand from a point  along some edge {,  }, but the other endpoint  of that edge is already occupied by some contracted particle . Particle  virtually expands into . In particular,  writes into both 's and 's memories that  is the head of a virtual particle denoted (, ), together with the port numbers of 's port leading to  and 's port leading to . The virtual particle plays the role that  was playing up to that point in time (e.g., as a stem particle). Particles  and  now starts cooperating in order to simulate the actions of (, ).
After virtual expansion, let us now speak of virtual contraction. Consider some virtual particle (, ) (playing the role of some particle  who virtually expanded and now occupies points  and  correspondingly). First, consider the case that no handover is involved. That is, particle (, ) decides to contract to point , the head of (, ). Particle  leaves the simulation and the virtual particle is now simulated by particle  alone. At first glance, this may create a strange situation, since the virtual particle used to play the role of , and  is the one leaving the simulation. However, recall that particles do not have identities, and the names , , etc. we used for our convenience only. As a part of the above virtual contraction, we say that the actual particle occupying points  and  (who used to be named  and  correspondingly) have lost their old names. Instead, the actual particle occupying point  is now called , and it plays every role  used to play, in particular, as a stem particle. The new name of the particle occupying  is not important. (For the sake of convenience, we can call it .) We also say that  virtually moved from  to  by way of the following two virtual movement operations: first, a virtual expansion (to ) and then, a virtual contraction (from ).
Similar to the non-virtual case, a virtual contraction can take place also as a part of a handover. Let us show how to simulate the contraction action where a non-virtual particle  is non-virtually expanded from some point  to a neighboring point . There, some neighboring contracted particle  could expand into , thus forcing  to contract to .
If  is, instead, the virtual particle (, ) (occupying points  and  correspondingly), then still some neighboring contracted particle  may wish to expand into (w.l.o.g)  (occupied by ). Note that since  is contracted,  is not virtual. Reading , particle  learns that  participates in the simulation of a virtual particle (, ). Then  virtually expands into the tail  of (, ) by having  and  simulate (the tail and head of) a virtually expanded particle (, ), playing the role of  . Note that  needs to act too in order to let  know that the simulation of (, ) is over. This leaves  contracted. As in the previous case of a virtual contraction from the tail, the particle occupying  is thus renamed . (The new name of the particle occupying  is not important.) Note that we have shown here the case of a contraction from the tail, otherwise, no renaming of the particles would have been necessary.
Auxiliary Implementations. Auxiliary primitive Redirect involves an edge  between some points ,  occupied by some particles ,  (correspondingly). Let  and  be the port numbers of  and  for . (Recall that both port numbers are known to  and , see Section 2.2.) Particle  writes in  the instruction that the port  should, instead, be numbered  + 3  6. Particle  changes its other port numbers accordingly. It is easy to see that, since  and  have common chirality, the two particles now have the same port numbering. Moreover, particle  also writes in  the numbers of the

22

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

ports corresponding to directions ì and ì . Since the port numbering of  and  are now the same, it is easy for  to point at other ports of  as well. Thus, we also use this primitive (with the obvious additional instruction) to convey an additional direction (the stem rotation direction) in the second movement primitive.
The movement primitives sometimes rely on either the root or leaf to detect when the stem particles (and possibly the connected branch particles) are all contracted or all expanded (including being virtually expanded). This can be done using the following auxiliary primitive, called Detect. Let us show how to detect the global predicate that all stem particles are contracted. (Detecting that all stem particles are expanded can be done similarly.) The root (resp., the leaf) first performs a "local validity check", that is, it verifies that both itself and its neighbor in the stem are contracted. If so, it sends a token along the stem. Whenever a stem particle  receives that token,  similarly does a local validity check. If this check fails,  (destroys the token and) returns an "answer" token towards the root (resp., leaf) with value   ­ thus informing the root (resp., the leaf) that not all particles are contracted. If  is the leaf (resp., root) and its local validity check succeeds, it sends back an "answer" token with a  value to the root (resp., leaf).
To also detect whether the branch particles are all contracted, one can modify the above algorithm as follows. A stem particle  that holds the token sent by the root (resp., leaf) also requests the corresponding branch root(s) (at the same distance(s) from  as ) to perform a similar check along its branch. When an "answer" token (either with a  or with a   value) is sent back towards the root (resp., leaf), the stem particle  holding that answer token also waits for the answer from the branch root. The answer token forwarded by  towards the root (resp. leaf) carries the logical "and" of both values (arriving from the stem and from the branch).
Moving away from . The first primitive we now describe (Outerwards Movement Primitive, or OMP), is applied to the stem initially occupying 0, . . . , -1. OMP moves (all the particles of) the stem by  points in the direction of ì (see Algorithm 1 and Figure 2). From a high level, the first part of OMP expands all the stem particles (such that the tail of the root does not move). This doubles (to 2) the number of points occupied by the stem. (Intuitively, if an expansion ordered by OMP is blocked by an uncollected particle, this is handled using virtual expansions). Then the second part contracts all the stem particles, such that the head of the leaf does not move. This performs the moving of the stem. Once OMP terminates, the stem occupies the destination points , . . . , 2-1, where + =  +  · ì for 0     - 1. If no particle occupies these destination points initially, then when the primitive terminates, particles 1, . . . ,  occupy , . . . , 2-1 respectively. Otherwise, when the primitive terminates, some of the original particles have been replaced; that is, such a particle  moved virtually, and its name  was assigned to some other particle.
In more details, during the first part of the primitive (see procedure  in Algorithm 1), all of the stem's particles expand in the direction of ì whenever possible. Initially, all the particles are contracted. Whenever the leaf particle is activated and contracted, it expands in the direction of ì (expands virtually if the grid point in question is occupied). Whenever a contracted non-leaf particle  is activated and its child + is expanded,  expands in the direction of ì (that is, towards +). This is a virtual expansion if + is virtually expanded, otherwise,  expands by handover with +. As a result, the stem occupies points 0, . . . , 2-1. At this point, it may be composed of two sets of particles. One set consists of the particles that were in the stem when procedure  started. The other set (possibly empty) consists of particles that were uncollected before the procedure was invoked, but became collected (and parts of the stem) when a stem particle expanded into them virtually.
The root detects when every stem particle is expanded (virtually or otherwise) (using Detect) and informs all particles to start the second part (see procedure  in Algorithm 1). At this point, all the stem particles are expanded (possibly virtually expanded). Whenever an expanded non-root stem particle + is activated and its parent 

Efficient Deterministic Leader Election for Programmable Matter

23

is contracted, + contracts to its head (in the direction of ì ) through a handover. Note that if + is virtually expanded, then this contraction is virtual. Whenever the root particle 1 is activated, it contracts into its head if it is expanded. Note that if 1 is a virtually expanded particle occupying some points  and , then the particle at the tail  leaves the stem and the role of 1 is now played by the particle at point . Once the root detects that all of the stem particles are contracted (using Detect), the primitive is done.

(a) Initially, the stem occupies point  (with a "ring") and the black points 1, . . . , -1. The striped points form two branches of already collected particles. The checkered point is occupied by an uncollected particle.

(b) After the first part, all of the points , 1, . . . , 2-1 are occupied by either an expanded particle or a virtually expanded particle (i.e., two contracted particles ­ see the points with "spots"). Note that the uncollected particles from the left figure are collected during the first part.

(c) After the second part, the stem occupies the black points , . . . , 2-1. Note that because two of these points were initially occupied, two particle are left behind ­ in the points with a "wave" pattern. Furthermore, the stem is now disconnected from its branches ­ see the striped points.

Fig. 2. First Step: Moving a stem of size  = 4 away from  by  points

Lemma 24. When executed by a stem of size , primitive OMP terminates in  () rounds. Once OMP terminates, the stem is contracted and occupies the destination points , . . . , 2-1.
Proof. Let us first show that procedure Expansion takes  () rounds. A similar proof provides the same runtime for procedure Contraction. At the start of procedure Expansion, name the stem particles 1, . . . ,  starting from the root to the leaf. We assume that at this point, each of those is a non-virtual particle, and is contracted. This is clearly true the first time OMP is used. We shall show that all the primitives end up that way too.
During the execution, particles can be renamed as defined above for virtual movement operations. We shall show that at any time during the execution, the stem consists of exactly  particles named 1, . . . ,  , but some of them may be virtual. (Intuitively, this may result from the stem expanding into points occupied by uncollected particles.)
Let us say that the leaf particle  holds an expansion permit if it is contracted. A non-leaf particle   holds an expansion permit if   is contracted and   's child is expanded. Since the leaf is initially contracted, the leaf  initially holds an expansion permit. It expands in direction ì in  (1) rounds (see lines 6 and 11 in Algorithm 1) and thus the leaf parent's now has a permit. We say that the leaf forwarded the very same expansion permit to its parent. The parent -1 now expands (see lines 8 and 11 in Algorithm 1) too, forwarding the very same permit to its own parent -2. More generally, if some particle  having a permit ° expands when -1 is contracted, we say that  forwarded ° to -1. Similarly, if  having a permit ° expands when -1 is expanded, but -1 later contracts, this still is a forwarding of permit ° to -1. It is easy to see by induction (from the leaf to the root) that this expansion permit is thus forwarded all the way towards towards the root. Moreover, each particle holding a permit expands in  (1) rounds, so the permit proceeds from each stem particle  toward the root in  (1) rounds.
Notice that the expansion operation of -1 forced the leaf to contract. Thus the leaf now has a second permit. We now claim that the total number of permits is bounded by . (In fact, it is exactly ). Once the root receives the first permit, it expands in  (1) rounds. Since the root 1 cannot contract in procedure Expansion, 1 remains expanded

24

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

Algorithm 1 Moving by  points in the direction of ì

1: procedure Expansion

2: During the atomic activation of a stem particle :

3: if  is contracted and not virtually expanded then

4:

Let  be the other endpoint of ì (for )

5:

if  is not occupied then

6:

 expands into 

7:

else if  is occupied by an expanded particle  then

8:

 expands (through a handover with ) into 

9:

// See the definition of the virtual expansion (through handover) operation for more details.

10:

else if  is occupied by a virtually expanded particle or an uncollected (contracted) particle then

11:

 virtually expands into 

12:

// See the virtual expansion operation's definition for more details.

13:

14: procedure Contraction

15: During the atomic activation of a stem particle :

16: if  is the root then

17:

if  is expanded then

18:

 contracts into its head

19:

else if  is contracted and the tail of a virtually expanded particle (, ) then

20:

 virtually contracts into its head

21:

// See the virtual contraction operation's definition for more details, in particular regarding 's renaming.

22: else if 's parent  is not expanded nor in a virtually expanded particle then

23:

if  is expanded then

24:

 contracts into its head (through a handover with )

25:

else if  is the tail of a virtually expanded particle (, ) then

26:

 virtually contracts into its head through a handover with 

27:

// See the definition of the virtual contraction (through handover) operation for more details.

during this procedure, so no permit can be forwarded to it. Similarly, it is easy to see by induction that no more than  permits can be forwarded to  . Note that the leaf is the only one who can have new permits (not forwarded to it), however, the leaf cannot have a new permit before forwarding any permit it possesses. The claim follows.
We have established that there are up to  different permits. Moreover, the forwarding of a permit, given no previous permit blocks its forwarding, takes  (1) time. These are the conditions for which pipelining is known to exist. That, is, using [7, 29], the total time until no permit can be forwarded is bounded by the length of the longest route of a permit plus the number of permits which is  ().
The first part ­ Procedure Expansion ­ does not terminate while there exists a contracted particle  that is not a part of a virtual expanded particle. (See lines 5-11.) Furthermore, every contraction is the result of an expansion, while the expansion of the leaf does not cause any contraction. Hence, eventually, all the stem particles are expanded. Moreover, virtual expansions and virtual contractions (as used here) do not change the number of a stem particles. Hence, upon termination of procedure Expansion, there exists exactly one virtually expanded particle for every (initially uncollected) particle that occupies a point in {, . . . , 2-1}. By induction on time (and using the definition of virtual movement operations), if there are 0     such uncollected particles, then the stem eventually consists of  virtually expanded particles and  -  expanded particles when procedure Expansion terminates. Hence, 2 points are occupied. Since the

Efficient Deterministic Leader Election for Programmable Matter

25

stem's root stays in  and expands into 1, and the stem remains connected, the points 0, . . . , 2-1 ­ and only these points ­ are occupied by the stem particles.

The second part, Procedure Contraction, does not terminate while there exists an expanded particle or a virtually

expanded particle. In the beginning, the stem's root is expanded ­ it is either an expanded particle  or a virtually

expanded particle (, ). In either case, the root eventually contracts. In the first case,  contracts into its head (see line

18); in the second,  is removed from the stem and  replaces  as the stem's root (see line 20). After which, the root's

child eventually contracts through a handover with the root. Once again, the root eventually contracts. Eventually, all

of the stem particles are contracted. Note that every virtually expanded particle at the start of Procedure Contraction

results in a particle being removed from the stem. Hence, there remain exactly  stem particles. Since, in addition, the

stem's leaf stays in 2-1 and the stem remains connected at all times, the stem particles occupy points , . . . , 2-1

(and only these).



Rotating around . The second step of a phase, the Partial Rotation Primitive (or PRP) rotates a segment of size  > 1 around  by 60° clockwise ­ see Figure 3. For the first rotation, the stem's root sets ì to the clockwise predecessor of ì (e.g., if ì is W, then ì is SW) and communicates the direction to all the stem particles. Then, to rotate around , the stem (1) moves  points in the direction of ì (see Algorithm 2). After which, the stem (2) rotates clockwise around its root by 60° (described as a modified version of Algorithm 2). Finally, the stem's root (3) sets ì to ì 's clockwise successor (e.g., from SW to W) and communicates the new direction to all the stem's particles, to prepare for the next rotation. For the next 5 rotations, the stem similarly executes (1), (2) and (3).
Let us first describe part (1) of primitive PRP. Some challenge is posed by the fact that a particle cannot count (beyond a constant number). However,  particles can count (even in unary) to . Each particle just floods the step with a "move" message. To move, each particle uses a move message originated by a different particle (and moves that message away such that it never returns; recall that the stem is a directed tree). Hence, eventually, each particle moves  steps. In the description below, we actually use two kind of move messages ­ one for the expansion and one for the contraction. A second minor challenge is posed by the requirement that the stem remains connected. Note, however, that under the scheme just described, the parent and the child of a particle  move once between each of 's move, ensuring the continued connection ­ giving the first half of Observation 25. Finally, the role of generating new "move" messages (as opposed to forwarding them) starts with the root and is passed from point to point until the leaf. Note that every move is in the direction of ì . The runtime follows easily from the fact that all the messages are pipelined through the stem (see again [7, 29]).
In Algorithm 2, each (stem) particle can hold at most one ("expand" or "contract") message and initially has a  flag set to  if and only if it is the root. A (stem) particle  who holds a message that has been received from 's parent (resp., child), can only forward that message to its child (resp., parent) +, if it has any, and can delete the message if it has none. (Moreover, to forward or delete a "contract" message,  must be able to contract through a handover with its branch child, if it has one; Algorithm 2 ensures this is eventually possible by having non-leaf branch particles contract through a handover with their child whenever possible, and the leaf branch particle contract into its head when expanded.) Note that to be able to receive this message, + must not hold a message (if + does hold a message, then the message at  waits). Whenever  either forwards or deletes a message,  also executes the message's action (i.e.,  either expands or contracts), as described in Algorithm 2. (Note that the stem particles do not break connectivity while moving in this manner by Observation 25.) Every message is created by a particle  with a  flag set to . (This is not described in Algorithm 2). Actually,  creates a "double" expand message, in the sense that when possible,  forwards

26

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

one expand message to its parent and one to its child (if they exist) simultaneously. After forwarding these expand messages,  creates and sends, similarly, "contract" messages to both its parent and child (if they exist) simultaneously once this is possible. If  is not the leaf, then after its child + no longer holds a "contract" message,  sets +. to  and . to  . Otherwise (p is now the leaf),  waits until all of the particles in the stem and branches (of the connected component) are contracted ­ using Detect ­ before it orders all stem (and connected branches) particles to terminate Algorithm 2.

Algorithm 2 Moving by  points in the direction of ì

1: During the atomic activation of a stem particle :

2: if  has a "contract" message and can forward it then

3: if  is expanded then

4:

if  has a branch child  and  is contracted then

5:

 contracts through a handover with , and forwards the "contract" message

6:

else if  has no branch child then

7:

 contracts and forwards the "contract" message

8: else if  is the head of a virtual particle (, ) then

9:

the virtual particle (, ) virtually contracts into its head

10:

//  and  are renamed: the details are given in the virtual contraction operation's definition.

11:

 forwards the "contract" message

12: else if  has an "expand" message and can forward it then

 One easily sees that  must be contracted

13:

if

the

other

endpoint 

of

ì

is

occupied

by

some

particle




then

14:

 virtually expands into  

15: else  expands into 

16:  forwards the "expand" message

17:
18: During the atomic activation of a branch particle : 19: if  is expanded then 20: if  has no child then  contracts into its head 21: else if 's child is contracted then  contracts through a handover with its child

Now, let us describe part (2) of primitive PRP which rotates the stem by 60° clockwise. Intuitively, the rotation of the stem is not accomplished by any rotation-like behavior from particles. Instead, they continue walking in the same direction as in part (1). However, the second particle of the stem (the child of the root) walks one point forward, the third particle walks 2 points forward, etc. To do so, particles do not count (beyond some constant). Instead, for each point walked by particle   on the stem, particle  +1 walks one point. Then, when particle   is done, its child  +1 walks yet another point.
Specifically, this is done just by making three simple modifications to Algorithm 2. First, the  flag is set to  for the root's child instead of the root. (If the root has no child, then the rotation is done.) Second, the particle that creates an "expand" or "contract" message (i.e., the particle with the  flag set to ) only forwards the messages to its child (and not to its parent). The last modification concerns the stem's tree structure. Once a particle sets its start flag to  , it modifies its parent and child edges to their clockwise successors (to maintain the stem's tree structure despite the staggered movement in direction ì ).
It is easy to observe that these three modifications are enough to ensure the particles 1, . . . ,  move, respectively, by 0, . . . ,  - 1 points in the direction of ì . In the triangular grid, this corresponds to a rotation around the stem's

Efficient Deterministic Leader Election for Programmable Matter

27

root. Observe also that, although the particles do not move the same amount of times, the stem remains connected throughout the rotation because (1) each particle  makes one move in between each of its parent's moves and (2) the additional move  does when the parent is done moving induces no disconnection due to the choice of ì ­ giving the second half of Observation 25. (The first point is simple to show; before particle  moves, it does not forward its move message, and thus cannot accept another move message; hence, this delays the parent from forwarding its next move message to  and moving again.)

(a) Initially, the stem occupies the black points  , . . . , 2-1. The points with a "checkered" pattern are occupied by uncollected particles.

(b) After the first part, the stem has moved by  points in the direction of ì . At the same time, it sweeps all of the grey points for uncollected particles. Here, two particles are collected, forming two new branches (see the checkered points).

(c) During the second part, the stem rotates around the stem's root ­ while "pulling" the branches of collected particles. Hence, after the second part, the stem has rotated by 60° clockwise around .

Fig. 3. (Partial) Second Step: Rotating a stem of size  = 4 around  by 60°

Observation 25. The stem does not disconnect during part (1) nor part (2) of primitive PRP .

Lemma 26. When executed by a stem of size , primitive PRP terminates in  () rounds.

Proof. During the executions of parts (1) and (2) of primitive PRP, the (contracting) behavior of the branch particles

resembles procedure Contraction of primitive OMP. Hence, any correctness and runtime result needed for the branch

particles can be easily obtained by adapting the proof of Lemma 24. For part (1) of primitive PRP, one can easily see

that 2 messages are created. Specifically, every stem particle , from the root to the leaf, creates an "expand" message

followed by a "contract" message. These messages are forwarded away from  (and never return because of the stem's

tree structure). Hence, every stem particle receives all the 2 messages. Whenever a stem particle receives one of these

two messages, it can execute the corresponding movement action in  (1) rounds and does not disconnect the stem by Observation 25. (Note that if  has a branch child , but  is expanded, then  contracts in  (1) rounds ­ possibly

through a handover.) Hence, every stem particles moves  points in the direction of ì . Moreover, the messages are

pipelined and thus, following [7, 29] here too, part (1) of primitive PRP takes  () rounds. The correctness and runtime

of part (2) of primitive PRP can be obtained similarly.



Primitive SDP (Stem Doubling Primitive): Moving back to  and doubling the stem's size. The third movement primitive SDP resembles primitive OMP (Algorithm 1). Initially, the stem is contracted and occupies points , . . . , 2-1. In the first part, the stem expands in the direction of ì. This can be done by using the first part of Algorithm 1 with the reverse direction ì.

28

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

Following the above first part of SDP, there may be some   {0, . . . ,  } virtually expanded particles in the stem. In a second part of SDP, these virtually expanded particles break off into two normal contracted particles. After which, non-root expanded stem particles contract through handover with their parents, if possible. When these movements are no longer possible, the last  particles of the stem (including the leaf) are contracted.
The leaf detects when that happens ­ using Detect ­ and starts the third part of SDP ­ the actual doubling of the stem. Here, stem particles absorb newly-collected branch particles in the stem ­ that is, stem particles contract through handovers with branch particles, thus moving them into the stem ­ whenever possible. Let  be some branch particle brought in that way into the stem. Note that  is still expanded towards the branch. Particle  then contracts (through handover with their branch child if such exists). Then,  starts acting like the other stem particles. A stem particle with no branch children contracts through handover with its child in the stem. The root detects ­ using Detect ­ when the stem is contracted or when there are no longer any newly-collected branch particles. In the first case, the primitive terminates. In the latter case, the root first forces the stem to contract ­ by allowing the leaf particle to simply contract if expanded ­ after which the primitives terminates. Note that in the second case, the stem grows but does not double in size.

(a) Initially, the stem occupies the black points , . . . , 2-1. The checkered points are occupied by (contracted) particles that were collected during the previous step (i.e., the rotation around ).

(b) After the first part, all of the points , 1, . . . , 2-1 are occupied by either an expanded particle or a virtually expanded particle (i.e., two contracted particles ­ see the points with "spots").

(c) After the second part, the contracted particles occupy the last particles in the stem (see the black points with no incident bold edges).

(d) During the third part, the stem moves backs to  and doubles in size (if there are enough newly-collected particles to do so).

Fig. 4. Third Step: Moving a stem of size  = 4 back towards  while doubling its size

Lemma 27. When executed by a stem of size , primitive SDP terminates in  () rounds.

Proof. The first part of primitive SDP is essentially, the same as primitive OMP, only with a different direction.

Thus, correctness and runtime can be shown similarly to the proof of Lemma 24. The second and third parts highly

resemble the second part of OMP. Hence, their correctness and runtime is easily obtained by adapting the proof of

Lemma 24.



Now, we can prove Lemmas 20 and 21.

Efficient Deterministic Leader Election for Programmable Matter

29

Proof of Lemma 20. Let us show by induction that the set of collected particles is connected at the start of phase   1. For  > 1, that statement is equivalent to the following: the set of collected particles is connected at the end of phase  - 1. The base case holds trivially. Next, assume that the set of collected particles is connected at the start of some phase   1. Primitive OMP disconnects the stem from its branches (and possibly leaves behind particles in 0, . . . , -1). Note that the particles left behind do not move during primitive PRP. After primitive PRP, the set of stem particles and newly-collected branch particles is connected. Thus, after primitive SDP's first part (i.e., the expansion towards ), the set of collected particles is connected. It is easily shown that the set of collected particles remains connected throughout the remainder of primitive SDP. Hence the induction step follows and the lemma statement holds. 

Proof of Lemma 21. The phase's runtime follows from Lemmas 24, 26 and 27. Furthermore, primitives OMP and

PRP sweep all the points at grid distance   {, . . . , 2 } from  by Lemmas 24 and 26. Since all particles are within

distance  () of  (by Lemma 19), no particle is collected if  >  (). Next, consider    (). Initially, there

exists (at least) one uncollected particle at grid distance  from  ­ for any   {, . . . , min{2,  ()}} ­ by Lemma 19. Primitives OMP and PRP collects all of these particles, such that they are either in the stem, in the branches of distance

    2 - 1 from  or occupy some of the nodes 0, . . . , -1 (since they were left behind during primitive OMP) at the start of primitive SDP. Let 1 be the number of branches of distance     2 - 1 from  and let 2 be the number of contracted particles in the stem after the second part of primitive SDP. Note that 1 + 2  min{,  () -  },

by Lemma 19 and the fact that (newly-collected) branch particles do not change their distance from  throughout the

rotation. Moreover, note that the 2 contracted particles are the last 2 particles of the stem. Hence, the stem can "pull" in at least one branch particle into the stem from each of the (above-mentioned) 1 branches. Thus, the stem's size

grows by at least min{,  () -  } when primitive SDP ends. Furthermore, primitive SDP cannot grow the stem's size

by more than double. Hence, the lemma statement holds.



30

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

5 THE OUTER-BOUNDARY DETECTION PRIMITIVE (OBD)
This section is included for the sake of completeness ­ to demonstrate that the runtime cost of removing the boundary assumption is only linear in  + . Recall that in the previous section, we assumed that a particle on the outer boundary in the initial configuration knows which of its ports lead to the outer face.5
To implement the detection procedure (OBD), we used tools from traditional distributed computing in the sense that no particle movement is used. The detailed definition of the primitive is necessarily cumbersome, because the memory size of each particle is constant. Hence, coding the procedure resembles programming a Turing machine where the particles simulate both the tape, the head, and the finite control. The description becomes even more cumbersome since the algorithm uses pipeling to increase the efficiency. This makes its description resemble programming multiple Turing machines in parallel, working on the same tape. Hence, we first describe the primitive informally and then give a more formal definition. Similarly, it is pretty easy to understand the ideas of the proof informally (but a more detailed proof is also given for completeness).
Very informally, the particles over a global boundary simulate a virtual ring of v-nodes of a classical network type. Note that by abuse of notation, v-nodes ­ defined in Section 2 ­ are now considered to be constant-size computational agents whose communication is limited to the ring and with no movement capabilities. Moreover, they possess a "sense of direction" [25] allowing each v-node to know which neighbor is clockwise and which is counter-clockwise. The ring executes a classical style algorithm in which v-nodes sum up their boundary counts. Some grid geometry insight is used here to interpret the meaning of that sum: the sum is equal to 6 if the ring corresponds to the outer boundary, and to -6 otherwise ­ see Observation 4. To perform this summing up process, the v-nodes first elect a leader (otherwise, over a virtual ring, it is not clear where to start summing up and when is this process terminated).6 At any point of time during the election process, the ring is covered by non-overlapping sets of consecutive v-nodes. Some of those are called "segments". The others are single sets. Initially, every v-node is in a segment containing only itself (so a segment may be a singleton set too). Let us first describe the election as if it is executed by segments (the non-segment singletons may just react) . We implement that view later.
Associated with each segment of some  v-nodes 1 (1), ... ( ) is a vector (called "label") of length , [ (1 (1)), . . . ,  ( ( ))] going clockwise. A segment  needs to compare its vector with the vector of the next segment clockwise, denoted by 1. If 's vector is smaller, segment  "kills" the next segment 1 and "swallows" its v-nodes one by one (unless all the v-nodes of  are swallowed by some other segment before  finishes swallowing all the v-nodes of 1).
The speed up compared to the boundary detection algorithms in [3, 24] is obtained by removing three bottlenecks. First, two consecutive segments were compared v-node by v-node in [3, 24] ­ like string comparison on a Turing machine. We manage to pipeline the comparisons. Second, the comparison process is somewhat complicated by the fact that segments may change over time. For that reason, the previous algorithms slowed the comparison down even further to compare only when the segments were stable. We manage to overcome the segments' dynamic nature without slowing the competition down. Finally, in [3, 24], each particle  waited to hear a termination signal from the detection primitive over every boundary  belonged to. We use flooding to have outer boundary particles announce their termination to all other particles, resulting in faster termination detection. The flooding saves the propagation

5In this section, we still make the common assumption that particles have common chirality. Note that this assumption is made by most previous papers too (in fact, it is not too hard conceptually to avoid this assumption; in particular, [24] may have not bothered to avoid the additional runtime overhead of the chirality agreement since the runtime of the rest of their algorithm was cubic, so the runtime of the chirality agreement was not their bottleneck). 6Up to 6 leaders may be elected because of the symmetry of the grid (another grid geometry insight taken from [3]).

Efficient Deterministic Leader Election for Programmable Matter

31

time over possibly longer boundaries. Moreover, the announcement just by the outer boundary prevents the congestion created when the results of every boundary were announced.
Following [3, 24], a property that follows from the embedding on the grid is that eventually, some configuration  is reached that is stable in the sense that the virtual ring is covered by up to 6 equal segments. Then, a segment cannot grow nor shrink. Moreover, a segment can know how many such eventual equal segments may exist in  by considering only the sum of the counts over its own segment. Hence, a segment  can detect that the ring has stabilized to  by comparing with up to 6 segments clockwise. (Moreover, that comparison takes  (| |) in runtime, since the other segments are supposed to have the same size as that of .) In addition, by multiplying its own sum at this point by the number of segments in the stable configuration, each segment can know the total sum of the counts over the ring.
For this high level description, it remains to explain how the segment computation is implemented at the level of v-nodes. Implementing most of the above operations is trivial, since the head v-node (the one on the segment's clockwise side) can be the segment's leader and thus oversee operations. Moreover, implementing the communication of the segment with all the other v-nodes is trivial. That is, to communicate with the next segment clockwise (if such exists), the head v-node of a segment just communicates clockwise. A more interesting implementation is that of the comparison between two neighboring segments , 1. The difficulty comes from the v-nodes' constant memories (which implies, furthermore, that their communication has constant "bandwidth"). Such more complex operations are detailed later, after presenting the implementation of the v-nodes. Still, as a very informal example, let us outline how the vectors of two consecutive segments of equal size are compared using pipelining. The algorithm (1) creates, conceptually, a "train" consisting of one mobile agent (called "token" later) per v-node in the segment, each agent carrying the boundary count of its creating v-node, (2) reverses the direction of one of two neighboring trains such that the trains' head agents neighbor each other and the trains' tail agents are far away from each other, and then (3) compares the train head agent of  with that of 1, then delete those head mobile agents, advances the next token in each train until they neighbor each other and compares them, etc.
The implementation of a virtual ring algorithm over the particles on a global boundary is described in Section 5.1 together with other basic definitions such as segments and their labels. Section 5.2 presents an efficient lexicographic comparison primitive to compare the length and the label of a segment  to those of its neighboring (successor clockwise) segment. It turns out that the successor segment may still grow clockwise during the comparison, as well as between comparisons. However,  cannot. Hence, if  is found to be "larger" than (or equal to) its successor segment,  compares again and again. However, if  is found to be "smaller" then  will remain smaller and the successor segment can be "killed". This is described in Section 5.3. If a segment  and its successor are found to be equal, it may be the case that the above mentioned "stable" configuration has been reached with up to 6 equal segments covering the virtual ring. The detection of the stable configuration, the summing up process and the termination announcement are described in Section 5.4.
Before delving into details about the algorithm, let us say a few informal words also about the analysis. The high level correctness arguments are basically those of [3, 24]. The correctness proofs of each individual primitive are rather standard (e.g. that there always remains at least one segment, since it cannot happen that every segment is smaller than the next one on a ring, and if segment  is smaller than 1, then  remains smaller). To see the linear runtime complexity, note that a smaller segment  "beats" a larger one 1. Moreover, for  to grow by |1| v-nodes,  spends  (|1|) time on comparisons and "swallowing". In particular, the travel of a train of size | | into a segment of size |1| is accomplished in runtime  (| |). The reversing of the order of a train of |1| mobile agents (tokens) takes  (|1|) time. Also, the travel to check whether there are 6 equal segments of the same size | | takes  (| |) time.

32

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

5.1 Implementation and Definitions
Recall that a single (contracted) particle  may occupy a boundary point  with multiple local boundaries and thus, may be associated with multiple v-nodes. In that case,  simulates these multiple v-nodes simultaneously (and each v-node participates in an execution of primitive OBD that is unrelated to the executions of OBD involving other v-nodes of the same particle ). Particles simulate v-nodes by using designated memory variables and communicating (from a v-node to its clockwise successor or predecessor, which must always exist ­ see Observation 3) using the following implementation. (Note that this implementation leverages the particles' common chirality, which we have already assumed, without loss of generality, to be clockwise.) With this implementation, v-nodes form one virtual ring per global boundary. Although the ring's real orientation (from a global view outside the particle system) is clockwise if the global boundary is the outer one, and counter-clockwise otherwise, that "real" orientation has no impact in this section and thus the rings are all considered to be oriented clockwise. In particular, Observation 4 holds no matter what the ring's "real" orientation is.
Each particle  occupying a point  uses the following (two-dimensional) array to store incoming messages:  [0, . . . , 5] [0, . . . , 5]. The first index indicates the message's sender particle ­ more specifically, the port  assigns to the edge leading to the sender particle ­ and the second distinguishes the receiver v-node  () ­ or more specifically, the local boundary . When  simulates the v-node  (), it computes port numbers ~ and  (and, respectively, ~ and  ) to communicate with  ()'s successor (respectively, predecessor) v-node  ( ) (respectively,  ( )). Ports ~ and ~ are used to indicate  to the simulating particles of, respectively,  ( ) and  ( ). Ports  and  are used to specify, respectively, the receiver v-nodes  ( ) and  ( ) ­ the crucial property being that  (respectively,  ) corresponds to one of the edges of  (respectively,  ).
Specifically, let  be the port corresponding to 's first edge and  to 's last edge. Then, the ports  =  - 1  6 and  =  + 1  6 lead respectively to 's clockwise predecessor and successor points w.r.t. . Let us call the particles occupying these points (respectively)  and  . Particle  computes the port numbers ~, ~ that  and  respectively assign to the edges {, } and {, }. (Recall that  has access to that information ­ see Section 2.2.) From these, particle  computes  and  as follows:  = ~ - 1  6 and  = ~ + 1  6.
When  () wishes to write to its clockwise successor (respectively, predecessor) v-node,  writes  ()'s message in  . [ ~ ] [  ] (respectively,  . [ ~ ] [  ]). When  () wishes to read incoming messages from its clockwise predecessor (respectively, successor),  reads . [ ~ ] [] (respectively, . [ ~ ] []) for any port  that corresponds to an edge in .

Lemma 28. The above implementation allows particles to correctly simulate communication between v-nodes.

Proof. First, recall that particles have common chirality, which we consider without loss of generality to be clockwise.

Consider that the v-node  (), simulated by a particle , wishes to communicate a message to its clockwise successor

v-node  ( ), simulated by some particle  (necessarily in N ()). By definition of  ( ), there exist two unique edges   ,    with a common unoccupied endpoint . By Observation 3,  is the last (clockwise) edge of . Since
port  corresponds to , port  =  + 1  6 corresponds to the clockwise successor of  ­ the edge  = {,  }. By the model assumptions,  correctly obtains the port ~ that  assigns to  (and thus to  and ). Then,  writes in  . [ ~ ] [  ] where  = ~ + 1  6. Since  and  ( ) have the same chirality (i.e., clockwise),  is the clockwise predecessor of . Hence, port  corresponds to  for  , and thus to a port in  . Thus,  correctly decodes that
the message is sent from the particle occupying  (i.e., ) and is sent to  ( ) (since  corresponds to an edge in  ).

Similarly, the communication between  () and  ( ) can be shown to be correct.



Efficient Deterministic Leader Election for Programmable Matter

33

Segments. The algorithm maintains disjoint segments; each is defined as a finite, contiguous sequence of v-nodes along a global boundary. (Initially, every v-node belongs to a segment containing only itself.) A segment is considered to be directed clockwise. The tail of the segment is the first v-node of the segment encountered when walking on the ring clockwise and the head the last one. A segment is dynamic in the sense that v-nodes can leave and join it. The only v-node who may leave a segment at some point in time is its tail at that time. The head is responsible for the segment's growth. That is, v-nodes may either belong to some segment ­ those are pledged ­ or may not belong to a segment ­ those are free; if the head's successor is free, then the head requests its successor to join the segment. Then, that v-node is said to be absorbed by the segment and becomes its new head. A segment's tail may be in a defector state (initially, no v-node is in the defector state). Once activated, a defector v-node becomes free and exits the defector state; if this newly free v-node is not a segment head then it also forces its successor to become a defector. A segment with a defector tail is said to be disbanding. Indeed, we show later, in Section 5.3, that a disbanding segment eventually disappears even if for some time its head still continues absorbing free v-nodes.
The label of a segment  ­ denoted by  () ­ is the corresponding sequence of boundary counts, one per v-node; the length of  ­ denoted | | ­ is the number of v-nodes in the segment and the sum of  ­ denoted () ­ is the sum of the boundary counts along the segment. For some segment , if the predecessor  () of 's tail (resp., successor of its head) is pledged, then  ()'s segment is said to be the predecessor (resp., successor) of . Additionally, for any given (non-disbanding) segment , we define 's projection on a given global boundary as the contiguous clockwise sequence of v-nodes starting from 's tail  ( ) (and including all of ) to (but not including) the next non-defector tail 1 (1). (Possibly,  ( ) = 1 (1).) The projection may contain free v-nodes as well as pledged ones that belong to some other segment ~. In the latter case, segment ~ is necessarily disbanding. Projections play an important role in Section 5.3.
5.2 Lexicographic Comparison Primitive (LCP)
A segment  is smaller than its successor segment 1 if either (a) the size of  is smaller, or (b) the sizes are equal and the label of  is smaller lexicographically. The comparison primitive is composed of two modules, one to check condition (a) and the other to check (b). Intuitively, with the separation, we can allow segments that change; we do not want to freeze the segments during comparison, since this would have resulted in the larger time complexity of the boundary detection of [3, 24]. Moreover, the separation allows the comparison initiated by a segment  to have a runtime of  (| |).
The primitive is described using tokens, that is, messages that (virtually) act as mobile computational agents. Very informally, in module (a) (length comparison), each v-node in  generates a token with the tail token and the head token being distinguished. That is, a token in the train may be the head token, the tail token or even both (when the segment contains only one v-node). Let such a sequence consisting of one token per v-node be called train. This train of 's tokens starts marching in a FIFO order into 's successor segment 1, such that only a constant number of tokens can reside in a single v-node. First, the head token moves into the tail of 1. After that, for the head token to advance by one step to the next v-node in 1, the head token "consumes" the token following it in the sequence. Thus, the number of tokens in the train shrinks as they advance. If the head token consumes the tail token but still has not reached the head v-node of 1, then (and only then)  is shorter than 1.
For module (b) (label comparison), both  and 1 generate sequences of tokens, one per v-node. A token generated by a v-node with boundary count  carries  with it. The module then reverses the order of the tokens in 1. That is, let the train be 1 (tail token), 2, ... (head token). Token  -  is moved to virtual token , for 0    . (To reorder, the algorithm virtually completes 1 to be a virtual ring 0, 1, ...,  - 1, ,  - 1,  - 2, ...0 and the tokens march in a FIFO order over the ring to their designated places.) Next, the head tokens of  and 1 compare themselves ­ note that they now

34

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

reside in neighboring v-nodes ('s head v-node and 1's tail v-node). Then, the head tokens of both trains are deleted, the next tokens in those trains become the head tokens, march to the neighboring v-nodes and compare themselves, etc. This concludes the high level description. Let us now supply more details.

Multiplexing trains of tokens: Note that at the same time segment  utilizes a sequence of tokens to compare with its successor 1, the predecessor 0 of  may initiate a comparison between 0 and . This implies additional trains traversing , such as the train of 0 and the train  generates in order to facilitate the comparison with 0. Luckily, it is easy to show that the number of trains that traverse the v-nodes of segment  at any given time is constant ­ see Observation 29. To prevent the case that one train blocks the other, we designate several memory variables in each v-node for each possible train in each direction (clockwise and counter-clockwise). Note that a constant number of trains can pass from a v-node  () to its neighbor  () simultaneously without increasing the runtime, since the amoebot model allows the writing of several memory variables at the same activation of a particle.
For the comparison primitive discussed now, two different train types are used: one for the length comparison and one for the label comparison. Note that it is straightforward to translate the token based description into a corresponding algorithm for the amoebot model (with v-nodes): whenever a v-node holds a certain token, it simulates the token accordingly. If the v-node holds (necessarily a constant number of) multiple tokens, the v-node simulates them in their order of arrival, thus keeping the order also when forwarding them.

Details for Length Comparison. The initiating segment's head creates a length train creation token, which moves along the segment counter-clockwise until it reaches the tail, instructing the v-nodes to generate length tokens, the collection of which is a length train encoding | | in unary (since the train is composed of | | tokens). The length train moves clockwise from  into 1. However, in 1, forwarding the train head token consumes a unit token. More precisely, a head token (of the length train of ) moves from a v-node 1 (1) of 1 to the next (clockwise) v-node 2 (2) of 1 if and only if (1) v-node 2 (2) has a free memory location reserved to the length train of  and (2) 1 (1) holds at that time another token  (beside the head token) of that train. Token  is then deleted when the head token is forwarded. Note that every other token of any train marching clockwise (correspondingly, counter-clockwise) in a segment marches to the next v-node  () of the segment clockwise (resp. counter-clockwise) provided  () has a free slot (in those reserved for that train). No consuming takes place in the march of other tokens.
If all the tokens of the length train are consumed before the tail token reaches the head of 1 (i.e., a non-head v-node holds both the head token and tail token and no other token in that train), then | | < |1|. If, on the other hand, the head of 1 holds both the head token and tail token and no other token in that train, then | | = |1|. In which case, the head v-node of 1 is marked and remains marked until primitive LCP terminates. (In the case that 1 absorbs additional v-nodes before or during the label comparison, the mark is used to prevent the runtime from growing beyond  (| |)). Otherwise, | | > |1|. (This is the case in which the head of 1 holds the head token together with an additional one.) In all three cases, when the head token computes the result of the computation, it becomes a result token. This last token moves (counter-clockwise) to the head of segment , deletes all the remaining tokens in the (length) train along the way and returns the length comparison's value.

Label Comparison. The initiating segment  creates a label token train representing the segment's label. More precisely, it generates a count token at each v-node  () of segment , holding  ()'s boundary count  ( ()). The token generated at the head is also a head token, and the one generated at the tail is also a tail token.

Efficient Deterministic Leader Election for Programmable Matter

35

Segment 1 is then instructed to create a reverse count train that is structured initially the same as the count train of segment  above, with one important exception: for the reverse count train, tokens are only generated by v-nodes located between the tail of 1 (including) and the marked v-node of 1 (including). The head token of this train then marches counter-clockwise until it reaches the tail of 1. Every other token of the reverse count train first marches clockwise until it reaches the marked v-node (of 1) and then counter-clockwise. (If no additional actions are taken later, then eventually, this process leads to the reverse count train having its head token in the tail v-node of 1 and its tail token in the marked v-node of 1.)
The initiating segment's head compares the count tokens of both trains in order to determine the result of the lexicographic comparison. More precisely, the head v-node of  compares the first-to-arrive count tokens (of ) with the first-to-arrive token in the reverse train at the tail of 1. If one of them is larger, then the corresponding segment is deemed larger; the head v-node of segment  stores the result of the comparison and initiates a delete of the remaining tokens of both segments. Otherwise, the two compared equal tokens are deleted so the next tokens in both trains can be read by the head of . (Recall that the count train marches clockwise while the reverse count token marches counter-clockwise.) Eventually, either one token in the compared pairs is larger (and the corresponding segment is deemed larger) or no count token remains. In the latter case, the segments are deemed equal. The result is stored at the head v-node of . Finally, that head sends a clean token to the marked v-node of 1, which unmarks it, and then comes back to the head of . At that point this primitive terminates.

Remark. · The execution of this primitive may be interrupted by decision of the algorithm using it as a subroutine (namely, by the Outer-Boundary Detection primitive). Any v-node or token executing the primitive and being instructed to cancel, terminates its execution of the primitive. (This can happen if segment  loses to its predecessor segment ­ a process that takes place in parallel to the comparison between  and 1.)
· During the execution of the primitive, 1 may grow. · This remark explains the conditions in the statement of lemma 31 below. It turns out that even though conditional,
the lemma is strong enough to prove later the correctness of the Outer-Boundary Detection primitive.

Observation 29. The number of trains that traverse the v-nodes of a segment  at any given time is constant.

Observation 30. Consider a train of length . As long as the the token at the head of the train can move one step within  (1) time (e.g., it has not arrived yet at its destination v-node) then each token moves  steps within  () time. If the head token can no longer move, then, within  () time, a configuration is reached where the first  tokens after the head cannot move (since the location each needs to move to is occupied by the previous token in the train).

Proof. See [7, 29].



Lemma 31. · The primitive terminates in  (| |) time. · The primitive returns the correct comparison result when 1 (and ) does not grow and the execution is not cancelled. · if the execution is not cancelled, the following two (correctness) properties are guaranteed. First, if  () <  (1) initially, than the result is <. Second, if the result is <, than  () <  (1) at the end of the primitive.

Proof. First, note that  (1) cannot become lexicographically smaller during the primitive. The termination and

time complexity follow from Observation 30 and from the observation that at any point, a token just waits for the token

that precedes it in its own train as well as for the other train.



36

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

5.3 Segment Competition
Let us first describe this module as if it is performed by segments as computational agents, and explain the (rather straightforward) implementation of the segments' algorithm by v-nodes (and tokens and trains of tokens) later. Every v-node starts as a segment of length 1: that is, as both the head and (non-defector) tail of a segment. Every segment performs expansion attempts repeatedly until an outside signal (discussed in a later subsection) instructs it to stop. In an attempt, a segment  whose successor v-node  () is free (that is, unpledged) absorbs  (). Specifically, 's head informs its unpledged successor who then becomes pledged and also the new head of segment . Alternatively, segment  may have a successor segment 1, that is, the successor v-node 1 (1) of the head of  is pledged. Hence, 1 (1) is the tail of segment 1. That tail 1 (1) may be in a defector state (so 1 is disbanding). This completes the attempt and another attempt starts. (Eventually, the defector v-node 1 (1) becomes free, so 1 (1) can be absorbed by a future attempt.) Otherwise, 1 is not disbanding, and  starts a competition and locking operation. First, it starts a competition with 1 by activating primitive LCP (from the previous section). If  wins (i.e., if  has a strictly smaller label than 1) then  checks whether it is disbanding (that is, whether 's tail v-node is in the defector state). If so, then no further action is taken by  in the module described in this subsection, except for disbanding (v-nodes becoming defectors and then free). Otherwise,  locks its tail ­ a locked v-node cannot be put in the defector state. Next,  forces 1 to disband (once 1 is unlocked if it is locked) and finally,  unlocks itself. If this point is reached, the operation is said to be successful. Otherwise the operation is unsuccessful. Whether successful or unsuccessful, the current expansion attempt is done and the segment starts a new one. Note that after an expansion attempt with a successful competition and a locking operation, each v-node of 1 (one by one, starting from the tail of 1) eventually becomes a defector, and then becomes free. Recall that these v-nodes are absorbed by  in future expansion attempts (unless  disbands too before absorbing all the v-nodes of 1).
Importantly, the competition procedure described in this subsection never detects its own termination. An additional module is presented later to force the termination of the Outer-Boundary Detection primitive. Until the forced termination, each segment  keeps competing with its successor 1 if 's label is greater or equal than 1's label. However, we show later that every global boundary is eventually stable: that is, it is covered by non-disbanding segments with equal labels. Note that at that point, the segments of such boundaries no longer change.
Competition and Locking Operation. Although a simple description with segments as computational agents is given above, it is in fact, the segment's head who dictates its segment's expansion attempts. The following describes the competition and locking operation initiated by . First, the head  () of  starts a lexicographic comparison with 1. If (the result is that)  () <  (1), then  () sends a locking token to 's tail  ( ). Eventually,  ( ) receives that token. If  ( ) is a defector, then it sends a unsuccessful token to  () and the operation is done. Otherwise,  ( ) becomes locked and sends back a disband token to  (). Once  () receives this token, it waits until the tail 1 (1) of 1 is unlocked. When that happens,  () instructs 1 (1) to become a defector. Finally,  () sends a unlocking token to  ( ), which sends back an acknowledgement token to  (). Upon  ()'s reception of that token, the operation is over.
Observation 32. A boundary always consists of at least one non-disbanding segment.
Proof. When the primitive starts, every v-node is a non-disbanding segment. Consider the competition between some segment  and its successor 1 as a result of which 1 starts disbanding. (Note that this is the only case that 1 can start disbanding.) From the description of the algorithm, at that time,  is locked, and thus is not disbanding. Moreover,

Efficient Deterministic Leader Election for Programmable Matter

37

from the description of the algorithm and the correctness of the lexicographic comparison primitive (see Lemma 31),

segment  locks itself only if its successor 1 has a strictly greater label than . Moreover, the label of  cannot grow

until its successor starts disbanding. At the same time, the label of 1 cannot shrink until it starts disbanding, at which

point, it cannot instruct any other segment (including ) to disband (because 1 cannot lock). That is, if  later disbands,

it is because of another segment whose label is strictly smaller. The observation follows.



Observation 33. A stable boundary consists of either 1, 2, 3 or 6 segments.

Proof. A stable boundary consists of segments with equal labels only (and at least one, by the previous observation).

Then, these segment's sums are equal integers. Since the sum of counts of all the v-nodes in a ring is either 6 or -6 by

Observation 4, the statement follows.



Lemma 34. Every boundary is eventually stable.

Proof. By Observation 32, a boundary always has at least one (non-disbanding) segment. Also, note that a boundary

(of length ) with a single non-disbanding segment of length  is stable. Thus, to show the lemma statement, it suffices to

show that for a non-stable boundary, within finite time, either the number of non-disbanding segments strictly decrease or the sum  of their lengths strictly increase. Note that the number of non-disbanding segments is non-increasing

(since a disbanding segment remains disbanding until all its v-nodes are absorbed by its predecessor segment, and no

segment ever splits otherwise). Also note that the length of a non-disbanding segment is non-decreasing.

First, consider the case that the boundary is covered by non-disbanding segments. If all of them are equal in their

labels, then the boundary is stable. Otherwise, at least one of them starts disbanding by Lemma 31 and the action taken

when a segment  wins a comparison with its successor.

If the boundary is not covered by non-disbanding segments, then there either exists a disbanding segment or a free

v-node. Recall that there must also exist a non-disbanding segment  by Observation 32. Furthermore, without loss of

generality, the clockwise successor 1 (1) of the head of  is either the tail of a disbanding segment 1 or a free v-node. In the first case, 1 (1) eventually becomes free. Hence, in both cases, eventually either  absorbs 1 (1) and  grows
by one, or  becomes disbanding. Since there must always exist a non-disbanding segment, one can consider a maximal

chain of segments 1, 2 = , . . . ,  such that  never disbands and each of 1, . . . , -1 disbands before it absorbs an

additional v-node. Then, again, the tail of -1 eventually becomes free. Since  never disbands,  eventually absorbs

that tail v-node and  grows by one. Thus, the lemma holds.



Round Complexity Analysis. To analyze the round complexity of the segment competition algorithm, we focus not on segments but rather on their projections. Segment projections grow through successful competition and locking operations only, unlike segments which grow by absorbing individual free v-nodes. More precisely, consider some initiating segment  and its successor segment 1, such that  performs an expansion attempt with a successful competition and locking operation. Then, 's projection after the attempt is the concatenation of the projections of  and its successor 1 just prior to that competition.

Lemma 35. A boundary of length  becomes stable in  () rounds.

Proof. Consider an arbitrary execution. By Lemma 34, the boundary is eventually stable and consists of segments of length    each. By the definition of a projection, at that point, the projection of each segment equals the segment itself. First, only the projections' growth is analysed. The core of the proof (see statement below) is to show that these

38

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

projections grow to a size of  in  () rounds. (Note that segments do grow during these first  () rounds, but not

necessarily as much as their projections.) After that, the segments that are smaller than their projections grow to a size

of  in  () rounds. Let us show the following statement by strong induction on 1    : any operation (including initialization) in

the execution, that results in a projection changing to be of length , finishes within the first  () = (2 + 5) rounds

(where  = 10). The base case is trivial, since all the projections of length 1 are obtained by initialization. Consider an

operation

(denoted

O)

that

results

in

a

projection

of

length

1

<









and

assume

that

the

induction

hypothesis

holds

for all  <  . Then, O must be a successful competition and locking operation, involving an initiating segment  and its

successor segment 1. (Note that as a result,  and 1 cannot be disbanding before O ends.) Operation O "merges" 's

projection,

of

length

1





<

 ,

and

1's

projection,

of

length




-





.

We

assume

the

"label"

of

the

first



counts

of

's projection is not lexicographically smaller than the "label" of the first  counts of 1's projection (in the other case, a

similar proof can be obtained).

The prior operations (possibly initialization) that result in 's projection changing to length  and 1's projection

changing to length   -  finish within the first  { (), (  - )} =  (  - ) rounds. Consider a configuration  ­

within the first  (  - ) rounds ­ that is after these two operations end, but before O ends. Note that in , | |, |1| may

be,

respectively,

much

smaller

than

,




-

.

Also

note

that

1

cannot

be

locked

in



and

until

O

ends;

otherwise,

1

would need to terminate its own expansion attempt before O ends and hence its projection would grow beyond   - .

If | | <  in , then  must grow to a length of  before it can compare with 1. Furthermore, if |1|   in , then

1 must grow to a length of (at least)  + 1 before  can compare successfully with 1 (recall the assumption on the

projections' "labels"). This takes at most  rounds for both segments. (Recall that  and 1 do not become non-disbanding before O ends and both segments take at most 1 round to absorb a free v-node.) However,  may be executing an (unsuccessful) comparison ­ started when |1|   ­ when round  (  - 1) +  starts. Since  does a single comparison

with 1 at a time,  completes a successful comparison within  + 2 rounds of  by Lemma 31. Finally, recall that until O ends,  and 1 do not become disbanding, and 1 is not locked. Hence,  completes its expansion attempt within

 + 2 + 4 rounds of  and the induction step follows.



5.4 Detecting the Termination of Primitive OBD

The segment competition algorithm from the previous subsection does not yet solve boundary detection. The remaining

parts of that task are (1) to let the segment heads know when the boundary becomes stable, (2) to have the segment

heads compute the sum of the v-nodes' boundary counts and (3) to start the termination announcement if the boundary

is the outer boundary (i.e., if this sum is 6).

Whenever primitive LCP ­ invoked in the segment competition algorithm ­ deems that the initiating segment  has

the same label as its successor and no stability check is currently being executed by , segment  checks if its boundary

is stable. (On the other hand, whenever primitive LCP deems that segment  and its successor have different labels or

 becomes disbanding,  halts any stability check it is currently performing.) To do so,  first verifies that its sum is

consistent with a stable boundary (i.e., |()|  {1, 2, 3, 6}). Then,  compares its label (in a pairwise manner) with

that of the previous

6 | () |

segments. If all of these comparisons return that the segments are equal (and none of these

segments change), then  is a part of a stable boundary (see Theorem 36 from [3]). (Note that  also does not change,

since otherwise its stability check is cancelled.) Following the detection, a segment  computes whether it is on the

outer boundary ­ if and only if the sum of (all the v-nodes of all the segments) counts is 6 ­ and if so, informs the other

segments on that boundary about the result. Only after all other segments of the outer boundary are notified does a

Efficient Deterministic Leader Election for Programmable Matter

39

particle-system-wide notification ­ by flooding ­ take place (thus allowing all other segments to terminate primitive OBD fast). Indeed, the other segments of the outer boundary can (and may) compute that result themselves. However, it is important that they know the result before they receive the notification. (Since upon receiving the flooding message, the recipient terminates its participation in the primitive; hence, v-nodes on the outer boundary receiving the flooding too early could have concluded they were not on the outer boundary.)

Segment Sum Verification. For a segment  to verify that the sum of the v-node counts is in {1, 2, 3, 6} is somewhat complicated by the fact that the sum can be too large (in its absolute value) to be held by one v-node. Luckily, recall that if the boundary is stable, the sum is in {1, 2, 3, 6}. Let us now describe a procedure that either detects that this sum is not in {1, 2, 3, 6} or computes the sum if it is. The segment creates two token trains ­ a positive token train and a negative token train. Intuitively, the positive train (respectively, the negative train) initially encodes the segment's label restricted to positive (resp. negative) values. Specifically,  generates two sequences of tokens, each consisting of one token per v-node. As before, the head and and the tail tokens of each train are distinguished. In the positive (resp., negative) token train, the token generated by a v-node carries its boundary count  if  > 0 (resp.,  < 0) and 0 otherwise. Although each token initially takes value in {-1, . . . , 3}, we allow the tokens to take values in {-6, . . . , 6} in order to sum up the boundary counts. The two token trains march clockwise towards the head v-node of . To ensure the trains do not block each other, v-nodes assign designated memory variables to each train.
We say that two tokens are mergeable if their sum is in {-6, . . . , 6}. Whenever a v-node holds two mergeable tokens of the same train, the v-node forwards a single token carrying the sum. We say that the v-node merged these two tokens. If one of the merged tokens is the head (resp., tail) token, the resulting token becomes the new head (resp., tail) token (possibly both, if the head and tail tokens are merged). Whenever the head v-node ( () of the segment cannot perform a merging operation as above, it attempts to perform a merging of the following kind: if ( () holds two mergeable tokens ­ one from each train ­ ( () replaces these two tokens by new tokens, one in each train. One of the new token carries the sum of the replaced tokens and the other carries 0. Note that a token carrying 0 is mergeable with any other token.
Eventually, one of the token trains is reduced to a single token (both the head and tail now) carrying a value of 0. Then, the head v-node waits until it either also holds the single token  of the other train (when that token is both the head and the tail token), or two tokens of the other train such that their absolute values add up to at least 7. In the first case, if  has an absolute value in {1, 2, 3, 6}, then () is equal to 's value and is consistent with a stable boundary. Otherwise (or in the second case), () is not computed but is known to be inconsistent with a stable boundary.

Stable Boundary Check. If a segment  computes that |()|  {1, 2, 3, 6}, it remains for  to verify that its label is

equal to that of the previous 

=

6 | () |

segments (that includes 

itself, on a stable boundary). Segment 

can do this

verification in  (| |) rounds. This process is extremely similar to LCP so we do not describe it in detail here. Similarly,

the proof is too similar to be repeated. Let us just touch upon the minor additions on top of LCP. First, of course, there

are  comparisons, not just one. Second, to compare with its predecessor, the token trains move in the reverse direction

and the role of the head and tail tokens are exchanged. Third, when comparing to a far away segment rather than to

the predecessor, the comparison train of  marches not just to 's predecessor segment -1, it needs to proceed until

-1's tail and then to -1's predecessor -2 (when comparing to -2). To compare with such a "far" segment, the tail token needs to count how many segments it has passed so far on the way from  (and later, back to ). For that, it

counts segment heads encountered. Fourth, when comparing to a segment, the train of  marks the tail of that segment.

(Segment -1's tail is marked by 1, segment -2's tail by 2, etc; Note that in parallel, the tail of -2 may also be marked

40

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

by the process initiated by -1, etc.) Fifth, whenever a marked segment ~ becomes disbanding, its tail  ( ) sends two tokens. One token is sent counter-clockwise in order to cancel all (stability check) comparisons with ~'s predecessor. (Note that this correctly cancels, for any stability check ~ is participating in, the current comparison because ~ must be the last already compared segment by Observation 37.) The other token is sent clockwise to inform all (stability check) initiators ­ that have already compared with ~ ­ that ~ is disbanding. Note that the segments between ~ and  cannot become disbanding before ~ does by Observation 37, and hence the second token ­ by leveraging  ( )'s marked number ­ correctly reaches the intended initiators.

Informing Other Segments on the Outer Boundary. Once a segment  detects that the boundary is stable, it can deduce whether it is on the outer boundary or not. Specifically, segment  is on the outer boundary if and only if the total sum of counts  · () equals 6 ­ see Observation 4. If  is on the outer boundary, it informs all of the other segments on that boundary that they are on the outer boundary. To do so, the head v-node of  sends an outer token along the boundary. Once the token has gone around the boundary back to 's head, the v-node requests its simulating particle to start the termination announcement, described in the next paragraph. However, multiple outer tokens may be travelling along the boundary (if multiple segments have detected that they are on the outer boundary). To ensure 's head can detect when its token does a full walk of the boundary, an outer token is initially created with a value of 0. Whenever the outer token is forwarded into another segment's tail, the token's value is incremented. Hence,  can detect whether a received token is its own token by checking if its value is .

Termination Announcement. To obtain fast termination detection, outer boundary particles announce the termination of primitive OBD to all the other particles using flooding. Every particle receiving the flooding stops executing the primitive. Since flooding is a well-known algorithm, we omit the details.

Theorem 36 ([3]).

There exists

a sequence of 1 +

6 | |

adjacent equal label segments,

whose common sum 

has an

absolute value in {1, 2, 3, 6}, along a boundary if and only if that boundary is stable. Then, the first and last segments of the

sequence are the same.

Observation 37. Consider a stable boundary check initiated by a segment . As long as the last already compared segment ~ remains non-disbanding, then so do all other already compared segments. Hence, the stable boundary check is properly cancelled if ~ becomes disbanding. Moreover, either none of the already compared segments grow or  cancels its stable boundary check.

Proof. As long as segment  is executing the stable boundary check,  is non-disbanding and its label does not change (otherwise,  cancels the stable boundary check). Given this, a simple induction leads to the statement. 

Lemma 38. While a boundary of length  is not stable, its virtual particles do not detect that the boundary is stable.

Proof. Assume, by contradiction, that some segment  executing the stable boundary check detects that the boundary

is stable (while, in fact, it is not). First, note that  cannot be disbanding nor does it grow (otherwise the stable boundary

check fails). Moreover, none of the compared segments disband nor grow (otherwise the stable boundary check also

fails ­ see Observation 37). Thus, if the  comparisons between segment  and its  previous segments returns that

they have equal

labels, then there is

a sequence

of 1 +

6 | () |

adjacent equal

label segments. However, this leads to a

contradiction with Theorem 36, and thus the lemma statement holds.



Lemma 39. Once a boundary of length  is stable, its v-nodes detect that the boundary is stable in  () rounds.

Efficient Deterministic Leader Election for Programmable Matter

41

Proof. Once the boundary is stable, then from the algorithm description and Theorem 36, at least one segment

detects that the boundary is stable. Moreover, the segment does so in  () rounds.



Corollary 40. There exists an outer boundary v-node that initiates the termination announcement within  ( ) rounds. Moreover, it does so only after all outer boundary v-nodes are aware that they are on the outer boundary.

Proof. The first part of the statement follows from Lemma 39 and the fact that the outer token traverses the outer

boundary in  ( ) rounds. The second part follows from the fact that a v-node waits for the outer token to traverse

the outer boundary before initiating the termination announcement.



Theorem 41. Primitive OBD terminates in  ( + ) rounds.

Proof. The outer boundary becomes stable in  ( ) rounds by Lemma 35. Furthermore, there exists an outer

boundary v-node that initiates the termination announcement in  ( ) rounds by Corollary 40. Since the termination

announcement starts only after all outer boundary v-nodes know they are on the outer boundary (by Corollary 40), all

particles correctly deduce which of their local boundaries are part of the global outer boundary. Moreover, the flooding

mechanism takes at most  () rounds. Hence, the theorem statement holds.



42

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

ACKNOWLEDGMENTS
The research of Fabien Dufoulon was supported in part at the Technion by a fellowship from the Lady Davis Foundation. The research of Shay Kutten was partially funded by a grant from the Binational Science Foundation. The research of William K. Moses Jr. was supported, in part, by NSF grants, CCF1540512, IIS-1633720, CCF-1717075, and BSF grant 2016419.

REFERENCES
[1] Marta Andrés Arroyo, Sarah Cannon, Joshua J. Daymude, Dana Randall, and Andréa W. Richa. A stochastic approach to shortcut bridging in programmable matter. Natural Computing, 17(4):723­741, 2018.
[2] Hans-Jurgen Bandelt and Victor Chepoi. Metric graph theory and geometry: a survey. Contemporary Mathematics, 453:49­86, 2008. [3] Rida A. Bazzi and Joseph L. Briones. Stationary and deterministic leader election in self-organizing particle systems. In Proceedings of the 21st
International Symposium on Stabilization, Safety, and Security of Distributed Systems, pages 22­37. Springer, 2019. [4] Sarah Cannon, Joshua J. Daymude, Cem Gökmen, Dana Randall, and Andréa W. Richa. A local stochastic algorithm for separation in heterogeneous
self-organizing particle systems. In Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques (APPROX/RANDOM 2019). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2019. [5] Sarah Cannon, Joshua J. Daymude, Dana Randall, and Andréa W. Richa. A markov chain algorithm for compression in self-organizing particle systems. In Proceedings of the 2016 ACM Symposium on Principles of Distributed Computing, pages 279­288. ACM, 2016. [6] Victor Chepoi, Feodor Dragan, and Yann Vaxès. Center and diameter problems in plane triangulations and quadrangulations. In Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms, page 346­355, 2002. [7] Israel Cidon, Shay Kutten, Yishay Mansour, and David Peleg. Greedy packet scheduling. SIAM Journal on Computing, 24(1):148­157, 1995. [8] Joshua J. Daymude, Zahra Derakhshandeh, Robert Gmyr, Alexandra Porter, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. On the runtime of universal coating for programmable matter. Natural Computing, 17(1):81­96, 2018. [9] Joshua J. Daymude, Robert Gmyr, Kristian Hinnenthal, Irina Kostitsyna, Christian Scheideler, and Andréa W. Richa. Convex hull formation for programmable matter. In Proceedings of the 21st International Conference on Distributed Computing and Networking, pages 2:1­2:10, 2020. [10] Joshua J. Daymude, Robert Gmyr, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. Improved leader election for self-organizing programmable matter. In Proceedings of the 13th International Symposium on Algorithms and Experiments for Sensor Systems, Wireless Networks and Distributed Robotics, pages 127­140. Springer, 2017. [11] Joshua J Daymude, Robert Gmyr, Andrea W Richa, Christian Scheideler, and Thim Strothmann. Improved leader election for self-organizing programmable matter. arXiv preprint arXiv:1701.03616, 2017. [12] Joshua J. Daymude, Kristian Hinnenthal, Andréa W. Richa, and Christian Scheideler. Computing by programmable particles. In Distributed Computing by Mobile Entities, pages 615­681. Springer, 2019. [13] Joshua J. Daymude, Andréa W. Richa, and Jamison W. Weber. Bio-inspired energy distribution for programmable matter. In International Conference on Distributed Computing and Networking 2021, pages 86­95, 2021. [14] Zahra Derakhshandeh, Shlomi Dolev, Robert Gmyr, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. Brief announcement: amoebot­a new model for programmable matter. In Proceedings of the 26th ACM Symposium on Parallelism in Algorithms and Architectures, pages 220­222. ACM, 2014. [15] Zahra Derakhshandeh, Robert Gmyr, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. An algorithmic framework for shape formation problems in self-organizing particle systems. In Proceedings of the Second Annual International Conference on Nanoscale Computing and Communication, pages 21:1­21:2. ACM, 2015. [16] Zahra Derakhshandeh, Robert Gmyr, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. Universal shape formation for programmable matter. In Proceedings of the 28th ACM Symposium on Parallelism in Algorithms and Architectures, pages 289­299. ACM, 2016. [17] Zahra Derakhshandeh, Robert Gmyr, Andréa W. Richa, Christian Scheideler, and Thim Strothmann. Universal coating for programmable matter. Theoretical Computer Science, 671:56­68, 2017. [18] Zahra Derakhshandeh, Robert Gmyr, Andréa W. Richa, Christian Scheideler, Thim Strothmann, and Shimrit Tzur-David. Infinite object coating in the amoebot model. arXiv preprint arXiv:1411.2356, 2014. [19] Zahra Derakhshandeh, Robert Gmyr, Thim Strothmann, Rida Bazzi, Andréa W. Richa, and Christian Scheideler. Leader election and shape formation with self-organizing programmable matter. In Proceedings of the 21st International Conference on DNA Computing and Molecular Programming, pages 117­132. Springer, 2015. [20] Giuseppe Antonio Di Luna, Paola Flocchini, Giuseppe Prencipe, Nicola Santoro, and Giovanni Viglietta. Line recovery by programmable particles. In Proceedings of the 19th International Conference on Distributed Computing and Networking, pages 4:1­4:10. Association for Computing Machinery, 2018. [21] Giuseppe Antonio Di Luna, Paola Flocchini, Nicola Santoro, Giovanni Viglietta, and Yukiko Yamauchi. Mobile ram and shape formation by programmable particles. In European Conference on Parallel Processing, pages 343­358. Springer, 2020.

Efficient Deterministic Leader Election for Programmable Matter

43

[22] Giuseppe Antonio Di Luna, Paola Flocchini, Nicola Santoro, Giovanni Viglietta, and Yukiko Yamauchi. Shape formation by programmable particles. Distributed Computing, 33(1):69­101, 2020.
[23] Gianlorenzo D'Angelo, Mattia D'Emidio, Shantanu Das, Alfredo Navarra, and Giuseppe Prencipe. Asynchronous silent programmable matter achieves leader election and compaction. IEEE Access, 8:207619­207634 (preliminary version appears in AAMAS 2020), 2020.
[24] Yuval Emek, Shay Kutten, Ron Lavi, and William K. Moses Jr. Deterministic leader election in programmable matter. In Proceedings of the 46th International Colloquium on Automata, Languages, and Programming, pages 140:1­140:14, 2019.
[25] Paola Flocchini, Bernard Mans, and Nicola Santoro. Sense of direction: Definitions, properties, and classes. Networks: An International Journal, 32(3):165­180, 1998.
[26] Paola Flocchini, Giuseppe Prencipe, and Nicola Santoro. Distributed computing by mobile entities. Current Research in Moving and Computing, 11340, 2019.
[27] Nicolas Gastineau, Wahabou Abdou, Nader Mbarek, and Olivier Togni. Distributed leader election and computation of local identifiers for programmable matter. In Proceedings of the 14th International Symposium on Algorithms and Experiments for Wireless Sensor Networks, ALGOSENSORS 2018, pages 159­179. Springer, 2019.
[28] Nicolas Gastineau, Wahabou Abdou, Nader Mbarek, and Olivier Togni. Leader election and local identifiers for three-dimensional programmable matter. Concurrency and Computation: Practice and Experience, 2020.
[29] Yishay Mansour and Boaz Pattshamir. Greedy packet scheduling on shortest paths. Journal of Algorithms, 14(3):449­465, 1993. [30] Alexandra Porter and Andrea Richa. Collaborative computation in self-organizing particle systems. In Proceedings of the 17th International Conference
on Unconventional Computation and Natural Computation, pages 188­203. Springer, 2018. [31] Tommaso Toffoli and Norman Margolus. Programmable matter: concepts and realization. Physica D: Nonlinear Phenomena, 47(1-2):263­272, 1991.

44

Fabien Dufoulon, Shay Kutten, and William K. Moses Jr.

A FIGURES ILLUSTRATING THE PRELIMINARY DEFINITIONS

Fig. 5. The black and striped grid points form two shapes in the triangular grid. All other grid points are colored in grey and white. The left shape is simply-connected (i.e., has no holes) and its outer boundary is the set of striped grid points. The right shape is not simply-connected and has one hole ­ the set of grey grid points. The area of the right shape is the set of black and grey grid points.

Fig. 6. Black and patterned grid points form the shape. The striped grid points are erodable. Furthermore, from left to right, these grid points have a boundary count of, respectively, 3, 0, 1, -1 and 2. The checkered grid point is redundant but not erodable. The grid point with "spots" is not redundant. Note that it is strictly convex (with a count of 1) w.r.t. its first local boundary ­ the black dashed edges ­ and has a boundary count of -1 w.r.t. its other boundary ­ the grey dashed edge.

Efficient Deterministic Leader Election for Programmable Matter

45

Fig. 7. The shape's boundary grid points ­ colored in grey ­ are subdivided into v-nodes(s) ­ one per local boundary ­ represented here by black hexagons. Each global boundary is transformed into a virtual ring of v-nodes, where a v-node's successor in the ring is its clockwise successor. Note that the outer boundary's virtual ring is oriented clockwise and the other boundary's ring counter-clockwise.

q p

q p

(a) Triangular grid with white unoccupied grid points and black occupied grid points. Particle  is contracted and particle  is expanded.

(b) Particle  expands from its original occupied grid point ­ the one with a "wave" pattern, now 's tail ­ into the grid point with a "stripe" pattern, now 's head.

Fig. 8. Particle Movement

