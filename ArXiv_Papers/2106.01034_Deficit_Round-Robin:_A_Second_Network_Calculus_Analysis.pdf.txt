1

Deficit Round-Robin: A Second Network Calculus Analysis

Seyed Mohammadhossein Tabatabaee, Member, IEEE, and, Jean-Yves Le Boudec, Fellow, IEEE

arXiv:2106.01034v1 [cs.PF] 2 Jun 2021

Abstract--Deficit Round-Robin (DRR) is a widespread scheduling algorithm that provides fair queueing with variable-length packets. Bounds on worst-case delays for DRR were found by Boyer et al., who used a rigorous network calculus approach and characterized the service obtained by one flow of interest by means of a convex strict service curve. These bounds do not make any assumptions on the interfering traffic hence are pessimistic when the interfering traffic is constrained by some arrival curves. For such cases, two improvements were proposed. The former, by Soni et al., uses a correction term derived from a semi-rigorous heuristic; unfortunately, these bounds are incorrect, as we show by exhibiting a counter-example. The latter, by Bouillard, rigorously derive convex strict service curves for DRR that account for the arrival curve constraints of the interfering traffic. In this paper, we improve on these results in two ways. First, we derive a non-convex strict service curve for DRR that improves on Boyer et al. when there is no arrival constraint on the interfering traffic. Second, we provide an iterative method to improve any strict service curve (including Bouillard's) when there are arrival constraints for the interfering traffic. As of today, our results provide the best-known worst-case delay bounds for DRR. They are obtained by using the method of the pseudo-inverse.
Index Terms--Deficit Round-Robin, Delay bound, Worst-case delay, Network Calculus, Strict service curve, Deterministic networking
!

1 INTRODUCTION

Deficit Round-Robin (DRR) [1] is a scheduling algorithm that is often used for scheduling tasks, or packets, in realtime systems or communication networks. It is a variation of Weighted Round-Robin (WRR) that enables flows with variable packet lengths to fairly share the capacity. The capacity is shared among several clients or queues by giving each of them a quantum value and by providing more service to those with larger quantum. DRR is widely used because it exhibits a low complexity, O(1), provided that an allocated quantum is no smaller than the maximum packet size; and it can be implemented in very efficient ways, such as the Aliquem implementation [2].
We are interested in delay bounds for the worst case, as is typical in the context of deterministic networking. To this end, a standard approach is network calculus. Specifically, with network calculus, the service offered to a flow of interest by a system is abstracted by means of a service curve. A bound on the worst-case delay is obtained by combining the service curve with an arrival curve for the flow of interest. An arrival curve is a constraint on the amount of data that the flow of interest can send; such a constraint is necessary to the existence of a finite delay bound. The exact definitions are recalled in Section 2.1.
The network calculus approach was applied to DRR in [3], where a strict service curve is obtained. A strict service curve is a special case of a service curve hence can be used to derive delay (and backlog) bounds. The result was obtained under general assumptions such as per flow maximum packet size and assuming a server that offers any kind of strict service curve rather than a constant-rate server. They show that their delay bounds are smaller than or equal to all
· EPFL in Lausane, Switzerland E-mail: hossein.tabatabaee@epfl.ch, jean-yves.leboudec@epfl.ch

previous works [4]­[6]. We call this the strict service curve of Boyer et al.
The strict service curve of Boyer et al. does not make any assumptions on the interfering traffic. Hence, the resulting delay bounds are valid, even in degraded operational mode, i.e., when interfering traffic behaves in an unpredictable way. However, in real-time systems, there is also interest in finding worst-case delay bounds for nondegraded operational mode, i.e., when interfering traffic behaves as expected and satisfies known arrival curve constraints. For such cases, significantly smaller delay bounds were presented at a recent RTSS conference [7]. The main improvement in [7] is derived as follows. First, the network calculus delay bound is computed using the strict service curve of Boyer et al.; then, it is improved by what we call the correction term of Soni et al. The correction term is obtained by subtracting two terms: The former gives the maximum possible interference caused by any interfering flow in a backlogged period of the flow of interest and is derived from a detailed analysis of DRR; and the latter gives the effective interference caused by an interfering flow in a backlogged period of the flow of interest, given the knowledge of an arrival curve of that interfering flow. Unfortunately, the method is semi-rigorous and cannot be fully validated. Indeed, our first contribution is to show that the correction term of Soni et al. is incorrect; we do so by exhibiting a counter-example that satisfies their assumptions and that has a larger delay (Section 3).
Later, Bouillard, in [8], derived new strict service curves for DRR that account for the arrival curve constraints of the interfering traffic and improve on the strict service curve of Boyer et al., hence on the delay bounds. These results require that arrival curves are concave and the aggregate strict service curve (i.e., the strict service curve of the DRR subsystem) is convex.

Our next contribution is obtaining a better strict service curve for DRR when there is no arrival curve constraint on interfering traffic. To do so, we rely on the method of pseudo-inverse, as it enables us to capture all details of DRR; a similar method was used to obtain a strict service curve for Interleaved Weighted Round-Robin in [9]. We also provide simplified lower bounds that can be used when analytic, closed-form expressions are important. One such lower bound is precisely the strict service curve of Boyer et al. (Fig. 3), hence the worst-case delay bounds obtained with our strict service curve are guaranteed to be less than or equal to those of Boyer et al.
Our following contribution is a new iterative method for obtaining better strict service curves for DRR that account for the arrival curve constraints of interfering flows. Our method is rigorous and is based on pseudo-inverses and output arrival curves of interfering flows. We also provide simpler variants. Our method improves on any available strict service curves for DRR, hence, we always improve on Bouillard's strict service curve. Furthermore, our method accepts any type of arrival curves, including non-concave ones (such as the stair function used with periodic flows), and can be applied to any type of strict service curve, including non-convex ones (such as the strict service curve we obtained when there is no arrival curve constraint on interfering traffic).
The delay bounds obtained with our method are fully proven. Furthermore, we compute them for the same case studies as in Bouillard's work [8] (one single server analysis) and as in Soni et al. [7] (including two illustration networks and an industrial-sized one). We find that they are smaller than Bouillard's and the incorrect ones that use the correction term of Soni et al. Hence as of today, it follows that our delay bounds are the best proven delay bounds for DRR, with or without constraints on interfering traffic.
The remainder of the paper is organized as follows. After giving some necessary background in Section 2, we describe the counter example to Soni et al. in Section 3. In Section 4, we present our new strict service curves for DRR, with no knowledge of interfering traffic. In Section 5, we present our new strict service curves for DRR; they account for the interfering arrival curve constraints. In Section 6, we use numerical examples to illustrate the improvement in delay bounds obtained with our new strict service curves.
This work is the extended version of [10], which was presented at the RTAS conference, 2021. The conference version did not include a discussion of Bouillard's service curve, which was published after the conference submission date.

flow that sends up to a bits every b time units has, as arrival

curve, the stair function, defined by a,b(t) = a

t b

. Another

frequently used arrival curve is the token-bucket function

 = r,b, with rate r and burst b, defined by r,b(t) = rt + b for t > 0 and r,b(t) = 0 for t = 0. Both of these arrival
curves are sub-additive.

Consider a system S and a flow through S with input and output functions A and D; we say that S offers  

F as a strict service curve to the flow if the number of bits

of the flow output by S in any backlogged interval (s, t] is D(t) - D(s)  (t - s). A strict service curve  can always be assumed to be super-additive (i.e., to satisfy (s + t) 

(s)+(t) for all s, t) and wide-sense increasing (otherwise,

it can be replaced by its super-additive and non-decreasing

closure [13]). A frequently used strict service curve is the

rate-latency function R,T  F , with rate R and latency T , defined by R,T (t) = R[t - T ]+, where we use the notation [x]+ = max {x, 0}. It is super-additive.

Assume that a flow, constrained by a sub-additive arrival

curve , traverses a system that offers a strict service curve

 and that respects the ordering of the flow (per-flow FIFO).

The delay of the flow is upper bounded by the horizontal

deviation defined by h(, ) = supt0{inf{d  0|(t)  (t+d)}}. Also, the output flow is constrained by an arrival curve  =   where is the deconvolution operation

defined in the next paragraph. The computation of h(, ) and  can be restricted to t  [0 t] for t  infs>0{(s)  (s)} [13, Prop. 5.13], [14].

For f and g in F , the min-plus convolution is defined
by (f  g)(t) = inf0st{f (t - s) + g(s)} and the min-plus deconvolution by (f g)(t) = sups0{f (t + s) - g(s)} [11]­ [13]. We will use the min-plus convolution of a stair function

with a linear function, as shown in Fig. 1.

a,b(t)

(1  a,b) (t)

4a

3a

2a

a

t

b 2b 3b 4b

4a

3a

2a

a

t

a b 2b 3b 4b

(a) a,b

(b) (1  a,b)

Fig. 1: Left: the stair function a,b  F defined for t  0 by

a,b(t)

=

a

t b

. Right: min-plus convolution of a,b with the

function 1  F defined by 1(t) = t for t  0, when a  b. The

discontinuities are smoothed and replaced with a unit slope.

2 BACKGROUND
2.1 Network Calculus Background
We use the framework of network calculus [11]­[13]. Let F denote the set of wide-sense increasing functions f : R+  R+  {+}. A flow is represented by a cumulative arrival function A  F and A(t) is the number of bits observed on the flow between times 0 and t. We say that a flow has   F as arrival curve if for all s  t, A(t) - A(s)  (t - s). An arrival curve  can always be assumed to be sub-additive, i.e., to satisfy (s + t)  (s) + (t) for all s, t. A periodic

If a flow, with arrival curve  and a maximum packet size lmax, arrives on a link with a rate c, a better arrival
curve for this flow at the output of the link is the min-plus convolution of  and the function t  lmax + ct; this is
known as grouping (also known as line-shaping) and is also
explained Section 2.4. The non-decreasing closure f of a function f : R+ 
R+  {+} is the smallest function in F that upper bounds f and is given by f(t) = supst f (s). Also, the nondecreasing and non-negative closure [f ]+ of f is the smallest non-negative function in F that upper bounds f .

2

The lower pseudo-inverse f  of a function f  F is defined by f (y) = inf{x|f (x)  y} = sup{x|f (x) < y} and satisfies [15, Sec. 10.1]:

x, y  R+, y  f (x)  x  f (y)

(1)

The network calculus operations can be automated in tools such as RealTime-at-Work (RTaW) [16], an interpreter that provides efficient implementations of min-plus convolution, min-plus deconvolution, non-decreasing closure, horizontal deviation, the composition of two functions, and a maximum and minimum of functions for piecewise-linear functions. All computations use infinite precision arithmetic (with rational numbers).

2.2 Deficit Round-Robin
A DRR subsystem serves n inputs, has one queue per input, and uses Algorithm 1 for serving packets. Each queue i is assigned a quantum Qi. DRR runs an infinite loop of rounds. In one round, if queue i is non-empty, a service for this queue starts and its deficit is increased by Qi. The service ends when either the deficit is smaller than the head-ofthe-line packet or the queue becomes empty. In the latter case, the deficit is set back to zero. The send instruction is assumed to be the only one with a non-null duration. Its actual duration depends on the packet size but also on the amount of service available to the entire DRR subsystem.

comparing our results to [7], the reader is invited to remem-

ber that a DRR flow in this paper corresponds to a DRR class

in [7].

The DRR subsystem is itself placed in a larger system

and can compete with other queuing subsystems. A com-

mon case is when the DRR subsystem is at the highest

priority on a non-preemptive server with line rate c. Due to

non-preemption, the service offered to the DRR subsystem

might not be instantly available. This can be modelled by

means of a rate-latency strict service curve (see Section 2.1

for

the

definition),

with

rate

c

and

latency

c Lmax

where

Lmax

is the maximum packet size of lower priority. If the DRR

subsystem is not at the highest priority level, this can be

modelled with a more complex strict service curve [13, Sec-

tion 8.3.2]. This motivates us to assume that the aggregate of

all flows in the DRR subsystem receives a strict service curve

, which we call "aggregate strict service curve". If the DRR

subsystem has exclusive access to a transmission line of rate

c, then (t) = ct for t  0. We assume that (t) is finite for

every (finite) t. (Note that the aggregate strict service curve

 should not be confused with the strict service curves (also

called "residual" strict service curves in [3]) that we obtain

in this paper for every flow.)

Here, we use the language of communication networks,

but the results equally apply to real-time systems: Simply

map flow to task, map packet to job, map packet size to job-

execution time, and map strict service curve to "delivery

curve" [18], [19].

Algorithm 1 Deficit Round-Robin

Input: Integer quantum Q1, Q2, . . . , Qn Data: Integer deficits: d1, d2, . . . , dn
1: for i  1 to n do 2: di  0; 3: end for

4: while True do

5: for i  1 to n do

6:

if (not empty(i)) then

7:

A service for queue i starts.

8:

di  di + Qi;

9:

while (not empty(i))

10:

and (size(head(i))  di) do

11:

di  di-size(head(i);

12:

send(head(i));

13:

removeHead(i);

14:

end while

15:

A service for queue i ends.

16:

if (empty(i)) then

17:

di  0;

18:

end if

19:

end if

20: end for

21: end while

In [3] as in much of the literature on DRR, the set of packets that use a given queue is called a flow; a flow may however be an aggregate of multiple flows, called microflows [17] and an aggregate flow is called a class in [7]. In this paper, and in order to be consistent with the network calculus conventions, we use the former terminology and consider that a DRR input corresponds to one flow. When

2.3 Strict Service Curve of Boyer et al.

The strict service curve of Boyer et al. for DRR is given in

[3], and we rewrite it using our notation. For flow i, let dmi ax be its maximum residual deficit, defined by dmi ax = limax - where limax is an upper bound on the packet size and is the

smallest unit of information seen by the scheduler (e.g., one

bit, one byte, one 32-bit word, ...). Also, let Qtot =

n j=1

Qj .

Then, for every flow i, their strict service curve is the rate-

latency latency

service Ti =

curve Ri,Ti ((t)) with rate

j=i

dmj ax

+(1+

dmi ax Qi

)

j=i Qj

Ri

=

Qi Qtot

and

(see Section 2.1

for the definition of a rate-latency function).

2.4 Correction Term of Soni et al.

When interfering flows are constrained by some arrival

curves, Soni et al. give a correction term that improves

the obtained delay bounds using the strict service curve of

Boyer et al. in [7], which we now rewrite using our notation.

Assume that every flow i has an arrival curve i, and the
server is a constant-rate server with a rate equal to c. Let DiBoyer-et-al be the network calculus delay bound for flow i obtained by combining i with the strict service curve of

Boyer et al., as explained in Section 2.3. The delay bound proposed in [7] is DiSoni-et-al = DiBoyer-et-al - CiSoni-et-al with

CiSoni-et-al =
j,j=i

Sj (DiBoyer-et-al) - j (DiBoyer-et-al) + c

(2)

where hi =

Sj (t) d=ef Qj + dmj ax 1thi +Qj

j=i Qj +dmj ax c

and Hi

=

hi +

(Q1i+-dmic(atQx-c+toHt ij)=i)1Qtj.HIin,

3

Flow 3: Flow 2: Flow 1: Output: Packet Arrival:

10

20

30

40

50

60 62

10 
 = 0 ! = 10 

!'(=

14.907

) *

62

4

10 1

!"##

=

72.093

 

!$%&

=

87

 

(Arrival and departure of packet of interest)

Fig. 2: Trajectory scenario for the packet of interest of flow 1 (Section 3.2). This packet arrives at ta1rr and departs at td1ep.

the correction term CiSoni-et-al, function Sj represents a lower bound on the maximum interference caused by flow j in a backlogged period of flow i; the term with the arrival curve j represents the actual interference caused by flow j.
Two additional improvements are used in [7]. The former, called grouping, uses the fact that, if a collection of flows is known to arrive on the same link, the rate limitation imposed by the link can be used to derive, for the aggregate flow, an arrival curve that is smaller than the sum of arrival curves of the constituent flows (as explained in Section 2.1). This improvement is also known under the name of line shaping and is used, for example, in [20]­[22]. The other improvement, called offsets, uses the fact that, if several periodic flows have the same source and if their offsets are known, the temporal separation imposed by the offsets can be used to compute, for the aggregate flow, an arrival curve that is also smaller than the sum of arrival curves of the constituent flows (the latter would correspond to an adversarial choice of the offsets). Both improvements reduce the arrival curves, hence the delay bounds. Note that both improvements are independent of the correction term (and, unlike the correction term, are correct); they can be applied to any method used to compute delay bounds, as we do in Section 6.

2.5 Bouillard's Strict Service Curves

A new method to compute strict service curves for DRR

that account for the interfering arrival curve constraints

was recently presented in [8]; the method works only when

arrival curves are concave and the aggregate strict service

curve is convex, and it improves on the strict service curve

of Boyer et al. Specifically, in [8, Thereom 1], for the flow

of interest i, there exists non-negative numbers HJ for any

J  {1, . . . , n} \ {i} such that iBouillard is given by

+

iBouillard =

sup

J {1,...,n}\{i}

Qi j/J Qj



-

jJ

j

- H^J 

(3) where an inductive procedure is presented to compute H^J .

We call these Bouillard's strict service curves.

3 THE CORRECTION TERM OF SONI ET AL. IS
INCORRECT
In this section, we show that the delay bound of Soni et al., namely the correction term given in equation (14) in [7], is invalid. For flow 1 in a system, we denote the delay bound of Soni et al. by D1Soni-et-al, and we denote the delay experienced by a packet of flow 1 in the trajectory scenario by D1TS.

3.1 System Parameters
Consider a constant-rate server, with a rate equal to c, that uses the DRR scheduling policy. All flows have packets of constant size l, and have quanta Q1 = 100l, Q2 = 5l, and Q3 = 10l.
Each flow is constraint by a token-bucket arrival curve:

1) 1(t) = r1,b1 with r1 = 0.86c and b1 = l.

2) 2(t) = r2,b2 with r2 = 0.0401c and b2 = l.

3)

3(t)

=

r3 ,b3

with

0



r3

<

Q3 Qtot

c

and

b3

=

20l.

Assuming a token-bucket r,b for a flow implies that this

flow has a minimum

observe

that

ri

<

Qi Qtot

packet-arrival c for i = 1, 2, 3.

time

equal

to

l r

.

We compute the

Also, delay

bound of Soni et al. for flow 1, as explained in 2.4, and we

obtain

D1Soni-et-al

=

14.03383

l c

-

1.236215 c .

3.2 Trajectory Scenario
We now construct a possible trajectory for our system. First, we give the inputs of our three flows. All queues are empty, and the server is idle at time t = 0. Then,
1) Flow 3 arrives first and A3(t) = min (3(t), 20l) for t > 0 (yellow arrows in Fig. 2).
2) Flow 1 arrives shortly after flow 3 and A1(t) = min (1(t), 63l) for t > 0 (green arrows in Fig. 2).
3) Flow 2 arrives shortly after flows 1 and 3 and A2(t) = min (2(t), 4l) for t > 0 (red arrows in Fig. 2).
Then, for the output, we have the following:

4

1) Flow 3 arrives first and has 20 ready packets. As its

deficit was zero before this service and Q3 = 10l, the server

serves 10 packet of this flow. The end of the service for flow

3

is

t1

=

10

l c

(the

first

yellow

part

in

Fig.

2).

2) Then, there is an emission opportunity for flow 1 and

A1(t1) = 9.6l, which means flow 1 has 9 ready packets

at time t1. The server starts serving packets of this flow.

At

the

end

of

service

of

these

first

9

packets,

at

t2

=

19

l c

,

flow 1 has another 8 ready packets; hence, the server still

serves packets of flow 1. This continues and 62 packets of

flow 1 are served in this emission opportunity; the emission

opportunity

ends

at

t4

=

72

l c

(the

first

green

part

in

Fig.

2).

3) Then, there is an emission opportunity for flow 2 and

A2(t4) = 3.8872l, which means flow 2 has 3 ready packets at time t4. At the end of service of 3 packets, another packet

is also ready for flow 2. In total, 4 packets of flow 2 are

served in this emission opportunity (the red part in Fig. 2).

4) A

72.093

l c

.

packet for flow 1 arrives at This packet should wait for

ta1rr = flow 2

72

+

0.08l r1

and flow 3

 to

use their emission opportunities, and then it can be served.

We call this the packet of interest of flow 1, for which we capture the delay (the first blue arrow, at ta1rr, on Fig. 2).
5) For flow 3, again 10 packets are served (the second

yellow part in Fig. 2).

6) Finally, the packet of interest is served and its depar-

ture

time

is

td1ep

=

87

l c

.

It follows that the delay for the packet of interest is

D1TS

=

td1ep - ta1rr

=

15

l c

-

0.08l r1



14.907

l c

.

Note

that

D1TS > D1Soni-et-al. To fix ideas, if l = 100 bytes and c =

100 Mb/s, the delay bounds are D1Boyer-et-al = 146.228µs,

D1Soni-et-al = 112.172µs, and D1TS = 119.256µs.

For any flow i, dmi ax is the maximum residual deficit (defined in
Section 2.3). Then, for every i, S offers to flow i a strict service curve i0
given by i0(t) = i ((t)) with

i(x) = (1  Qi,Qtot ) [x - i (Qi - dmi ax)]+

(4)

+ min([x -

Qj + dmj ax ]+, Qi - dmi ax)

j=i

n

Qtot = Qj

(5)

j=1

i(x) d=ef x +

i,j (x)

(6)

j,j=i

i,j (x) d=ef

x + dmi ax Qi

Qj + Qj + dmj ax

(7)

Here, a,b is the stair function, 1 is the unit rate function
and  is the min-plus convolution, all described in Fig. 1. Furthermore, i0 is super-additive.

The proof is in Appendix A.1. See Fig. 3 for some illustrations of i0. Observe that i in (4) is the strict service
curve obtained when the aggregate strict service curve is
 = 1 (i.e., when the aggregate is served at a constant, unit
rate). In the common case where  is equal to a rate-latency function, say c,T , we have i0(t) = i(c(t - T )) for t  T and i0(t) = 0 for t  T , namely, i0 is derived from i by a re-scaling of the x axis and a right-shift.

600

imaxRate

3.3 The Contradiction with the Bound of Soni et al.

We found a trajectory scenario such that D1Soni-et-al is not a valid delay bound. Let us explain why the approach of

Soni et al., presented in [7], gives an invalid delay bound. In

[7], it is implicitly assumed that as the delay for a packet of flow 1 is upper bounded by D1Boyer-et-al (the obtained
delay bound using the strict service curve of Boyer et al.

for flow 1), only packets of interfering flows arriving within a duration D1Boyer-et-al will get a chance to delay a given
packet of flow 1. However, in the trajectory scenario given

in Section 3.2, all packets of flow 2 (an interfering flow for

flow

1)

arriving

within

the

time

interval

[0,

75

l c

]

with

the

duration

75

l c

>>

D1Boyer-et-al

=

18.3

l c

-

2.15 c

delay the

packet of interest of flow 1.

4 NEW DRR STRICT SERVICE CURVE
Our next result is a non-convex strict service curve for DRR; we show that it is the largest one and it dominates the state-of-the-art rate-latency strict service curve for DRR by Boyer et al. We also give simpler, lower approximations of it. Specifically, we also find a convex strict service curve and two rate-latency strict service curves.
Theorem 1 (Non-convex Strict Service Curve for DRR). Let S be a server shared by n flows that uses DRR, as explained in Section 2.2, with quantum Qi for flow i. Recall that the server offers a strict service curve  to the aggregate of the n flows.

Bytes

400

i0

200 00

iconvex

iminLatency

50

100

150

200

Time (µs)

Fig. 3: Strict service curves for DRR for an example with three input flows, quanta = {199, 199, 199} bytes, maximum residual deficits dmax = {99, 99, 99} bytes, and (t) = ct with c = 100 Mb/s (i.e., the aggregate of all flows is served at a
constant rate). The figure shows the non-convex DRR strict service curve i0 of Theorem 1; it also shows the two ratelatency strict service curves imaxRate (same as that Boyer et al.) and iminLatency in Corollary 1 and the convex service curve iconvex = max imaxRate, iminLatency in Corollary 2.

We then show that the strict service curve we have obtained is the best possible one.
Theorem 2 (Tightness of the DRR Strict Service Curve). Consider a DRR subsystem that uses the DRR scheduling algorithm, as defined in Section 2.2. Assume the following system parameters are fixed: the number of input flows n, the quantum Qj allocated to every flow j, maximum residual deficits dmj ax for every flow j, and the strict service curve  for the aggregate of all flows. We

5

assume that  is Lipschitz-continuous, i.e., there exists a constant

K

>

0

such

that

(t)-(s) t-s



K

for

all

0



s

<

t.

Let

i

be

the

index of one of the flows.

Assume that bi  F is a strict service curve for flow i in any system that satisfies the specifications above. Then bi  i0 where i0 is given in Theorem 1.

The proof is in Appendix A.2. Note that assuming the aggregate strict service curve  is Lipschitz-continuous does not appear to be a restriction as the rate at which data is served has a physical limit. We then provide closed-form for the network calculus delay bounds when the flow of interest i is constrained by frequent types of arrival curves, as defined in Section 2.1.

Theorem 3 (Closed-form Delay Bounds Obtained with the

Non-convex Strict Service Curve of DRR). Make the same

assumptions as in Theorem 1, yet with one difference: Assume

that the aggregate strict service curve is a rate-latency function,

i.e.,  = c,T . Also, assume that flow of interest i has i  F as an arrival curve. Let i be defined as in (6).

Then, the closed-form of the network calculus delay bound

h(i, i0) is given as follows:

1) if i is a token-bucket arrival curve, i.e., i = ri,bi with

ri



Qi Qtot

,

T + max

i

(bi) c

,

i

(i(i)) c

-

i

(8)

Theorem 4 (Lower Bounds of Non-convex Strict Service Curves for DRR). Make the same assumptions as in Theorem 1. Also, for flow i, consider functions i,j  F such that for every other flow j = i, i,j  i,j. Let i be defined as in (6) by replacing functions i,j with i,j for every flow j = i. Then, let i be the lower-pseudo inverse of i, i.e., i = i.
Let i0 be the result of Theorem 1 by replacing functions i,j, i, and i with i,j , i, and i.
Then, S offers to flow i a strict service curve i0 and i0  i0.
The proof is in Appendix A.4. There is often interest in service curves that are piecewise-linear and convex, a simple case is a rate-latency function. Specifically, convex piecewise-linear functions are stable under addition and maximum, and the min-plus convolution can be computed in automatic tools very efficiently [13, Sec. 4.2]. Observe that, if the aggregate service curve  is a rate-latency function, replacing i by a rate-latency (resp. convex) lower-bounding function also yields a rate-latency (resp. convex) function for i0, and vice-versa. Therefore, we are interested in ratelatency (resp. convex) functions that lower bound i. We now give two lower bounds of the non-convex strict service curve for DRR using Theorem 4 that are common: a convex lower bound and two rate-latency lower bounds.

with i 2)

= if

Qi-(bi+dmi ax

i

ri
is a

)mod Qi . token-bucket

arrival

curve

and

we

take into account the effect of grouping, i.e., i(t) =

min (ct + limax, ri,bi (t))

with

ri



Qi Qtot

,

T + max

i

(i c

(i

))

,

i

(i(¯i)) c

-

¯i

(9)

with i

=

bi -limax c-ri

and ¯i

=

Qi-(i(i)+dmi ax)mod
ri

Qi

.

3) if i is a stair arrival curve, i.e., i(t) = ai

ai bi



Qi Qtot

,

t bi

with

T + max

i(ai c

)

,

i

(i(i)) c

-

i

(10)

with i =

Qi-(ai+dmi ax)mod Qi
ai

bi

The proof is in Appendix A.3. Theorem 3 enables us to

compute the exact delay bounds in a very simple closed-

form, independent of the complicated expression of our

non-convex strict service curve. However, we provide sim-

plified lower bounds of the non-convex strict service curve

for DRR when analytic, closed-form expressions are important. The function i,j(x), defined in (7), is the maximum interference that flow j can create in any backlogged period of flow i, such that flow i receives a service x. Using i,j as
it is results in the strict service curve of Theorem 1, which

has a complex expression. If there is interest in simpler

expressions, any lower bounding function is a strict service

curve. In Theorem 4, we show that any upper bounding of
function i,j, (which gives a lower bound on i) results in a lower bound of i0, which is a valid, though less good, strict service curve for DRR.

Bytes

1,500

1,000 500

ci,ojncave

mi,jinLatency

mi,jaxRate

i,j

00 100 200 300 400 500 600 700 Bytes

Fig. 4: ci,ojncave

Illustration defined in

of functions i,j , mi,jaxRate, mi,jinLatency, and (7), (11), (12), and (17), respectively. These

functions are obtained for the example of Fig. 3.

To obtain a rate-latency strict service curve, we use two affine upper bounds of i,j : mi,jaxRate, which results in a ratelatency function with the maximum rate, and mi,jinLatency, which results in a rate-latency function with the minimum
latency (Fig. 4). They are defined by

mi,jaxRate(x)

d=ef

Qj Qi

(x +

dmi ax) + Qj

+

dmj ax

(11)

mi,jinLatency(x)

d=ef

Qi

Qj - dmi ax

x

+

Qj

+ dmj ax

(12)

Corollary 1 (Rate-Latency Strict Service Curve for DRR).
With the assumption in Theorem 1 and the definitions (11)-(12), S offers to every flow i strict service curves imaxRate ((t)) and

6

iminLatency ((t)) with

imaxRate = Rimax,Timax

(13)

iminLatency = Rimin,Timin

Rimax

=

Qi Qtot

and Timax

=

mi,jaxRate(0)

j,j=i

(14) (15)

Rimin =

Qi - dmi ax Qtot - dmi ax

and Timin =

mi,jinLatency(0)

j,j=i

(16)

The right-hand sides in (13) and (14) are the rate-latency functions defined in Section 2.1.

with

iJ (x) = 1  Qi,QJtot

x - iJ (Qi - dmi ax) +

(20)

+ min([x -

Qj + dmj ax ]+, Qi - dmi ax)

jJ

QJtot =

Qj

(21)

jJ

iJ (x) d=ef x + i,j (x)

(22)

jJ

The above result is obtained by using Theorem 4 with mi,jaxRate and mi,jinLatency; hence, i  imaxRate and i  iminLatency. Also, observe that the strict service curve of Boyer et al., explained in Section 2.3, is equal to imaxRate ((t)). It follows that i0 dominates it; hence, obtained delay bound using i0 are guaranteed to be less than or equal to those of Boyer et al.
A better upper bound on i,j can be obtained by taking
its concave closure (i.e., the smallest concave upper bound) that is equal to the minimum of mi,jaxRate and mi,jinLatency:

ci,ojncave(x) = min mi,jaxRate(x), mi,jinLatency(x)

(17)

Corollary 2 (Convex Strict Service Curve for DRR). With the
assumption in Theorem 1 and the definitions (13)-(14), S offers to every flow i a strict service curve iconvex ((t)) with

iconvex(x) = max imaxRate(x), iminLatency(x)

(18)

The above result is obtained by using Theorem 4 with ci,ojncave. Also, it can be shown that it is the largest convex lower bound of i. When  is a rate-latency function, this provides a convex piecewise-linear function, which has all
the good properties mentioned earlier.

5 NEW DRR STRICT SERVICE CURVES THAT ACCOUNT FOR ARRIVAL CURVES OF INTERFERING FLOWS
The next result provides a method to improve on any strict service curve by taking into account arrival curve constraints of interfering flows. It can thus be applied to the strict service curves presented in Section 4 and to Bouillard's strict service curves.

In (19), [.]+ is the non-decreasing and non-negative closure, defined in Section 2.1, and  is the composition of functions.

The proof is in Appendix A.5. The essence of Theorem
5 is as follows. Equation (19) gives new strict service curves inew for every flow i; they are derived from already available strict service curves iold and from arrival curves on the input flows j; thus, it enables us to improve any collection of strict service curves that are already obtained.

The computation of service curves in Theorem 5 and

of the resulting delay bounds can be restricted to a finite

horizon. Indeed, all computations in Theorem 5 are causal

except for the min-plus deconvolution j jold. But, as

mentioned in Section 2.1, such a computation and the com-

putation of delay bounds can be limited to t  [0; t] for any

positive t such that j(t) j = 1 : n. To find such a t,

 jold(t) we can use

for every m  1 and any lower bound on

jold.

We take, as

then compute tj sufficient horizon,

= infs>0{j(s) t = maxj tj . The

 jold(s)} and computations in

Theorem 5 can then be limited to this horizon or any upper

bound on it. The computations can be performed with a tool

such as RealTime-at-Work (RTaW) [16], which uses an exact

representation of functions with finite horizon, by means of

rational numbers with exact arithmetic.

Theorem 5 can be iteratively applied, starting with the

strict service curves that do not make any assumptions

on interfering traffic, as obtained in Section 4, and for

every flow an increasing sequence of strict service curves

is obtained; specifically, recall that i0 is defined in Theorem

1, then, for every by replacing jold

integer m  1 with jm-1 in

and (19):

every

flow

i,

define

im

5.1 A Mapping to Refine Strict Service Curves for DRR by Accounting for Arrival Curves of Interfering Flows

Theorem 5 (Non-convex, Full Mapping). Let S be a server

with the assumptions in Theorem 1. Also, assume that every flow i

has an arrival curve i  F and a strict service curve iold  F ,

and let Ni = {1, 2, . . . , n} \ {i}, and for any J  Ni, let J¯ = Ni \ J .

Then, for every flow i, a new strict service curve inew  F is

given by





+

inew

=

max

iold

,

max
J Ni

iJ





-

jJ¯

j

jold  

(19)



+

im

=

max
J Ni

iJ





-

jJ¯

j

jm-1 


(23)

It follows that im is a strict service curve for flow i and i0  i1  i2  . . . (see Fig. 5 (left)).
Alternatively, we can first compute Bouillard's strict service curve jBouillard for every flow j, as explained in Section 2.5. Observe that jBouillard does not usually dominate the non convex service curve i0 obtained in Theorem 1 (see Figure 6). Therefore, since the maximum of two strict service
curves is a strict service curve, we can take the maximum of both. Specifically, define i0 = max iBouillard, i0 , then,

7

550

550

500

500

450

400

!$

350

!#

300

250

200

Bytes

450

400

!#'

350

300

!"

250

!"' = max( !", !%&'())*+,)

200

Bytes

150

!"

150

100

100

50

0

20

40

60

80

100

120

140

160

180

200

Time ()

50

!%&'())*+,

0

20

40

60

80

100

120

140

160

180

200

Time ()

Fig. 5: Strict service Mb/s and b = {5l, l,

curves for flow 2 of l}. When iteratively

the example of Fig. applying Theorem

3, 5,

where all flows have token-bucket arrival curves starting with either i0 (Left: the sequence i0 

with r i1 

= {5, i2) or

1,

1}

l 512

starting

with max iBouillard, i0 (Right: the sequence i0  i1 = i2), after 2 iterations, the strict service curves of all flows become

stationary in the horizon of the figure, and the scheme stops The sufficient horizon t in this example is 200µs. Obtained with the

RTaW online tool.

550

In practice, in all cases that we tested, when initializing

500

! %'

the method with either choice, we always converge to the

same strict service curve for every flow (Fig. 5).

450

! $'

We are guaranteed simple convergence for the strict

400

service curves of all flows when iteratively applying The-

350

!&

orem 5, starting from any available strict service curves

300

for all flows. This is because, first, as explained above,

Bytes

computations of such strict service curves can be limited

250 200

!"'

!&' = max( !&, !'()*++,-.)

to a sufficient finite horizon; second, by iteratively applying Theorem 5, we obtain an increasing sequence of strict

150

service curves for all flows, and every strict service curve

is upper bounded by , the aggregate strict service curve.
100
In all cases that we tested, the iterative scheme became

50

!'()*++,-.

stationary in such a finite horizon. Note that the computed

strict service curves at each iteration are valid, hence can be

0

20

40

60

80

100

120

Time ()

140

160 180 200

used to derive valid delay bounds; this means the iterative

Fig. 6: Strict service curves for flow 2 of the example of Fig. 5,

when (Left:

iteratively applying Corollary 5, the sequence ¯i0  ¯i1  ¯i2

star¯ti3in)gorwisthtaretiinthgerwithi0

max iBouillard, i0 (Right: the sequence ¯i0  ¯i1  ¯i2 

¯i3 ), after 3 iterations, the strict service curves of all flows become stationary in the horizon of the figure, and the scheme stops. The sufficient horizon t in this example is 200µs. The

strict service curves of both sequences are precisely equal (i.e.,

¯i1 = ¯i1 , ¯i2 = ¯i2 , and ¯i3 = ¯i3 ,); also strict service curves of the last step is precisely equal to the last step of Fig. 5, i.e.,

¯i3 = i2. Obtained with the RTaW online tool.

for every integer m  1 and every flow i, define im by replacing jold with jm-1 in (19):

scheme can be stopped at any iteration. For example, the iterative scheme can be stopped when the delay bounds of all flows decrease insignificantly.

Observe that the computation to compute strict service

curve of Theorem tions of iJ   -

5, inew in jJ¯ j

(19), requires 2n-1 computa-

+

jold

for each J (where n


is the total number of the input flows of the DRR subsys-

tem). In some cases (class based networks) n is small and

this is not an issue; in other scenarios (per-flow queuing),

this may cause excessive complexity. To address this, we

find lower bounds on the strict service curve of Theorem 5

where only one computation at each step m is needed; this

is less costly when n is large.





+ Corollary 3 (Non-convex, Simple Mapping). Make the same

im

=

max im-1

, max
J Ni

iJ





-

jJ¯

j

jm-1





assumption as in Theorem 5. Then, for every flow i, a new strict service curve ¯inew  F is given by



(24)

It follows that im is a strict service curve for flow i and i0  i1  i2  . . . (see Fig. 5 (right)).

¯inew = max iold, i   + iold 

(25)

8

with

iold(t) d=ef

i,j iold(t) - j

jold

+
(t)

(26)

j,j=i

Also, ¯inew  inew. In (25),  is the non-decreasing closure, defined in Section 2.1, and  is the composition of functions; also, note that  and iold are functions of the time t.
The proof is in Appendix A.6. The essence of Corollary 3 is the same as explained after Theorem 5. Corollary 3 can be iteratively applied either starting with i0, defined in Theorem 1, or starting with i0 = max iBouillard, i0 , i.e., the maximum of i0 and the strict service curve of Bouillard, explained in Section 2.5 (see Fig. 6).
In the examples that we tested, we observed that the iterative scheme obtained with Theorem 5, our non-convex, full mapping, converges to the same results as the iterative scheme obtained with Corollary 3, our non-convex, simple mapping; however, it requires more iterations (see Fig. 5 and Fig. 6).

5.2 Convex Versions of the Mapping
Computation of the strict service curves of Theorem 5 and Corollary 3 can be costly. We first explain some sources of complexity and how to address them. We then propose convex versions, for both the non-convex, full mapping in Theorem 5 and the non-convex, simple mapping in Corollary 3.
5.2.1 Convex Versions of Theorem 5
One source of complexity lies in the initial strict service curves i0. For every flow i, i0 can be replaced by its simpler lower bounds. As presented in Section 4, i0 can be replaced by its convex closure iconvex ((t)), or rate-latency functions iminLatency ((t)) and imaxRate ((t)).
Another source of complexity is function iJ , as defined in (20), is non-convex and results in strict service curves that are also non-convex (Fig. 5). If there is interest in simpler expressions of Theorem 5, any lower bounding function on iJ results in a lower bound of inew, which is a valid, though less good, strict service curve for DRR.
Corollary 4 (Convex, Full Mapping). Make the same assumptions as in Theorem 5. Also, for a flow i, let ^iJ  F such that ^iJ  iJ .
Let ^inew be the result of Theorem 5, in (19), by replacing functions iJ with ^iJ .
Then, S offers to flow i a strict service curve ^inew and ^inew  inew.
As of today, in tools such as RTaW working with functions that are linear and convex is simpler and tractable. Hence, we apply Corollary 4 with ^iJ = iconvexJ =

max imaxRateJ , iminLatencyJ (convex closure of function

iJ ) and

imaxRateJ = RimaxJ ,TimaxJ

iminLatencyJ = RiminJ ,TiminJ

RimaxJ

=

Qi QJtot

and TimaxJ

=

mi,jaxRate(0)

jJ

(27) (28) (29)

RiminJ

=

Qi - dmi ax QJtot - dmi ax

and TiminJ

=

mi,jinLatency(0)
jJ

(30)

The sequence of obtained strict service curves is thus defined by iconvex,0 = iconvex   = iconvex and for m  1 (see Fig. 7 (left)):



+

iconvex,m

=

max
J Ni

iconvexJ





-

jJ¯

j

jconvex,m-1 

(31)

Alternatively, we can first compute the strict service

curve of Bouillard jBouillard for every flow j, as ex-

plained in Section 2.5, and iteratively apply Corollary 5

withiconvexJ , starting with max iBouillard, iconvex ; specif-

ically, iconvex,0 = max iBouillard, iconvex , then, for every integer m  1 and every flow i, define iconvex,m as



+

iconvex,m

=

max
J Ni

iconvexJ



-

jJ¯

j

jconvex,m-1 


(32)

It follows that iconvex,m is a strict service curve for flow i

and at each step m  1, one can use a better strict service

curve max iconvex,m , iconvex,m-1 (see Fig. 7 (right)).

In practice, in all cases that we tested, when initializing

the method with either choice, we always converge to the

same strict service curve for every flow (Fig. 7).

Let us explain why computing the above strict service

curves is simpler. Min-plus convolution and deconvolution

of piecewise linear convex can be computed in automatic

tools, such as RTaW, very efficiently [13, Section 4.2].

As illustrated in Fig. 7, obtained strict service curves

are convex, thus computing the min-plus deconvolution

with such strict service curves is much simpler than

with those in Fig. 5. Also, the composition is simpler, as for f  F , a function f , iconvexJ (f (t)) is equal to max RimaxJ , f (t) - TimaxJ + , RiminJ f (t) - TiminJ + ,

which includes only multiplication, addition, and maximum operations.

5.2.2 Convex Versions of Corollary 3
Again here a source of complexity lies in the initial strict service curves i0. For every flow i, i0 can be replaced by its simpler lower bounds. As presented in Section 4, i0 can be replaced by its convex closure iconvex ((t)), or rate-latency functions iminLatency ((t)) and imaxRate ((t)).
Also, another source of complexity is function i,j (and the resulting function i). Function i,j, as defined in (7),

9

Bytes

550 500 450 400 350 300 250 200 150 100 50
0

!"#$%&',+

!"#$%&',* !"#$%&',) = !"#$%&'

20

40

60

80

100

120

140

160

180

200

Time ()

Bytes

550 500 450 400 350 300 250 200 150 100 50
0

!"#$%&',*'

!"#$%&',) = !"#$%&' !"#$%&3,)' = max( !"#$%&', !,#-.//012)

!,#-.//012

20

40

60

80

100

120

140

160

180

200

Time ()

Fig. 7: Strict service curves for flow 2 of the example of Fig. 5, when iteratively applying Corollary 5 as explained in (31), starting with

either iconvex (Left: the sequence iconvex,0  iconvex,1  iconvex,2) or starting with max iBouillard, iconvex (Right: the sequence

figicounrvee,xa,0ndtheicosncvheex,m1 e=stopicosn.vTexh,e2),suafffitecrie2ntitheorartizioonns,tthine

strict service curves of all flows become stationary in the this example is 200µ. Obtained with the RTaW online tool.

horizon

of

the

550

550

500

500

450 400

!"#$%&',+

!"#$%&',*

450 400

!"#$%&',3'

!"#$%&',2'

350

350

Bytes

300

300

Bytes

!"#$%&'

250

250

200

200

150 100

!"#$%&',) = !"#$%&'

150

100

!"#$%&',0' = max( !"#$%&', !(#)*++,-.)

50 0

20

40

60

80

100

120

140

160

180

200

Time ()

50 0

!(#)*++,-.

20

40

60

80

100

120

140

160

180

200

Time ()

Fig. 8: Strict service curves for flow 2 of the example of Fig. 5, when iteratively applying Corollary 6, starting with either iconvex (Left: the sequence ¯convex,0  ¯convex,1  . . .) or starting with max iBouillard, iconvex (Right: the sequence ¯convex,0  ¯convex,1 
. . .). The iterative scheme stops when the computed delay bounds for all flows decreased by leas than 0.25µs. The sufficient horizon t in this example is 200µs. The delay bounds obtained with the strict service curve of the last iteration of both cases are equal, however, the strict service curves are different. The strict service curves of all flows become stationary after 16 iterations. Obtained with the RTaW online tool.

is non-concave and non-linear (because it uses floor operations). This might create discontinuities that can make the computation hard, see Fig. 6. To address this problem, we derive the following convex version of Corollary 3.
Theorem 6 (Convex, Simple Mapping). Make the same assumptions as in Corollary 3. Also, for a flow i, let i,j and i be defined as in Theorem 4.
Let ¯inew be the result of Corollary 3 by replacing functions i,j and i with i,j and i, respectively.
Then, S offers to every flow i a strict service curve ¯inew .
The proof is not given in detail, as it is similar to the proof of Corollary 3 after replacing functions i,j and i with i,j and i, respectively.

We apply Theorem 6 as follows: Apply Theorem 6 by replacing i,j and i with mi,jaxRate and imaxRate defined in (11) and (13); also, Apply Theorem 6 by replacing i,j and i with mi,jinLatency and iminLatency defined in (12) and (14); then, we take the maximum of the two strict service curves
obtained in each case.

This can be iteratively applied: In both cases, let the ini-

tial strict service curves iconcave,0 be defined as in Corollary

2. Specifically, the sequence of obtained strict service curves

are or

thus defined ¯iconvex,0 =

by either ¯iconvex,0 = max iconvex, iBouillard

iconvex and

 for

= iconvex m  1,

¯iconvex,m = max ¯im , ¯im with

10

550

TABLE 1: Delays bounds of all classes of Section 6.1.

500

450

!"#$%&' 

400

Class Electric protection (µs) Virtual reality games (ms) Video conference (ms)
4k videos (ms)

Boyer et al. 52 1.75 2.61 5.78

Thm. 1 44.51 1.74 2.61 5.77

Bouillard 52 1.33 1.82 2.74

Thm. 5 44.51 1.32 1.81 2.72

Cor. 4 52 1.32 1.81 2.72

350

300

Bytes

250

!

!)

200

150

!"#$%&'

100

50
0 0

20

40

!*#+,--./0

60

80

100

120 140 160 180 200

Time ()

Fig. 9: A summary of strict service curves for flow 2 of the example of Fig. 5. The strict service curves i0 and iconvex are our non-convex and convex strict service curve of Section 4,
with no assumption on the interfering traffic. The strict service curves i and iconvex are our best non-convex and convex strict service curve that accounts for the interfering traffic, explain in
Section 5. Obtained with the RTaW online tool.

¯im = iminLatency 

 + iminLatency,m-1

,


¯im

= imaxRate 

 + imaxRate,m-1

.


(33)

Also, iminLatency,m-1 and imaxRate,m-1 are equal to

mi,jinLatency  ¯iconvex,m-1 - j ¯jconvex,m-1 + and

j=i

mi,jaxRate  ¯iconvex,m-1 - j

¯jconvex,m-1

+
,

j=i
(34)

respectively (see Fig. 8).

Let us explain why computing the above strict service

curves is simpler. The first reason is in computing the com-

position of mi,jaxRate (resp. mi,jinLatency) with another function.

Observe that for a function f  F , mi,jaxRate (f (t)) (resp.

mi,jinLatency (f (t)))

is

equal

to

Qj Qi

f

(t)

+

mi,jaxRate(0)

(resp.

Qi

Qj -dmi ax

f

(t)

+

mi,jinLatency(0)),

which

includes

only

multi-

plication, addition, and minimum operations. The second

reason is in computing the min-plus deconvolution; min-

plus convolution and deconvolution of piecewise linear

convex can be computed in automatic tools, such as RTaW, very efficiently [13, Section 4.2], and as illustrated in Fig.

8, obtained strict service curves are convex, thus comput-

ing the min-plus deconvolution with such strict service

curves is much simpler than with those in Fig. 6. The last

reason is in computing the composition of imaxRate (resp.

iminLatency) with another function. Observe that for a func-

tion f  to Rimax

F , imaxRate (f (t)) (resp. iminLatency [f (t) - Timax]+ (resp. Rimin f (t) -

(f (t)) ) is equal Timin +), which

again includes only multiplication, addition, and maximum

operations.

Alternatively, one can apply Theorem 6 by replacing i,j and i with ci,ojncave and iconvex defined in (17) and (18);

however, in this case, there is no guarantee that this version conserves convexity and we do not consider it further.
In the examples that we tested, we observed that the iterative scheme obtained with Corollary 6, our convex, full mapping, converges to the same results as the iterative scheme obtained with Theorem 6, our convex, simple mapping; however, it requires more iterations (see Fig. 7 and Fig. 8).
6 NUMERICAL EVALUATION
In this section, we compare the obtained delay bounds by using our new strict service curves for DRR, presented in Sections 4 and 5, to those of Boyer et al., Bouillard, and Soni et al. We use all network configurations that were presented by Bouillard in [8] and Soni et al. in [7], specifically, one single server, two illustration networks, and an industrialsized one. For the illustration networks, we use the exact same configuration of flows and switches that Soni et al. use. For the industrial-sized network, Soni kindly replied to our e-mail request by saying that, for confidentiality reasons, they do not have the rights to provide more details about the network configuration than what is already given in [7]. Consequently, we use the same network but randomly choose the missing information (explained in detail in Section 6.3).
6.1 Single Server
We use the exact same configuration of flows and the server that Bouillard uses in [8]. Consider a DRR subsystem with four classes of traffic: Electric protection, Virtual reality games, Video conference, and 4k videos constrained with token bucket arrival curves with bursts b = {42.56, 2160, 3240, 7200} kb and rates r = {8.521, 180, 162, 180} Mb/s, respectively; also, the packet sizes are lmax = {3.04, 12, 12, 12} kb. The server is a constant-rate server with rate equal to c = 5Gb/s, i.e., (t) = ct. All classes have the same quantum equal to 16000 bits.
The delay bounds obtained with different methods are given in Table 1. Our delay bounds always improve on those of Boyer et al. and Bouillard; when the delay is very small (electric protection) our non-convex service curves bring a considerable improvement. As discussed in Section 5, the results are the same with the non-convex, full mapping (Theorem 5) and the non-convex simple mapping (Corollary 4). The results of the convex full and simple mappings (Corollary 3 and Theorem 6) are also identical, but less good than the former. Also, the results are the same for all choices of initial strict service curves. As we showed that the delay bounds of Soni et al. are incorrect we do not compute them for this example, but for the sake of comparison we will compute them for their case-studies.

11

ple of the output port S41, class C1 service curve

m1a.in Tcohnetribduitifofnerisengicveen iins stehctaiotn pVa, rwtheorfe wCe2proapnodse aCn3 floew3 sv1t5hva19t areS3 optrtiamnizsemd iNttCedapfprrooamch Sfo4r DtoRRe8scihnedFuliegrubraesed1 naertweotrrkas.nsmitted Ftoig.e19: Sinwitched Ethernet network (Example 1)

InFSigecutiroen V6.I further improvements to classical NC approach

Delays (micro seconds) Delays (micro seconds)
Delays (micro seconds) Delays (micro seconds) Delays (micro seconds)

Engnehcqueysei4yoyh1sps(nFamneosondimaesahanscdtecEuuRmwsssnepeodxdtiinppttcctrehpttoitsisoeearsdhitdepprRweioeinshvsohimtwsnehri,rRef.otntftuomrwz.mdoidntuesec[dw)iacetroonobniso-loiTeflflhtsheeccacashtturTsintOtirfoeartnpoabiintlntemetooahfketiieelIiootnecaehaciooooooriuseretnRgtwwVecirstlnnndhydnnkhFeeaeeiissff-rrf-fritlt...ncootiFeuggnnidrS1ugfvo4r1ourCrtaAaRtbscbDawbqaqitbhbeefFFobwaaoa6Eeflhosoeoeeeeeeenmlltruaeuuyr.vvvvFv.5oy7243xaRlh1exuqnolrbnaii.easoxf2233445aeDT11236ilaQda.if0505050sbi42enoeggnotf0000000neuDt2lRatst,,,nuacutdsvtaswhcqeh4erwynihhnReeada,Sdes..shxoi4vvvptencaecsnrRumetvaxservegusqvnvv741)5iTbRlo1nsauturnla1se1voivneD1d1tioai21Rfm,,,lv(hty]cveFstuuvflT52rsm3stIw0ha2u8o2.i0sa1fl,pWc,tu1h+nevvistshaelwmafiocacocsaavvRvel:ivlevtlvs85:oogsfsvvamraaap7ehdlllQkls116hhhtuwtne1a2sthNRc,,lfieo11eawNo.diodno49aea=mDyvRtyii4tse0eevnrs9h73Taavvdswbshxsdtw-nousRfr1r,idwsdstifleCeevar91sreotAeedt1an-seralatb.:01viresne0u,Sd)nobdo,itbetfszceurawsnlt1hb1ia,ovmBscww-lvDu.S1ocafluerphywFeospwa5fromtaeddlslvwn1.ce30aa(fidhtLiliwavry,camhEToIeerRo3SSS17spstngekenshs8tleT,bAepFttec6s0v3aadnEeeeihlvxt132erreihiwhnt1eodRoiietlsebo1)he6,Otctrnmtpehk,aQcaestartedli(eeicn9edvrwrcevephvomoiisIhnae8npsrreoydrsothficwanfltpii1:hxDhrnoretqvaeobuasncup1ine6ouflrtkncntoiptoa1aoiifatN2uccieelaRyNbnleh,haadntnyrvnselvioawrtrmec1etrrshkfesbtlue8scsvhbDoecedalaeiRecdwwoikieieo[vaueee.1nEdd1tiyEc2e6aaltsrctakh61u0emrnipwsRa8nrtw,(iaineytotrpnivsomctc6ha0vn,e3nw]rxtl1dcesnnthdwdwvpfie5usRri,saldesaoteenCrgtolsaahftdd.alevkeirvvrroe5diacck1hawehyrtoav5i9.cvflvo-se,12eetrfsivvvxmowrskurikesmT55229stssvicorinseetssci1eteda2345asioosiavnssv11556t2edcrflawiztehdshxeshloetadh1sais1wp2266aF(vvvqitvkhaenp-eelogso6fntµC2etnlmopi6847.etcnecvurhulnde.lcf.kconxinsvsdlcbwsbeovftdao1ieahxanuvvvsvaxA4vdu.ehoaenceeseh1ETm1cp9w1i1stowvsree.iduurelns1icD31uCrdbtayn8unlk35ieuaiatevthlvv)EbtfaelaoraExrsvilscwovSs1te1avti1yscvwesRnvbuoCte1rr7tagon)afxt1ylh0S1futa2ho1hrigaieeoaeosiya,ddr7nrR+aeso6t[o0aae9ncntes2233445lnea,soaioo0505050rrxtt119191levimepalvnn0000000renhisScivm nsdtkorseehhttcot090904i]fimlfnlut2adaoehfiheilrpdnlpoyhuo000.hndcdeeacsatvoatrtdc,t-tmicie5(ekeggrlhwsniaexsirrsnEife.aiamrctsaniveeue[2tttasvd(Sb2pifllsoyw.nce7oibixDbs1odd.nWsrntintsu4t,evseos(I(raiecvbamvAaAVfnbaMfsialenoRRstaofldy.asa7drlcahy]iitneoi.FnDauoinauti4fnnorrrareeiiRfyeyefa-ewtnesma,ttnia,ttaozhm12seenIntvsdreeitrf.trCsacpIbbtde9iflddntccShxvISFIIEctRInrht,msgfiutieeta=mnFewavwbidloFwgesoooiaosvphlnnnhR)vv.tppioriavofih.Ieo[tgesk.epugcpiinn1erarawxrvicipvdt.Rt1sao2aOsn0fcfrgmiaai7oaaioWsdtvlasnolenunSiwvghit6ihscoCofle1atysi3xtanyc,goiil0am eguAlvlf1vesvwrteuiocreaur)uehe]rcntgrEr1oh)uesellrtaflwdirhturstidssotectwnpkk,ea0nneladln(,lrhxkh2233445.ac..iuscnecwdii(dca.wthr.irdt88888lireasfsstvu.i0505050vymeoaisle.sbvuk.nnza3.1Dcne0ocsmd.item daee00000001heFao.esetmedn[.ucnutoicm d00000rdvewcaircociiiirspffS4e,meespInehivtsg8amr)nairi0seol1tshilm1r1rorvlatRevcnrthtiivodetasach6litfeeseaxdMeabibateaopintakdiuxFid1]onRhaeovio5Enmite2n0yiaa2nsdlvant.neapeooihrxoDDDDDDDrcsalRecus.tswrt1aseu2nascsovns,dneedthysvpa(08,fl.eitsi50fiEdniomcieoorhpn.dh)tsacreeeeeeef.inrespc[xrfiVoebcerbesdorsfog)Tnvelugoaitditngcvlo2cipalIelflllllllfiTnyrw7orucluefttceTyowdh0tie-reaaaaaaaannnauesnavlcoflnugPelrahIedtaCCotwIghiies-itooflesvw.Wchmideyyyyyyyrsotdneecnneivm n]icehigduv2dvIc.honflSnnsaaed8sioetsttir,mmtreodasci89rc,sterTII.uiii,trusobbbbbbbhxrdxxhddydhoeiirmeeaeirosifoasossssrc/e,wv6ora)mcyttthInvdedo1neocvNoooooooakorotwnimswep1acsofiittntxswvIhEhrppwaisfecleauuuuuuuehuarn:ogflc7nyehsehveetnpvoosea.nnno.1t)nEiaierabannnnnnnedtusnvs,5scSSlSedsletetoettnxa.1ionsnesumrcieidddddddsemoecstSTpeutylivstoTu6etnvrmDvnn13w2e1ulnwbvhgis0icossssssseoae9dract9brlsviWldnnweai,iadp1twidgpeawiexwrlesxm(cevftidsnroodooooSoosErsany11opmube.iksleFdsnw41tupohrtaavfbbfbbiu,OseentoasoreivltweipbFert.idlennsv1ahauPsasreinBttBtttdomim1revviSnvvvflnetrele0safieIaaaa2uRo.ewhsabteottoegaplteatovooirstgiC12)i345Tdn,tfiiiitdnErytxhc1cfahlvsnnnnrtnspuylcdKnEnveeaumteyut6rnIsipiirffaroioIovqlh.viheeeevvvvaxdaoet,tgkglgmncihhe1cc2s,[teflTsrvoetaolPosebahe1ftdddd681d7uulope1inura.als7Acayh0neyra3reeIrcoceoetnaenv2elusage4efaarnmulsamd,i.,ruuuucbRcEvtce.tmttsavvovNth]1fwvydyrcetiwtaut7dmalnssssh3nEatto.vuf19nr4eoiId1foraveaficiOrpasdDiiiibpociostaio1lneraonnnn1snnfl1po5ascf1dpenEoehlnmlbtvlxnoabilfaf.sUmrrieggggbfvu30vnnpkwfieihEcm8nrnectao11ituneoeFegevfi1122334owptvtmeqn6aee,k0505050vmsxiaeNesCTCTtason.ohagshork00000000rnrLnvealtl1no21vvoeccoueotrxr9lrcoshhtwoielmvatooatpeteuitl1D6fdulOcnu9-rb,2o.htiTodoflifevhuttseeeh-ihptlarrvooraclz8de7tsrexos1ossmstrmeoo0eitumtuWoonlDd0rthcmashrtaesfreutheiflaRpdhueeulRwlltnpnsvorrobvtcSllfymcTrlnaeripttoi1naaaeeskepntkesaRvrpfcope1snuisigpblspOufehve1yosdodoMrrmmtuainvhdoesei1pencdooluvwrel4yyithDettl1yt(nRg1eCiflcuonntBr,klSednaens6trnenheehidlutfcFehOebegerdk2415haphonsinslxeodevvgsSeios:moIe4t21sesrtt1oe,,eayfaniys,,18ioNpDtfgs8n(d,switfieeecmtrawvpwFr1EsoloDldcwlmfvadswgiosmwrod-end1o.12aein.cEeuuievm flbuaa9cmhi[rotitRtt,bnntivgt1ftarnirmrriec2,sR6.arohaEtveffLeaalaorevotuee0itubaktsliiflcIf4cieoliDedcneim.vdaxn]shwc1orecrnvbnxdonvettpatdncyshRnaohcw1oaRkd6bo,Semr-svSrh3ittrfedvFvdaviu1eae7c)d.dkTniiandmIe1eetmnpem.miiwinvo19.rnnmon514swwatviufihbu6vlonTv-nannesvnledrdailh2eeihcctussT7eti,i0nEdggaEuc)parodctu-ce1uigtdsncenhicotquiseyhoghhv.xssepvs(n.Fs.h.iiowsnedimlis1a14t.aahmayvgnsc.u.te.EsuuRmw7n9ss.etsnepge.odf.tiainree[2trtc8vcehpauoitsirsoaexArstvvdhitdle7ru1trRepRkt5oeinshodvh,mletRvrbsnehrie,(vvRefi.alrt1nvttfftuofxo]1twzr1mooiiavvndtret0c5dwm2)ya1acoetrrg11olu.a5sonnsoo-helt1oicTe5flflhsThlfliccaaashnpattur9i(oOtuiu2ifoe..eainttfnopoiWbiirnvtntemmetvlfoourrhfactoeelE8lvfipoontvneeclckcfere6ioonoooroouiserR2gowweIccyirrrpemlnnknddndhWvdceeeaeesssntff-r-rf-rf-ecto02ttltxux...niDpnhahred,vevron1ngp1apev44eeeqeosRrapeeumosewvle6ri89aunvnesarnt1nRoavdg3ider1apoCfrtaAaRtbscbDawbqaqitaAohbhCcpxali2tnhosoroalyeftlnmllttuanaeuuuyn.e..hsvvvvFvv.siaoxxlaRlhllvla1eiuqhxnbcas13faioteaeDTgtT11236lQdaomeBftlsb7onoenebnTopfneutmDt2klRtetF,,,,nuawvoaEerysqefluhheferwilo1ynihhRnedu,ddenhehxyeiowvvvepostenarricsrRuyteeioxser2xegusxvnvtt741iubppRcosnu3vrrfliudrtess.tttwtiaoai21Rfma,,(httycvesa)ushxuhhooflpercsmtsthsiaauoli0siflWh,tmnivvitIhza,ewemalsfyrtemocoaencoclmtrbeloinvtos85oCsfm letesmalpieeh1122334lslQlsxhh,rhtwuQs0505050piae1a,hsRpc,,rlfieooaawyd0000000disdlxttoasveyni4taeeeavrsr.ph9tTarlavvpdostwmebhxs1irt-SusRchxrkh,oexwdsiahmieiterebr91srevsotAdrgdtanvls1Felapb.set,veirsnoee0u0ai,dt)envdtbb2efhszqetuesasona1h.phoma,oBcvwwrsl-olvD.ocicauer1pnyhFeos,wh5fulmtfie1nosdrlismatlvrit1.t=lafidhtTLiliort,acofimhsTsIveateritRfi-.17ssgfegren1whttlefprf,ibAeFte6csvrwio3andEeeecehhlthotrhohangheoodRsLiremsvei1hea,OctBrn,mrat1QcerleStmuserlies8ein9eoveudb.vfrlueephvnoneisIhnipectldtsrfidFfiavnflopirmiot1:hxDttr4hnaoeLtaeqrrmbarasncfhuicnb6hvflkncCtaipoonahaetiiiyaeovfatNcixlunceaeRyne1,lrr2etnyervseclxie9Coawm tmarraQhiekabestl,btlestclvhbDettedvnaaReoc.waawolsix2iiv[falruneeidd1natiyh0a1eoarattsrosFckfihx6fisnmmaipwaRae8norytwielxari'etotpenismvec,e,snnw]w7tcalindcenxCdCd,pfietarhac,dspRrifaldtveiiothCssgllsftddalekbntvsihxrtnroexacRcelaw5acuhxmybrovflvose,eieesx,ywskrioka[sT55229wrlloetsaonirdisvfscietrmdaosiToa7osb6ossfli11556tdsfedchxainzcedahxoeuehvtasdhudsaitswt2266F(feuviqtheuoa-e]ugsd1entetsµCfiltmsopire.etl7ercevhnnuldhre.cf.iwchironinastecwWnlsvfaontaisrdahxaolsavhx1Adu.dehslCamhmnscted5eeEeTcfawseisCm wDrn.diaeeunul.no.eiceDuCrde.nxrvnlkieaduiaisath8tsey)xaaeelaoaE.nirsiscFodissflteorTtcesRmeRunCtytrrsosotagpvoaftlh,fiut2ahifhwrigfaeoheoeaes,inBdnohnwrRoeo[oaysrrchatvsbRalnrea,ttsasi1Cr119191lioepuabrlvonr4nhgxise=cim sotrsoottcot09090tsi]fiolomutovtta,ebh,bfihxilipt1nblecyhu000.hpoc2aycsamtvotlfrtdctasfmieedeudsegagrfliahsnoiaexvusihrsweqief1iamsaumnceii3ituecuzttfltasvde(DbtpoflnrtsnuuowtnceodbFhfirbsdrdleWsrvhnmimsuSotyep1otialeifldwyasRadrlcienyrdiiciC.aeihnawtefeeosewunmtetnpciaotvths4eetifx3ChsRtdeie3ddschxIsychrtssesgrefeo.idstoeomoos.tpn)sith[gres.lerxrprdt.nfrC7aaIitm hivihthoCtfaaiaoanguAveeomc]nreEseawxittfx.ritch,aneladxkuseiathrn88888leseabkWeztcosmim aecd.[acdt00000hearcccfeeesph8aaitlsll-inoIerahteeessabatonu]enRostmiosdlpedirosals.sruncntdewtf(zh.esleoorssmacfc-erbfogTnagescvatipmfiTluclueifytaontvigtiatCCCvuhi(ieoidttncnncenhcvca1oeitstteeresiriihxxxxh0gdndydhoheeeaesssss)fr):tttt

network interconlex links tput port it Round width of es (interm frame

1hxains dtoo2smdaiflflefrorothnelytrabnysmtihsseioncoonf fiCgxuqruaetuieohneaodf-otfh-leineswitch S4. pFalcokwet.sI{nvt1he. .fo. rvm5e}r, c{avs6e,. . .hxv1is2}re,saent dto {zver1o3. .I.n. tvh2e0l}ataterre assigned aofahCts"nflirltn.noaxlcflooeTomhT=,wowfluh[chee7tewolupds]stwa3shxuhc,i"usz,osrte.weseilefQspIadetaanreotiarhxCkamtrrspentalgq1iohpoasidshu,enimatrtsvat.esgrfuiCneohsLeaittasmrnnou.2levilmott,LcehecctbnlehllreleaCmaaQtatyeonsxhnsaasFhxfssedxtpsaxsCC,,haihtalwatsnxeaxCpqyraradriboeflsenu3btetfeuodcrfi,reiinwahtntntcuhdlhmrrseCmoe.eaietdexnaorishtmntsripguffeoe,eoorhaettonsurxispcmpsotbiaeptmufieoaimuosvtccuflnttnhlhemeoFpadpelwosIpoyFssForfosm.utIrhOrrCaFhottatTmepx;fOx.hrh(WeuAc.eaacweulqtnIrltesarhttoldiushooepzhssmrpeaeisaomzaiCveuuitanrodsiescctxegnf:tlsiwklc)oae.eonensAstnsesedllchsyouaDoes.feln,lARleaiacmRdllesillted

than those of Boyer et al. Second, delay bounds obtained with our new strict service curve for DRR that accounts for arrival curve of interfering flows are always better than the (incorrect) ones of Soni et al. and are considerably better than Bouillard's. The obtained delay bounds using to:TEhPFeLoLrAeUmSANN5E,. Doouwnrloandoedno-ncMoany 0v9e,2x020faut 1ll8:3m1:5a8 pUTpCifnrogm,IEaEEreXplboree.ttReerstritchtioansnapply. or equal to those of obtained using Corollary 4, its convex version; also, they are equal to those of Corollary 3, our non-

classes have the same quantum equal to 199 bytes. The rate

of Si

thhaeslCmlaixnasxkw,hsi=tacrhiemiFnaeChxgqxullimaatlaextn,ocyclCem=qxinu,1ha0l=0toiMmF1iCb6hnx/µlssim,. iEnanvderye(v1fle) oryw

switch vi has

ng policy. d [7]. We

AoTaulitgmp.ourHatitxhpemoinmrct 1euh,mswflhoiotpwhwasncvaktnireatfiifimsscpiczlcoeelnmasslesimtnerstaaa.xtiFinoaienrnsdtdo, fdbmeyDfiRicaniRtistmoaaktrueeamnses-twbptiuaotccc0hkkeett

arrival arrival



curve with rate it is constrained

equal

to

limax Ti

and

burst

equal

to

by a stair arrival curve given by

limax limax

;

also,

t Ti

.

For the sake of comparison, as Soni et al. do not consider

convex simple mapping. Note that the results do not differ whatever the initial strict service curves are. When using token-bucket arrival curves, the run-times (on the RTaW online tool) of Theorem 5 and Corollary 3 are in the order of 3 minutes; for their convex versions, Corollary 4 and Theorem 6, they are in the order of 30 seconds; when using stair arrival curves, the run-times (on the RTaW online tool) of Theorem 5 and Corollary 3 are in the order of 5 minutes;

grouping and offsets (explained in Section 2.4) in these two examples, we also do not consider them. This means that the ownloaded on Maay r0r9i,2v0a20l actu18r:v31e:58wUeTCufrsoem fIEoErE bXpolouren. dRienstgricttiohnes aipnplpy.ut of a class at a

for their convex versions, Corollary 4 and Theorem 6, they are in the order of 1 minute and 45 seconds, respectively.

switch is simply equal to the sum of arrival curves expressed for every member flow. Arrival curves are propagated using

6.3 Industrial-Sized Network

the delay bounds computed at the upstream nodes. We We use the network of Fig. 12; it corresponds to a test

illustrate the reported values in [7] for the delay bounds configuration provided by Airbus in [21]. The industrial-

of Soni et al. For the other results, we use the RTaW online sized case study that Soni et al. use in [7] is based on this

12

r to mes. nce
ork or a
ion
omays: odel
an we amthe ch.
netrk.
neting envior
ure bus teritch orts and ttle exo at full ates ms. not
hed ink has ters

Delays (ms) Delays (ms)
Delays (ms)

113 S1 820 66 S8 358

132 S3 1156

113 S2 821 143 S4 1207 95 S7 457 160 S5 857

142 S6 708

Fig. from

1[223F: ].Iingduursetria1l-.sAizeFdDnXetwnoertkwtooproklogayr.cThhieteficguturereis

taken

70

DDeelalay ybobuonudsnodfsBoofuiBllaorudillard

DDeelalay ybobuonudsnodbstaoinbetidnwedithuCsoinrogllacroyn4v, oeuxr vcoenrsveioxnfuollfmTahpepionrge. m 5

60

DDeelalay ybobuonudsnodbstaoinbetidnwedithuTshienogreTmhe5,ooruermno5n-convex full mapping.

4.5

50

4

3.5

3
40
2.5

2
30 1.5

1

20

0.5 0

100

200

300

400

500

600

700

800

900

Source-destination pairs

10

0
E30n0 d-Systems exchange Ethernet frames through VL. 0

1000

2000

3000

4000

Source-destination pairs

5000

6000

7000

Switching a DfDerelaalaymybbeounfdrsosomoffBBoaoyeyreterrtaeatnl.asl.mitting to a receiving End Syst25e0m is baDsDeeeladlayybobonunadssVSoofnLSi eot(nadil.eettael.rministic routing). The Virtual Link deDfiDenelaleayysbbooauunnlddossgoobibtcatiianneeldduwunsitihindgThiTerhoereceomtrie5omn5al connection from

Fig. 14: Delay bounds of the industrial case for all sourcedestination pairs in the system. The obtained delay bound ob-
tained with Theorem 5 and Corollary 4, our non-convex and con-

one2s00ource End-system to one or more destination End sys- vex full mapping, are equal to those of obtained with Corollary

tems.

It is a path with multicast characteristic.

Figure

2

3 and Theorem 6, our non-convex and Source-destination paths are ordered

convex simple mapping. by values of Bouillard's

show150s an example of a multicast Virtual Link, considering bound.

the network architecture of figure 1. Its source is an input of switch S1 and its destination End
100

End System Systems are

best-effort; bytes; and

they their

have a maximum packet-size equal to 1535 minimum packet arrival time is between

outputs of switches S8, S3, S4 and S7. This VL includes the 2 and 128ms. For every flow, the path from the source to

four paths S1-S8, S1-S3, S1-S8-S4 and S1-S8-S4-S7 (they a destination can traverse at most 4 switches. Specifically,

are d50epicted as plain lines on figure 2).

1797, 2787, 1537, and 291 source-destination paths have 1,

2, 3, and 4 hops, respectively. We choose the paths randomly

0 0
src

1000
S1

2000

3000

4000

S8 Source-destindateiosnt1pairs

5000

6000

7000

dest2

S3

and satisfy all these constraints. Due to the limited expressiveness of the language used
by the RTaW online tool, we could not implement the

Fig. 13: Delay bounds of the industrial case for all source- industrial-size network there. Therefore, we used MATLAB,

destination pairs in the system. The comparison with delay bounds with Bouillard's method is illustrated in Fig. 14. The oobutraninoend-Scdo2enlvaeyxbaonudndcoonbvStae4ixnefudllwdmietsahtp3Tphinego,Srea7mre5eaqdnuedastlC4toortohlolasrSey54o,f obtained with Corollary 3 and Theorem 6, our non-convex and convex simple mapping. Source-destination paths are ordered by values of Boyer's bound.

which has the required expressiveness. The obtained delay bounds are quasi identical for the full and simple versions of the mappings, therefore we illustrate results only for Theorem 5 (non-convex full mapping) and Corollary 4 (convex full mapping).
Note that the results are identical for both mentioned

network in [23]. We combine the avaSil6able information in

choices of initial strict service curves. We also computed the delay bounds obtained with the strict service curve of Boyer

both papers to understand this network. It includes 96 end- et al., with Bouillard's strict service curve and with the cor-

sraytseteomfs,th8Feisgwliunitkrcehs ea2sr,.e9A8e4qmfluoaulwlttsio,caacnsd=t6V411i0r20tpuMoaslbsi/Lbsli,enapknadthse.vTehrye

rection term of Soni et al. In all cases, and as in [7], the arrival curve used for bounding the input of a class at a switch in-

sewaTcihhtcehswrSoiiutchthiansghaaosswf6ietiacnhcphinugtValLantdeins6csytoaeutqitucpaaulltltyoen1dd6e-µfissyn.seWtdeme. fisO.nndTlhtyhreaoetne

corporates as well as

the effects of delay bounds computed upstream, grouping (line shaping) and offset (Section 2.4);

EncldasSseysstoefmflwowitshianrethceonAsvidioerneidcs: cnreittiwcaolrflkocwans, bmeutlhtiemseoduiarce furthermore, the offsets are such that they create maximum

offloonwes,VainrtduablesLt-ienfkfo, r(ti.fleo.,wMs.oTnhoerTeriasnosnmeitDteRrRassscuhmedputlieorna)t. separation, as with [7]. We find that our bounds significantly

evTehrye sowbijtecchtiovuetpisuttopoprrtowviitdhena=lo3gicclaaslsiesso. lAattieovneroyf DVRLR: a improve upon the existing bounds, even the incorrect ones

gleis1bsvc5seeh3snoet5-fdmebutfhyfaloetexerrit,samtctfthloueaermmsstq.hpbu1etaea2nmnd8dtuuamwlttuiaiildmrliteztiheca3dati0isisoa7ta0nflcllloobaowyfscstsaae,,tsaVewndfLiodttrhob1ty58eh33aeo54cnhcbderyeVitatsietLpcisanp.lfalRoitccrieloaagtntshaissoer,,dn-,

(Fig. 13). Moreover, we always improve on Bouillard's delay bounds. Also, delay bounds obtained using Theorem 5 are considerably improved compared to its convex version for

thaereavcariitliacballe; tBheayndhwaviedtah monaxaimnyumothpearckVeLt-siiszeuneaqfufaelcttoed1.50 flows with low delay bounds.

byAtevsiratnudaltLheinirkmisindiemfiunmedpbaycktehte afrorlilvoawl itnimg epaisrabmetewteeresn: Remark on run-times: For the industrial sized described

4 and 128ms. 500 multicast flows, with 3845 destinations, above, run-times (on a 2.6 GHz 6-Core Intel Core i7 com-
a·re tmheunltaimmeedoiaf tahnedVthLe,ir class has a quantum equal to puter) of Theorem 5 and its convex version are 96 and 72

1535 bytes; they have a maximum packet-size equal to 500 minutes, respectively; however, run-times of Corollary 3 and
b·yteths;eanBdatnhdewirimdtihnimAullmocpaaticoknet-Gararipva(l BtiAmGe )is obfetwtheeenV2L, its convex version are higher and are 130 and 103 minutes, andw1h2i8cmhsc. o26rr6emspuolntidcasstofltohwesm, winitihm1u7m33ddeelsatyinbaetitownes,enarethe respectively. This is because the number of classes is small,

emission of two consecutive source End System,

frames

of

the

VL

by

i1ts3

i.e., 3 classes. To increase this, we divided at uniformly random flows of each class to three new classes, which results in 9 classes in total. By doing so, run-times of Theorem 5 and its convex version are 275 and 220 minutes, respectively; however, run-times of Corollary 3 and its convex version are lower and are 162 and 130 minutes, respectively. This supports the fact that computation of strict service curves of Corollary 3 is faster than those of Theorem 5, when the number of flows is large.
7 CONCLUSION
The method of the pseudo-inverse enables us to perform a detailed analysis of DRR and to obtain strict service curves that significantly improve the previous results. Our results use the network calculus approach and are mathematically proven, unlike some previous delay bounds that we have proved to be incorrect. Our method assumes that the aggregate service provided to the DRR subsystem is modelled with a strict service curve. Therefore it can be recursively applied to hierarchical DRR schedulers as found, for instance, with class-based queuing.
REFERENCES
[1] M. Shreedhar and G. Varghese, "Efficient fair queuing using deficit round-robin," IEEE/ACM Transactions on Networking, vol. 4, no. 3, pp. 375­385, 1996.
[2] L. Lenzini, E. Mingozzi, and G. Stea, "Aliquem: a novel DRR implementation to achieve better latency and fairness at O(1) complexity," in IEEE 2002 Tenth IEEE International Workshop on Quality of Service (Cat. No.02EX564), 2002, pp. 77­86.
[3] M. Boyer, G. Stea, and W. M. Sofack, "Deficit round robin with network calculus," in 6th International ICST Conference on Performance Evaluation Methodologies and Tools, 2012, pp. 138­147.
[4] S. S. Kanhere and H. Sethu, "On the latency bound of deficit round robin," in Proceedings. Eleventh International Conference on Computer Communications and Networks, 2002, pp. 548­553.
[5] D. Stiliadis, "Traffic scheduling in packet-switched networks: Analysis, design, and implementation," Ph.D. dissertation, 1996, aAI9637506.
[6] L. Lenzini, E. Mingozzi, and G. Stea, "Full exploitation of the deficit round robin capabilities by efficient implementation and parameter tuning."
[7] A. Soni, X. Li, J. Scharbarg, and C. Fraboul, "Optimizing network calculus for switched ethernet network with deficit round robin," in 2018 IEEE Real-Time Systems Symposium (RTSS), 2018, pp. 300­ 311.
[8] A. Bouillard, "Individual service curves for bandwidth-sharing policies using network calculus," IEEE Networking Letters, vol. 3, no. 2, pp. 80­83, 2021.
[9] S. M. Tabatabaee, J.-Y. Le Boudec, and M. Boyer, "Interleaved weighted round-robin: A network calculus analysis," in 2020 32nd International Teletraffic Congress (ITC 32), 2020, pp. 64­72.
[10] S. M. Tabatabaee and J.-Y. Le Boudec, "Deficit round-robin: A second network calculus analysis," 2021 IEEE 27th RealTime and Embedded Technology and Applications Symposium RTAS 2021, p. 13, 2021. [Online]. Available: http://infoscience.epfl.ch/ record/285728
[11] J.-Y. Le Boudec and P. Thiran, Network Calculus: A Theory of Deterministic Queuing Systems for the Internet. Springer Science & Business Media, 2001, vol. 2050.
[12] C. S. Chang, Performance Guarantees in Communication Networks. New York: Springer-Verlag, 2000.
[13] A. Bouillard, M. Boyer, and E. Le Corronc, Deterministic Network Calculus: From Theory to Practical Implementation. Wiley-ISTE.
[14] K. Lampka, S. Bondorf, and J. Schmitt, "Achieving efficiency without sacrificing model accuracy: Network calculus on compact domains," in 2016 IEEE 24th International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunication Systems (MASCOTS), 2016, pp. 313­318.

[15] J. Liebeherr, "Duality of the max-plus and min-plus network calculus," Foundations and Trends in Networking, vol. 11, no. 3-4, pp. 139­282, 2017.
[16] "RealTime-at-Work online Min-Plus interpreter for Network Calculus," https://www.realtimeatwork.com/minplus-playground, accessed: year-month-day.
[17] A. Charny and J.-Y. Le Boudec, "Delay bounds in a network with aggregate scheduling," in Quality of Future Internet Services. Springer, 2000, pp. 1­13.
[18] D. B. Chokshi and P. Bhaduri, "Modeling fixed priority nonpreemptive scheduling with real-time calculus," in 2008 14th IEEE International Conference on Embedded and Real-Time Computing Systems and Applications, Aug 2008, pp. 387­392.
[19] L. Thiele, S. Chakraborty, and M. Naedele, "Real-time calculus for scheduling hard real-time systems," in 2000 IEEE International Symposium on Circuits and Systems (ISCAS), vol. 4, May 2000, pp. 101­104 vol.4.
[20] A. Mifdaoui and T. Leydier, "Beyond the Accuracy-Complexity Tradeoffs of CompositionalAnalyses using Network Calculus for Complex Networks," in 10th International Workshop on Compositional Theory and Technology for Real-Time Embedded Systems (co-located with RTSS 2017), Paris, France, December 2017, pp. pp. 1­8. [Online]. Available: https://hal.archives-ouvertes.fr/ hal-01690096
[21] J. Grieu, "Analyse et e´valuation de techniques de commutation ethernet pour l'interconnexion des syste`mes avioniques," September 2004. [Online]. Available: https://oatao.univ-toulouse. fr/7385/
[22] A. Bouillard, "Trade-off between accuracy and tractability of network calculus in fifo networks," 2020.
[23] H. Charara, J. . Scharbarg, J. Ermont, and C. Fraboul, "Methods for bounding end-to-end delays on an afdx network," in 18th Euromicro Conference on Real-Time Systems (ECRTS'06), 2006, pp. 10 pp.­202.
[24] S. M. Tabatabaee, J.-Y. Le Boudec, and M. Boyer, "Interleaved weighted round-robin: A network calculus analysis," 2020. [Online]. Available: https://arxiv.org/pdf/2003.08372.pdf
[25] M. Boyer and P. Roux, "A common framework embedding network calculus and event stream theory," May 2016, working paper or preprint. [Online]. Available: https://hal. archives-ouvertes.fr/hal-01311502

14

Supplementary Material
Deficit Round-Robin: A Second Network Calculus Analysis
Seyed Mohammadhossein Tabatabaee, Jean-Yves Le Boudec

APPENDIX A PROOFS

A.1 Proof of Theorem 1
The idea of the proof is as follows. We consider a backlogged period (s, t] of flow of interest i, and we let p be the number of complete service opportunities for flow i in this period, where a complete service opportunity starts at line 7 and ends at line 15 of Algorithm 1. p is upper bounded by a function of the amount of service received by flow i, given in (36). Given this, the amount of service received by every other flow j is upper bounded by a function of the amount of service received by flow i, given in (38). Using this result gives an implicit inequality for the total amount of service in (40). By using the technique of pseudo-inverse, this inequality is inverted and provides a lower bound for the amount of service received by the flow of interest.
From [3, Sub-goal 1], the number p of complete service opportunities for flow of interest, i, in (s, t], satisfies

Di(t) - Di(s)  pQi - dmi ax

(35)

Therefore, as p is integer:

p

Di(t) - Di(s) + dmi ax Qi

(36)

Furthermore, it is shown in the proof of [3, Sub-goal 2] that

Dj(t) - Dj(s)  (p + 1)Qj + dmj ax

(37)

Using (36) we obtain

Dj(t)-Dj(s) 

Di(t) - Di(s) + dmi ax Qi

Qj + (Qj + dmj ax)

i,j (Di(t)-Di(s))

(38)

Next, as the interval (s, t] is a backlogged period, by the

definition of the strict service curve for the aggregate of

flows we have

(t - s)  (Di(t) - Di(s)) + (Dj(t) - Dj(s)) (39)
j=i

We upper bound the amount of service to every other flow j by applying (38):

j=i Qj + dmj ax ; as there is no plateau in i, its lowerpseudo inverse is simply its inverse which is obtained by flipping the axis (Fig. 15), and is obtained as

i(x) = (1  Qi,Qtot ) [x - i (Qi - dmi ax)]+

(42) 

+ min [x -

Qj + dmj ax ]+, Qi - dmi ax

j=i

i is illustrated in Fig. 15. In (42), observe that the term

with min expresses the finite part at the beginning between

0 and i (Qi - dmi ax); also, observe that the term with the

min-plus convolution expresses the rest (see Fig. 1.b with

a = Qi and b = Qtot =

n j=1

Qj

.).

3000

2500

!

2000

#

#

1500

! !
!"#

1000

 =
! = !

# (# - #$%&)

!(! + !$%&)
!"#

# - #$%&

500

#

# - #$%&

#

! !
!"#

0

0

500

!(! + !$%&)

!"#

#1(00#0- #$%&) 1500

2000

2500

3000

Fig. 15: Illustration of i to i, defined in (6) and

a(4n2d),itrseslopweecrt-ivpesley.udFounincvtieornseiJih,aesqtuhael

same form as i.

A.2 Proof of Theorem 2
We use the following Lemma about the lower pseudoinverse technique.
Lemma 1 (Lemma 14 [24]). For a right-continuous function f in F and x, y in R+, f  (y) = x if and only if f (x)  y and there exists some  > 0 such that x  (x - , x), f (x ) < y.

(t-s)  (Di(t) - Di(s)) + i,j (Di(t) - Di(s)) (40)
j,j=i
i (Di (t)-Di (s))

Then we invert (40) using (1) and obtain

Di(t) - Di(s)  i((t - s))

(41)

Lastly, we want to compute i. ging i,j in (6), i(x) = x +

Observe
x+dmi ax Qi

that, by plugj=i Qj +

Proof of Theorem 2. We prove that, for any value of the system parameters, for any  > 0, and for any flow i, there
exists one trajectory of a system such that

s  0, (s, s +  ] is backlogged for flow i

and Di(s +  ) - Di(s) = i0( )

(43)

Step 1: Constructing the Trajectory
1) We use the following packet lengths for each flow j: As explained in Section 2.2, we have Qj  ljmax; thus, there exist an integer nj  1 such that Qj = njljmax + (Qj

15

For /lows   : {!$%&, ..., !$%&, !$()*+, !$%&, ..., !$%&, !$(),+, !$%&, ..., !$%&, !$(), !$%&, ..., !$%&, !$()}

Packet Arrivals:

! - 1

! + 1

!

!

For /low : {'$%&, ..., '$%&, '$()*+, '$%&, ..., '$%&, '$(), '$%&, ..., '$%&, '$()}

' - 1

'

'

Round 1

Round 2

Output: !!""#(#(!!--!$!$%%&&)) !"#(! + !$%&)

=0

=

! - !"#$

Round 3

!"# !

'

Round 4

!"# !

'

 =  +   = -

Fig. 16: Example of the trajectory scenario presented in Section A.2 with p = 2.

mod ljmax). Then, let ljmod = (Qj mod ljmax), ljmod- = ljmod - , ljmod+ = ljmod + .
2) Flows are labeled in order of quanta, i.e., Qj  Qj+1. 3) At time 0, the server is idle, and the input of every queue j = i is a bursty sequence of packets as follows:

· First, (nj - 1) packets of length ljmax followed by a

packet of length ljmod+ ; · Second, (nj + 1) packets of length ljmax followed by

a packet of length ljmod- . Note that if ljmod = 0, the sequence can be changed to nj packets of length ljmax followed by a packet of length ljmax - and the rest

of the proof remains the same;

· Third,

i0( )+dmi ax Qi

-1

times of a sequence of nj

packets of length ljmax followed by a packet of length

ljmod.

4) Let flow i be the first flow that is visited after flow i

by the DRR subsystem, i.e., i = (i + 1) mod n. The input of

flow i arrives shortly before all other flows j = i at time 0.

5) The output of the system is at rate K (the Lipschitz

constant of ) from time 0 to times s, which is defined as

the time at which queue i is visited in the second round,

namely

s

=

1 K

j=i

Qj - dmj ax

(44)

It follows that

t  [0, s], D(t) = Kt

(45)

6) The input of queue i starts just after time s, with a bursty sequence of packets as follows:

· First, (ni - 1) packets of length limax followed by a

·

packet of Second,

leni0g(th)+limdmiodax+
Qi

;

times of a sequence of ni

packets of length limax followed by a packet of length

limod.

7) After time s, the output of the system is equal to the
guaranteed service; by 3) and 6), the busy period lasts for at least  , i.e.,

t  [s, s +  ], D(t) = D(s) + (t - s)

(46)

Step 2: Analyzing the Trajectory Let p be the number of complete services for flow i in (s, s +  ], and let p be the start of the first service for flow i after these p services. We want to prove that

Dj(p) - Dj(s) = i,j (Di(s +  ) - Di(s)) (48)

We first analyze the service received by every other flow j = i. First, observe that every j = i sends (nj - 1) packets of length ljmax followed by a packet of length ljmod+ in the first service after t = 0; this is because at the end of serving these packets the deficits of flow j becomes dmj ax and the head-of-the-line packet has a length ljmax > dmj ax. Second, for the first service after time s, every other flow j = i sends (nj +1) packets of length ljmax followed by a packet of length ljmod- , and at the end of this service the deficit becomes zero. Third, observe that in any other complete services for flow j (if any), it sends nj packets of length ljmax followed by a packet of length ljmod. Hence, in the first complete service of
flow j after time s, flow j is served by Qj + dmj ax ; and in every other complete services for flow j, it is served by Qj.
(the red parts in Fig. 16) We then analyze the service received by flow i. First, it
should wait for all other j = i to use their first service after time s, and then flow i sends (ni - 1) packets of length limax followed by a packet of length limod+ ; this is because at the end of serving these packets the deficits of flow i becomes dmi ax and the head-of-the-line packet has a length limax > dmi ax. Second, observe that in any other complete services for flow i (if any), it sends nj packets of length ljmax followed by a packet of length ljmod. Hence, in the first complete service of flow i, which happens after time s, flow i is served by (Qi - dmi ax); and in every other complete services for flow i, it is served by Qi. (the green parts in Fig. 16)
Then, by combining the last two paragraphs, observe
that (Fig. 16)
· Flow i is served in (s, p] by [pQi - dmi ax]+. · Every other flow j has p + 1 complete services in
(s, p], and they are served by (p + 1)Qj + dmj ax .

It follows that

Dj(p) - Dj(s) = i,j (Di(p) - Di(s))

(49)

In particular,

D(s +  ) - D(s) = ( )

Then, there are two cases for s +  : whether s +  < p or (47) s +   p. In the former case, s +  is not in the middle of

16

a service for flow of interest and hence Di(s +  ) = Di(p); in the latter case, s +  is in the middle of a service for flow i and Di(s +  ) - Di(p) < Qi; thus observe that i,j (Di(s +  ) - Di(s)) = i,j (Di(p) - Di(s)). Hence, in both cases (48) holds.
Then, If we apply i to both sides of (47), the right-hand side is equal to i0( ). Thereby, we should prove
i (D(s +  ) - D(s)) = Di(s +  ) - Di(s) (50)

Let y = D(s +  ) - D(s) and x = Di(s +  ) - Di(s). Our goal is now to prove that

i (y) = x

(51)

Again consider the two cases for s +  . Case 1: s +  < p In this case the scheduler is not serving flow i in
[p, s +  ]; thus Di(s +  ) = Di(p). Combining it with (49),
it follows that

i(x) = x +

i,j (x)
j,j=i

j,j=i(Dj (p)-Dj (s))
y = x + (Dj(s +  ) - Dj(s))
j,j=i

(52)

and thus

i(x)  y

(53)

Let x - limod < x < x; flow i's output becomes equal to x during the emission of the last packet thus

i(x ) = x + (Dj(p-1) - Dj(s))

(54)

j,j=i

Hence

x  (x - limod, x), i(x ) < y

(55)

Combining (53) and (55) with Lemma 1 shows (51). Case 2: s +   p In this case the scheduler is serving flow i in [p, s +  ].
For every other flow j, we have Dj(s +  ) = Dj(p). Hence,
combining it with (48),

i(x) = Di(s+ )-Di(s)+ i,j (Di(s +  ) - Di(s)) = y

j,j=i

Dj (s+ )-Dj (s)

(56)

As with case 1, for any x  (x-limod, x), we have i(x) < y,

which shows (51).

This shows that (43) holds. It remains to show that the

system constraints are satisfied.

Step 3: Verifying the Trajectory

We need to verify that the service offered to the aggre-

gate satisfies the strict service curve constraint. Our trajec-

tory has one busy period, starting at time 0 and ending at

some time Tmax   . We need to verify that

t1, t2  [0, Tmax] with t1 < t2, D(t2) - D(t1)  (t2 - t1)
(57)
Case 1: t2 < s Then D(t2) - D(t1) = K(t2 - t1). Observe that, by the Lipschitz continuity condition on , for all t  0, (t) = (t) - (0) = (t)  Kt thus K(t2 - t1)  (t2 - t1). Case 2: t1 < s  t2

Then D(t2) - D(t1) = (t2 - s) + K(s - t1). By the Lipschitz continuity condition:

(t2 - t1) - (t2 - s)  K(s - t1)

(58)

thus D(t2) - D(t1)  (t2 - t1). Case 3: s  t1 < t2 Then D(t2) - D(t1) = (t2) - (t1)  (t2 - t1) because
 is super-additive.

A.3 Proof of Theorem 3

We first prove the following:

h

i, i0

=

T

+

sup{
t0

1 c

i

(i(t))

-

t}

(59)

First, as in [11, Prop. 3.1.1],

h i, i0 = sup{i0 (i(t)) - t}

(60)

t0

Second, we show that

i0

=

T

+

1 c

i

(61)

As in [25, Prop. 7], for two functions f, g  F where f is right-continuous, we have (f  g) = g  f ; as i0 = i   and i is continuous , it follows that

i0 =   i

(62)

Observe

that

(x)

=

1 c

x

+

T

for

x

>

0

and

(x)

=

0

for

x = 0. Combine this with the above equation to conclude

(61).

i,

Third, observe that and let us denote it

i by

is i

the left-continuous version = iL. It follows that

of

h

i, i0

=

T

+

sup{
t0

1 c

iL

(i(t))

-

t}

(63)

Observe that supt0{iL (i(t)) - t} = supt0{i (i(t)) - t} as i is right-continuous. Therefore, combining it with

the above equation, (59) is shown.

Let us prove item 1), i.e., assuming i = ri,bi . Define H

as

H (t)

d=ef

T

+

1 c

i

(i(t))

-

t

(64)

Using (59), we have h i, i0 = supt0{H(t)}. By plug-

ging i and i in H, we

1 c

rit + b +

rit+b+dmi ax Qi

have H(t) j=i Qj

=T -t

+

j=i(Qj +dmj ax)
c

+

Then,

as

ri



Qi Qtot

c,

observe that function H is linearly decreasing between

0  t < i with a jump at t = i; also, H(t)  H(i) for all t  i (see the above panel of Fig.17). Hence, the supremum of H is obtained either at t = 0 or t = i. This concludes

item 1).

Item 2) can be shown in a similar manner, however,

function H is non-decreasing between 0  t < i (see the

bottom panel of Fig.17).

The same proof holds for item 3).

17

 1

 +  !(!)

"#! " 

!



! - 1 

 1  +  ! ! !

!

1) ! = $!,&!

! 

"#! " ! - 1  

applying [13, Lemma 3.1], it follows that the inequality
holds for the non-decreasing closure of the left-hand side (with respect to t - s), namely



+

 - j (t - s)  iJ (Di(t) - Di(s)) (68)



jJ¯



Then, we use the lower pseudo-inverse technique to

invert (68) as in (1),



+



Di(t) - Di(s)  iJ  - j (t - s) (69)

jJ¯



!.! 2) ! = min($!,&! ,  + !'())



Fig. 17: Illustration of function H defined in (64)

A.4 Proof of Theorem 4
First observe that, since i,j  F , it follows that i  F . Second, as for every j = i, i,j  i,j, we have i  i. In [15, Sec. 10.1], it is shown that f, g  F , f  g  f   g. Applying this with f = i and g = i gives that i  i. It follows i(t) = i ((t))  i ((t)) = i(t). The conclusion follows from the fact that any lower bound in F of a strict service curve is a strict service curve.

A.5 Proof of Theorem 5

First we give a lemma on the operation of DRR, which follows from some of the results in the proof of Theorem 1.

Lemma 2. Assume that the output of flows j  J¯ are constrained

by arrival curves j  F , i.e., Dj is constrained by j. Then,

iJ   -

jJ¯ j

+ 

is a strict service curve for flow i.

Proof. Consider a backlogged period (s, t] of flow of interest i. As the interval (s, t] is a backlogged period, and since  is a strict service curve for the aggregate of flows, we have

(t - s)  (Di(t) - Di(s)) + (Dj(t) - Dj(s)) (65)
j=i

For j  J , upper bound (Dj(t) - Dj(s)) as in (38), and for j  J¯, upper bound (Dj(t) - Dj(s))  j(t - s), as j is an arrival curve for Dj, to obtain

(t - s) - j(t - s)
jJ¯
 (Di(t) - Di(s)) + i,j (Di(t) - Di(s)) (66)
jJ

iJ (Di(t)-Di(s))

As iJ is a non-negative function, it follows that



+

 - j (t - s)  iJ (Di(t) - Di(s)) (67)
jJ¯

As iJ is an increasing function, it follows that the righthand side is an increasing function of (t - s). Then, by

Hence, the right-hand side is a strict service curve for flow i. Observe that iJ = iJ.

As jold is a strict service curve for flow j, it follows that

j jold is an arrival curve for the output of flow j. Then,

for every J  Ni, apply Lemma 2 with j = j jold for

j  J¯ and conclude that iJ   -

jJ¯ j

+

jold

is a


strict service curve for flow i. Lastly, the maximum over all

J is also a strict service curve for flow i.

A.6 Proof of Corollary 3

We proceed the proof by showing that for every flow i,

¯¯iinneeww(t)

inew. Fix i  n  inew(t). Let

and t J  be

 0. We want to show that {j  Ni | i,j iold(t) <

j jold (t)}. Then, observe that





inew(t)  iJ (t) -

(j j) (t) (70)

jJ¯

Apply iJ to the both side and observe that

iJ (inew(t))  (t) -

(j inew) (t) (71)

jJ¯

as inew  iold(t) and i,j is increasing, it follows that

i,j (inew(t)) 

i,j iold(t)

(72)

jJ¯

jJ¯

Then, sum the both side of (71) and (72) to obtain

i (inew(t))  (t) +

i,j (i(t)) - j jold (t)

jJ¯

j=i[i,j (i(t))-(j j )(t)]+
(73)

Then, by applying [13, Lemma 3.1], it follows that the above

inequality holds for the non-decreasing closure of the left-

hand side. Thus,





i (inew(t))   +

i,j  i - j

j=i

jold + (t)

(74)

18

Lastly, we use the lower pseudo-inverse technique to invert

as in (1) and as i = i



inew(t)  i   +

i,j  i - j

j=i

jold + (t)


¯inew (t)

(75)

which concludes the proof.

19

