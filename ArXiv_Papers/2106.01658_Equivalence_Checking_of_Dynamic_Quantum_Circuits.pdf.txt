Equivalence Checking of Dynamic Quantum Circuits
Xin Hong1, Yuan Feng1*, Sanjiang Li1* and Mingsheng Ying1,2,3*
1Centre for Quantum Software and Information, University of Technology Sydney, Australia 2State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, China
3Department of Computer Science and Technology, Tsinghua University, China

arXiv:2106.01658v1 [quant-ph] 3 Jun 2021

Abstract--Despite the rapid development of quantum computing these years, state-of-the-art quantum devices still contain only a very limited number of qubits. One possible way to execute more realistic algorithms in near-term quantum devices is to employ dynamic quantum circuits, in which measurements can happen during the circuit and their outcomes are used to control other parts of the circuit. This technique can help to significantly reduce the resources required to achieve a given accuracy of a quantum algorithm. However, since this type of quantum circuits are more flexible, their verification is much more challenging. In this paper, we give a formal definition of dynamic quantum circuits and then propose to characterise their functionality in terms of ensembles of linear operators. Based on this novel semantics, two dynamic quantum circuits are equivalent if they have the same functionality. We further propose and implement two decision diagram-based algorithms for checking the equivalence of dynamic quantum circuits. Experiments show that embedding classical logic into conventional quantum circuits does not incur significant time and space burden.
Index Terms--Quantum circuits, quantum measurements, dynamic quantum circuits, equivalence checking
I. INTRODUCTION
The past five years have witnessed significant breakthroughs in building small-scale quantum devices and the largest quantum computers now have above 50 qubits. It is widely believed that near-term quantum devices will remain very limited in terms of the number of qubits they may have. Furthermore, these quantum devices also suffer from noises and short coherence time. This makes it highly difficult to implement large practical quantum circuits.
To fully exploit the power of quantum computing in these noisy intermediate-scale quantum (NISQ) [1] devices, several prominent approaches have been proposed to overcome the tight scale restriction. These include the quantum network approach [2], which connects multiple small-scale quantum computers, hybrid quantum/classical algorithms (see [3] for a survey), which join quantum computers with classical computers, and dynamical quantum circuits [4], [5], which try to build classical logic directly into quantum circuits.
Conventionally, a quantum circuit starts with a set of qubit initialisation, then an ordered sequence of qubit gates, and ends with or without measurements. As pointed out in [5], in these conventional quantum circuits, classical logic is not performed within the coherence time of the qubits.
*Email: {yuan.feng,sanjiang.li,mingsheng.ying}@uts.edu.au.

Dynamic quantum circuits are circuits in which measurements can be performed in the middle of the circuit and the measurement results are then used to control some quantum gates to be applied afterwards; early examples include quantum teleportation [6], [7], [8], [9] and quantum error correction (QEC) [10], [11], [12], [13]. For QEC, the syndrome of an encoded quantum state is detected through a set of measurements, and a series of quantum gates are then applied to the error quantum state according to the measurement results, and thus the quantum state is recovered.
The dynamic quantum circuit technique has also been used in extending the lifetime of quantum bits [14], resetting qubits [15], realising non-elementary quantum gates [4], [16], generating entanglement [17], [18], and embedding the classical real-time logic into quantum systems [5], [19]. Experiments in [5] show that dynamic circuits can indeed offer a `substantial and tangible advantage' on current noisy quantum hardware.
As dynamic quantum circuits will play a more important and central role in the near-future quantum computing, their verification becomes an imperative problem. Still lacking a formal definition of dynamic quantum circuits, it is not surprise that this problem is completely untouched. This paper provides a first such attempt and focuses on the equivalence checking of dynamic quantum circuits. Similar to the case of classical circuits, equivalence checking is essential to maintain the correctness of a quantum circuit. Moreover, as quantum circuits become larger and larger, they are more and more error-prone. It is necessary to provide automatic tools for checking the equivalence of different quantum circuit designs. For conventional quantum circuits, the decision diagram-based approach plays a prominent role, see, e.g., [20], [21], [22], [23]. For two quantum circuits, their equivalence is simply reduced to checking if the corresponding decision diagram representations are identical. However, due to the existence of classical control, it is not clear if all these decision diagram approaches can be directly applied to checking the equivalence of two dynamic quantum circuits.
In this paper, we first give a formal definition of dynamic quantum circuits and lay a rigorous foundation for our discussion by characterising their functionalities in terms of ensembles of linear operators. Then we formally define the notion of equivalence of dynamic quantum circuits and present two special cases, called m- and q-equivalences, which cover most, if not all, existing realistic dynamic quantum circuits.

The m-equivalence focuses on the measurement results while the q-equivalence cares only about the output quantum states. The quantum phase estimation (QPE) algorithm and QEC are, respectively, representative examples of the application scenarios of the two equivalence definitions. Then, we propose and implement two algorithms for checking the m- and qequivalences, based on the tensor decision diagram (TDD) [23]. As a data structure, TDD provides a compact and canonical representation for tensors and, in particular, quantum circuits. It can be used in many design automation tasks, e.g., simulation [23] and equivalence checking [24], for quantum circuits. In order to represent dynamic quantum circuits, what we need to do is to (a) represent measurements and classically controlled gates as tensors and construct their TDDs and (b) represent Boolean functions as TDDs. This is natural as TDDs are generalisations of binary decision diagrams [25] and tensors are, in a sense, generalisations of Boolean functions.
Our main contributions are summarised as follows:
1) A formal definition of dynamic quantum circuits and the characterisation of their functionalities in terms of ensembles of linear operators;
2) A formal definition of dynamic quantum circuit equivalence and two special cases, viz., m- and q-equivalences, covering most real-world application scenarios;
3) Implementation of two TDD-based algorithms for checking the m- and q-equivalences.
In the remainder of this paper, we first recall some basic concepts of quantum computing and tensor networks in Sec. II, and then present our formal definitions of dynamic quantum circuits and their equivalence in Sec. III. Algorithms for checking the m- and q-equivalences of dynamic quantum circuits are described in Sec. IV, followed by experiments and numerical results in Sec. V and conclusion in Sec. VI.

II. BACKGROUNDS
In this section, we recall some basic concepts from quantum computing and tensor networks. For quantum computing, we adopt notations from [26], [27]. Interested readers may consult [28], [29] for more details in tensor networks.

A. Quantum Circuits

A (conventional) quantum circuit is a series of quantum

gates, which are modelled by unitary matrices, acting on qubit

(quantum bit) variables. For each qubit q, we write Hq for its

state Hilbert space, which is two-dimensional. Using the Dirac

notation, a pure state of q is represented by | = 0|0 + 1|1 with complex numbers 0 and 1 satisfying |0|2 + |1|2 = 1. A sequence q = q1, ..., qn of distinct qubit variables

is called a quantum register. Its state Hilbert space is the tensor

product Hq =

n i=1

Hqi ,

which

is

2n-dimensional.

Thus,

an

n-qubit state can be also represented by an 2n-dimensional

vector | = (0, ..., 2n-1)T . A unitary transformation on q

is modelled by a 2n×2n unitary matrix U . This transformation

is also called an n-qubit quantum gate and denoted as G 

U [q]. We use the notation qv(G) to represent the qubits that

the gate is operated on. A quantum circuit can be formed

|0 H

·H·

|0 H ·

S H

|v

/ U U2

Fig. 1. Quantum circuit for 2-qubit Phase Estimation. The wires from top to bottom represent qubits q1, q2, and r respectively.

by a sequence of quantum gates: C  G1; . . . ; Gd, and the

quantum register of C is denoted qv(C) =

d i=1

qv(Gi).

To read out the information obtained by running a quantum

circuit, measurement are sometimes applied at the end of a cir-

cuit. Let q = q1, ..., qn be a quantum register. A measurement

on Hq is a collection {Mm}  L(Hq) of operators satisfying the normalisation condition: m Mm Mm = IHq , where IHq is the identity matrix in Hq and Mm (the index m stands for

the measurement outcome) are called measurement operators.

If the state of a quantum system is | immediately before

the measurement, then, for each outcome m, the probability

that m occurs is p(m) = | Mm Mm | and the state of the system after observing m is |m = Mm | / p(m).

The basic measurement used in this paper is the measure-

ment in the computational basis, which is formed by two

operators M0 = |0 0|, M1 = |1 1| for a single qubit.

If the qubit before the measurement was in state | =

0 |0 + 1 |1 , then the probability of obtaining outcome m  {0, 1} is p(m) = | Mm Mm | = |m|2, and the
state after measurement is Mm | / p(m) = |m .

Example 1. Depicted in Fig. 1 is a quantum circuit which implements the 2-qubit Phase Estimation [26], where

H = 1 2

1 1

1 -1

,

S =

1 0

0 -i

,

U is a unitary matrix, and |v is an eigenstate of U ; that is, U |v = e2i |v for some   [0, 1). Here the two measurements at the end are both in the computational basis, and the observed outcomes give the best two-bit approximation of  with high probability. In particular, if  = 0.12 is the binary representation of , then we will obtain 1 in q1 and 2 in q2 with probability 1.

B. Tensor Networks
A tensor is a multidimensional linear map associated with a set of indices. In this paper, we assume that each index takes value in {0, 1} and tensors take values from C, the field of complex numbers. That is, a tensor  with index set I = {x1, . . . , xn} is a mapping from {0, 1}I to C. It is also denoted by x1...xn or x. The value of  under an assignment {xi  ai, 1  i  n} is denoted by x1...xn (a1, . . . , an), or x(a), or even (a) for simplification. The number n of the indices of a tensor is called its rank. Scalars, 2-dimensional vectors, and 2 × 2 matrices are tensors with rank 0, 1, and 2, respectively.
The most important tensor operation is contraction. For any two tensors, their contraction is a tensor obtained by summing up over shared indices. For example, let x1,x2 and

Example 2. Fig. 2 shows the TDD of the H gate. In this diagram, dotted lines correspond to the 0-successors, and solid lines the 1-successors. The weight 1/ 2 on the incoming edge of the root is called the weight of the TDD. The dotted line of the root node (labelled with index x1) leads to the terminal node 1, meaning that when the index x1 takes value 0, the tensor will take value 1/ 2 × 1 = 1/ 2. All 1-weights are omitted in the diagram.

Fig. 2. TDD of the H gate.
x2,x3 be two tensors which share a common index x2. Then their contraction is a new tensor x1,x3 with x1,x3 (a1, a3) =
a2{0,1} x1,x2 (a1, a2) · x2,x3 (a2, a3). When both  and  are 2×2 matrices, contraction is exactly matrix multiplication.
Another useful tensor operation is slicing, which corresponds to the cofactor operation of Boolean functions. Let  be a rank n + 1 tensor. Then its slicing w.r.t. x = c for index x and c  {0, 1} is a rank n tensor. For example, let  be a tensor with index set I = {x, x1, . . . , xn}. The slicing of  w.r.t. x = c is a tensor |x=c over I = {x1, . . . , xn} given by |x=c(a) := (c, a), for any a  {0, 1}n. We call |x=0 and |x=1 the negative and positive slicing of  with respect to x, respectively.
Quantum states and quantum gates can both be represented by tensors. For example, the quantum state |0 can be represented by a rank 1 tensor x with x(0) = 1, x(1) = 0, and the H gate in Example 1 is represented by the rank 2 tensor with x1,x2 (00)= x1,x2 (01) = x1,x2 (10) = 1/ 2, x1,x2 (11) = -1/ 2. Clearly, each quantum circuit can be represented by the tensor obtained by contracting all its gates and input/output states.
A set of tensors can be connected to form a network. A tensor network is an undirected graph G = (V, E) with zero or multiple open edges, where each vertex v in V represents a tensor and each edge a common index associated with the two adjacent tensors. Tensors sharing the same index should be contracted, and this contraction leads to a rank m tensor if there are m open edges in the tensor network. In this way, quantum circuits are special tensor networks with every node representing a quantum gate or a quantum state.

A TDD tdd is determined by its weight tdd.weight and the root node tdd.root, every node in a TDD has an index node.index and, except the terminal node, two successors node.succ0 and node.succ1. Two TDDs tdd1 and tdd2 are identical iff tdd1.weight = tdd2.weight and tdd1.root = tdd2.root. As TDD provides canonical representation for conventional quantum circuits [23], to check if two such circuits are equivalent, we first calculate their TDDs and then compare their weights and nodes. If their TDDs are identical, then these two quantum circuits are equivalent.
III. DYNAMIC QUANTUM CIRCUITS
Informally speaking, a dynamic quantum circuit is a conventional circuit with measurements in the middle and the subsequent circuits can depend on the measurement outcomes [5]. To establish a rigorous foundation for verification of such circuits, we next give a formal definition, generalising the notion of quantum circuits with measurements in [27] by introducing more flexible control flows.
A. Dynamic Quantum Circuits
Definition 1 (Dynamic Quantum Circuits). A dynamic quantum circuit (dQC) is defined inductively as follows:
1) Each conventional quantum circuit C acting on qubits q is a dQC, and qv(C) = q;
2) Let M be the measurement in computational basis of Hr and, for each 0  i < 2t, Ci a dQC with rqv(Ci) = . Let f : {0, 1}|r|  {0, 1}t be a Boolean function. Then
C  if (2i · f (M [r]) = i  Ci) fi
is a dQC, and qv(C) = i qv(Ci). 3) If C1 and C2 are dQCs, then so is C1; C2 and
qv(C1; C2) = qv(C1)  qv(C1).

C. Tensor Decision Diagrams
The most commonly used equivalence checking methods for conventional quantum circuits are based on decision diagram [20], [21], [22], [23]. The current paper adopts the tensor decision diagrams (TDDs) proposed in [23] which can represent tensors and, thus, quantum circuits, in a canonical and compact way. Given a tensor , the root node r of its TDD  is labelled with an index of  and the two successors of r represent the negative (0-successor) and positive (1successor) slicing of  w.r.t. this index. The value of  under an assignment is obtained by multiplying the weights of the corresponding path in .

Intuitively, the construct in Clause 2 of the above definition denotes a dQC which first measures the qubits in r according to the measurement M . If f maps the measurement outcome to m, then Cm is chosen to be executed subsequently. Furthermore, Clause 3 describes sequential composition of dQCs.
Similar to conventional quantum circuits, a dynamic circuit is sometimes accompanied with a fixed input state for some of its qubits. Furthermore, a specific set of qubits will be discarded at the end and their quantum states are not included in the circuit output. To incorporate this situation, in the following we denote a dQC as a tuple
(C[q], | , i, o)

·H

·

|0

|0

H·

XZ

Fig. 3. Quantum circuit for Teleportation. The wires from top to bottom represent qubits q, q1, and q2 respectively.

·

·

|0 H · H

|0 H · S H

|v / U 2

U

Fig. 4. Dynamic quantum circuit for 2-qubit phase estimation. The wires with input |0 from left to right represent qubits q1 and q2, respectively, and the wire on the bottom denotes qubit r.

where q = qv(C), and i and o are both subsets of q indicating the (principal) input qubits and output qubits, respectively, and |  Hq\i is its fixed input state.
Definition 2 (Functionality of dQCs). The functionality of a dQC C, denoted [[C]], is an ensemble of linear operators on Hqv(C) defined inductively as follows:
1) If C is a conventional quantum circuit, then [[C]] = {U } where U is the unitary operator computed by C in the usual way;
2) Let C  if (2i · f (M [r]) = i  Ci) fi

and [[Ci]] = {Fi,k : k  Ji} for each i. Then [[C]] is an ensemble

|j r j|  Ff(j),k : 0  j < 2|r|, k  Jf(j) .

3) If C1 and C2 are dQCs with [[C1]] = {Ei : i  I} and [[C2]] = {Fj : j  J}, then

[[C1; C2]] = {FjEi : i  I, j  J }.

Finally, for dQCs where certain input qubits are with fixed
initial states and certain output qubits are discarded, the functionality is defined as follows. Let [[C]] = {Fj : j  J}. Then [[(C[q], | , i, o)]] is a super-operator from Hi to Ho such that for any   D(Hi),





[[(C[q], | , i, o)]]() = trq\o  Fj (| |  ) Fj .
jJ

Here trq\o is the partial trace operation which discards the q\o register and takes the reduced quantum state in the remaining part (the o register).

Example 3. Fig. 3 gives an example of dynamic quantum circuit. This circuit is the well known circuit for quantum teleportation which transfers a qubit by just sending two classical bits of information. Let the (conventional) circuit in the dashed box be C0[q, q1, q2], and D0  I, D1  X[q2], D2  Z[q2], and D3  ZX[q2]. Then the whole dynamic circuit can be written as (C[q, q1, q2], |00 q1,q2 , q, q2) where

C  C0; if (2i · M [q, q1] = i  Di) fi

and M =

3 i=0

|i

i| is the 2-qubit measurement in the com-

putational basis. It is easy to check that for any   D(Hq),

[[(C[q, q1, q2], |00 q1,q2 , q, q2)]]() = .

The circuit in Fig. 1 can also be transformed to a dynamic quantum circuit, since the controlled-S gate in the circuit do not change the measurement result of the first qubit. Thus, we can conduct the measurement before the controlled-S gate and replace it with a classically controlled gate.
Example 4. Fig. 4 shows the dynamic quantum circuit version of the phase estimation shown in Fig. 1. Let the (conventional) circuit in the left dashed box be C0[q1, r], the circuit in the right dashed box be D1[q2, r], and the circuit in the right dashed box without the S gate be D0[q2, r]. Then the whole dynamic circuit can be written as (C[q1, q2, r], |00 q1,q2 |v r , , q1q2) where
C  C0; if (2i · M [q1] = i  Di) fi
and M is the 1-qubit computational basis measurement. Note that there is no principal input for this circuit. It is easy to check that [[(C[q1, q2, r], |00 q1,q2 |v r , , q1q2)]] = |12 12| provided that U |v = e2i0.12 |v .
B. Equivalence of dQCs
With Definition 2, we can now define the equivalence of two dQCs as follows.
Definition 3 (Equivalence of dQCs). Two dynamic quantum circuits (C[q], | , i, o) and (C [q ], | , i, o) with the same principal input and output qubits are equivalent if their functionality are the same; that is,
[[(C[q], | , i, o)]] = [[(C [q ], | , i, o)]].
In this paper we are particularly concerned with the equivalence of two special classes of dynamic quantum circuits, which cover most real-world applications. In the first class, all input states are fixed (i.e. i = ) and all principal output qubits have been measured during execution of the circuit (the outcomes were or were not used in subsequent circuits). Typical examples include phase estimation in Example 4 and the period finding algorithm. Therefore, the output can be regarded as purely classical information; more precisely, it is merely a probability distribution over {0, 1, . . . , 2|o| - 1}. We call the equivalence of such dynamic circuits m-equivalence. It is not difficult to see that circuits depicted in Figs. 1 and 4 are m-equivalent.
In the second class of dynamic circuits, measurement outcomes during the execution process were used to control subsequent circuits, and do not constitute a part of the output of the entire circuit. Furthermore, the output quantum state is independent of the measurement outcomes. Typical examples

in this class include teleportation in Example 3 and error correction. We call the equivalence of such dynamic circuits q-equivalence. Again, it is easy to show that the circuit depicted in Fig. 3 is q-equivalent to the dynamic circuit (SWAP [q, q2], |0 q2 , q, q2) which transfers the state of q to q2 by employing the swap gate.
IV. TDD-BASED EQUIVALENCE CHECKING
In this section, we present our methods and algorithms for checking the m- and q-equivalence of dynamic quantum circuits. The idea is to represent each dynamic quantum circuit as a TDD and then compare if they are identical. To this end, we first consider how to represent measurements and classically controlled gates as tensors, and then consider how to represent Boolean functions as TDD. In this way, we shall have ensured that every element in a dynamic quantum circuit can be represented as a TDD. As a consequence, the TDD representation of the whole dynamic quantum circuit can be obtained by TDD contractions.
A. Tensor Representation of Measurements and Classically Controlled Gates
Note that measurement in the computational basis of a multi-qubit system can be decomposed into those of the 1qubit subsystems. Furthermore, the probability of measuring a qubit can be read out from the TDD representation of a quantum circuit. Therefore, there is no need to really operate a measurement if it is at the end of the circuit so will not be used to control other parts of the circuit.
More precisely, we regard each measurement as a rank 2 COPY tensor x,y = I provided that the measurement result is not used to control other parts of the circuit. Otherwise, we regard it as a rank 3 COPY tensor c,x,y, where (000) = (111) = 1 and it equals 0 in all other cases. In this representation, c captures the behaviour of the measurement result and x, y capture the behaviour of the quantum state. When the measurement result is c = 0, the tensor is exactly |c=0 = |0 0| = M0; and if c = 1, then it equals to |c=1 = |1 1| = M1.
A classically controlled-U gate can also be interpreted as a rank 3 tensor c,x ,y , where |c=0 = I and c=1 = U . That is, when the measurement result (i.e., the classical control bit) is 1 the quantum gate U will be applied, and, otherwise, it does nothing. Suppose M is the measurement whose outcomes are used to control U . Then the contraction of  with the tensor that represents M gives a rank 4 tensor |0 0|I +|1 1|U , which is equivalent to a quantum controlled-U gate.
The TDD of a dynamic quantum circuit can be obtained by contracting all tensors in the circuit.
Example 5. Consider the circuit in Fig. 4. The contraction of the first measurement with the classically controlled-S gate equals to the quantum controlled-S gate in Fig. 1 and the measurement in the end of the circuit is equivalent to an identity matrix. Thus, contracting all these tensors is just equivalent to contracting all tensors in Fig. 1 before measurement, which is also equivalent to contracting all

(a)

(b)

Fig. 5. The BDD (a) and TDD (b) representations of the logical AND gate.

tensors in Fig. 1 (including the measurement). This shows that these two dynamic quantum circuits are equivalent.

B. Representing Boolean Functions as TDDs
In a dynamic quantum circuit, measurement results are usually sent through a classical combinational circuit and the outputs are used to control the quantum system (see Clause 2 of Definition 1 for the formal description). Thus, we need also provide TDD representations for the classical logic.
A classical logic gate is in essence a Boolean function f : {0, 1}n  {0, 1}. To represent f as a tensor, we introduce a new index y to describe its output signal. Then, f can be described as a tensor  : {0, 1}n+1  {0, 1} with index set {x1, · · · , xn, y}, where x1,··· ,xn,y = 1 iff f (x1, · · · , xn) = y. We call this the tensor representation of f .
For example, consider the logic AN D gate whose Boolean function is f (x1, x2) = x1x2, which takes value 1 iff both x1 and x2 take values 1. Introducing a new index y to represent the output signal of this gate, f can be represented by a tensor x1x2y, where (000) = (010) = (100) = (111) = 1 since f (00) = f (01) = f (10) = 0 and f (11) = 1, and the tensor takes value 0 for all other combinations.
Let x1,··· ,xn,y1 and x1,··· ,xn,y2 be the tensor representations of two Boolean functions. Suppose y1 and y2 are used as input signals into another logic gate with tensor representation y1,y2,z. The contraction of the three tensors on y1, y2 is

x1,··· ,xn,z =

x1,··· ,xn,y1 · x1,··· ,xn,y2 · y1,y2,z .

y1 ,y2

Since, , ,  equal 1 iff x1, · · · , xn, y1, y2, z coincide with the input and output behaviour of the Boolean function, thus,

the contracted tensor x1,··· ,xn,z equals 1 iff x1, · · · , xn, z coincide with the input-output behaviour of connecting the

two outputs y1, y2 to the inputs of the last logic gate, i.e.,  is the tensor representation of the combined circuit.

According to this observation, the behaviour of a classical

circuit can thus be captured using the contraction of tensor

networks. In practice, the Boolean function is often given as

a binary decision diagram (BDD) [25]. In this case, it can be

easily transformed to a TDD by introducing two nodes which

are labelled with the output index of the classical circuit and

represent the tensors y(0) = 0, y(1) = 1 and y(1) = 0, y(0) = 1 respectively.

Example 6. Fig. 5 (a) is the BDD representation of the logic AN D gate. For this gate, introduce an index y to describe its

output, then redirect every edge linked to terminal node 0 to a node labelled with y with 0-successor 1 and 1-successor 0, and redirect every edges linked to terminal node 1 to a node labelled with y with 0-successor 0 and 1-successor 1, such as shown in Fig. 5 (b). Then this TDD captures the behaviour of the Boolean function and can be used to do further calculation.
In this way, the TDD representation of the classical circuit can be calculated from its Boolean function or transformed from its BDD representation. Contracting the TDDs of the classical parts and quantum parts of the dynamic circuit finally gives the TDD of the whole circuit.
C. Basic Algorithms
The direct method for checking the equivalence of two dynamic quantum circuits is to first calculate their TDD representations and then compare.
m-Equivalence. For m-equivalence, we have to extract the probabilities of observing different measurement outcomes from the TDD of the dynamic quantum circuit. Suppose the two TDDs to be compared are constructed using the same index order, and all output qubits are on the top of the TDDs. For a sequence s of measurement outcomes, let rs be the node reached from the root of the TDD following the path determined by s. The probability of s is exactly the norm of the sub-TDD rooted at rs weighted by the magnitude of the weight accumulated along the path. Here the norm of a TDD is obtained by contracting the TDD with its conjugate transpose, which has the same structure but with all corresponding weights conjugated. Finally, the circuits represented by the two TDDs are m-equivalent if, for each sequence s of measurement outcomes, the corresponding probabilities determined by s in these two TDDs are equal. Alg. 1 gives the detailed steps of this process.
q-Equivalence. For q-equivalence, we ignore probabilities of the measurement results and require that the state remained after measurements are independent of the measurement results. We need check if the output state is the same for all input states. If so, the two circuits are q-equivalent. Again, we assume that the measured qubits are on the top of the two TDDs and the two TDDs use the same index order. Alg. 2 gives the detailed procedure of this process. In the algorithm, we recursively visit the nodes of a TDD and add them to a set if the index of this node is not a measurement index. Since nodes in the TDD that represent the same tensor share the same address, thus, if the two circuits are q-equivalent, then, finally, the set will become a singleton. The algorithm uses this observation to determine the equivalence.
D. Optimisation
The equivalence of dynamic quantum circuits can be checked in a divide-and-conquer manner. Suppose the circuits are partitioned into corresponding sub-circuits. If two equivalent corresponding sub-circuits are found, we delete them from the circuits and check the remaining parts. The circuit partition scheme has been used in tensor network-based quantum circuit simulation [30] and TDD calculation [23]. In this paper, we

Algorithm 1 m eq(tdd1, tdd2) Require: tdd1, tdd2 are the TDDs of two dynamic circuits Ensure: return true iff the circuits represented by tdd1 and
tdd2 are m-equivalent if tdd1 = tdd2 then
return true end if x  min(tdd1.root.index, tdd2.root.index) if x is not a measurement index then
N1, N2  norm of tdd1, norm of tdd2 return N1 = N2 end if for i = 1, 2 do if tddi.root.index = x then
wi  tddi.weight Li  |wi| · tddi.root.succ0 Hi  |wi| · tddi.root.succ1 else Li, Hi  tddi end if end for return m eq(L1, L2)  m eq(H1, H2)
Algorithm 2 q eq(tdd1, tdd2) Require: tdd1, tdd2 are the TDDs of two dynamic circuits Ensure: return true iff the circuits represented by tdd1 and
tdd2 are q-equivalent nodes  get nodes(tdd1)  get nodes(tdd2) return |nodes| = 1
/ get nodes subroutine / Subroutine get nodes(tdd) r  tdd.root if r.index is a measurement index then
return get nodes(r.succ0)  get nodes(r.succ1) else
return {r} end if
consider a simple circuit partition scheme in which the circuit is partitioned qubit-by-qubit. More precisely, we first calculate the two tensors corresponding to the first qubit, compare them and then consider the second qubit and so on.
For m-equivalence, if the tensors corresponding to a same qubit of the two circuits are identical, they can be discarded. This is because, if such two tensors are identical, then the distributions of measuring this qubit are identical, and discarding them will not influence the equivalence of measuring other qubits. For q-equivalence, we should ensure that the tensors corresponding to every pair of qubits satisfy the requirement for q-equivalence, that is, the remaining tensor do not depend on the measurement indices, and the tensors of the two circuits are also identical. Then, such pairs of tensors can be discarded.
This qubit-by-qubit partition can help us reduce the number

of tensors needed to be considered at the same time. If there are still tensors that cannot be discarded, then they should be collected and contracted and checked using the basic algorithms. The effectiveness of this optimisation scheme has been confirmed in experiments (see Sec. V).
V. NUMERICAL RESULTS
In this section, we evaluate the effectiveness of our algorithms, with the aim to confirm that no significant time and space consumption will be incurred from embedding classical logic into conventional quantum circuits. More precisely, we compare our equivalence checking algorithms for dynamic quantum circuits with the TDD-based equivalence checking method for conventional quantum circuits. In addition, we also implemented the optimised algorithms based on qubit-by-qubit partition and compared them with the basic algorithms.
Benchmarks. We choose the dynamic quantum circuits of some commonly used algorithms such as quantum Fourier transform (QFT) [31], phase estimation (PE) [5] and circuits for error correction [32], teleportation [26] and state injection [4]. For each circuit, we compare them with the corresponding conventional quantum circuits given in [26]. We then check m-equivalence for the quantum Fourier transform and phase estimation circuits and check q-equivalence for the error correction, teleportation, and state injection circuits.
Implementation. In our experiments, for each pair of conventional quantum circuit C and its corresponding dynamic circuit C , we calculate the TDD representations of C and C and check their equivalence by comparing these two TDDs. To this end, we employ the TDD package provided in [23]. All the verification algorithms are implemented using Python3 and the experiments are conducted on a laptop with Intel i71065G7 CPU and 8GB RAM.
A. Comparison with EC of Conventional Quantum Circuits
Baseline. We compare the time and memory consumption of our verification algorithms with the TDD-based equivalence checking method proposed in [23] for conventional quantum circuits. Note that the latter cannot deal with dynamic quantum circuits. So we isolate from our algorithms the module for constructing TDD representations of dynamic circuits, and compare it with the module of the algorithm in [23] which constructs TDD representations of the corresponding conventional circuits. This comparison is fair, as both our algorithms and the algorithm in [23] need to construct two such TDDs and, once the TDDs are computed, the time/memory consumption of equivalence checking is negligible.
Results. Table I gives the experiment results, where columns `Basic Alg.' and `Alg. in [23]' record the time and memory consumption in generating TDD representations for a dynamic circuit by our basic algorithms and the corresponding conventional circuit by the compared algorithm, respectively. From the table we can see that our basic algorithms run as effectively as the equivalence checking algorithm for conventional quantum circuits, and the maximum number of the nodes of the TDDs constructed in the calculation process

TABLE I EXPERIMENT RESULTS

Benchmarks

Basic Alg.

Optimised Alg.

Alg. in [23]

tdd time(s) time(s) m nodes time(s) m nodes tdd time(s) nodes

qft 2

0.00

0.01 8

0.01 6

0.00

7

qft 3

0.01

0.03 15

0.01 10

0.01

15

qft 4

0.02

0.04 31

0.02 18

0.02

31

qft 5

0.05

0.08 63

0.03 34

0.03

63

qft 6

0.08

0.13 127

0.06 66

0.05

127

qft 7

0.16

0.27 255

0.10 130

0.09

255

qft 8

0.32

0.52 511

0.18 258

0.19

511

qft 9

0.51

0.87 1023

0.34 514

0.34

1023

qft 10

1.45

2.65 2047

0.72 1026

1.19

2047

meq

qft 11 qft 12 qft 13

2.79 7.71 13.74

4.59 4095

1.34 2050

1.79

11.21 8191

2.96 4098

3.46

19.83 16383 5.81 8194

6.03

4095 8191 16383

qft 14

28.01

39.80 32767 10.59 16386 11.66

32767

qft 15

53.76

75.08 65535 20.87 32770 21.18

65535

qft 16

119.31

158.57 131071 42.54 65538 39.00

131071

PE 2

0.01

0.03 20

0.01 11

0.01

20

PE 3

0.03

0.07 58

0.03 23

0.03

58

PE 4

0.16

0.28 180

0.06 47

0.09

180

PE 5

0.31

0.84 614

0.11 95

0.4

614

PE 6

1.32

2.41 2248

0.19 191

0.56

2248

PE 7

1.01

3.34 2664

0.32 383

1.80

762

Bitflip

0.01

0.06 108

0.03 50

0.03

108

qeq

Phaseflip Teleportation State inject S

0.01 0.00 0.00

0.10 108

0.06 51

0.06

0.03 20

0.02 14

0.01

0.01 10

0.01 8

0.01

108 20 10

State inject T 0.01

0.02 10

0.01 8

0.01

10

* The `nodes' column records the numbers of nodes in the TDDs of the circuit and the `m nodes' columns record the maximum numbers of nodes of the TDDs constructed in the calculation process. * The `tdd time' columns record the time for constructing the TDDs for the circuits, and the `time' columns record the time for running the algorithm (including TDD construction time).

is very close to the number of nodes of the final TDD representation of the circuit.
B. Comparison of the Optimised and Basic Algorithms
We also implemented two optimised algorithms for m- and q-equivalence checking, that is, the qubit-by-qubit equivalence checking method proposed in Sec. IV-D, and then compare them with the basic algorithms.
Results. Results of the optimised methods are recorded in column `Optimised Alg.' of Table I, where we can see that the optimised algorithms can significantly reduce the time/space consumption of the equivalence checking process. Consider the circuit qft 16 as an example. The basic algorithm takes 119 seconds with the maximal number of nodes appeared during the process being 131,071. In comparison, the optimised algorithm only takes 42.54 seconds with a maximum of 65,538 nodes. Thus, this optimisation method can really help in reducing the time and space consumption of the algorithms.
VI. CONCLUSION
Dynamic quantum circuits have been introduced as an effective method for executing quantum algorithms on near-term quantum devices. In this paper, we gave a formal definition of dynamic quantum circuits and proposed to characterise their functionalities in terms of ensembles of linear operators. Based on this novel semantics, two dynamic quantum circuits are equivalent if they have the same functionality. We further introduced two special kinds of equivalences for dynamic quantum circuits and implemented two equivalence checking algorithms based on the tensor decision diagram representations of dynamic quantum circuits. Experiments show that these algorithms are as efficient as the corresponding algorithms for conventional quantum circuits.

In the future, we will explore methods like employing an op-
timal contraction order to further improve the performance of
our equivalence checking algorithms. Another open question is
to devise effective algorithms for checking the equivalence of
general dynamic quantum circuits, which requires calculating
partial traces and thus advanced tensor network contraction
techniques like that introduced in [33] may help.
REFERENCES
[1] J. Preskill, "Quantum computing in the NISQ era and beyond," Quantum, vol. 2, p. 79, 2018.
[2] S. Wehner, D. Elkouss, and R. Hanson, "Quantum internet: A vision for the road ahead," Science, vol. 362, no. 6412, 2018.
[3] S. Endo, Z. Cai, S. C. Benjamin, and X. Yuan, "Hybrid quantumclassical algorithms and quantum error mitigation," Journal of the Physical Society of Japan, vol. 90, no. 3, p. 032001, 2021.
[4] C. A. Ryan, B. R. Johnson, D. Riste`, B. Donovan, and T. A. Ohki, "Hardware for dynamic quantum computing," Review of Scientific Instruments, vol. 88, no. 10, p. 104703, 2017.
[5] A. D. Corcoles, M. Takita, K. Inoue, S. Lekuch, Z. K. Minev, J. M. Chow, and J. M. Gambetta, "Exploiting dynamic quantum circuits in a quantum algorithm with superconducting qubits," arXiv:2102.01682, 2021.
[6] M. Barrett, J. Chiaverini, T. Schaetz, J. Britton, W. Itano, J. Jost, E. Knill, C. Langer, D. Leibfried, R. Ozeri et al., "Deterministic quantum teleportation of atomic qubits," Nature, vol. 429, no. 6993, pp. 737­739, 2004.
[7] M. Riebe, H. Ha¨ffner, C. Roos, W. Ha¨nsel, J. Benhelm, G. Lancaster, T. Ko¨rber, C. Becher, F. Schmidt-Kaler, D. James et al., "Deterministic quantum teleportation with atoms," Nature, vol. 429, no. 6993, pp. 734­ 737, 2004.
[8] L. Steffen, Y. Salathe, M. Oppliger, P. Kurpiers, M. Baur, C. Lang, C. Eichler, G. Puebla-Hellmann, A. Fedorov, and A. Wallraff, "Deterministic quantum teleportation with feed-forward in a solid state system," Nature, vol. 500, no. 7462, pp. 319­322, 2013.
[9] K. S. Chou, J. Z. Blumoff, C. S. Wang, P. C. Reinhold, C. J. Axline, Y. Y. Gao, L. Frunzio, M. Devoret, L. Jiang, and R. Schoelkopf, "Deterministic teleportation of a quantum gate between two logical qubits," Nature, vol. 561, no. 7723, pp. 368­373, 2018.
[10] P. Reinhold, S. Rosenblum, W.-L. Ma, L. Frunzio, L. Jiang, and R. J. Schoelkopf, "Error-corrected gates on an encoded qubit," Nature Physics, vol. 16, no. 8, pp. 822­826, 2020.
[11] Z. K. Minev, S. O. Mundhada, S. Shankar, P. Reinhold, R. Gutie´rrezJa´uregui, R. J. Schoelkopf, M. Mirrahimi, H. J. Carmichael, and M. H. Devoret, "To catch and reverse a quantum jump mid-flight," Nature, vol. 570, no. 7760, pp. 200­204, 2019.
[12] D. Gottesman, "An introduction to quantum error correction and faulttolerant quantum computation," in Quantum information science and its contributions to mathematics, Proceedings of Symposia in Applied Mathematics, vol. 68, 2010, pp. 13­58.
[13] A. Paler, I. Polian, K. Nemoto, and S. J. Devitt, "Fault-tolerant, highlevel quantum circuits: form, compilation and description," Quantum Science and Technology, vol. 2, no. 2, p. 025003, 2017.
[14] N. Ofek, A. Petrenko, R. Heeres, P. Reinhold, Z. Leghtas, B. Vlastakis, Y. Liu, L. Frunzio, S. Girvin, L. Jiang et al., "Extending the lifetime of a quantum bit with error correction in superconducting circuits," Nature, vol. 536, no. 7617, pp. 441­445, 2016.
[15] D. Riste`, C. Bultink, K. W. Lehnert, and L. DiCarlo, "Feedback control of a solid-state qubit using high-fidelity projective measurement," Physical Review Letters, vol. 109, no. 24, p. 240502, 2012.
[16] S. Bravyi, D. Browne, P. Calpin, E. Campbell, D. Gosset, and M. Howard, "Simulation of quantum circuits by low-rank stabilizer decompositions," Quantum, vol. 3, p. 181, 2019.
[17] D. Riste, M. Dukalski, C. Watson, G. De Lange, M. Tiggelman, Y. M. Blanter, K. W. Lehnert, R. Schouten, and L. DiCarlo, "Deterministic entanglement of superconducting qubits by parity measurement and feedback," Nature, vol. 502, no. 7471, pp. 350­354, 2013.
[18] O.-P. Saira, J. Groen, J. Cramer, M. Meretska, G. De Lange, and L. DiCarlo, "Entanglement genesis by ancilla-based parity measurement in 2d circuit qed," Physical Review Letters, vol. 112, no. 7, p. 070502, 2014.

[19] C. K. Andersen, A. Remm, S. Lazar, S. Krinner, J. Heinsoo, J.C. Besse, M. Gabureac, A. Wallraff, and C. Eichler, "Entanglement stabilization using ancilla-based parity detection and real-time feedback in superconducting circuits," npj Quantum Information, vol. 5, no. 1, pp. 1­7, 2019.
[20] P. Niemann, R. Wille, D. M. Miller, M. A. Thornton, and R. Drechsler, "Qmdds: Efficient quantum function representation and manipulation," IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 35, no. 1, pp. 86­99, 2015.
[21] G. F. Viamontes, I. L. Markov, and J. P. Hayes, "Checking equivalence of quantum circuits and states," in 2007 IEEE/ACM International Conference on Computer-Aided Design. IEEE, 2007, pp. 69­74.
[22] L. Burgholzer and R. Wille, "Improved dd-based equivalence checking of quantum circuits," in 2020 25th Asia and South Pacific Design Automation Conference (ASP-DAC). IEEE, 2020, pp. 127­132.
[23] X. Hong, X. Zhou, S. Li, Y. Feng, and M. Ying, "A tensor network based decision diagram for representation of quantum circuits," arXiv:2009.02618, 2020.
[24] X. Hong, M. Ying, Y. Feng, X. Zhou, and S. Li, "Approximate equivalence checking of noisy quantum circuits," in 58th Design Automation Conference (DAC). ACM, 2021.
[25] R. E. Bryant, "Symbolic boolean manipulation with ordered binarydecision diagrams," ACM Computing Surveys (CSUR), vol. 24, no. 3, pp. 293­318, 1992.
[26] M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information. Cambridge University Press, 2000.
[27] M. Ying, Foundations of Quantum Programming. Morgan Kaufmann, 2016.
[28] I. L. Markov and Y. Shi, "Simulating quantum computation by contracting tensor networks," SIAM Journal on Computing, vol. 38, no. 3, pp. 963­981, 2008.
[29] J. Biamonte, "Lectures on quantum tensor networks," arXiv:1912.10049, 2019.
[30] E. Pednault, J. A. Gunnels, G. Nannicini, L. Horesh, T. Magerlein, E. Solomonik, and R. Wisnieff, "Breaking the 49-qubit barrier in the simulation of quantum circuits," arXiv:1710.05867, vol. 15, 2017.
[31] R. B. Griffiths and C.-S. Niu, "Semiclassical fourier transform for quantum computation," Physical Review Letters, vol. 76, no. 17, p. 3228, 1996.
[32] S. J. Devitt, W. J. Munro, and K. Nemoto, "Quantum error correction for beginners," Reports on Progress in Physics, vol. 76, no. 7, p. 076001, 2013.
[33] F. Pan, P. Zhou, S. Li, and P. Zhang, "Contracting arbitrary tensor networks: General approximate algorithm and applications in graphical models and quantum circuit simulations," Physical Review Letters, vol. 125, p. 060503, Aug 2020.

