arXiv:2106.00765v2 [quant-ph] 3 Jun 2021

Connectivity constrains quantum codes
Nouédyn Baspin 1 and Anirudh Krishna 2
1Université de Sherbrooke, Sherbrooke, Québec, Canada J1K 2R1 2Stanford University, Stanford, CA, USA, 94305
Abstract Quantum low-density parity-check (LDPC) codes are an important class of quantum error correcting codes. In such codes, each qubit only affects a constant number of syndrome bits, and each syndrome bit only relies on some constant number of qubits. Constructing quantum LDPC codes is challenging. It is an open problem to understand if there exist good quantum LDPC codes, i.e. with constant rate and relative distance. Furthermore, techniques to process encoded information in quantum LDPC codes are poorly understood. Making progress on this problem is essential for using quantum LDPC codes in scalable quantum computers. We present a unified way to address these problems. Our main results are a) a bound on the distance, b) a bound on the code dimension and c) limitations on certain fault-tolerant gates that can be applied to quantum LDPC codes. All three of these bounds are cast as a function of the graph separator of the connectivity graph representation of the quantum code. We find that unless the connectivity graph contains an expander, the code is severely limited. This implies a necessary, but not sufficient, condition to construct good codes. This is the first bound that studies the limitations of quantum LDPC codes that does not rely on geometric locality. As an application, we present limitations of quantum LDPC codes associated with local graphs in D-dimensional hyperbolic space.
Dedicated to the memory of David Poulin
nouedyn.baspin@usherbrooke.ca anirudhk@stanford.edu

1 Introduction
A fault-tolerant quantum circuit will require error correction at regular intervals to avoid the build up of errors [ABO97, AGP05, Kit97, KLZ98, Sho96]. The error correcting code used is assessed using various figures-of-merit. Of these, the two most fundamental are the code dimension k and the distance d. The code dimension k is the number of qubits that can be encoded in the code. The distance d measures the number of single-qubit errors required to irreparably corrupt encoded information. The choice of code also affects how encoded information can be processed in a quantum circuit. We want to design a code in a way that protects encoded information from unavoidable interactions with the environment which might corrupt the code; yet at the same time, we want the code to be amenable to interactions that facilitate computation. Understanding the optimal tradeoff between these three figures-of-merit is a fundamental question in quantum error correction [Got96, AL99, SK10, KL97, EOT20]. In this paper, we study these tradeoffs in the context of quantum low-density parity-check (LDPC) codes.
A quantum LDPC code is characterized by how syndrome information is gathered. Unlike the classical setting, we cannot directly read quantum codewords. The state of a register of n qubits could be in some delicate superposition which measurements can upset. The only information we can use for diagnosis is the syndrome, itself just a binary string. Each bit of the syndrome is obtained by measuring a set of qubits in a manner prescribed by the error correcting code. These specific measurements are designed to preserve the encoded information and are called stabilizer measurements. Each bit of the syndrome is obtained by measuring the corresponding stabilizer generator. Together, the stabilizer generators generate a stabilizer group, a set of measurements that does not destroy encoded quantum information. In a quantum LDPC code, we need only measure a constant number of qubits for each bit of the syndrome. Furthermore, each qubit only affects the value of at most a constant number of syndrome bits. This property is expected to simplify the process of obtaining the syndrome which, in addition to the code dimension and distance, is also a criterion for picking a quantum error correcting code. Indeed, quantum LDPC codes may have benefits for constructing scalable fault-tolerant quantum circuits [KP13, Got14, FGL18]. In sharp contrast to the classical setting, it is unknown whether good quantum LDPC codes exist, i.e. whether quantum LDPC code families exist where k and d scale linearly with n.
For ease of implementation, we may wish to construct quantum LDPC codes that are spatially local in 2 dimensions. A local quantum code refers to a code family embedded in RD in which the qubits involved in a particular syndrome bit are contained in a ball of diameter w, where w is some constant, independent of the size of the code. Unfortunately, locality is a fundamental problem in the design of quantum error correcting codes. Bravyi and Terhal [BT09] proved that any local code in RD obeys d = O(n1-1/D). This bounds the distance of a D-dimensional local code away from n. Subsequently, Bravyi, Poulin and Terhal [BPT10] proved that any local code in RD obeys kd2/(D-1) = O(n). In particular, 2-dimensional codes are very restricted: their distance d can scale at best as ( n), implying that the code dimension is constant. The famous surface code (and the closely related color code and variants) saturates this bound up to constant factors [Kit03, BK98, BMD06, Bom10].
Constructive approaches that eschew locality to build quantum LDPC codes still face difficulties. There exist codes that achieve a code dimension scaling linearly in the block size but with limited distance [TZ14, BH14, KP12, ZP19, FML02, GL14, LL17, LAV20]. It proved to be very challenging to achieve a distance scaling better much better than ( n) [FML02]. In the latter half of 2020, a series of works heralded one breakthrough after another [KKL14, EKZ20, KT20, HHO20, BE20]. The current record is held by a construction due to Panteleev and Kalachev, who demonstrated the existence of codes with code dimension k = (log(n)) and distance scaling as (n/ log(n)) [PK20].
In contrast to these constructive approaches, we take steps to extend the Bravyi-Poulin-Terhal bounds to general LDPC codes that are not constrained to be local. Such a top-down approach to bound the properties of quantum LDPC codes might serve to answer why finding constructive approaches has been difficult.
In addition to these concerns, we need ways to process encoded information fault tolerantly. This means
1

that if a subroutine within a circuit fails, it only corrupts the limited set of qubits it acts on. We do not want errors in one location to spread to errors in another, thereby overwhelming the error correcting code. Transversal gates are one way to implement a fault-tolerant gate [NC02]. In its simplest form, transversal gates refer to gates acting independently on each physical qubit in the code. Note that this is trivial in the classical setting: to implement the logical NOT on a 3-bit repetition code, we need just flip each bit of the code. However, this is considerably more difficult in the quantum setting as the set of transformations even on just a single qubit corresponds to SU (2), a dense group. Bravyi and Koenig [BK13] proved that transversal gates on D-dimensional local quantum error correcting codes are limited. Specifically, transversal gates on 2-dimensional local codes can at best implement transformations of a finite group of transformations referred to as the Clifford group. This finite group of transformations is insufficient to implement all gates required to run interesting algorithms and can even be simulated efficiently on a classical computer [AG04]. Subsequently Pastawski and Yoshida showed that there is a relation between the distance of D-dimensional local codes and the gates they support [PY15]. To state their result in a non-technical way, they proved that implementing transformations outside the finite group would come at the cost of the distance of the code. Recent work by Burton and Browne [BB20] extends this result and has shown that a specific class of finite rate quantum LDPC codes (that are not constrained by locality) has a structure where transversal gates can still only implement Clifford transformations on encoded information. This suggests that locality itself might not be the constraint that limits transversal gates.

1.1 Summary of results

We prove that the connectivity of a quantum LDPC code restricts our ability to encode, protect and process information. This is the first bound that studies the limitations of quantum LDPC codes that does not rely on locality. We make use of the intimate relation between quantum LDPC codes and the connectivity graph representation.

Given a code, the connectivity graph is a graph with vertices corresponding to the qubits of the code, and an edge between qubits if and only if they are both involved in a syndrome bit, or equivalently, if they are both in the support of a stabilizer generator. Such a construction has been used before, see for example work by Kovalev and Pryadko [KP13] or by Gottesman [Got14] (where it is called the adjacency graph).

We demonstrate that the parameters of the quantum code are upper bounded by the properties of

the connectivity graph. This is quantified via the graph separator. A balanced (vertex) separator of

a graph G = (V, E) is a subset S  V of vertices that needs to be removed from a graph to partition

it into two disconnected subgraphs which do not contain more than half the total number of vertices

of G. Essential to our results is the notion of a graph that has consistently poor connectivity: we can

find small separators, not only for G, but also for any of its subsets. We say G is s-separable if every

subgraph G  G of size |G | = r has a separator S such that |S |  s(r). The separator splits G into

two sets A and B such that neither is larger than r/2. Finally, there are no edges between A and B.

Henceforth we will use shorthand and say that G is s-separable if this holds.





As an example, the n × n grid graph has a separator of size n. We just have to remove a single

column of vertices from the middle to cleave the graph in two. In fact, any planar graph is poorly

connected; the famous Lipton-Tarjan Theorem states that any planar graph with n vertices has a separator of size O( n) [LT79]. Since a subset of a planar graph is also planar, then a planar graph is O( r)-separable. On the other hand, expander graphs are tightly connected and have separators

of size (n).

We present three main results, all of which bound the properties of quantum codes based on separators.
For simplicity, we state all bounds here for a family of codes C with associated connectivity graphs G where G is s-separable such that s(r) = O(rc) for 0 < c  1.

First, we show that the distance of quantum LDPC codes is upper bounded by the size of the separator. To prove this result, we introduce techniques to relate the properties of a quantum code with the tree

2

decomposition of the connectivity graph, which in turn imply bounds on the distance.
Theorem 1 (Informal distance bound). Let C = {Cn} be a family of n, k, d quantum LDPC codes with corresponding connectivity graphs G = {Gn}. If G is s-separable for s(r) = O(rc) where 0 < c  1, then
d = O(nc) .

This result shows that a code cannot be significantly improved by adding a few long-range generators. Consider a code family C whose connectivity graphs G = {Gn} are known to be s-separable. To each graph Gn  G we augment edges Eaug = Eaug(n) which depends on n. We call G the graph family consisting of these augmented graphs. By removing the endpoints of the edges in Eaug, it can be noted that any Gn  G is s -separable for s (r) = s(r) + 2|Eaug|. It follows from Theorem 1 that d = O(s (n)) = O(s(n) + 2|Eaug|). As an immediate consequence--if s(r) = o(r), and G therefore yields a code family with vanishing relative distance--G cannot yield a good code family unless |Eaug| = (n).
Second, we obtain a bound on the code dimension.
Theorem 2 (Informal dimension bound). Let C = {Cn} be a family of n, k, d quantum codes with corresponding connectivity graphs G = {Gn}. Suppose G is s-separable and s(r) = O(rc) for c  (0, 1). We have the bound
k = O(d2(c-1)n) .

This implies that the only way to achieve a constant rate and growing distance is if G is very connected: s(r)  r. This requirement of connectedness can be made formal through Lemma 16: if s(r)  r, then the connectivity graphs of this code family contain expanders as subgraphs. In addition to being an important fundamental question, this question is also relevant in the context of faulttolerance constructions with quantum LDPC codes. In his construction that demonstrates constant qubit overhead, Gottesman [Got14] requires that the code dimension scale linearly and distance scale polynomially in n. Having mentioned this, we discuss some limitations of our result. First, we note that we do not know if the bound on the distance is tight. Owing to this, expander subgraphs are only a necessary condition to construct good codes. Observe that for the hypergraph product codes d = O( n), whereas k = O(n) is achievable. Furthermore, while we can rederive the Bravyi-Terhal bounds for D-dimensional local codes, we cannot rederive the Bravyi-Poulin-Terhal bound. As stated above, the separator for planar graphs is known to scale as O( n). Looking at Theorems 1 and 2 above and letting c = 1/2, we observe that kd2 =O(n3/2). This may be because graphs local in 2D are not the only graphs with separators of size O( n), as bounded separators do not guarantee that the graph be embeddable in low-dimensional Euclidean space. For example, as stated in section 4, it can be shown that this is the case for graphs local in 3D hyperbolic space. Although the main parts of our work only deal with stabilizer codes (the quantum analogue of linear codes in the classical setting), we show in appendix C that both these bounds extend to a much larger class of codes defined by commuting projectors.
Our last theorem shows that transversal gates are restricted in the types of transformations they can implement on a quantum code.

Theorem 3 (Informal bound on transversal gates). Let C = {Cn} be a family of n, k, d quantum

codes with corresponding connectivity graphs G = {Gn}. Suppose G is s-separable where for c  (0, 1),

s(r) = O(rc) and d = (n), then transversal operations are limited to the

1- (1-c)

level of the Clifford

hierarchy.

These results follow from a decomposition of arbitrary connectivity graphs into a union of correctable regions, i.e. regions which if erased, would still allow recovery. As a result, Theorems 2 and 3 are not limited to LDPC codes.

3

The rest of the paper proves these results and explores their consequences. In section 2, we establish

background required to state our result. We define quantum stabilizer codes in 2.1, some important

properties and their representations in terms of graphs. In 2.2, we define the notions of separability

and the closely related notion of treewidth. These are metrics of connectivity in terms of which our

main theorems are stated. In section 3 we formally state and prove our main results. First section 3.1

focuses on Theorem 1 on the distance. Then section 3.2 focuses on Theorem 2 on the code dimension.

Lastly, section 3.3 focuses on Theorem 3 on transversal gates. In section 4, we consider codes

locally embeddable in D-dimensional hyperbolic space HD. The motivation for considering codes

embeddable in a hyperbolic manifold of even dimension is that such codes would have constant rate

[BT16, LL17, GL14, Has13]. We use recent results by Kisfaludi-Bak [KB20] who showed that graphs

locally embedded in D-dimensional hyperbolic space HD have bounded separators. For D  3, we

will

find

that

the

distance

of

a

D-dimensional

hyperbolic

code

is

upper

bounded

by

O(n1-

1 D-1

).

This

can be considered an extension of the Bravyi-Terhal bound for local codes in HD. It is reminiscent of the bound on the distance of local codes in RD-1. To be clear, we only consider codes locally embeddable in HD; codes obtained from manifolds say as the quotient of an infinite tiling would not

be part of such a construction. This is because the process of forming the quotient could change the

size of the separator considerably. As a result, codes that can be embedded locally on a surface of

genus g will require another approach. Delfosse has shown that a systolic inequality of Gromov can be

used to generalize the Bravyi-Poulin-Terhal bound to 2-dimensional surface codes. It was shown that

quantum surface and color codes embedded in such manifolds must obey kd2 = O(n log(k)2) [Del13].

This section concludes by discussing this idea and provides a generalization of Delfosse's bound for

2-dimensional hyperbolic codes. Specifically, we consider codes embedded in surfaces of genus g. The

work of Dujmovi, Eppstein in a surface of genus g have

and Wood separators

[oDf EsiWze1O5](degmno).nsTtrhaitseidmtphlaietscroedsetrsictthiaotnsaroenlotchaellpyeerfmorbmedadnecde

of local codes on surfaces of genus g. To compare Delfosse's bound to our bound, suppose the code

obtained from a 2-dimensional hyperbolic manifold has genus g  k. In that case, we find that

Delfosse's bound is tighter as it reads d = O(log(g) n/g). However, our bound applies to any local

code.

2 Background and Notation
2.1 Stabilizer codes
In our paper, we focus on stabilizer codes on n qubits. A qubit is associated with the complex Euclidean space C2 and n qubits with (C2)n. Let P denote the n-qubit Pauli group and for any two operators P, Q  P, let [P, Q] = PQ - QP denote their commutator. An n, k quantum code C is a 2k-dimensional subspace of the n-qubit space (C2)n. It is specified by the stabilizer group S, an Abelian subgroup of the n-qubit Pauli group that does not contain -I. The code space C is the set of states left invariant under the action of the stabilizer group, i.e. C = {| : S | = | S  S}. S is generated by (n - k) independent generators. We may consider codes with an over-complete set of stabilizers generators of size m  n - k. Technically not all of these elements are independent but we shall call them generators for convenience when no confusion may arise.
Let L = {L : [L, S] = 0, S  S} denote the logical operators: the group of Pauli operators that commute with S and preserve C. The action of the logical operators on the code space C can be classified by the quotient group L/S = {[L] : L  L} where we let [L] denote the coset LS = {LS : S  S}. If L, L belong to the same coset then their action on C is equivalent : LL  S. We write L  L when they belong to the same class.
The code dimension k corresponds to the number of nontrivial, independent elements of L/S. The distance d = minLL\S | supp(L)| is a metric to estimate the closeness of codewords. To implement a universal set of gates, we require a finite set of gates that can approximate any unitary on n qubits to the desired level of precision. Typically, this set is chosen to be the set of gates in the
4

Clifford group together with one additional gate that is not in the Clifford group. The Clifford group is a finite group and corresponds to the automorphism group of the Pauli group.

The Clifford hierarchy is a generalization of the Clifford group and plays an important role in the theory of quantum error correction [GC99]. The -th level of the Clifford hierarchy, denoted K( ), is defined recursively. The 1st level of the Clifford hierarchy, denoted K(1), is the Pauli group. For  2,
the hierarchy is defined as

K( ) = {W : W PW   K( -1) P  Pn} .

(1)

It can be seen from this definition that K(2) is the Clifford group.
Let W be a unitary gate and let W denote the encoded version of W . In other words, if ES : Ck  Cn is the encoding operation for the quantum error correcting code defined by the stabilizer group S, then W ES(| ) = ES(W | ). We say that W can be implemented in a transversal manner if W = W1  ...  Wn for some single-qubit gates {Wi}i.
We recall some definitions from [BT09]. Let V = [n] index the qubits and Q(V ), the n-qubit space associated with C2 n. For any subset U  V , let Q(U )  Q(V ) denote the |U |-qubit space with the corresponding indices. For ease of notation, we shall use U to also refer to Q(U ) where no confusion may arise. Let U = [n] \ U be the complement of U . For any Pauli operator L we write its support supp(L)  V the set of qubits on which L acts nontrivially. Central to everything that follows is the notion of correctability of sets of qubits.

Definition 4 (Correctable set). For U  V , U is correctable if there exists a recovery map R : U  V such that for any code state C  C, R(TrU (C)) = C.

Acting on the region U alone cannot alter the information contained in the entire code in a meaningful way. This idea is formalized by Lemma 5 known as the Cleaning lemma:
Lemma 5 (Cleaning Lemma). Suppose the code C has at least one nontrivial logical operator. For any subset U  V ,

1. there is a non-trivial L  L that is supported entirely in U , or
2. for all [L]  L/S, there is a representative in L  [L] such that L acts trivially on U . One has L L = i Si, with {Si} a set of generators and the support of each Si overlaps with U .
As a consequence, correctable regions turn out to have a rather interesting property. If the support of a logical operator L intersects a correctable region U , then it can be cleaned out of U . This is illustrated in fig. 1.

Figure 1: Visualizing the Cleaning Lemma: In this schematic, V is the dark region of all qubits and U is the light region within. The support of logical operators is depicted using a dashed line. Either the region U contains logical operators as in (a) or all logical operators can be made to run outside it as in (b).
Intuitively we expect that subsets of qubits that are sufficiently far away from one another can be corrected independently.
5

Definition 6 (Boundary). Let C be a stabilizer code and U  V . We define the outer and inner boundaries respectively as follows:
1. Outer boundary: +U is the set of all qubits corresponding to v  U such that there exists at least one stabilizer generator S and u  U satisfying v, u  supp(S).
2. Inner boundary: -U is +U , the outer boundary of the complement of U .
It follows from the Cleaning Lemma that if U is correctable, then any logical L  L can be cleaned to U . The converse holds true.
Definition 7 (Decoupled subsets). Disjoint subsets {Ui}, Ui  V are said to be decoupled if no generator overlaps with more than one Ui, i.e. i, j = i,
+Ui  Uj =  .
Lemma 8 (Union Lemma). Let {Ui}i be decoupled sets of qubits and write T = iUi. If L  L such that supp(L)  T , then L can be decomposed as a product of logicals, each supported entirely on one subset Ui: L = iLUi, supp(LUi)  Ui, LUi  L. If each Ui is correctable, it follows that T is correctable.
Proof. Let Ui be one cluster of the decoupled set and LUi the restriction of L on Ui. LUi has to commute with any generators whose overlap with L is only contained within Ui. Due to the decoupling condition, this is the case for all generators having support on Ui. Since LUi commutes with all generators having support on Ui, we conclude LUi  L. However, every Ui is correctable, therefore LUi = IUi, i.e. they act as identity on the qubits Ui.
Lemma 9 (Expansion Lemma). Given correctable regions U , T such that U  +T , then T  U is correctable.
Proof. Set W  U  T . Since U is correctable, any logical operator L whose support intersects with U can be cleaned to T  W , and we let L denote the cleaned operator. This implies that L = LT  LW . Note that no check acts on both T and W as +T  U which means that LT , by itself, is a bonafide logical operator. Since T is correctable, we have LT = I. Therefore T  U is correctable.
In addition to the algebraic view as presented above, quantum codes can also be represented graphically. We shall use the following object, called a connectivity graph representation:
Definition 10 (Connectivity graph). The connectivity graph of a code C written G = G(C) = (V, E) is defined so that:
1. V = [n], each vertex is associated with a qubit, and
2. (u, v)  E if and only if there exists a generator S  S such that u, v  supp(S).
Further, + and - extend naturally to G(C)
Remarks: The Tanner graph is a common graphical representation of LDPC codes. However our results can be more naturally expressed through the connectivity graph. We highlight that the connectivity graph, unlike the Tanner graph, is not unique. Indeed, several quantum codes could correspond to the same structure. However, this weaker notion suffices to obtain the desired bounds on the distance and code dimension. Importantly this graph dispenses with Pauli labels between the stabilizers and qubits and no longer carries information concerning the commutation relations. Taking this information into account could be important in restricting the types of graphs that emerge; we do not do so here. This representation was also used for different purposes, see for example [KP13] or [Got14].
6

The following observations will be useful. Consider two disjoint subsets U1, U2  V . If there is no edge between U1 and U2 then they are decoupled. Equivalently, the distance on the connectivity graph between these two sets is at least two. In other words, +U1 is the neighborhood of U1 in the connectivity graph. If the quantum code family is LDPC, then the connectivity graph has bounded degree. Suppose C = {Cn} is a code family with qubit degree upper bounded by V and stabilizer degree bounded by C. Then each vertex in the connectivity graph is connected to at most V (C - 1) other qubits. We expect the degree to be less than this because the stabilizer generators can overlap, and likely will, to obey commutation relations. Example: As an example, consider a portion of the surface code as shown in fig. 2 below. The surface code is a code defined on the 2-dimensional square grid. The qubits are identified with the edges of the lattice, the X stabilizers with the vertices and the Z stabilizers with the faces. An X (Z) stabilizer acts on a qubit if the vertex (face) corresponding to the stabilizer is adjacent to the edge corresponding to the qubit. The corresponding connectivity graph has vertices on all edges of the grid in addition to diagonal connections.
Figure 2: (a) Cellular representation of the surface code. Z-generators are associated with the faces, qubits are on the edges, and X-generator are on the vertices. (b) Tanner graph of the surface code. Z(X)-checks are the blue (red) squares, and qubits are the grey dots. When a generator involves a qubits, it is represented by an edge. (c) Connectivity graph of the surface code. The grey dots are still the qubits, but the generators are no longer represented. Instead, qubits share an edge when they are touched by the same separator. The blue and red edges are induced by the Z and X generators highlighted in (a) and (b).
2.2 Separator and treewidth
In this section, we present two different, yet intimately related, metrics to characterize the connectivity of a graphs. The first is the separability which measures the difficulty of cleaving the graph into two or more disjoint subgraphs none of which are too large. The second is the treewidth obtained from the tree decomposition of a graph. The tree decomposition of a graph G is a tree whose nodes are clusters of vertices of G (this is defined in detail below). The width of the tree is the minimum size of its nodes and measures the connectivity of the graph. In the following sections, we cast our bounds on quantum codes in terms of these quantities. Definition 11. Let G = (V, E) be a graph,   [1/2, 1). Then the -separator of G, written sep(G) is the smallest set S  V such that
1. A, S, B are a disjoint partition, i.e. V = A S B. 2. Both of |A|, |B|  |V |. 3. There are no edges between A and B.
Now if we were to consider the graph made of the disjoint union G = G1  G2, where G1 and G2 are densely connected, the separator alone of G would only give a very superficial information about
7

its connectivity. In order to make a more consistent statement about the connectivity of a graph, we introduce a notion of separability that also relies on subgraphs.

Definition 12. For any graph G on n vertices, we say G is (s, )-separable, with s : N  N, and





[

1 2

,

1)

if

r



{1, ..., n},

max{sep(G ) : G  G, |G |  r}  s(r)

A set of graphs G = {Gi} is (s, )-separable if every graph Gi in G is (s, )-separable.

The function s simply allows us to bounds the size of the -separator for every subgraph of size smaller than a variable parameter r.

Remark: The constant  is not strictly important as for any , there exists a constant c > 0, such

that

any

(s, )-separable

graphs

is

(c

·

s,

1 2

)-separable

[LT79].

Henceforth, for brevity, we just say

that a graph is s-separable to mean that it is (s, )-separable for some .

As an example, consider a grid graph as shown in fig. 2. This graph is poorly connected; we can

partition grid with

the vertices n = (L2)

into two sets by removing vertices has a separator of

a thin size L

strip from = ( n).

the As

middle. In other words, an L × L shown in the famous theorem by

Lipton and Tarjan [LT79], this is true for any planar graph. In general, the size of the separator for

`local' graphs embedded in D-dimensional Euclidean space is known to be O(n(1-1/D)) [MTTV97]. In

contrast, expander graphs famously have large separators, i.e. s = (n). This means that we have to

remove a lot of vertices from an expander before we can break it in two.

We now define the tree decomposition, and then the tree width.

Definition 13. A tree decomposition of a graph G = (V, E) is a pair ({Q(i), i  I}, T = (I, E)) where {i : i  I} is a family of subsets Q(i)  V and T = (I, E) is a tree. The sets I and E refer to the nodes and edges of the tree T respectively. Furthermore, the pair Q, T must obey the following properties:

1. iI Q(i) = V , 2. for every edge {v, w}  E there exists i  I with {v, w}  Q(i),
3. for every i, j, k  I the following holds: if j lies on the path from i to k in T , then Q(i)  Q(k)  Q(j).

The width of the tree decomposition ({Q(i) : i  I}, T = (I, E)) is defined as maxiI |Q(i)| - 1. The treewidth tw(G) of G is the minimum width of a tree decomposition of G.

To avoid confusion between the graphs G and T , we shall henceforth refer to the vertices v  V of G and the nodes i  I of T . The tree decomposition of a graph is not unique; for instance, a trivial decomposition of a graph G is to make one giant node N containing all the vertices of G. The treewidth however is the minimum width across all decompositions and is therefore well defined. The notation Q(i) is meant to be suggestive as it will soon refer to the qubits in that node.
Example: We consider some examples to illustrate this idea. The first example is the tree decomposition of a tree as shown in fig. 3. On the left is a binary tree of depth 2 and on the right is the corresponding tree decomposition. The vertices of the graph are gray and the nodes of the tree are green. It is simple to check Property 1. Notice that every node of the tree decomposition contains a single edge from the tree trivially satisfying Property 2. Finally, Property 3 is simple to verify: only two adjacent nodes ever share qubits. Since the size of each node is 2, the treewidth is 1.
As a second example, consider the surface code again as shown in fig. 4 on the left along with its tree decomposition on the right. The graph on the left indicates via green boxes how vertices are partitioned to form the nodes of the tree. Recall the structure of the connectivity graph of the surface code as shown in fig. 2. We choose the nodes of the tree by selecting vertices of the connectivity graph diagonally as

8

Figure 3: A tree on the left and its tree decomposition on the right. Each vertex of the tree is denoted using a gray circle and each node of the tree is denoted using a green box. The treewidth of a tree is 1.
shown. Again, it is straightforward to verify that this tree decomposition satisfies the definition. First, the diagonals contain every vertex and thus satisfy Property 1. It is also straightforward to verify that every edge is contained in at least one node, satisfying Property 2. Finally, since two successive nodes overlap on one diagonal array of vertices, the decomposition satisfies Property 3. The treewidth of this graph is obtained from the largest node of the tree which corresponds to the node cd. The treewidth is therefore 11.
Figure 4: On the left is the connectivity graph representation of the 3 × 3 surface code. Its vertices are partitioned into subsets a, b, c, d, e, f . On the right is a tree decomposition of the same graph. The node ab contains the union of the vertices in a and b.
We will make use of the following important connections between the separator and the treewidth of graphs [DN16, BPTW10]. Lemma 14. For any graph G = (V, E) such that G is s-separable, then tw(G) = O(s(|G|)). Similarly, if G has treewidth tw(G), then G is s-separable by a function s such that s(G) = O(tw(G)) Of particular interest are instances when the connectivity graph of the code has a sublinear-sized separator. As we shall see in the following section, this implies limits on the code dimension and distance.
2.3 Linear treewidth, separation, and expansion
The notion of graph expansion has already found applications in analyzing the structure of quantum codes, and it is natural to ask how the treewidth and how the separability relates to the expansion. The vertex expansion of a graph is generally defined through its Cheeger constant. Definition 15. For any graph G on n vertices, we define its Cheeger constant h(G) as
|A| h(G) = min
AG,|A|n/2 |A| Lemma 16. For any graph G on n vertices we can find H  G with |H|  c · n and h(H)  c/2 for some c, c > 0 if either of these two conditions is fulfilled
9

1. tw(G)  c · n 2. G is s-separable only if s(r)  c · r
Proof. Case 1 is Proposition 2 in [GM09]. For Case 2, note that tw(G)  s(G)  c · n by Lemma 14.

3 Main results

3.1 Bound on the distance

We now state and prove the first main result: the distance of a code family is bounded by the treewidth of the connectivity graph.
Theorem 17. Let C be a code and G = G(C) be the corresponding connectivity graph of bounded degree . If G has treewidth tw(G) then the distance obeys d   · (tw(G) + 1).

Proof. Consider a tree decomposition T of G such that the width of the tree T is the treewidth of G. For the sake of contradiction, assume d > (tw(G) + 1).
Suppose the tree T is non-trivial and has depth D  1 (and the root at depth 0). Let p  I be some node at depth D - 1. Let the leaves {j1, ..., jt}  I be the children of p.
Consider the set A = iQ(ji) \ i+Q(ji). The purpose of A is to be a correctable anchor whose boundary will be provably small. This will allow us to grow A to a larger, but still correctable region.
First, it follows from lemma 8 that A is itself correctable. This is because once the boundaries are removed, A is a union of decoupled sets as per definition 7. 1

Q(p) +A

+A

Q(p1)

Q(p3) Q(p2)

Q(j1)

Q(jt)

Q(j1)

Q(j2)

Figure 5: On the right is an illustration of the process used to iteratively grow a correctable region in the tree decomposition. The leaves Q(j1) \ +A and Q(j2) \ +A in the light yellow region can be verified to be correctable from the Union Lemma. Since their boundary is upperbounded by the size of the parent node Q(p1), we can find the nodes in the red triangle to be correctable using the Expansion Lemma. Call the union of these nodes pred; pred and p2 are childre of the parent node p3 and we may proceed recursively.
Next, we turn to +A. Consider any pair of qubits u, u such that u  A, u  +A. By construction, there must be some leaf ji such that u  Q(ji) and since u  +A, either:
1. u  +Q(ji), or
2. u  Q(ji) but u  +Q(jj) for some j.
1Including the case of Q(ji) and Q(jk) sharing a qubits q. In that case, Q(ji) \ +Q(jk)  Q(jk) \ +Q(ji) can be decomposed as the union of three decoupled sets: something in Q(ji) not connected to anything in Q(ji), q, and something in Q(jk) not connected to anything in Q(ji). The Cleaning lemma still applies.

10

We conclude that +A  i+Q(ji). Let Pext = Q(p)  +Q(p) be the extended parent. The purpose of Pext will be to bound the size of +Q(ji) and extend our anchor. By the definition of the treewidth, |Q(p)|  tw(n) + 1. Furthermore, since the degree of the qubits in the connectivity graph is at most , it follows that |+Q(p)|  (tw(n) + 1). Since d > (tw(n) + 1) by assumption, both Q(p) and +Q(p) are correctable. It follows from Lemma 9 that Pext is correctable. For every leaf ji and every u  -Q(ji), u shares an edge with the exterior of Q(ji). Therefore there exists another node j such that u  Q(j) by Property 2 of Definition 13. By Property 3 of Definition 13, it follows that u  Q(p). We conclude that -Q(ji)  Q(p). For any v  +Q(ji), either v is in Q(p), or it is outside of Q(p), though still in its boundary: +Q(ji)  Q(p)  +Q(p) = Pext. More generally +A  i+Q(ji)  Pext. We now have the necessary ingredients to extend the anchor. Since A and Pext are correctable with +A  Pext, then iQ(ji)  Q(p)  A  Pext is correctable 2. This too follows from Lemma 9. This shows that the qubits in p together with its children together are correctable. We can combine these nodes to form one larger leaf. Notice that after combining the p and its children into one node, the resulting tree is still a valid tree decomposition of the connectivity graph G. Save for the new amalgamated node, the size of the rest of the nodes of the tree is still upper bounded by tw(G) + 1.
The proof now proceeds by repeating this process until the entire tree is contracted to one node. First, we can contract the children of all nodes at depth D - 1 to reduce the depth of the entire tree to D - 1. It follows that this tree is also a valid tree decomposition, with all the leaves corresponding to correctable sets as proved above. This process can be iterated until the entire tree becomes one giant node which itself must be correctable. If the tree decomposition has several disjoint components, each of these components is a tree with bounded treewidth. Each can be proved to be correctable, and then since disjoint, their union is also correctable. This implies the whole code is correctable, a contradiction if the code is to encode at least one logical qubit.
From Lemma 14, it can be noted that easily separable graphs have bounded treewidth. Applied to Lemma 17, the proof of Theorem 1 follows naturally.
Proof. Note that d = O(tw(Gn)) = O(s(|Gn|)) = O(s(n)).
This theorem then leads to the following conclusion ­ unless the graph is very connected, the distance cannot grow linearly.
Corollary 18. If {Cn} is a family of n, k, d codes such that the corresponding connectivity graphs {Gn} are s-separable. Then if s(n) = o(n), then d = o(n).
Conversely, any family C = {Cn} with linear distance implies the existence of an expander family of graphs {Gn}, Gn  Gn by Lemma 16.
3.2 Bound on the code dimension
In this section, we explain how the separability of a graph can be used to bound the code dimension k. The intuition is to find large correctable regions in a code, and thereby limit the number of degrees of freedom. This is the idea behind the proof of the Bravyi-Poulin-Terhal result [BPT10]. We begin by restating the following result as a lemma and provide an alternate proof without the use of von Neumann entropies. The tradeoff is that our proof only works in the case of stabilizer codes, whereas the statement below extends to all quantum codes.
2To verify that the inclusion holds, it is sufficient to verify that iQ(ji)  A  Pext. Since A = iQ(ji) \ i+Q(ji) it suffices to show that i+Q(ji)  Pext, which is the conclusion of the previous paragraph
11

Lemma 19 (Bravyi-Poulin-Terhal [BPT10], Eq. 14). Consider an n, k, d stabilizer code C defined on a set of qubits Q, |Q| = n, such that Q = A B C. If A, B are correctable, then

k  |C| .

(2)

Proof. Let H  Fm2 ×2n be the symplectic representation of the stabilizer generators of C. We let rank H = n - k denote the rank of H and for some set of indices E  [n], we let HE denote the matrix obtained by selecting those columns indexed by E.
Delfosse and Zémor [DZ13] show (see Lemma 3.3) that an erasure E  [n] is correctable if and only if:

2|E|  rank(H) + rank(HE) - rank(HE) .

(3)

Consider the tripartition Q = A B C where A and B are correctable. We infer from eq. 3 that

2|A|  rank(H) + rank(HA) - rank(HBC )

 rank(H) + rank(HA) - rank(HB) .

(4)

The last inequality follows because removing columns from a matrix can at best reduce its rank. Similarly, we obtain

2|B|  rank(H) + rank(HB) - rank(HA) .

(5)

Adding eq. 4 and eq. 5, we get (|A| + |B|)  rank(H). We can now substitute |A| + |B| = n - |C| (because A, B, C form a tripartition of the set of qubits) and rank(H) = n - k into this equation to obtain k  |C|.

The bounds on the code dimension and the level of the transversal gates depend on partitions of graphs into correctable sets. To this end, we will use the following function

Definition

20.

The

function

Sd

is

defined

by

the

recurrence

relation

Sd(r)

=

c

·

s

+

2S

(

r 2

),

together

with the condition that Sd(t) = 0 for all t < d, where c is some constant.

The constant c arises because we may transform a (s, )-separable graph into a (cs, 1/2)-separable graph (see Definition 12 and the remark below it). The function Sd is important in quantifying the size of sets we get by recursively partitioning the connectivity graph until the resulting pieces are all correctable. This is made concrete in the next lemma:

Lemma 21. Consider a graph G = (V, E) that is s-separable. For every d  |G|, there exists a partition V = A A, with A a union of decoupled subsets of size strictly less than d, and |A| = Sd(|V |).

Proof.

First

we

remind

the

reader

that

any

(s, )-separable

graph

is

(c · s,

1 2

)-separable.

We iteratively construct A and A.

Start with A = V, A = .

By

assumptions,

there

exists

a

1 2

-

separator S1 such that V = VL S1 VR. We then write A = VL  VR, and A = S1.

If either or both of |VL|, |VR|  d, they are separated further. We then have A = VRR VRL VLR VLL, and A = S1  S2. Here, S2 is the union of the separators of both the left and right partitions VL and VR. This process can repeated until every subset V·  A is smaller than d.

To bound the size of A, note that when V· is split, |A| increases by at most cs(|V·|). In successive

iterations,

it

will

be

further

increased

by

the

cost

of

separating

V·L, V·R,

with

|V·L|, |V·R|



1 2

|V·|.

As

noted above, this iterative process comes to a halt when |V·| < d. The size of A is therefore bounded

by

the

recursive

function

Sd(r)

=

c

·

s

+

2Sd(

r 2

).

The

function

Sd

obeys

Sd(t) =

0

for

t<d

as

the

recurrence halts when the sets V·  A are smaller than d. Hence we have |A|  Sd(|V |).

12

Figure 6: Graphical representation of our argument. The blue cube can be separated into two smaller correctable elements, which will be A. Then the separator, the yellow plane, can be separated again yielding C, the red line, and B what remains of the yellow plane.

This recurrence relation is straightforward to solve. In appendix A, we show that when s(r) = O(rc), Sd(r) = O(dc-1r). We can summarize the general idea of our results as follows. Note that to find large A, B, given an easily separable graph, we can recursively separate said graph in order to obtain small correctable regions, which will be A. Then G \ A can be recursively separated anew, yielding B. See Figure 6.
Lemma 22. Let C be a code on n qubits and G = G(C) be the corresponding connectivity graph. If G is s-separable, then we have the bound k  Sd  Sd(n).
Proof. From Lemma 21, we can recursively separate the connectivity graph to find A such that |A| = Sd(|V |) = Sd(n) . Since A  G then A is s-separable. Applying Lemma 21 again to A, we can find sets B and B such that |B| = Sd(|A|) = Sd  Sd(n). Next, note that A is a union of disjoint subsets {V·}. By construction of the connectivity graph, this implies they share no generator, and are decoupled sets as per definition 7. Since every subset V· has size less than d, we can use the Union Lemma 8 to show that A is correctable. Similarly, B is correctable.
From Lemma 19, with B as the region C, we obtain k  Sd  Sd(n).
In special cases where the separator scales polynomially, we have the following bound:
Corollary 23. Let C = {Cn} be a family of n, k, d quantum LDPC codes with a s-separable family of connectivity graphs G = {Gn}. If exists a constant c  1 such that the separator has the form s(r) = O(rc), then
kd2(1-c) = O(n) .

Let us assume that we have growing distance, d = (f (n)) for some function f (n). Then the bound

reads k = O

n f (n)(2-2c)

. This implies that the only instances when we have constant rate and growing

distance is when c = 1, or s(r) = (r). Therefore there exists an expander family {Gn}, Gn  Gn by

Lemma 16.

Although this result allows us to formulate a bound in purely graph-theoretic terms, we cannot rederive the Bravyi-Poulin-Terhal bound. Indeed they make use of the Expansion Lemma to obtain regions V· of size d2, instead of d. This optimization cannot be carried out here as we do not have a guarantee on the boundary of the regions V· we create. In other words, we make no assumptions on the structure of the subgraph that we obtain from the separator. As a consequence, our bound applies to all codes and not just LDPC codes. As we will see when dealing with D-dimensional hyperbolic codes, some spaces induce small separators and large boundaries so we do not expect the Expansion Lemma to always yield a tighter bound.For example, graphs embeddable locally in 3-dimensional hyperbolic space have separators of size O( n). These are highly nonlocal codes therefore that may be able to bypass the

13

restrictions on purely local codes. These spaces might be expected to yield a poor distance and better tradeoffs. Without being able to pin down the structure of the graph induced by the separator, we cannot derive tighter bounds on the rate-distance tradeoff.

3.3 Bounds on transversal gates

In this section, we prove that transversal gates on quantum LDPC codes can only implement a limited set of transformations on the encoded information. We begin with by recalling a result from [BK13] that we will build on.
Lemma 24. Let C be a code such that its set of qubits can be partitioned as Q = ii==R1 +1i, where each i is correctable. The transversal gates on this code are limited to the R-th level K(R) of the Clifford hierarchy.

We are then in position to prove the following result.
Lemma 25. Let C be a code on n qubits and G = G(C) be the corresponding connectivity graph. Let Sd be the function defined in Definition 20, and let us denote Sd composed R times with itself as
RSd(n) = Sd  · · ·  Sd (n) .
R times
If G is s-separable, then the tranversal gates on this code are limited to the R-th level of the Clifford hierarchy K(R) for the smallest R satisfying
RSd(n) < d .

Proof. We proceed iteratively. The recursive separation of Lemma 21 acting on G yields partitions A1 and A1, where A1 is correctable, and |A1|  Sd(n). For i > 1, we separate Ai-1 into Ai and Ai (note that Ai is the complement of Ai within Ai-1 and not the entiree graph G). We repeat this process R times until AR is correctable. In doing so we get R + 1 correctable regions which is achieved when RSd(n) < d.

Corollary 26. Let C = {Cn} be an n, k, d code family and G = {Gn} be the corresponding connectivity

graph. Suppose G is s-separable, such that s(r) = O(rc) for c  (0, 1), and d = (n) for   (0, 1).

Transversal gates on C belong to K(R) where R =

1- (1-c)

.

Proof. For an s-separable graph, we known from Appendix A that Sd(n)  dc-1n for some constant  > 0. The condition from Lemma 25 can be satisfied if
(dc-1)Rn < d .

Equivalently, taking the logarithm base n, we get

R[logn() + (c - 1) logn(d)] < logn(d/n) .

Rearranging terms, we get

R>

1 - logn(d)

.

(1 - c) logn(d) - logn()

As we assume that d   n for sufficiently large n, it is sufficient to satisfy

R

>

1 - logn( n) (1 - c) logn( n)

.

Or, in the limit n  

1-

R>

.

(1 - c)

Therefore R =

1- (1-c)

is the smallest number of partitions required to create R disjoint cleanable

regions as stipulated in Lemma 25.

14

Remarks: Note that this bound cannot be tight in the case of D-dimensional quantum codes as it is
weaker than the results of Pastawski and Yoshida [PY15]. As we will see in the next section, a local graph in RD is s-separable where the separator s(r) = rc and c = 1 - 1/D. This then implies that

1-

R

D.



While the bound from Pastawski and Yoshida, reexpressed in our language, reads R  (1 - )D + 1 .

We cannot reproduce their bound for the same reason that we cannot reproduce the Bravyi-PoulinTerhal bound: in [BK13], the separation of the D-dimensional lattice is better than the separation into multiple sectors we have based on Sd.
Indeed the interest of the results presented here lies within more exotic spaces and constructions where the lattice-based approach of the numerous no-go theorems in RD breaks down.
We also mention a general limitation on obtaining practical codes. Let C be a family of quantum LDPC codes with s-separable connectivity graph G. Suppose s(r)  rc and that we can achieve d = (nc). This implies that we can implement gates in K(R), where R = 1/c . In particular, if c  1/2, we are limited to Clifford gates. This implies that there is a tradeoff between the distance and our ability to perform transversal gates even without the restriction of locality.

4 Quantum codes in HD
Several constructions of quantum codes are naturally expressed through hyperbolic geometry [Del13, BL20, FML02]. We use our results to study limitations of codes embeddable in HD and in hyperbolic surfaces. We demonstrate that D-dimensional hyperbolic codes have distance upper bounded by O(n(D-2)/(D-1)), reminiscent of Euclidean codes in (D - 1)-dimensions. However the tradeoff between the code dimension and distance is not as restrictive as in Euclidean space. This in turn could allow for a higher code dimension than codes embedded in RD. Our results follow from some recent work by Kisfaludi-Bak [KB20] who proved that certain classes of hyperbolic graphs have bounded separators.
We begin by comparing our work with previous results to provide some intuition on what follows. Recall that the Bravyi-Terhal and Bravyi-Poulin-Terhal results are statements on the geometry of RD. A ball of areaA in the Euclidean plane can be split into two equally-sized half balls by a line segment of length A. As a consequence one expects a graph nicely embedded in such a ball to have a separator of size O( A). By the same token, a ball of area A in 2-dimensional hyperbolic space has a diameter of size O(log(A)) in the limit of large balls. We therefore expect the hyperbolic plane to perform poorly in terms of distance.
Similarly, this geometric consideration can be used to justify why the hyperbolic space might be particularly well suited to our technique. As previously noted after Corollary 23, Theorem 2 does not allow us to rederive the Bravyi-Poulin-Terhal bound since we cannot guarantee that the regions we create through the recursive separation have small boundaries. However we do not expect this to be relevant in hyperbolic space since, due to the isoperimetric inequality, the boundary of a region is proportional to its volume in the limit of large volumes.
In order to formalize this correspondence between geometry and graphs, we need a precise definition of what it means for a graph to be nicely embedded in such a space. We naturally expect the density of vertices to not diverge, and two vertices linked by an edge should not be too far apart. This leads to definition 27.
Let (M, d) denote a metric space M equipped with a metric d : M × M  R0. Denote by B(x, w) = {y  M : d(x, y)  w} the ball of radius w around the point x  M .
15

Definition 27. A graph G = (V, E) is said to be (, w)-local on a metric space (M, d) if there exists a map  : V  M such that

1. (u, v)  E = d((u), (v))  w.
2. x  M , let B (x, w) = {v  V : (v)  B(x, w)} be the (possibly empty) preimage of a ball. Then x  M, |B (x, 2w)|  

A recent result by Kisfaludi-Bak [KB20] demonstrates that (, w)-local graphs embedded in HD have small separators. We begin by repeating Theorem 2 from [KB20] as it applies to this class of graphs.

Lemma 28. Let D  2, let G be (, w)-local in HD . Then G is

s,

D D+1

-separable where

(i) if D = 2, then s(r) = O(log(r)) (ii) if D  3, then s(r) = O(r(D-2)/(D-1)).

From theorems 1 and 2, we can then prove the following theorem.

Theorem 29. If C = {Cn} is a family of n, k, d LDPC codes such that the corresponding connectivity graphs G = {Gn} are (, w)-local in HD. Then we have the bounds

(i)

if

D = 2,

then

d = O(log(n))

and

k

d2 log(d)2

= O(n),

and

(ii)

if

D  3,

then

d = O(n(D-2)/(D-1))

and

2
kd D-1

= O(n).

Proof. The distance bounds are a trivial application of Theorem 1. For the 2D case, one finds Sd(r) =

O(r

log(d) d

)

from

Lemma

22.

Hence

k

=

O(n

log(d)2 d2

)

from

Theorem

2.

In the D  3 case, we have

k

=

O(d-

2 D-1

n)

from

Corollary

23.

We can see from this result that the distance of the D-dimensional hyperbolic codes for D  3 obeys the same upper bound as (D - 1)-dimensional Euclidean local codes.
Note that these results do not apply to quotients of the form HD/ as this can change the size of the separator completely. A straightforward consequence is that a graph on a 2-torus does not necessarily have a O(log(n)) separator. Fortunately, in the case of hyperbolic surfaces, we can still bound the separator as a function of their genus. We turn next to these codes.

4.1 Surfaces of genus g
The class of 2D topological codes has generated a wealth of literature and is among the most likely candidates for physical implementation in the near future. One could attribute this popularity to their relative ease of implementation, and tractable properties. Unfortunately, due to a result by Delfosse, these codes are known to be strongly limited and are constrained by kd2 = O(log(k)2n). Here we generalize this bound for local codes on an arbitrary surface of genus g, denoted g, and we prove that for fixed g, d = O( n), which is saturated by the surface code.
Topological graph theory provides a very natural bridge between graphs embeddable on a surface and their separability. We employ a result due to Dujmovi, Eppstein and Wood [DEW15] which states that graphs embedded in g with planarity p have bounded separators. A graph is said to p-planar if it can be drawn with at most p crossings on each edge. They proved that any graph that can be embedded in g that is p-planar has a separator of size O( (g + 1)(p + 1)n).
Observe that all -local graphs that can be embedded on g must be t-planar for some constant t. This is because:
16

1. Every edge (a, b) can be contained within a ball B of radius w.
2. For any edge (c, d) crossing (a, b), c and d must be at a distance less than w to some point p in the ball, which is at a distance at most w from a and b.
3. Since the number of points at a distance less than 2w is bounded by , there can be at most  crossings
Together, these observations imply that any -local graph on g is t-planar for some constant t. This implies the following result.
Theorem 30. Let C = {Cn} be a family of n, k, d LDPC codes such for every connectivity graph G  G = {Gn}, G is (, w)-local on a surface of genus g. We have the bounds
(i) d = O(gn), and
(ii) kd = O(gn).
We can also use this result to think about experimental implementation of good quantum codes. We might wish to implement codes such that there are as few edge crossings as possible. If we consider implementing codes on a flat surface, then we would need a significant number of edges overlapping. Indeed the number of edges crossing would have to scale as n. This in turn would mean that the code is no longer (, w)-local.

5 Conclusions

In this paper, we have shown that there is an intimate relation between quantum codes and the graphs on which they are defined. Given a code, we can obtain the connectivity graph from which we can infer properties of the associated quantum codes. We have three main results. First, we found that the distance of the quantum LDPC code is bounded by the size of the separator of the associated connectivity graph. Second, we found that the code dimension of a code is bounded as a function of the size of the separator via a recurrence relation. Third, we found that transversal gates can only implement a limited set of transformations depending on the connectivity of the graph. Together, the first two results state that we have good quantum LDPC codes only when the connectivity graph contains an expander.

We used these results to explore properties of quantum LDPC codes. We explored the properties of

codes embedded in D-dimensional hyperbolic space. We found that a local code in D-dimensional

hyperbolic

space

has

a

separator

bounded

as

s(r)

=

O(r1-

1 D-1

)

and

that

for

closed

2-manifolds

with

genus g, local codes are bounded by s(r) = O(gr).

These results raise many interesting questions.

1. No code family has been shown to saturate the Bravyi-Terhal or Bravyi-Poulin-Terhal bounds for D  3, although there exist two candidates.[Haa11, LAV20] Can the bounds we present here be saturated? For example, for any treewidth  does there exist a code whose distance is within a constant factor of  ?
2. Can our bound on the distance from the treewidth be made independent from the maximum degree of the connectivity graph?
3. Low-connectivity codes have poor performance, but do all codes with poor connectivity have low-dimensional local embeddings?

17

4. High connectivity is necessary for good quantum codes. What extra ingredients are needed to obtain good quantum codes? Can high connectivity be used to prove lower bounds in certain contexts? On a related note, our result does not say anything about whether we can bound the distance of quantum LDPC codes away from scaling linearly with n. Unfortunately, our approach will not be sufficient to do so. Indeed, the fact that there exist code families for which the rate is constant implies that they are well connected.
5. The connectivity graph representation relies on selecting a particular basis for our generators. Can these results be generalized to be basis independent?
We add that we use the same techniques as reference [BPT10] to also prove bounds on the code dimension of classical codes based on the graph separator in Appendix B. We would like to highlight that in contrast to local codes, there are many basic open questions concerning quantum LDPC codes. For a broad discussion on the subject, we point the interested reader to a review by Breuckmann and Eberhardt [BE21].

6 Acknowledgements
This paper is dedicated to the memory of David Poulin, a role model as a researcher and a mentor. David inspired and encouraged us to explore fundamental questions in quantum error correction while simultaneously studying consequences for real-world implementations. His presence will be missed.
We would like to thank Guillaume Duclos-Cianci for facilitating this collaboration; Stefanos Kourtis for helpful discussions; Chris Chubb, Nicolas Delfosse, Patrick Hayden, Anthony Leverrier, Noah Shutty and Christophe Vuillot for catching mistakes in an earlier draft and comments that helped improve the paper; and Sam Cree for a clear presentation of the Bravyi-Koenig bound which inspired section 3.3. AK is supported by the Bloch postdoctoral fellowship at Stanford University and NSF grant CCF-1844628.

References

[ABO97]

Dorit Aharonov and Michael Ben-Or. Fault-tolerant quantum computation with constant error. In Proceedings of the twenty-ninth annual ACM symposium on Theory of computing, pages 176­188. ACM, 1997.

[AG04]

Scott Aaronson and Daniel Gottesman. Improved simulation of stabilizer circuits. Physical Review A, 70(5):052328, 2004.

[AGP05] Panos Aliferis, Daniel Gottesman, and John Preskill. Quantum accuracy threshold for concatenated distance-3 codes. arXiv preprint quant-ph/0504218, 2005.

[AL99]

Alexei Ashikhmin and Simon Litsyn. Upper bounds on the size of quantum codes. IEEE Transactions on Information Theory, 45(4):1206­1215, 1999.

[BB20]

Simon Burton and Dan Browne. Limitations on transversal gates for hypergraph product codes. arXiv preprint arXiv:2012.05842, 2020.

[BE20]

Nikolas P Breuckmann and Jens N Eberhardt. Balanced product quantum codes. arXiv preprint arXiv:2012.09271, 2020.

[BE21]

Nikolas P Breuckmann and Jens Eberhardt. LDPC quantum codes. arXiv preprint arXiv:2103.06309, 2021.

[BH14]

Sergey Bravyi and Matthew B Hastings. Homological product codes. In Proceedings of the forty-sixth annual ACM symposium on Theory of computing, pages 273­282, 2014.

18

[BK98]

Sergey Bravyi and Alexei Yu Kitaev. Quantum codes on a lattice with boundary. arXiv preprint quant-ph/9811052, 1998.

[BK13]

Sergey Bravyi and Robert König. Classification of topologically protected gates for local stabilizer codes. Physical Review Letters, 110(17):170503, 2013.

[BL20]

Nikolas P. Breuckmann and Vivien Londe. Single-shot decoding of linear rate LDPC quantum codes with high performance, 2020.

[BMD06] Hector Bombin and Miguel Angel Martin-Delgado. Topological quantum distillation. Physical Review Letters, 97(18):180501, 2006.

[Bom10] Hector Bombin. Topological order with a twist: Ising anyons from an abelian model. Physical Review Letters, 105(3):030403, 2010.

[BPT10] Sergey Bravyi, David Poulin, and Barbara Terhal. Tradeoffs for reliable quantum information storage in 2D systems. Physical Review Letters, 104(5):050503, 2010.

[BPTW10] Julia Böttcher, Klaas P Pruessmann, Anusch Taraz, and Andreas Würfl. Bandwidth, expansion, treewidth, separators and universality for bounded-degree graphs. European Journal of Combinatorics, 31(5):1217­1227, 2010.

[BT09]

Sergey Bravyi and Barbara Terhal. A no-go theorem for a two-dimensional self-correcting quantum memory based on stabilizer codes. New Journal of Physics, 11(4):043029, 2009.

[BT16]

Nikolas P Breuckmann and Barbara M Terhal. Constructions and noise threshold of hyperbolic surface codes. IEEE transactions on Information Theory, 62(6):3731­3744, 2016.

[Del13]

Nicolas Delfosse. Tradeoffs for reliable quantum information storage in surface codes and color codes. In Information Theory Proceedings (ISIT), 2013 IEEE International Symposium on, pages 917­921. IEEE, 2013.

[DEW15] Vida Dujmovi, David Eppstein, and David R Wood. Genus, treewidth, and local crossing number. In International Symposium on Graph Drawing, pages 87­98. Springer, 2015.

[DN16]

Zdenek Dvorák and Sergey Norin. Strongly sublinear separators and polynomial expansion. SIAM Journal on Discrete Mathematics, 30(2):1095­1101, 2016.

[DZ13]

Nicolas Delfosse and Gilles Zémor. Upper bounds on the rate of low density stabilizer codes for the quantum erasure channel. Quantum Information & Computation, 13(9-10):793­826, 2013.

[EKZ20]

Shai Evra, Tali Kaufman, and Gilles Zémor. Decodable quantum LDPC codes beyond the square root distance barrier using high dimensional expanders. In 2020 IEEE 61st Annual Symposium on Foundations of Computer Science (FOCS), pages 218­227. IEEE, 2020.

[EOT20] Lior Eldar, Maris Ozols, and Kevin Thompson. The need for structure in quantum LDPC codes. IEEE Transactions on Information Theory, 66(3):1460­1473, 2020.

[FGL18]

Omar Fawzi, Antoine Grospellier, and Anthony Leverrier. Constant overhead quantum fault-tolerance with quantum expander codes. In 2018 IEEE 59th Annual Symposium on Foundations of Computer Science (FOCS), pages 743­754. IEEE, 2018.

[FML02] Michael H Freedman, David A Meyer, and Feng Luo. Z2-systolic freedom and quantum codes. Mathematics of quantum computation, Chapman & Hall/CRC, pages 287­320, 2002.

[GC99]

Daniel Gottesman and Isaac L Chuang. Demonstrating the viability of universal quantum computation using teleportation and single-qubit operations. Nature, 402(6760):390­393, 1999.

19

[GL14]

Larry Guth and Alexander Lubotzky. Quantum error correcting codes and 4-dimensional arithmetic hyperbolic manifolds. Journal of Mathematical Physics, 55(8):082202, 2014.

[GM09] Martin Grohe and Dániel Marx. On tree width, bramble size, and expansion. Journal of Combinatorial Theory, Series B, 99(1):218­228, 2009.

[Got96] Daniel Gottesman. Class of quantum error-correcting codes saturating the quantum Hamming bound. Physical Review A, 54(3):1862, 1996.

[Got14] Daniel Gottesman. Fault-tolerant quantum computation with constant overhead. Quantum Information & Computation, 14(15-16):1338­1372, 2014.

[Haa11] Jeongwan Haah. Local stabilizer codes in three dimensions without string logical operators. Physical Review A, 83(4), Apr 2011.

[Has13] Matthew B Hastings. Decoding in hyperbolic spaces: LDPC codes with linear rate and efficient error correction. arXiv preprint arXiv:1312.2546, 2013.

[HHO20]

Matthew B Hastings, Jeongwan Haah, and Ryan O'Donnell. Fiber bundle codes: Breaking the N 1/2poly log(N ) barrier for quantum LDPC codes. arXiv preprint arXiv:2009.03921,
2020.

[KB20]

Sándor Kisfaludi-Bak. Hyperbolic intersection graphs and (quasi)-polynomial time. In Proceedings of the Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 1621­1638. SIAM, 2020.

[Kit97]

A Yu Kitaev. Quantum computations: algorithms and error correction. Russian Mathematical Surveys, 52(6):1191­1249, 1997.

[Kit03]

A Yu Kitaev. Fault-tolerant quantum computation by anyons. Annals of Physics, 303(1):2­ 30, 2003.

[KKL14]

Tali Kaufman, David Kazhdan, and Alexander Lubotzky. Ramanujan complexes and bounded degree topological expanders. In 2014 IEEE 55th Annual Symposium on Foundations of Computer Science, pages 484­493. IEEE, 2014.

[KL97]

Emanuel Knill and Raymond Laflamme. Theory of quantum error-correcting codes. Phys. Rev. A, 55:900­911, Feb 1997.

[KLZ98]

Emanuel Knill, Raymond Laflamme, and Wojciech H Zurek. Resilient quantum computation: error models and thresholds. In Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, volume 454, pages 365­384. The Royal Society, 1998.

[KP12]

Alexey A Kovalev and Leonid P Pryadko. Improved quantum hypergraph-product LDPC codes. In Information Theory Proceedings (ISIT), 2012 IEEE International Symposium on, pages 348­352. IEEE, 2012.

[KP13] [KT20]

Alexey A Kovalev and Leonid P Pryadko. Fault tolerance of quantum low-density parity check codes with sublinear distance scaling. Physical Review A, 87(2):020304, 2013.
Tali Kaufman and Ran J Tessler. Quantum LDPC codes with  {n} logk(n)) distance, for any k. arXiv preprint arXiv:2008.09495, 2020.

[LAV20] Anthony Leverrier, Simon Apers, and Christophe Vuillot. Quantum XYZ product codes. arXiv preprint arXiv:2011.09746, 2020.

[LL17]

Vivien Londe and Anthony Leverrier. Golden codes: quantum LDPC codes built from regular tessellations of hyperbolic 4-manifolds. arXiv preprint arXiv:1712.08578, 2017.

20

[LT79]

Richard J Lipton and Robert Endre Tarjan. A separator theorem for planar graphs. SIAM Journal on Applied Mathematics, 36(2):177­189, 1979.

[MTTV97] Gary L Miller, Shang-Hua Teng, William Thurston, and Stephen A Vavasis. Separators for sphere-packings and nearest neighbor graphs. Journal of the ACM (JACM), 44(1):1­29, 1997.

[NC02]

Michael A Nielsen and Isaac Chuang. Quantum computation and quantum information, 2002.

[PK20]

Pavel Panteleev and Gleb Kalachev. Quantum LDPC codes with almost linear minimum distance. arXiv preprint arXiv:2012.04068, 2020.

[PY15]

Fernando Pastawski and Beni Yoshida. Fault-tolerant logical gates in quantum errorcorrecting codes. Physical Review A, 91(1), Jan 2015.

[Sho96]

Peter W Shor. Fault-tolerant quantum computation. In Proceedings of 37th Conference on Foundations of Computer Science, pages 56­65. IEEE, 1996.

[SK10]

Pradeep Sarvepalli and Andreas Klappenecker. Degenerate quantum codes and the quantum Hamming bound. Physical Review A, 81(3):032318, 2010.

[TZ14]

Jean-Pierre Tillich and Gilles Zémor. Quantum LDPC codes with positive rate and minimum distance proportional to the square root of the blocklength. IEEE Transactions on Information Theory, 60(2):1193­1202, 2014.

[ZP19]

Weilei Zeng and Leonid P Pryadko. Higher-dimensional quantum hypergraph-product codes with finite rates. Physical Review Letters, 122(23):230501, 2019.

A Closed-form expression for recurrence relation

Lemma

31.

Let

Sd(n)

be

a

function

that

obeys

the

recurrence

relation

Sd(n)

=

s(n)

+

2Sd(

n 2

),

together

with the condition that Sd(t) = 0 for t < d. For c < 1, if s(n) = O(nc), then

Sd(n) = O dc-1n .

It follows that Sd  Sd(n) = O d2(c-1)n .

Proof. Suppose we start with the more general recurrence relation:

Sd(n) = s(n) + 2Sd(n) .

(6)

It can be expanded as follows:

m
Sd(n) = 2as (an) + O

n log1/(2) s(mn) . d

(7)

a=0

This is because the recurrence can itself be expanded as a tree; the root corresponds to the function

Sd(n) and each successive layer breaks the previous layer into constituent parts using the recurrence

relation. The recurrence halts when Sd(t) = 0 which is achieved when t < d and the depth of the tree

is therefore m :=

log1/

n d

. It follows that mn = O(d). The sum over the 2m leaves of the tree is

2ms(mn) = O

n log1/(2) s(mn) . d

21

If s(n) = O(nc) for some c  1, then s(mn) = O(dc), and the summation in eq. 7 can be expressed as follows:

m

2as

(an)



nc

dc nc

n log1/(2) = dc d

n log1/(2) .
d

(8)

a=0

Plugging this back into eq. 7, we get the desired result

Sd(n) = O

dc

n log1/(2) d

.

Note that if  = 1/2, then log1/(2) = 1 and it follows that Sd(n) = O dc-1n . Next, we turn to the composition of Sd with itself,

Sd  Sd(n) = O

dc

Sd(n) log1/(2) d

= O dc 1 log1/(2) dc n log1/(2) log1/(2)

d

d

= O dn

(9) (10) (11)

where  = c - log1/(2) + log1/(2)(c - log1/(2)) and  = (log1/(2))2. If  = 1/2, then  = 2(c - 1) and  = 1 and

Sd  Sd(n) = O(d2(c-1)n) .

(12)

This concludes the proof.

B Classical codes

In [BPT10], the authors also derive a bound on the parameters of classical codes using the following lemma.

Lemma 32 (Bravyi, Poulin, Terhal). Consider a classical code defined on bits Q = A B. Consider A = Ai with Ai correctable, and no constraint acts on two different Ai. Then A is correctable, and

k  |B|.

(13)

Our results can be seen to extend naturally to the classical setting. Corollary 33. For an s(n)-separable family of classical codes {Cn}, we have k = O(Sd(n)). Proof. This follows from applying Lemma 32 to 21 taking B  A.

C Bound on codes defined by commuting projectors

The Bravyi-Poulin-Terhal bound [BPT10] applies to a much larger class of codes than just stabilizer

codes. Mirroring their result, we consider a class of codes defined by a set {a}a of commuting

projectors where each projector a acts on some constant number of qubits, and every qubit can affect

at most a constant number of projectors. We refer to such a code as a low-density commuting projector

code.

A

stabilizer

code

is

the

special

case where

each

projector

can be

expressed

as

a

=

1 2

(1

+

Sa)

for some stabilizer generators {Sa}a. However in general, a commuting-projector code need not have

22

this specific structure. The codespace C is the space C = {| : a | = | a}. In this section, we prove that our main results extend to this general class of codes.
At the outset, this may seem difficult as the workhorse behind our results was the Cleaning Lemma. However, there exist analogues of the Union and Expansion Lemmas. For proofs, we refer the reader to Lemma 2 and Corollary 1 respectively of the paper by Bravyi, Poulin and Terhal [BPT10].
Before stating the lemmas, we note that the idea of a boundary, either exterior + or interior - carries over quite naturally. Let V be the set of qubits defining a code and U  V be some subset of qubits. The external boundary +U of U is the set of qubits v  U such that there exists a projector acting on v and some u  U . The internal boundary -U is the exterior boundary of U . The boundary U is the union +U  -U . We say that two regions U1 and U2 are decoupled if there exist no projectors a that are supported jointly on the two regions. The definition of the connectivity graph extends in a natural way: two qubits are connected by an edge if they are both in the support of a projector . Therefore two regions U1 and U2 are decoupled if there exist no edges between them in the connectivity graph.
Lemma 34 (Generalized Union Lemma). Let U1, U2 be any correctable regions such that U1 and U2 are decoupled. Suppose that +U1 is also correctable, then U1  U2 is correctable.
Observe the qualitative difference in this case from that of stabilizer codes: we also require that +U1 be correctable in order for the union to be correctable. This difference will manifest in the bounds on code properties by making the bounds weaker in the case of commuting projector codes.
Lemma 35 (Generalized Expansion Lemma). Let U be a correctable set of qubits. Consider any region B  V and C  U , such that U  BC and BC is correctable. Then U  C is correctable.
We are now ready to prove a bound on the distance.
Theorem 36. Let C be a low-density commuting projector code on n qubits. Let G = G(C) be the corresponding connectivity graph with bounded degree . If G has treewidth tw(G), then d  82 tw(G).
Proof. For the sake of contradiction, assume d > 82 tw(G).
Consider a set of leaves {j1, ..., jt} sharing the same parent node p, and define Ai = Q(ji) \ k+Q(jk), and A = iAi. Each Ai is then what remains of Q(ji) after we remove the qubits connected to another leaf.
As noted before in the proof of Theorem 17, for any Ai, we have +Ai  i+Q(ji)  Pext, and we remind the reader that Pext = Q(p)  +Q(p). From the definition of treewidth, |Q(p)|  tw(G) + 1, and +Q(p)  |Q(p)|. Then |Pext|  tw(G) + 1 + (tw(G) + 1). This implies |Pext|  4 tw(G). Since d > 4 tw(G)  |Pext|  +Ai, and the Ai are decoupled, then A is correctable by Lemma 34.
We will now want to prove that A  Pext is correctable using the Generalized Expansion Lemma 35.
First, note that since +A  Pext, then A = -A  +A  -A  Pext. By the Generalized Expansion Lemma, it only remains to prove that -A  Pext is correctable. It was already noted that +A  i+Q(ji), and trivially -A  ++A. We can then easily bound the size of this region: |-A  Pext|  |++A  Pext|  |+Pext  Pext|  ( + 1)|Pext|  ( + 1) · 4 tw(G)  82 tw(G) < d. As A  -A  Pext, and -A  Pext is correctable, then A  Pext is correctable by Lemma 35. Just as for Theorem 17, iQ(ji)  Q(p)  A  Pext.
We can then repeat the argument as in Theorem 17 and prove the entire code is correctable: a contradiction if the code is to encode at least one logical qubit
We now turn to the case of the bound k.
Theorem 37. Let C be a commuting-projector code on n qubits. Let G = G(C) be the corresponding connectivity graph of bounded degree . If G is s-separable, then we have the bound k  Sd/  Sd/(n).
23

Proof. We remind the reader that Lemma 19 also holds for non stabilizer codes [BPT10]. However due to the restriction from Lemma 34 that +M1 has to be correctable, we will have to adapt our use of the recursive separation: instead of creating regions of size d, we will stop at d/. From 21, we can find A such that A is the union of disjoint subsets {V·} of size less than d/, and |A|  Sd/(n). For every V·, |+V·|  |V·| < d, which shows that A is correctable.
By applying the same argument as 22, we find k  Sd/  Sd/(n).

D Conditions for separators on HD

In this section, we wish to clarify when we can apply Kisfaludi-Bak's results. Their statement is not in terms of (, w)-local graphs, but instead in terms of a certain class called noisy uniform ball graphs (NUBG). This class is defined as follows.
Definition 38 (Noisy uniform ball graphs (NUBG)). Let (M, d) be a metric space. Let  > 0 and   1 be fixed constants. A graph G = (V, E)  NUBGHD (, ) if there is a function  : V  M such that for all pairs v, w  V , we have

1. d((v), (w)) < 2 = (v, w)  E. 2. d((v), (w))  2 = (v, w)  E.

Pairs of vertices v, w where d((v), (w))  [2, 2] can either be connected or disconnected.

Definition 38 requires all vertices close enough to another vertex to be connected. Note that a (, w)local graph G can be extended to a (w/2, 2)-NUBG graph by adding edges between any two vertices that are a distance w/2 away, written Gw/2 = (Vw/2, Ew/2). The vertex set Vw/2 = V and the edges in the modified graph Gw/2 obey the condition

(u, v)  Ew/2  d((u), (v))  w .

Since the density  is constant, this modification adds at most a constant number of edges. Note then that a separator S for the NUBG graph Gw/2 is also a separator for G.
For completeness, we repeat the definition of Theorem 2 from [KB20] using the language of NUBG graphs as in the original paper.

Lemma 39. Let D  2,  > 0 and   1 be constants, and let G be NUBGHD (, ) in HD . Then G

is

(s,

D D+1

)-separable

where

(i) if D = 2, then s(r) = O(log(r)), and (ii) if D  3, then s(r) = O(r(D-2)/(D-1)).

24

