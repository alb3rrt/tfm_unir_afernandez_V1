arXiv:2106.00315v2 [cs.FL] 3 Jun 2021

Ordering regular languages: a danger zone
Giovanna D'Agostino, Davide Martincigh, and Alberto Policriti
University of Udine, Italy
Abstract. Ordering the collection of states of a given automaton starting from an order of the underlying alphabet is a natural move towards a computational treatment of the language accepted by the automaton. Along this path, Wheeler graphs have been recently introduced as an extension/adaptation of the Burrows-Wheeler Transform (the now famous BWT, originally defined on strings) to graphs. These graphs constitute an important data-structure for languages, since they allow a very efficient storage mechanism for the transition function of an automaton, while providing a fast support to all sorts of substring queries. This is possible as a consequence of a property--the so-called path coherence--valid on Wheeler graphs and consisting in an ordering on nodes that "propagates" to (collections of) strings. By looking at a Wheeler graph as an automaton, the ordering on strings corresponds to the co-lexicographic order of the words entering each state. This leads naturally to consider the class of regular languages accepted by Wheeler automata, i.e. the Wheeler languages. It has been shown that, as opposed to the general case, the classic determinization by powerset construction is polynomial on Wheeler languages. As a consequence, most of the classical problems turn out to be "easy"-- that is, solvable in polynomial time--on Wheeler languages. Moreover, deciding whether a DFA is Wheeler and deciding whether a DFA accepts a Wheeler language is polynomial. Our contribution here is to put an upper bound to easy problems. For instance, whenever we generalize by switching to general NFAs or by not fixing an order of the underlying alphabet, the above mentioned problems become "hard"--that is NP-complete or even PSPACE-complete.
1 Introduction
Adding an order to a class of structures (graphs, groups, monoids...) is a natural move. Moreover, ordering is a basic data-structuring mechanism, strongly favoring computational manipulations of the considered class.
Over the class of finite automata, order has been added e.g. in [7], where the order must propagate along equally labeled transitions. Much more recently, in an effort to find a common denominator to a number of different algorithmic techniques, Gagie et al. proposed (in [13]) a new simple strategy for enforcing and using order on a given automaton. Starting from an underlying order of the alphabet, the order on the states (formally given in Definition 1) must: i) agree with the order of the labels of their incoming edges, and ii) be coherent

2

G. D'Agostino et al.

on target/source nodes, for pairs of arcs with equal labels. It turns out that this kind of automata, called Wheeler automata, (a) admit an efficient index data structure for searching subpaths labeled with a given query pattern, and (b) enable a representation of the graph in a space proportional to that of the edges' labels since the topology can be encoded with just O(1) bits per node [13] (as well as enabling more advanced compression mechanisms, see [3,11]). This is in contrast with the fact that general graphs require a logarithmic (in the graph's size) number of bits per edge to be represented, as well as with recent results showing that in general, the subpath search problem can not be solved in subquadratic time, unless the strong exponential time hypothesis is false [4,5,6,8,10].

c

a

q1

c

q2

q0

f

d

q4

c

q3

f

q5

c

Fig. 1. A WDFAs A recognizing the language Ld = ac + dcf . Condition (i) of Definition 1 implies input consistency and induces the partial order q1 < q2, q3 < q4 < q5. From condition (ii) it follows that (q1, c)  (q4, c), thus q2 < q3. Therefore, the only order that could make A Wheeler is q0 < q1 < q2 < q3 < q4 < q5. The reader can verify that condition (ii) holds for each pair of equally labeled edges.
In Figure 1 is depicted an example of a Wheeler automaton (see also Definition 1). Notice that the minimum DFA recognizing L is not input consistent, hence not Wheeler; we will return on this point later. One is naturally led to consider the class of Wheeler languages, i.e. the regular languages recognized by some Wheeler automaton, as well as to raise the question of whether it is possible to decide, just by looking at a (generic, possibly not Wheeler) DFA, whether the language it recognizes is Wheeler. Wheeler languages have been studied extensively in [2], where it is shown that we can decide in polynomial time whether a DFA recognizes a Wheeler language. Unfortunately, trying to use the same strategy on a NFA language does not work. In fact, in this paper we show that the problem for NFAs becomes PSPACE-complete.
Consider the example in Figure 2 and confront it with Figure 1. Even tough apparently we made an insignificant change to the automaton, that is we have simply swapped character-labels d and b, the new language recognized by the

Ordering regular languages: a danger zone

3

c

a

q1

c

q3

q0

f

b

q2

c

q4

f

q5

c

Fig. 2. A failed attempt to build a WDFA recognizing the language Lb = ac + bcf . Condition (i) of Definition 1 induces the partial order q1 < q2 < q3, q4 < q5, and condition (ii) implies (q1, c)  (q2, c), thus q3 < q4. But if we apply condition (ii) again, we obtain (q2, c)  (q3, c), a contradiction.

automaton turns out to be not Wheeler. This example illustrates that the order of the underlying alphabet plays a significant role when determining whether an automaton, and even a language, is Wheeler. Notice that swapping d and b can be seen as considering a different order on : from a  c  d  f to a  d  c  f . Again a natural question is raised: when presented with an automaton (or a language) that is not Wheeler, is there a different way to order the alphabet so that the automaton (language) becomes Wheeler? Being able to answer in polynomial time to this this question would be very helpful for applications. Unfortunately, as shown in Section 3, this problem turns out to be NP-complete even for DFAs.
WNFAs have the following useful property: turning a WNFA into a DFA using the (classic) powerset construction actually results in a WDFA with at most twice the number of states of the original WNFA. In other words, the blow-up of states that we can observe when converting NFAs into DFAs, does not occur for Wheeler non-deterministic automata. Nevertheless, it is known (see [1]) that a blow-up of states can occur even when we switch from the minimum DFA recognizing a language L to the minimum WDFA recognizing L. As a last contribution, in this paper we give an answer to a question put forward in [1]. We provide an algorithm to compute the minimum WDFA starting from the minimum DFA. Our algorithm works in exponential time in the worst case and, since the dimension of the output might be exponential in the dimension of the input, is optimal for the task.
Due to space constraints, we present only the sketches of the proofs of our results. The full proofs, complete with all the missing details, can be found in the Appendix.

4

G. D'Agostino et al.

2 Wheeler languages

First of all, we fix some notation. Let  denote a finite alphabet endowed with a total order (, ). We denote by  the set of finite words over , with 
being the empty word, and we extend the order  over  to the co-lexicographic order (, ), where    if and only the reverse of , i.e.  read from the
right to the left, precedes lexicographically the reverse of . Given two words ,   , we denote by    the property that  is a suffix of . For a language L  , we denote by Pref(L) the set of prefixes of strings in L. We denote by
A = (Q, q0, , F, ) a finite automaton (NFA), with Q as set of states, q0 initial state,  : Q×  2Q transition function, and F  Q final states. The dimension
of A, denoted by |A|, is defined as the number of states of A. An automaton is
deterministic (DFA) if |(q, a)|  1, for all q  Q and a  . As customary, we extend  to operate on strings as follows: for all q  Q, a   and   

(q, ) = {q},

(q, a) =

(v, a).

v(q,)

We denote by L(A) = {   : (q0, )  F = } the language accepted by the automaton A. We make the assumption that every automaton is basic, that is, every state is reachable from the initial state and every state can reach at least one final state. Notice that this assumption is not restrictive, since removing from a NFA every state not reachable from q0 and every state from which is impossible to reach a final state can be done in linear time and does not change the accepted language. It immediately follows that:

­ there might be only one state without incoming edges, namely q0; ­ every word that can be read starting from q0 belongs to Pref(L).
Lastly, given a finite set Q, totally ordered by the relation <, we say that I  Q is an interval if and only if for all q, q, q  Q with q  q  q, if q, q  I then q  I. We denote by I := [qmin, qmax] a generic interval, where qmin (qmax) is the minimum (maximum) element of I with respect to <.
The class of Wheeler automata has been recently introduced in [13]. An automaton in this class has the property that there exists a total order on its states that is propagated along equally labeled transition. Moreover, the order must be compatible with the underlying order of the alphabet:

Definition 1 (Wheeler Automaton). A Wheeler NFA (WNFA) A is a NFA (Q, q0, , F, ) endowed with a binary relation <, such that: (Q, <) is a linear order having the initial state q0 as minimum, q0 has no in-going edges, and the following two (Wheeler) properties are satisfied. Let v1  (u1, a1) and v2  (u2, a2):
(i) a1  a2  v1 < v2 (ii) (a1 = a2  u1 < u2)  v1  v2.
A Wheeler DFA (WDFA) is a WNFA in which the cardinality of (u, a) is always less than or equal to one.

Ordering regular languages: a danger zone

5

In Figure 1 is depicted an example of a WDFA.
Remark 1. A consequence of Wheeler property (i) is that A is input-consistent, that is all transitions entering a given state u  Q have the same label: if u  (v, a) and u  (w, b), then a = b. Therefore the function  : Q   that associate to each state the unique label of its incoming edges is well defined. For the state q0, the only one without incoming edges, we set (q0) := #.
In [13] it is shown that WDFAs have a property called path coherence: let A = (Q, q0, , F, ) be a WDFA according to the order (Q, <). Then for every interval of states I = [qi, qj] and for all   , the set J of states reachable starting from any state of I by reading  is also an interval. Path coherence allows us to transfer the order < over the states of Q to the co-lexicographic order  over the words entering the states: for each state q define the set Iq = { : (q0, ) = q)}. With abuse of notation, we extend to subsets of  as follows: U V , with U, V  , if and only if    for each   U,   V such that {, } / U  V . Then, two states q and p with Iq = Ip satisfy q < p if and only Iq Ip (again proved in [1]). An immediate consequence of this fact is that a WDFA admits an unique order of its states that makes it Wheeler and this order is univocally determined by the co-lexicographic order of any word entering its states. This result is important for two different reasons. First of all, it makes possible to decide in polynomial time whether a DFA is Wheeler: for each state q, pick a word q entering it and order the states reflecting the co-lexicographic order of the words {q : q  Q}; then check if the order satisfies the Wheeler conditions. Secondly, it is the key to adapt Myhill-Nerode Theorem to Wheeler automata. We recall the following defintion.
Definition 2 (Myhill-Nerode equivalence). Let L   be a language. Given a word   , we define the right context of  as
-1L := {   :   L},
and we denote by L the Myhill-Nerode equivalence on Pref(L) defined as
 L   -1L = -1L.
The (classic) Myhill-Nerode Theorem, among many other things, establishes a bijection between equivalence classes of L and the states of the minimum DFA recognizing L. This minimum automaton is also unique up to isomorphism and a similar result, fully proved in [2], holds for Wheeler languages as well.
In order to state such an analogous of Myhill-Nerode Theorem for Wheeler languages, the equivalence L is replaced by the equivalence cL defined below.
Definition 3. The input consistent, convex refinement cL of L is defined as follows.  cL  if and only if
­  L , ­  and  end with the same character, and 2

6

G. D'Agostino et al.

­ for all   Pref(L), if min(, )  max(, ), then  L  L .
The Myhill-Nerode Theorem for Wheeler languages proves that there exists a minimum (in the number of states) WDFA recognizing L. As in the classic case, states of the minimum automaton are, in fact, cL-equivalence classes, this time consisting of intervals of words. Also such WDFA is unique up to isomorphism.
A further important consequence, especially for testing Wheelerness, is stated in the following Lemma (again proved in [2]).
Lemma 1. A regular language L is Wheeler if and only if all monotone sequences in (Pref(L), ) become eventually constant modulo L. In other words, for all sequences (i)i0 in Pref(L) with
1 2 . . . i . . . or 1 2 · · · i . . .
there exists an n such that h L k, for all h, k  n.
Lemma 1 shows how it is possible to recognize whether a language L is Wheeler simply by verifying a property on the words of Pref(L): trying to find a WDFA that recognizes L is no longer needed to decide the Whelerness of L. As it turns out, we can verify whether the property depicted in Lemma 1 is satisfied just by looking at any DFA recognizing L, as shown in Theorem 1 (see [2]).
Theorem 1. Let A be a DFA such that L = L(A), with initial state q0 and dimension n = |A|. L is not Wheeler if and only if there exist µ,  and  in , with   µ, , such that:
1. µ L  and they label paths from q0 to states u and v, respectively; 2.  labels two cycles, one starting from u and one starting from v; 3. µ,    or   µ, .
The length of the words µ,  and  satisfying the above can be bounded:
4. |µ|, ||  ||  n3 + 2n2 + n + 2.
Since in this work we make an extensive use of Theorem 1, here is a simple example on how and why it works. Consider the automata depicted in Figure 3. As shown in Figure 1 and 2, the language Ld is Wheeler whereas Lb is not, as can be easily proved using Theorem 1. In fact, consider the automaton Ab. By setting µ := a,  := b and  := c, one can verify conditions 1-3 of the theorem are satisfied. Notice that condition a Lb b follows immediately from the fact that (q0, a) = (q0, b) in the minimum DFA Ab.
If we try to transpose the same reasoning to the automaton Ad by setting µ = a,  = d and  = c, condition 3 of Theorem 1 is no longer satisfied. We can not find 3 words satisfying conditions 1-3 of Theorem 1, therefore Lb is Wheeler.

The polynomial bound given by condition 4 of Theorem 1 allows us to design an algorithm that decides whether a given DFA recognizes a Wheeler language:

Ordering regular languages: a danger zone

7

c

c

q1 a

q0 c

d

q2

q3

f

(a) The minimum DFA Ad recognizing Ld = ac + dcf .

q1 a

q0 c

b

q2

q3

f

(b) The minimum DFA Ab recognizing Lb = ac + bcf .

Fig. 3. The minimum DFAs recognizing the languages Ld (Wheeler) and Lb (not Wheeler).

using dynamic programming (see [1]), it is possible to keep track of all the relevant paths and cycles inside the DFA and check, in polynomial time, whether there exists three words satisfying the conditions of the theorem.
Things change if, instead of a DFA, we are given a NFA. Trying to exploit the same idea used for DFAs does not work: the problem of deciding whether two words µ and  read by a NFA are Myhill-Nerode equivalent is PSAPCEcomplete, whereas is polynomial on DFAs (simply compute the minimum DFA using Hopcroft's algorithm and check whether the two states reached by µ and  coincide). Even worse, the straightforward attempt of building the minimum DFA recognizing the NFA's language might lead to a blow-up of the sates, resulting in a exponential time (and exponential space) algorithm.
We show that the problem of deciding whether a NFA recognizes a Wheeler language is indeed hard, but doesn't require exponential time to be solved: the problem turns out to be PSPACE-complete. To show this, we first need to adapt Theorem 1 to work on NFAs, as described in the following corollary.
Corollary 1. Let A = (Q, q0, , F, ) be a NFA of dimension n := |A|. Then L := L(A) is not Wheeler if and only if there exist three words µ, , , with   µ, , such that
1. µi L j for all 0  i, j  2n; 2.  labels two cycles, one starting from a state p  (q0, µ) and one from a
state r  (q0, ); 3. µ,    or   µ, .
The length of the words µ,  and  satisfying the above can be bounded:
4. |µ|, || < ||  O(n3 · 23n).
Proof (Sketch). (=) Let D be the minimum DFA recognizing the language L, with initial state q^0. Recall that D might have up to 2n states. From Theorem

8

G. D'Agostino et al.

1 we know that L is not Wheeler if and only if there exist µ^, ^ and ^ satisfying conditions 1-4 of Theorem 1. Although there is not a perfect correspondence between cycles in A and cycles in D, whenever we find in D a path µ^ (respectively, ^) and a cycle ^ both ending in the same state u^ (v^), we can find in A a path µ = µ^^i ( = ^^j) and a cycle 1 = ^k1 (2 = ^k2 ) both ending in the same state u (v), for some i, j, k1, k2  n. Note that the word ^(n+1)k1k2 labels two cycles starting from u and v. Moreover, we have
|^(n+1)k1k2 |  (n + 1)|^k1k2 |  (n + 1)|^|  (i + 1)|^| > |µ^^i|,
and similarly |^(n+1)k1k2 | > |^^j|. Since |^|  O(23n), we have |^(n+1)k1k2 |  O(n3 · 23n) and therefore the words µ,  and  := ^(n+1)k1k2 satisfy conditions 2-4 of this corollary. Finally, condition 1 is satisfied for all i, j  0 because when reading µi and j on D, they reach different states. (=) As we did while proving the opposite direction, given three words µ, ,  in A satisfying condition 1-3, we can always find, for some i, j, k  2n, three words µ^ = µi, ^ = j and ^ = k in D that almost satisfy condition 1-3 of Theorem 1. The only requirement that might be missing is that µ^ L ^. The upper bound 2n in condition 1 ensures that this requirement is fulfilled, hence we can apply Theorem 1 to conclude that L is not Wheeler.
Despite the fact the the bound in condition 4 has become exponential by switching to NFAs, it is still possible to check in polynomial space (but exponential time) whether there are three words µ,  and  satisfying the conditions of Corollary 1. Thus we can prove the following:
Proposition 1. Given a NFA A, deciding whether the language L := L(A) is Wheeler is PSPACE-complete.
Proof (Sketch). To prove that the problem is in NP, we guess (using nondeterminism) three words µ,  and  satisfying the conditions of Corollary 1. Since this words are too long to be stored, we first guess their length bit by bit and then we guess their characters one by one, starting from the last one and proceeding from right to left. Meanwhile, for all   {µ, , } and for all state t of A, we follow backwards the edges of A labeled as the character of  that we are guessing. This way, we can compute the set of states from which is possible to reach t by reading . This allows us to find, for all i, j  2n, the sets Qiµ := (q0, µi) and Qj := (q0, j). We can then test whether µi L j by confronting the language accepted by the automaton A with set of initial states Qiµ and the language accepted by the automaton A with set of initial states Qi. This can be done in polynomial space since the problem of deciding whether two NFAs recognize the same language is known to be PSPACE-complete.

To prove the hardness of the problem, we show a polynomial reduction from
the universality problem for NFA, i.e. the problem of deciding whether the language accepted by a NFA A over the alphabet  is such that L(A) = . Let A = (Q, q0, , F, ) be a NFA and let L := L(A). We can assume, without

Ordering regular languages: a danger zone

9

loss of generality, that q0  F , otherwise A would not accept the empty word and we could immediately derive that L = . Starting from A, we build in constant
time a NFA A over the alphabet   {a, b, c} that recognizes the language

L := a · (Lc) · L + b · ( + c),

where a, b, c are three characters not in  and such that a  b  c (the order of the characters of  is irrelevant in this proof). If we prove that L =  if and only if L is Wheeler, the reduction is complete and the thesis follows. Notice
that, since   L, the following property holds:

L =   (Lc) · L = ( + c).

(1)

Let us prove that L =  implies that L is not Wheeler. If L = , then by (1) we have L = (a + b)( + c). The minimum DFA recognizing L has only one cycle, therefore from Theorem 1 it follows that L is Wheeler. We next prove that L not Wheeler implies L = . Notice that a-1L = (Lc) · L so that, by (1) if L = , then a-1L = (Lc) · L = ( + c). However we have b-1L = ( + c), thus a L b. Moreover, it can be proved that, for all n, both a L acn and b L bcn hold. Therefore the monotone sequence
ac  bc  ac2  bc2  · · ·  acn  bcn  . . .

is not constant modulo L and from Lemma 1 it follows that L(A) is not Wheeler.

3 Generalized Wheelerness
As we have already pointed out in the introduction, changing the underlying order of the alphabet might turn a Wheeler language into a not Wheeler one and vice versa. For instance, consider again the Wheeler languages Ld and the regular (but not Wheeler) language Lb depicted in Figure 3. If we change the order of  from a  c  d  f to a  d  c  f , the Wheeler language Ld turns into a non-Wheeler language (isomorphic to Lb under the isomorphism  between alphabets that fixes characters a, c, f and sends d into (d) = b). Hence, by not fixing an apriori order of the alphabet  we enlarge the class of languages.
Definition 4 (Generalized Wheelerness). A NFA A over the alphabet  is called a Generalized Wheeler Automaton (GWNFA) if and only if there exists an ordering of the elements of  that makes A Wheeler. A language L is called generalized Wheeler (for short GW) if and only if there exists a GWNFA that recognizes L.
Let A be a WDFA. Then, every word  that labels a cycle in A is primitive (see [2]), that is there exists no  =  and i > 1 such that  = i. A direct consequence of this property is that Wheeler languages form a subclass of star-free

10

G. D'Agostino et al.

languages, i.e. the class of languages that can be defined by a regular expression not containing the Kleene star. Since star-free expressions, and thus star-free languages, are closed under permutations of the alphabet, even GW languages must be a subclass of star-free languages. Here we show that the inclusion is strict, therefore GW languages must be studied separately.
Proposition 2. If ||  2, then the set {L   : L is GW} is a proper subset of {L   : L is star-free}.
Proof. Let a, b be two distinct characters of , and consider the language L = a(aba)a + ba(aba)b. It is possible to prove that L is star-free, but L is not GW: consider the sequence (i)i2 with 2n = a(aba)n and 2n+1 = ba(aba)n. Since, for all i, the word i is a prefix of i+1, independently from how a and b are ordered we have
aaba  baaba  aabaaba  baabaaba  · · ·  a(aba)i  ba(aba)i  . . .
Moreover, for all i we have a(aba)i L ba(aba)i, since a(aba)i · a belongs to L but ba(aba)i · a does not. We can then apply Lemma 1 to conclude that L is not Wheeler. Since this result does not depend on the order of the alphabet, L is not GW.
We mentioned that we can decide in polynomial time whether a DFA is Wheeler. On the contrary, deciding whether a NFA is Wheeler is NP-complete, even when we bound the outdegree of each state of the NFA to be at most 5 (see [12]). As one may expect, deciding whether a NFA is a GWNFA is not easier than deciding whether a NFA is Wheeler. In fact, we show in Proposition 3 that the problem is NP-complete. We actually prove a stronger result in Proposition 4: even deciding whether a DFA is a GWNFA is NP-complete. Since the proof of Proposition 4 is cumbersome, we decided to present also it weaker version, i.e. Proposition 3, which shows a more natural reduction from the problem of deciding whether a NFA is Wheeler. Both proofs can be found in the Appendix. It is worth noticing that the proof of Proposition 3 can be adapted to work even on DFAs, hence giving an alternative way to prove that deciding whether a DFA is a GWNFA is NP-complete. Nonetheless, Proposition 4 is still stronger, since it also proves that deciding whether a DFA recognizes a GW language is NP-complete.
Proposition 3 (GWNFA hardness). Let A be a NFA. Deciding whether A is a GWNFA is NP-complete.
Proposition 4 (GWDFA and GW languages hardness). Let L   be a language and A be a DFA. Both the problems of deciding whether A is a GWNFA and deciding whether L is GW are NP-complete.

4 DFA to WDFA
As discussed in Section 1, a Wheeler automaton can be represented more compactly than a generic finite automaton. Therefore, if we are given a Wheeler

Ordering regular languages: a danger zone

11

language L represented as a DFA A that recognizes L, we may be tempted to look for a WDFA A that recognizes the same language to achieve a better, i.e. more compact, representation. Unfortunately, this approach might not work in our favor: in [1], a family (Lm)m1 of Wheeler languages with the property that the dimension of the minimum WDFA recognizing Lm is exponential in the dimension of the minimum DFA recognizing Lm is presented. Note that we can always assume that, whenever we are given a DFA or a WDFA, the automaton is minimum. In fact, both tasks of minimizing a DFA and minimizing a WDFA can be done in polynomial time (see [9] for DFAs and [1] for WDFAs). Here we answer (positively) to the open question put forward in [1] whether there exists an algorithm to compute the minimum WDFA starting from the minimum DFA. Our algorithm works in exponential time in the worst case and, since the dimension of the output might be exponential in the dimension of the input, is optimal for the task.
Let L = L(A) be the language recognized by the given (minimum) DFA A. Recall that there is a 1 to 1 correspondence between the cL-classes and the states of the minimum WDFA recognizing L. First of all, our algorithm identifies a representative for each cL-class; to be able do this in exponential time, we first need to put a bound on the length of such representatives.
Lemma 2. Let A be the minimum DFA recognizing the Wheeler language L = L(A) over the alphabet , and let C1, ..., Cm be the pairwise distinct equivalence classes of cL. Then, for each 1  i  m, there exists a word i  Ci such that |i| < n + n2, where n := |A|.
Proof (Sketch). Suppose by contradiction that there exists a class Ci such that for all   Ci it holds ||  n + n2, and let   Ci be a word of minimum length. Since A has n states, there must exists a factor of  that corresponds to a cycle in the run of  on A. Let  be the word obtained by erasing such factor from . Since  and  ends in the same state of A, we have  L . From the minimality of  it follows that  cL , therefore there must exists a word  that is not Myhill-Nerode equivalent to  and that is included (co-lexicographically) between  and . We can further assume that the length of  is greater than n2, hence we can identify a common factor of  and  that labels two cycles in the runs of  and  on A. We can then apply Theorem 1 to conclude that L is not Wheeler, a contradiction.
The algorithm works as follow: first of all, it generates the list containing every word of length less than n + n2 that can be read on A. This can be done in exponential time since the list contains at most ||n+n2 words. Then, we order the list co-lexicographically and we apply the following proposition.
Proposition 5 (Minimum DFA to minimum WDFA). Let A be the minimum automaton recognizing L = L(A) with |A| = n, over the alphabet  with || = . Let d := n + n2 and define
Pref(L)d := {  Pref(L) : ||  d}.

12

G. D'Agostino et al.

Assume that we are given the elements of Pref(L)d in co-lexicographic order, i.e. Pref(L)d = {1, ..., k} with i  i+1. Then it is possible to build the minimun WDFA recognizing L in O(k + n2 ·  · m log m) time, where m is the dimension of the output.
Proof (Sketch). From Lemma 2 we know that each cL-class has at least one representative in Pref(L)d. By considering the list [1]L, . . . , [k]L we can spot such representatives: i represents a cL-class if and only if i and i+1 belong to different L-classes or they belong to the same class but their last character is different.
Each representative of a cL-class become a state of our WDFA. To compute the edges of the automaton, we simply check, for all representative  and for all c  , the cL-class of  · c.

5 Conclusions
Having an order on the set of states of an automaton that is consistent with a given order of the underlying alphabet has important implication from a practical point of view. In fact, deterministic or even non-deterministic finite state automata enjoying this property--Wheeler automata--can be used to efficiently analyse the language they accept by standard tools.
In this work we established a few limitations along the directions that one can imagine to take in order to extend the nice properties of Wheeler languages.
More specifically, we proved that adding as a degree of freedom the possibility to re-order the underlying alphabet produces a significantly more complex (NPcomplete) class of languages. In addition, the polynomial test we have for testing whether a language is Wheeler when the latter is presented by a deterministic automaton, turns out much more complex (PSPACE-complete) if the language is presented by a non-deterministic one. The picture is completed by explicitly giving an algorithm that turns a DFA into a Wheeler automaton, whenever this is possible.
Proving the above limitations should clarify the role played by apparently secondary aspects of the definition of Wheeler language. This kind of study should help to better understand the nature of Wheeler languages, with the ultimate goal of singling out any feature that may admit some sort of extension.
Consider, in more general terms, the following open problem: is there a class of automata A properly extending the class of Wheeler automata and such that their deterministic equivalent DA is such that |DA|  poly(|A|)?

Ordering regular languages: a danger zone

13

6 Appendix

Proof of Corollary 1. Let D = (Q^, q^0, ^, F^, ) be the minimum DFA recognizing L. Clearly D has at most 2n states. (=) From condition 2 it follows that µ  Pref(L), so consider the following list of 2n + 1 states of D:
^(q^0, µ0), ^(q^0, µ1), . . . , ^(q^0, µ2n).
Since D has at most 2n states, there must exist two integers 0  h < k  2n such that ^(q^0, µh) = ^(q^0, µk). Therefore k-h labels a cycle starting from ^(q^0, µh). Similarly, there exist 0  h < k  2n such that k-h labels a cycle starting from ^(q^0, h). The words
µ^ := µh ^ := h ^ := lcm(k-h,k-h)·2n ,

where the factor 2n in the definition of ^ ensures that |µ^|, |^|  |^|, satisfy
condition 2 of Theorem 1. Condition 1 of Theorem 1 follows automatically from
conditions 1 of this corollary. Lastly, condition 3 of Theorem 1 follows from
conditions 3 of this corollary and the fact that   µ, . Thus we can apply
Theorem 1 to conclude that L is not Wheeler.
(=) Since L = L(D) is not Wheeler, let µ^, ^, ^ be as in Theorem 1. The DFA D has at most 2n states, hence the length of ^ is bounded by the constant 23n + 2 · 22n + 2n + 2. We have µ^^  Pref(L), so let t0 = q0, t1, . . . , tm be a run of µ^^n over A. We set u := |µ^| and g := |^|, and consider the list of n + 1 states

tu, tu+g, tu+2g, . . . , tu+ng = tm
Since A has n states, there must exist two integers 0  h < k  n such that tu+hg = tu+kg. That is, there exists a state p := tu+hg such that p   q0, µ^^h and ^k-h labels a cycle starting from p. We can repeat the same argument for a run of ^^n over A to find a state r and two integers h, k such that r  (q0, ^^h) and ^k-h labels a cycle starting from r. We can then define the words

µ := µ^^h  := ^^h  := ^lcm(k-h,k-h)·n

which satisfy the conditions 2 and 3.

Condition 4 is satisfied since |^|  23n+2·22n+2n+2 and lcm(k-h, k-h) < n2.

Finally, condition 1 is satisfied for all i, j  0. Indeed, for all l the words µ^ and

µ^^l lead to the same state of D, thus µ^ L µ^^l. Similarly, for all l we also have

^ L ^^l. Since i si such that µi = µ^^si, and similarly, j sj such that

j = ^^sj , the thesis follows from µ^ L ^.



14

G. D'Agostino et al.

Proof of Proposition 1. We prove that checking the conditions in Corollary 1
is in NPSPACE. We can use non-determinism to guess, bit by bit, the length of
µ,  and  and store this guessed information in three counters u, v, g respectively,
using O(n) space for each. We also need to guess the ending states p, r  Q of
µ, . Then we start guessing the characters of µ,  and  starting from their last
one and proceeding backwards toward their first one, checking condition 3 of
Corollary 1 in constant space. Whenever we guess a character of µ (respectively,
, ) we decrease by one the counter u (v, g), so we know when the guessing
stops. If condition 3 is satisfied, we calculate (we will show later how) the sets
(q0, µ), (q0, ), (p, ), and (r, ) and check condition 2, that is, whether p  (q0, µ), r  (q0, ), p  (p, ), and r  (r, ). If condition 2 is satisfied, we consider condition 1: for fixed i, j  2n consider the automata Aiµ and Aj obtained from the NFA L(A) by considering as initial states the sets (q0, µi), (q0, j), respectively. Notice that we have µi L j if and only if L(Aiµ ) = L(Aj ) and checking whether L(Aiµ ) = L(Aj ) can be done in polynomial space, since deciding whether two NFAs recognize the same language is a well-
known PSPACE-complete problem.
To conclude the proof, we claim that we are able to calculate in polynomial space, for all q  Q and for all   {µ, , }, the set (q, ). While guessing
µ character by character, we can compute, for each state q, the set Qµ,q of the states from which is possible to reach q reading µ. To build Qµ,q we start from the set Q0 := {q} and we follow backwards the edges entering q and labeled as the last character of µ. We call Q1 this new set of states and we repeat the process by following backwards the edges entering each state of Q1 and labeled
as the second to last character of µ. Proceeding inductively, we compute the sets Q0, Q1, . . . Qu = Qµ,q; notice that to calculate Qk+1 we only need Qk and the k-th to last character of µ, thus we can update (instead of storing) the set Qk. We can do the same for  and  to compute, for each q  Q, the sets Q,q and Q,q. Once we have stored, for all q  Q and for all   {µ, , }, the sets Q,q, our claim follows easily. For instance, to compute (q0, µ) we build, for all t  Q, the set

Q(t) := {q  Q : t  (q, µ)} =

Qµ,p.

pQ,t

Then we have t  (q0, µ) if an only if q0  Q(t).

To prove the completeness of the problem, we will show a polynomial reduc-
tion from the universality problem for NFA, i.e. the problem of deciding whether the language accepted by a NFA A over the alphabet  is such that L(A) = .
Let A = (Q, q0, , F, ) be a NFA and let L = L(A). We can assume without loss of generality that q0  F , otherwise A would not accept the empty word and we could immediately derive that L = . Let a, b, c be three characters
not in  and such that a  b  c with respect to the lexicographical order
(the order of the characters of  is irrelevant in this proof). First, we build the automaton A starting from A by adding an edge (qf , q0, c) for each final state

Ordering regular languages: a danger zone

15

qf  F , see the top part of Figure 1. Notice that A recognizes the language L = L(A) = (Lc) · L, and it is straightforward to prove that L =  if and
only if L = ( + c): if L = , let  be a word in ( + c) containing n
occurrences of c. Then  = 0 c 2 c . . . n-1 c n for some 1, . . . , n  . Hence   (c) ·  = L. On the other hand, if L =  let  be a word in
 \ L. Then  · c / L.

c

A

c

q0

A

N

A

a

q0

b

q1

, c

Fig. 4. The automaton A. Every accepting state of A, labeled A in the figure, has a back edge labeled c connecting it to q0. Conversly, non-accepting states of A, labeled N in the figure, do not have such back edges.

We build a second automaton A as depicted in Figure 4. Let L = L(A) be the language recognized by A. We claim that L =  if and only if L is
Wheeler. (=) If L = , we have already proved that L = ( + c). Hence we have L = (a + b) · ( + c). The minimum DFA recognizing L has only one loop, therefore by Theorem 1 L is Wheeler. (=) If L = , let  be a word in  \ L. Notice that  =  since we assumed
that   L. Every possible run of  over A must lead to a non-accepting state, hence  · c / L. This implies that for all i  0 we have a · ci ·  · c / L (notice
that the only edge labeled c leaving q0 ends in q0). On the other hand, for all j  0 we have bcj ·  · c  L, hence for all i, j  0 we have aci L bcj. Thus the following monotone sequence in Pref(L)

ac  bc  acc  bcc  · · ·  acn  bcn  . . .

is not eventually constant modulo L. From Lemma 1 it follows that L is not

Wheeler.



16

G. D'Agostino et al.

Proof of Lemma 2. Suppose by contradiction that there exists a class Ci such that for all   Ci it holds ||  n + n2, and let   Ci be a word of minimum length. Consider the first n + 1 states q0 = t0, ..., tn of A visited by reading the first n characters of . Since A has only n states, there must exist 0  i, j  n with i < j such that ti = tj. Let  be the prefix of  of length i (if i = 0 then  = ), let  be the factor of  of length j - i labeling the path ti, ..., tj, and let  be the suffix of  such that  = . By construction, the words  and  :=  end in the same state, hence  L . Moreover, from || < || and the minimality of  it follows that  cL . Suppose that   , the other case being completely symmetrical. Since  and
 share the same suffix , they end with the same character. This means that the words  and , which are Myhill-Nerode equivalent but not cL equivalent, were not split into two distinct cL-classes due to input-consistency, therefore there must exists a word  such that      and  L . Formally, assume
by contradiction that for all words  such that      it holds  L . Then, by definition of cL, it would follow  cL , a contradiction. Let  be a word such that      and  L . From   ,  it follows that   , so we can write  =  for some   . Recall that by construction  =  with ||  n, hence ||  n2. Consider the last n2 + 1 states r0, ..., rn2 of A visited by reading the word , and the last n2 + 1 states p0, ..., pn2 visited by reading the word . Since A has only n states, there must exist 0  i, j  n2
with i < j such that (ri, pi) = (rj , pj). Notice that it can't be ri = pi, otherwise from the determinism of A it would follow rn2 = pn2; from the minimality of A it would then follow  L , a contradiction. Let  be the suffix of  of length n2 - j, and let  be the factor of  of length j - i labeling the path ri, ..., rj. Since ||  n2, there exists    such that  = . We can then rewrite ,  and  as
 =  = 
 =  = 
 =  = .

Let k be an integer such that |k| is greater than || and ||. Set µ := ;

from      it follows that   µ  . If k  µ set  := ,

otherwise set  := . In both cases, the hypothesis of Theorem 1 are satisfied,

since k labels two cycles starting from the states ri and pi, that we have proved

to be distinct. We can conclude that L is not Wheeler, a contradiction, and the

thesis follows.



Proof of Proposition 5. Consider the pairwise distinct equivalence classes C1, . . . , Cm of the equivalence cL. Clearly, the minimum Wheeler automaton recognizing L has m states. We can assume without loss of generality that the
equivalence classes are co-lexicographically ordered, i.e. Ci  Ci+1 for all i < m. For sake of simplicity, given a word    we will write [] to indicate its
equivalence class modulo L, and we will write []W to indicate its equivalence class modulo cL.

Ordering regular languages: a danger zone

17

Let K := {1, ..., k} and, for all i, let Ki := {j  K : [j ]W = Ci}. Since each Ci is convex in Pref(L), each Ki must be convex in K, that is each Ki is an interval. Therefore the list of equivalence classes [1]W , ..., [k]W must be partitioned in consecutive runs of the same class, each class appearing in one and only one run. From Lemma 2 we know that each equivalence class has at least one representative in Pref(L)d, hence the list [1]W , ..., [k]W must contain exactly m runs.
For all 1  j < k, we have [j]W = [j+1]W if and only if
[j] = [j+1]  [j ] = [j+1]  last(j ) = last(j+1) ,
where last() denotes the last character of . This means that we can identify the m runs of the equivalence cL just by looking at the two lists 1, ..., k and [1], ..., [k]: whenever last(j) = last(j+1) or [j] = [j+1], we know that a new cL run must start at j+1. In O(k) we are able to determine the m runs and to pick a representative for each of them, i.e. we can find m indexes i1, ..., im such that for all 1  j  m it holds ij  Ci. We call the set {ai1 , ..., aim } a fingerprint of the language L, i.e. a set of words that has cardinality m such that distinct elements of the set belong to distinct cL-classes.
We show how to build the minimum Wheeler DFA recognizing L, starting from any fingerprint of L and the standard minimum DFA recognizing L. Let {1, ..., m} be a fingerprint of L and let A be the minimum DFA recognizing L. We can assume without loss of generality that 1  ...  m. We build the automaton AW = (Q, 1, , F, ), where the set of states is Q = {1, ..., m} and the set of final states is F = {j : j  L}. The transition function  can be computed as follow. For all 1  j  m and for all c  , check whether j · c  Pref(L). If j · c / Pref(L), there are no edges labeled c that exit from j. If instead j · c  Pref(L), locate j · c using a binary search. There are three possible cases.
1. j · c  1. Then (j , c) = 1. 2. m  j · c. Then (j, c) = m. 3. There exists s such that s j · c s+1. It can not be the case that both
jc L s and jc L s+1, since {1, ..., m} is a fingerprint of L. Hence we distinguish three cases. (a) s L jc L s+1. Then (j , c) = s. (b) s L j c L s+1. Then (j , c) = s+1. (c) s L jc L s+1. Since {1, ..., m} is a fingerprint of L, it is either
c = last(j c) = last(s), in which case (j, c) = s, or c = last(s+1), in which case (j , c) = s+1.


Proof of Proposition 3. The problem is in NP, since we can use non-determinism to guess the order of the alphabet and then check whether such order makes the NFA Wheeler.

18

G. D'Agostino et al.

To prove the hardness, we show a polynomial reduction from the problem of deciding whether a NFA is Wheeler. Let A be a NFA with initial state q0, over the alphabet  = {a1 . . . , a} ordered by the relation a1  · · ·  a. We want to build a new automaton A such that A is a GWNFA if and only if A is Wheeler. A will be an automaton of size |A| + O() over the alphabet  of size O().
The automaton A will be built starting from A and adding extra states and transitions. We define the new alphabet as
 = {a1, . . . , a, x1, . . . , x-1, e, f },
with xi, e, f / , and we add two final states qe and qf . We then build  - 1 gadgets, one for each pair of consecutive characters (ai, ai+1) of , each one connected to A{qe, qf } as depicted in Figure 5. This completes the construction of the automaton A. Notice that A is input-consistent, but in general it is not deterministic.

qi2

ai

qi7

xi

xi

qi3

xi

qi5

e

qe

ai+1

q0

f

xi

qi4

qf

xi

xi

qi1

ai

qi6

Fig. 5. The gadget Gi, connected to q0 and to the sinks qe and qf .
We want to show that A is Wheeler according to the order (, ) if and only if A is a GWNFA. (=) Define the order  over  by setting
a1  ...  a  x1  ...  x-1  e  f. We show that A is Wheeler according to (, ) by ordering its states. Since A is Wheeler, there already exists an order of its states that makes A Wheeler.

Ordering regular languages: a danger zone

19

Therefore, we simply need to extend this order to the states of A. Recall that in [1] it has been proved that a WNFA is Wheeler if and only if, for each pair of states q, p such that Iq = Ip, either Iq Ip or Ip Iq holds, where by definition Iq Ip if and only if, for all   Iq and for all   Ip such that {, }  Iq  Ip, we have   . Therefore we check, for each pair of states q and p in A, that either Iq Ip (implying q < p) or Ip Iq (implying p < q) holds. Note that when Iq and Ip are disjoint, the condition Iq Ip translates to the following: for all   Iq and for all   Ip,    . In the discussion that follows we never compare two states that belong to A, since the order between them is already established.
First of all, we will order, for each i, the states with incoming edge xi. Since xi / , the only states to compare are the one belonging to the gadget Gi, i.e. qi4, qi5, qi6, qi7. Consider the languages
I4 := Iqi4 = xi(xiaixi) I5 := Iqi5 = ai+1xi(xiaixi) I6 := Iqi6 = xixi(aixixi) I7 := Iqi7 = ai+1xixi(aixixi).
Since ai+1  xi we have I4, I5  I6, I7. Moreover, consider any two words   I4 and   I5. If || < ||, we have    hence   . If ||  || instead, then the last || characters of  must be aixi(xiaixi)m, where m is such that  = ai+1xi(xiaixi)m. From ai  ai+1 we still get   , hence I4  I5. Similarly we can prove that I6  I7. It immediately follows that we need to order the states as follows: qi4 < qi5 < qi6 < qi7.
Secondly, for each 1  i   we need to sort the states with incoming edges labeled ai. Note that the automaton A might contain states with incoming label ai and we need to consider such states as well. For i = , the task is easy. The only gadget with a state labeled a is G-1, and such state is q3-1. Notice that Iq3-1 = {a}. Let q be a state of A with (q) = a. Since every word in Iq ends with a, it trivially follows that Iq3-1 Iq. If Iq = {a}, we are forced to set q3-1 < q. If instead Iq = {a}, the order of q and q3-1 does not matter. For sake of consistency, we set q3-1 < q. For i = 1, the only gadget with states labeled a1 is G1, and such states are q11 and q12. Let q be a state of A with (q) = a1 and consider the languages
I1 := Iq11 = x1x1a1(x1x1a1)
I2 := Iq12 = a2x1x1a1(x1x1a1).
For all   Iq, we have either  = a1 or  = aja1 for some    and some 1  j  . In both cases,  must precede co-lexicographically every word of I1 and I2, thus Iq  I1, I2. To compare I1 and I2, consider any two words   I1 and   I2. If || < ||, we have    hence   . If ||  || instead, then the last || characters of  must be a1x1x1a1(x1x1a1)m, where m is such that  = a2x1x1a1(x1x1a1)m. From a1 < a2 we still get   , hence I1  I2. It

20

G. D'Agostino et al.

follows that q11 and q12 must follow q (and all the other states of A with label a1), and we must set q11 < q12. Lastly, if 1 < i <  we should compare the sates qi3-1, qi1 and qi2 with the sates in Qi := {q  A : (q) = ai}. Applying both of the reasoning discussed in the cases i = 1 and i = , we can conclude that the state qi3-1 precedes all the states in Qi and that the states qi1 and qi2 follow all the states in Qi and must be ordered as qi1 < qi2.
The order of the states of A that we described makes A Wheeler with

respect to (, ), hence making it a GWNFA.

(=) If A is a GWNFA, then there exists an order  over  that makes A

Wheeler. Since A is a sub-automaton of A, it follows that even A is Wheeler

according to . Let  be the restriction of  over the alphabet ; we want to

show that  is the same order as . Assume by contradiction that  =. If for

all 1  i <  we have aiai+1, then  =, a contradiction. Hence there exists 1  i <  such that ai+1ai. Since  extends , this implies that ai+1  ai.
We will show that A is not Wheeler according to , a contradiction. Define

the words µ := xi,  := ai+1xi and  := xiaixi. From µ   and ai+1  ai we have µ,   . The word  labels two cycles in A starting from two distinct

states, i.e. qi4 and qi5. Moreover, µ and  label two paths that start from the initial state q0 and end in qi4 and qi5 respectively. Since qi4 and qi5 are not MyhillNerode equivalent, we can apply Theorem 1 to conclude that A is not Wheeler

according to , a contradiction. Thus  and  coincide.

We have shown that A is Wheeler according to , and that  extends .

Therefore we can conclude that A is Wheeler according to .



Definition 5 (Betweenness). Input: a list Y of n distinct elements Y = y1, ..., yn and k < n3 ordered triples (a1, b1, c1), ..., (ak, bk, ck), where each element of each triple belongs to Y . Elements belonging to the same triple are
distinct.
Output: yes/no answer. The answer is "yes" if and only if there exists a total order < of Y such that, for each k, either ak < bk < ck or ak > bk > ck.

Proof of Proposition 4. We can prove that both problems are in NP using an argument similar to the one employed in the proof of Proposition 3.
To prove the hardness, we show a polynomial reduction from the betweenness problem to both of the problems described; we will use exactly the same reduction for both problems. We start from an instance I = (Y, K) of the betweenness problem, where Y is the set Y = {y1 . . . , yn} and K  P(T 3) is a collection of k triples (a1, b1, c1), . . . , (ak, bk, ck), for some 1 < k < n3. We build a DFA A of size O(n + k), over an alphabet of size O(n + k). The alphabet is  = Y  {x1 . . . , xk, e, f }, where we introduce a new character xi for each triple (ai, bi, ci)  K and two extra "ending" characters e and f . To build G, we start with the initial state q0 connected with n states q1, . . . , qn through the edges (q0, yj, qj) for each 1  j  n. We also add two sinks qe and qf , the only final states. We add the states qi1j, qi3j , qi5j (see Figure 6) and the transitions

Ordering regular languages: a danger zone

21

qi5j

bi

qi3j

xi

xi

qj ai = yj

xi

qi1j

e

qe

q0

ci = ym qm

xi

qi2m

f

qf

xi

xi

qi6m

bi

qi4m

Fig. 6. The gadget Gi related to the i-th triple.
(qj , xi) = qi1j , (qi1j , xi) = qi3j , (qi3j , bi) = qi5j , (qi5j , xi) = qi1j
and (qi1j , e) = qe. We repeat the same process with ci: given the integer m such that ci = ym, we add the states qi2m, qi4m, qi6m and the transitions
(qm, xi) = qi2m, (qi2m, xi) = qi4m, (qi4m, bi) = qi6m, (qi6m, xi) = qi2m
and (qi2m, f ) = qf . Lastly, we remove the states among q1, . . . , qn that don't have outgoing edges. More formally, we define the sets A := {a1, . . . , ak} and C := {c1, . . . , ck} and we remove from G all the states qj such that yj / A  C. We show that the instance I = (Y, K) of the betweennes problem is satisfiable if and only if A is a GWNFA, if and only if L(A) is GW. (=) Since I = (Y, K) is satisfiable, there exists an ordering  : Y  {1, ..., n} of the elements of Y satisfying I. We order  as follows:
-1(1)  ...  -1(n)  x1  · · ·  xk  e  f.
This ordering induce a partial order on the states of A, where states with different incoming labels are ordered by such labels. Therefore we only need to order the states of A with the same incoming label. For each 1  i  k, the only states of A with incoming label xi are qi1j, qi3j , qi2m, qi4m, where j and m are integers such that ai = yj and ci = ym. Since, by construction, the order  satisfies the instance I, then only two cases can occur: either (ai) < (bi) < (ci), or (ci) < (bi) < (ai). In the first case, we set qi1j < qi2m < qi3j < qi4m. To realize that this is in fact the correct order of the

22

G. D'Agostino et al.

states, consider the following languages:

I1 := Iqi1j = {   : (q0, ) = qi1j } = aixi(xibixi)
I2 := Iqi2m = cixi(xibixi)
I3 := Iqi3j = aixixi(bixixi)
I4 := Iqi4m = cixixi(bixixi).
Since, by construction, we have ai, bi, ci  xi, it follows that I1, I2  I3, I4. Moreover, from (ai) < (bi) < (ci) we also have that I1  I2 and I3  I4, which completes the ordering. Symmetrically, if (ci) < (bi) < (ai) then we set qi2m < qi1j < qi4m < qi3j . We still need to order the states of A whose incoming labels belong to Y . For each 1  p  n, the states with incoming label yp belong to the sets V5 := {qi5j : bi = yp} or V6 := {qi6m : bi = yp} or Vp, where Vp = {qp} if qp is a state of A (i.e. if yp  A  C) and Vp =  otherwise. If Vp = {qp}, we set qp as the smallest state. We then sort the states of V5 and V6 by their first subscript; when the first subscript is equal, i.e. the two states that we want to confront are qi5j and qi6m (with ai = yj and ci = ym), then we set qi5j < qi6m if (ai) < (bi) < (ci) and we set qi6m < qi5j if (ci) < (bi) < (ai). This can be deduced by confronting the following languages:

I5 := Iqi5j = aixixibi(xixibi) I6 := Iqi6m = ci xi xi bi (xi xi bi ).

If i < i then, by construction, we have xi  xi , hence I5  I6. Symmetrically, if i < i then we have I6  I5. Lastly, if i = i then the order between I5 and I6

is determined solely by ai and ci = ci.

Since there is only one state with incoming label e and only one state with

incoming label f , we have finished. The order described makes A Wheeler, thus

A is a GWNFA and L(A) is GW.

(=) Assume that the instance I = (Y, K) of the betweenness problem is un-

satisfiable. We prove that L(A) is not GW. Assume by contradiction that L(A)

is GW, then there exists an ordering  of the elements of  such that L(A)

is Wheeler according to said order. Recall that Y   and consider the or-

der  := |Y . Since (Y, K) is unsatisfiable,  must violate one of the constraints, i.e. there exists an 1  i  k such that either (ai), (ci) < (bi) or

(bi) < (ai), (ci). Define the words µ := aixi,  := cixi and  := xibixi; then it is either µ,    or   µ,  (here the co-lexicographic order  is calculated

with respect to ). By construction,  labels two cycles in A starting from two

distinct states, qi1j and qi2m, which are not Myhill-Nerode equivalent. Moreover, µ and  label two paths that start from the initial state q0 and end in qi1j and qi2m respectively. We can then apply the Theorem 1 to conclude that L(A) is not Wheeler according to , a contradiction. Therefore L(A) is not GW, which

automatically implies that A is not a GWNFA.



Ordering regular languages: a danger zone

23

References

1. Alanko, J., D'Agostino, G., Policriti, A., Prezza, N.: Regular languages meet prefix sorting. In: Proceedings of the 2020 ACM-SIAM Symposium on Discrete Algorithms. pp. 911­930 (2020). https://doi.org/10.1137/1.9781611975994.55,
https://epubs.siam.org/doi/abs/10.1137/1.9781611975994.55 2. Alanko, J., D'Agostino, G., Policriti, A., Prezza, N.: Wheeler Languages. CoRR
arXiv:2002.10303 (Feb 2020) 3. Alanko, J., Gagie, T., Navarro, G., Benkner., L.S.: Tunneling on wheeler graphs
arXiv:1811.02457 (2019) 4. Backurs, A., Indyk, P.: Which regular expression patterns are hard to match?
CoRR arXiv:1511.07070 (2016) 5. Equi, M., Grossi, R., Mäkinen, V.: On the complexity of exact pattern matching
in graphs: Binary strings and bounded degree. CoRR arXiv:1901.05264 (2020) 6. Equi, M., Mäkinen, V., Tomescu, A.I.: Graphs cannot be indexed in poly-
nomial time for sub-quadratic time string matching, unless seth fails. CoRR arXiv:2002.00629 (2020) 7. e G. Thierrin, H.J.S.: Ordered automata and associated languages. Tamkang J. Math (5), 9­20 (1974) 8. Gibney, D., Hoppenworth, G., Thankachan, S.V.: Simple reductions from formulasat to pattern matching on labeled graphs and subtree isomorphism. CoRR arXiv:2008.11786 (2020) 9. Hopcroft, J.E.: An n log n algorithm for minimizing states in a finite automaton. Tech. rep., Stanford University (1 1971) 10. Potechin, A., Shallit, J.: Lengths of words accepted by nondeterministic finite automata. CoRR arXiv:1802.04708 (2018) 11. Prezza, N.: On locating paths in compressed tries. arXiv:2004.01120 (2020) 12. e Sharma V. Thankachan, D.G.: On the hardness and inapproximability of recognizing wheeler graphs. In: 27th Annual European Symposium on Algorithms, ESA 2019, September 9-11, 2019, Munich/Garching, Germany. pp. 51:1­51:16 (2019). https://doi.org/10.4230/LIPIcs.ESA.2019.51,
https://doi.org/10.4230/LIPIcs.ESA.2019.51 13. Travis Gagie, Giovanni Manzini e Sirén, J.: Wheeler graphs: A framework for bwt-
based data structures. Theoretical computer science 698, 67­78 (2017)

