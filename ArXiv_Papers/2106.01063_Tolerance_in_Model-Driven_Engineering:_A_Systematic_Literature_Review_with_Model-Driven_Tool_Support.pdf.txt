Tolerance in Model-Driven Engineering: A Systematic Literature Review with Model-Driven Tool Support
Nils Weidmann, Suganya Kannan, and Anthony Anjorin Paderborn University, Paderborn, Germany
IAV GmbH Ingenieurgesellschaft Auto und Verkehr, Berlin, Germany

arXiv:2106.01063v1 [cs.SE] 2 Jun 2021

ABSTRACT Managing models in a consistent manner is an important task in the field of Model-Driven Engineering (MDE). Although restoring and maintaining consistency is desired in general, recent work has pointed out that always strictly enforcing consistency at any point of time is often not feasible in real-world scenarios, and sometimes even contrary to what a user expects from a trustworthy MDE tool. The challenge of tolerating inconsistencies has been discussed from different viewpoints within and outside the modelling community, but there exists no structured overview of existing and current work in this regard. In this paper, we provide such an overview to help join forces tackling the unresolved problems of tolerating inconsistencies in MDE. We follow the standard process of a Systematic Literature Review (SLR) to point out what tolerance means, how it relates to uncertainty, which examples for tolerant software systems have already been discussed, and which benefits and drawbacks tolerating inconsistencies entails. Furthermore, we propose a tool-chain that helps conducting SLRs in computer science and also eases the reproduction of results. Relevant meta-data of the collected sources is uniformly described in a textual modelling language and exported to the graph database Neo4j to query aggregated information.
KEYWORDS tolerance, model-driven engineering, systematic literature review, consistency management

1. Introduction
In the domain of Model-Driven Engineering (MDE), consistency management is an important challenge when multiple semantically interrelated models are to be developed and maintained simultaneously. Consistency management involves multiple operations on models, such as (unidirectional) transformation, (concurrent) model synchronisation (propagating changes between models), and consistency checking. Up until now, fundamental research has focussed on preserving or restoring perfect consistency between the involved models when performing such operations on them. While eventually having consistent models in a software system is a desirable goal in general, several limitations reveal an apparent need for some form of faulttolerance in practice. In prior work, Stevens (Stevens 2014) argues for tolerating inconsistencies by listing several convincing scenarios. In the simplest case, the underlying consistency relation is partial, which means it is not always possible for a model management tool to return a consistent pair of models. In more complex cases, a consistent solution might exist, but the tool might not be able to return it, e.g. due to time restrictions.

There might be various consistent solutions, but it might be neither satisfactory to choose one of them at random, nor to present (potentially thousands of) equally good solutions to the user to choose one. Closely related, but yet significantly different, is the concept of uncertainty in models (Famelis et al. 2012a). In contrast to (temporarily) working with imperfect models, support for working with uncertainty allows a range of possible solutions to be encoded into a single model. This can be useful as certain information might be unknown at design time or be about to change during the development process. As approaches proposing support for tolerance and uncertainty tackle similar problems, i.e. increasing the practicability of MDE techniques, it is difficult to draw the line between such approaches.
Although the topic has been addressed in many ways and from different viewpoints (Balzer 1991; Egyed 2006; Stevens 2014; Guerra & de Lara 2018), there does not yet exist an overview of research on tolerance in MDE. Such an overview would facilitate further research for several reasons: First of all, it can collect and aggregate already achieved results and thereby unify definitions, establish common examples, and mo-

1

tivate research that has been left open. Second, fault-tolerance is a problem with a much broader scope than software modelling. Proposed definitions, examples, and (dis-)advantages might originate from other software engineering domains. In the database community, for example, there has been long-term research on maintaining and restoring consistency, and performing operations in the presence of errors (Decker & Martinenghi 2011; Decker 2017). Consequently, to avoid reinventing the wheel, research from related fields should be taken into account, as long as it matches the problem domain and transferring results to MDE is possible. To achieve these goals, an overview of existing research should provide a proper definition of tolerance and delineate between the terms tolerance and uncertainty. A collection of formal and practical frameworks should be identified that support handling of fault-tolerance in software modelling. To motivate tolerant system behaviour, a range of plausible examples is essential, which can be used in future approaches to facilitate comparison to existing work. Finally, a critical discussion of taking tolerance into account when modelling software systems should also be included to identify opportunities and risks that are inherent to tolerant approaches.
To address these requirements, we present the results of a Systematic Literature Review (SLR) on tolerance in MDE conducted from October 2019 to September 2020 following the standard methodology proposed by Kitchenham et al. (B. Kitchenham 2004; B. A. Kitchenham et al. 2009). With this review, we particularly aim at answering the following research questions:
RQ1 Scope and Classification: How is (in)consistency defined? How do tolerance and uncertainty differ? What makes an approach or tool tolerant? Which different dimensions of tolerance are there and how can tolerance be classified?
RQ2 Examples and Application Domains: In which application domains is tolerance relevant? Which examples are used to demonstrate ideas and results?
RQ3 Benefits and Challenges: What are the benefits of tolerance? What are open questions and challenges?
As a second contribution, we propose a framework that supported us while conducting this SLR and which can be reused for creating future literature reviews in computer science. In consensus with previous findings (Götz 2018), we noticed that SLRs in general are conducted with little or no tool support (or at least lack a respective description), although they involve numerous steps that could be automated, leading to unnecessary manual effort. Likewise, it also requires a substantial amount of work to reproduce the results of an SLR, leading to opacity of findings due to time restrictions. The gathering and reproduction of results should thus be eased to better utilise human resources for tasks that require advanced knowledge of the problem domain. We propose a tool-chain for partly automating the review process, which involves an adapter for querying the research database, a transformation of the results to a modelling language processable by eMoflon::Neo1, a model management tool that is a recent addition to the eMoflon tool suite (Weidmann et al.
1 https://github.com/eMoflon/emoflon-neo

2019), and an export to the graph database Neo4j2, which can be queried to analyse the results.
The remainder of this paper is structured as follows: Section 2 describes the survey procedure and sketches the used tooling. Summaries of the answers to the research questions are provided in Sect. 3, 4 and 5 (a more detailed tabular overview is available online3). Section 6 briefly analyses meta-data of the included sources and motivates further research on tolerance in MDE. Section 7 gives an overview of related work, before Sect. 8 concludes the paper.
2. Survey Procedure
This section briefly presents the methodology we followed to conduct the SLR. As all results should be reproducible and easily accessible for researchers of the modelling community, we therefore followed the guidelines proposed by Kitchenham et al. (B. A. Kitchenham et al. 2009) for literature reviews in the software engineering domain. The review was conducted from October 2019 to September 2020 and considers sources published until June 2020. We used DBLP as a research database due to its large amount of listed publications, its focus on computer science, and its well-described API for automated queries.4 Following the proposed guidelines, an initial and a final set of sources was determined by applying search phrases, and criteria for inclusion, exclusion, and quality of the gathered sources, described in the following.
To form an initial set of sources, we defined six search strings inspired by the research questions and the domain MDE, of which at least two must appear in a title. Each of these strings has a wildcard (*) as suffix to take nouns, verbs and adjectives into account. We therefore decided to query the database with all pairs formed from the search strings model*, consisten*, inconsisten*, uncertain*, tolera* and flexib*. As a combined inclusion and quality criterion, we further require the respective sources to be published at a conference listed by the CORE ranking5 and assigned to the research field 0803 (Software Engineering). Due to this requirement, the search is focussed on the software engineering domain and peer-reviewed publications, while journal and workshop papers are initially excluded. Due to the publishing behaviour in the computer science domain, we expect late-breaking research results to be published at conferences, whereas journal articles usually extend previously published results of conference papers in more depth. Furthermore, the list of journals at CORE6 was outdated when the review was conducted, making it difficult to apply equal criteria to journal and conference papers in the initial search step. Workshop papers often present work in progress and initial ideas to be published at conferences afterwards. To detect relevant papers which do not fulfil all criteria of the initial search, we applied snowballing at a subsequent step. In this manner, we retrieved 268 sources, which we denote in the following as core papers.
2 https://neo4j.com/ 3 https://drive.google.com/file/d/1uSuOn3hX5BHpLhw3jaH2ZpVffgTxHOov 4 https://dblp.uni-trier.de/faq/13501473.html 5 http://portal.core.edu.au/conf-ranks/ 6 http://portal.core.edu.au/jnl-ranks/

2 Weidmann et al.

To compile a final set of sources, we distributed the core papers between three researchers and assessed their relevance based on the abstract. In case it remained unclear if the respective paper should be considered, introduction and conclusion were read as well. As suitable examples demonstrating the use of tolerant system behaviour are essential to answer RQ2, the remaining parts of the papers were skimmed for such examples. The assessment was based on inclusion, exclusion, and quality criteria. A paper was included in the further review process if it (1) presents an MDE or Programming Languages (PL) approach related to (in)consistency management, or (2) if it contains an example or application related to tolerance or uncertainty. We excluded a paper if any of the search terms has a different meaning than the one implied by the research questions, e.g. if model refers to the physical behaviour of a Cyber-Physical System (CPS). Papers written in other languages than English were also excluded, while this criterion never had to be applied, probably due to the choice of search strings. To ensure a high quality of the selected sources, prefaces and extended abstracts were excluded. In total, 114 relevant core papers were identified and added to the final set of sources.
In a second iteration, we applied snowballing to consider papers that were not detected in our first iteration but might be nonetheless relevant to answer the research questions. The corpus of this SLR was extended by all sources which are cited by at least one of the core papers, resulting in 3201 additional papers. To keep the number of paper for the second assessment phase manageable, we added a further inclusion criterion for these additional papers: a minimum citation count by relevant core papers, as papers cited more frequently are more likely to be relevant. As newer sources naturally have a lower citation count, the number of required citations was set in relation to the publication year. As papers published at Software Engineering (SE) venues should be preferred, the minimum citation count per year was set to 0.2 for SE papers and to 0.3 for all other papers. As a result, 53 papers from SE venues and 41 papers from other venues were evaluated according to the same inclusion, exclusion, and quality criteria as the core papers. After the second assessment phase, 23 papers from SE venues and 20 other sources were added, increasing the final set of sources to 157 papers. An overview of our assessment and selection process is depicted in Tab. 1. For each property, a check () means that it is fulfilled by the respective category of papers, whereas a cross () means the opposite. If the property is irrelevant, this is indicated by a hyphen (-). The rightmost two columns contain the number of papers per category identified as (not) relevant.

 2 keywords in title?    -

published at an SE venue?
    

min. annual citation count
 0.2 < 0.2  0.3 < 0.3

initially read?
    

rele- not re-

vant levant

114 154

23

30

0

1093

20

21

0

2014

Table 1 Categorization of papers for the review

Although the survey procedure is well-defined and takes multiple objective measures into account in order to make results transparent and reproducible, several threats to validity have to be mentioned as well. Firstly, the naming conventions for conferences in the DBLP database and in the CORE ranking differ slightly. To overcome this problem, we matched the respective conferences if their acronym is the same, or if one name is a substring of the other. This method works well for venues listed in the latest version of the CORE ranking but, as conferences are renamed over time, older venues might not be identified as SE venues. While prefaces and extended abstracts were excluded, no distinction was made between different paper categories, such as full, short or tool paper. Even though late-breaking results are usually published as conference papers in the computer science domain, we might have missed results only published in journal papers, as those were not considered in the first assessment phase. Besides DBLP, the use of other research databases - such as Google scholar - could have helped to gather more sources for the SLR and to therefore minimise the risk of missing important work. Finally, although inclusion, exclusion and quality criteria were discussed between the involved researchers in detail before the review was conducted, only one researcher per paper evaluated its relevance, which might lead to biased results as the assessment of relevance depends on a single person.
Figure 1 SLR Metamodel
In Fig. 1, the metamodel for the representation of results is depicted. A Paper is written by Authors and appears at a Venue. For each Paper, the title and the year of publication are extracted. Boolean values indicate whether the paper is a core paper, and whether it was identified as relevant for the SLR in the initial reading phase. A cites relation defines which Paper references which other Papers. For the Author, only the name is stored, whereas the Venue is additionally flagged as being an SE conference listed at DBLP or not. In Fig. 2, the architecture for transferring the bibliography data records to a graph database is depicted. The DBLP research database provides an interface to query records that match a specified search string containing logical connectors and wild cards. Additionally, we exported the list of venues assigned to the research field 0803 (SE) as a Comma-Separated Values (CSV) file. For each possible pair of the six keywords, the database was queried and its venue was compared to the list of SE venues. In this way, the core papers

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 3

for this SLR are identified and saved as models typed over the metamodel of Fig. 1. After examining each of the core papers regarding its relevance for the research questions, the respective attribute was manually added in the bibliography model. In the last step, the files were exported from eMoflon::Neo to Neo4j (cf. Sect. 1), such that queries on the bibliography model can be used to analyse the collected data.
Figure 2 Component Diagram: Tool-chain
An important argument for the use of a database representation for the SLR was the snowballing step, which is - depending on the number of relevant papers - a time-consuming and errorprone task. To integrate citation information into the database, all papers referenced by the core papers were added via the database snapshot DBLP-Citation-network V127 which was created with the tool ArnetMiner (Tang et al. 2008). Having extended the bibliography model with all papers cited from the initial set of sources, it is possible to collect all papers that fulfil the condition for being added within the snowballing step with a single database query.
3. Scope and Classification
In order to answer the first research question, definitions for the key terms of this SLR were gathered and aggregated while analysing the relevant sources. Besides a brief summary, feature models for consistency (Fig. 3), tolerance (Fig. 4) and uncertainty (Fig. 5) were created to provide an overview of the different dimensions involved.
3.1. Consistency In general, consistency can be understood as a relation over sets of models, which can be specified in different ways (Stevens 2014; Sabetzadeh et al. 2008; Hamlaoui et al. 2014; Stevens 2018b, 2017, 2018a; Cicchetti et al. 2010). Most frequently, consistency is specified by a provided set of constraints (Kretschmer et al. 2018; Vierhauser et al. 2012; Reder & Egyed 2012a; Shan & Zhu 2004; Sabetzadeh et al. 2007; Lytra et al. 2012; Decker 2011; Mens et al. 2006; Blanc et al. 2008; Egyed et al. 2011; Egyed 2007a; Kretschmer et al. 2017; Egyed et al. 2008; Reder 2011; Leblebici et al. 2017; Krishna et al. 2005; Dávid et al. n.d.; Guerra & de Lara 2018; Jahanbanifar et al. 2016; Shan & Zhu 2006; Lytra et al. 2013; Balzer 1991; Riedl-Ehrenleitner et al. 2014; Egyed 2011; Nentwich et al. 2003; Zolotas et al. 2016; Egyed 2006; Nuseibeh et al. 2000; Xiong et al. 2009;
7 https://www.aminer.org/citation

Link et al. 2001; Burdusel et al. 2019; Babikian et al. 2020; Khelladi et al. 2019; Gogolla et al. 2015; Hegedüs et al. 2011; Reder & Egyed 2013), which can be formulated in different ways. Often, the Object Constraint Language (OCL) is chosen for defining consistency, but also graph constraints and logical constraints, such as formulae of propositional or first-order logic or as Satisfiability Modulo Theories (SMT), are commonly used. Independent of the language in use, a model (or a proposed solution) is typically viewed as being consistent if it satisfies all constraints.
Consistency can also be defined constructively via a given model transformation T, such that two models A and B are consistent if and only if A = T(B) (Wolfe et al. 2009; Macedo & Cunha 2013). Furthermore, multiple model transformations (e.g., syntactic changes) are often considered to be consistent if they implement the same underlying transformation (e.g., semantic change) (Kusel et al. 2015). This is especially relevant in the context of co-evolution, where multiple interrelated transformations are concurrently conducted. There are also constructive definitions which define methodological consistency over the sequence of operations required to construct a model. As long as certain steps are followed in the construction or "design" process, the consistency of the resulting model(s) can be guaranteed (Blanc et al. 2008; Reder & Egyed 2012b). For example, a name must be assigned immediately after an element is created.
Besides these general consistency specifications, some definitions are also tailored to a specific application area. When modelling CPSs, a model is said to be consistent with the real world - or any other system for which this can be checked if the model makes statements or reaches conclusions that are actually true (Kyrkou et al. 2015). For goal-oriented modelling, "plan consistency" means that the achievement of sub-goals implies the achievement of their parent goal (Friedrich 2018). In the application domain of software product line engineering, a feature model is consistent if at least one valid configuration exists (Barreiros & Moreira 2014).
The notions of consistency can be applied to both the intraand inter-model case. For inter-model consistency, multiple models are consistent if they are not in conflict regarding their overlapping parts, i.e., the same information contained in multiple models (Ciraci et al. 2012; Ehrig et al. 2008; Noyrit et al. 2010; Farias et al. 2012). Another important definition deals with the relationship between a model and its meta-model (Perrouin et al. 2009; Rose et al. 2009; Morin et al. 2010; Trollmann et al. 2011; Küster & Ryndina 2007; Guerra & de Lara 2018; Hao et al. 1992; Hili & Sottet 2017; Hili 2016; Schoenboeck et al. 2014; Demuth et al. 2016; Sottet & Biri 2016; Straeten et al. 2003; Burdusel et al. 2019; Babikian et al. 2020; Khelladi et al. 2019; Gogolla et al. 2015; Callow & Kalawsky 2013; Reder & Egyed 2013; Hegedüs et al. 2011). This notion can be handled on two levels: (i) structural consistency includes multiplicities, composition constraints, as well as the types of model elements. (ii) static semantics expressed, e.g. via OCL constraints. Finally, a set of constraints is often denoted as consistent if there exists at least one solution (e.g., a variable assignment) that satisfies all constraints (B. Wang et al. 2010; C. Wang & Cavarra 2009; Gogolla et al. 2009; Hao et al. 1992; Straeten et al. 2003).

4 Weidmann et al.

Figure 3 Consistency in MDE

3.2. Tolerance
Based on the collected definitions of consistency, the term tolerance can be specified more concretely.
Building on the constraint-based definition of consistency, tolerance can be implemented by weakening the requirement of constraint satisfaction (B. Wang et al. 2010; Perrouin et al. 2009; Barreiros & Moreira 2014; Petersen et al. 1997; Reder & Egyed 2012b; Leblebici et al. 2017; Dávid et al. n.d.; Vouk et al. 1990). Solutions that satisfy more important constraints are then "better", i.e., more consistent than other solutions that might satisfy more but less important constraints. Tolerance here is, therefore, basically a ranking or weighting of constraints and a score for solutions based on how many weighted constraints are satisfied. This prioritisation and sorting process is often referred to as "relaxation"; the constraints are sometimes denoted as "soft constraints" as their violation no longer directly implies exclusion of the respective solution. By defining different classes of inconsistencies and measuring consistency as vectors over these dimensions, one can obtain a more fine-grained view of the extent to which consistency is achieved or improved with respect to each class (Yu & Vahdat 2000; Kolovos et al. 2008). A similar approach divides the constraints or requirements into primary and non-primary, whereby non-primary constraints can be ignored in a tolerant scenario (Höllrigl et al. 2010; Reder 2011). The idea is to ignore inconsistencies that are "irrelevant", e.g., concerning white space or time stamps, layout, etc.
Another important group of strategies for implementing tolerance involve temporal aspects. Most approaches assume that inconsistencies can be tolerated up to some point in time when consistency is restored, such that fixes are delayed up to this point (Höllrigl et al. 2010; Yu & Vahdat 2000). For distributed systems, a variable threshold for inconsistencies is defined by a temporal window such that more inconsistencies are accepted at the beginning and fewer towards the end. These approaches aim at letting a system "stabilise" before demanding a high level of consistency.
In contrast to temporal strategies, a further group takes a spatial approach to implementing tolerance: case-based restoration guarantees that every part of the model that was consistent before is still consistent afterwards (Stevens 2014; Decker & Martinenghi 2008; Decker 2011; Stevens 2017; Egyed 2006; Balzer 1991). For efficiency reasons, only a subset of "relevant" cases can be determined, i.e., a scope of influence is com-

puted for changes, and then checked as for case-based restorers. Measure-based restorers guarantee that a chosen measure of consistency is not reduced by the restoration process.
A frequently named property of fault-tolerant systems is that strategies are implemented to detect and fix inconsistencies either automatically or by interacting with the user (Hamid & Mosbah 2005; Egyed et al. 2008; Guerra & de Lara 2018; Bagheri & Ghorbani 2007; Ebnenasir & Cheng 2007; Egyed 2007b; Link et al. 2001; Egyed 2011; Vouk et al. 1990). Even if a system is brought into an inconsistent state, it can transition back to a consistent state by applying fix strategies. Consequently, an inconsistent state is temporarily acceptable, making it unnecessary to check if edits are consistency-preserving, or to propagate changes to other models immediately. However, it is often important to keep track of inconsistent model parts as this can speed up the consistency restoration later. In case of user involvement, this can also help to avoid overwhelming users with too many design decisions.
Overall, tolerant concepts can help ease the work flow for modelling tasks by not enforcing an immediate resolution of inconsistencies. Additionally, they can function as a mechanism to detect unresolved conflicts in the real world, or to rethink prematurely made design decisions (Nuseibeh et al. 2000). Finally, tolerating and highlighting inconsistencies can be used to indicate misunderstandings or a potential disagreement of the involved developers (Xiong et al. 2009).
3.3. Uncertainty
To help make a distinction between tolerance and uncertainty, we provide an overview of the most common notions of uncertainty in the following.
Modelling with uncertainty often involves encoding a range of possible values or alternatives into a single attribute value or part of a model (Gao et al. 2011; Brambilla et al. 2017; Bucaioni et al. 2016; Famelis et al. 2015; Eramo et al. 2015; Famelis & Santosa 2013; Bagheri & Ghorbani 2007; Famelis et al. 2012a; Prasetya & Klomp 2019; Hansen & Thomsen 1999; Martinho et al. 2008). Additionally, the set of valid combinations of these parts must also be defined, which can possibly increase or reduce the range of valid alternatives. As a result, the designer is provided with a compact but expressive representation of all solution candidates. Furthermore, modelling with uncertainty can mean a probabilistic extension of a normal model made by

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 5

Figure 4 Tolerant MDE

adding probabilities to every assumed value, which are mostly attribute values (Kyrkou et al. 2015; Vallecillo et al. 2016; Cheng et al. 2009; Mayerhofer et al. 2016; Tran & Massacci 2014). These probabilities are often referred to as confidence values.
Uncertainty can be used in different phases of the modelling process, and there are multiple strategies to eventually resolve uncertainty (Förster & Schneider 2010; Famelis & Santosa 2013; Camilli et al. 2018; Hansen & Thomsen 1999; Bamgboye et al. 2018; Famelis et al. 2013; Garlan 2010; Camilli et al. 2017; Ibrahim et al. 2009). The lack of information about the content of models is denoted as design-time uncertainty, which makes it impossible to select among alternative design decisions. This uncertainty can be captured in partial models consisting of a "base model" enriched with annotations that express the set of alternatives (Salay, Chechik, & Horkoff 2012; Salay, Famelis, & Chechik 2012; Famelis et al. 2012b). By refining the partial model, uncertainties can be resolved during the design phase (Salay, Chechik, & Gorzny 2012). The residual uncertainty is denoted as run-time uncertainty and is resolved by the user via a selection out of all remaining alternatives.
Different sources of uncertainty can be distinguished regarding multiple dimensions (Camilli et al. 2017; Goldsby & Cheng 2008; Ghezzi et al. 2013; Ramirez et al. 2012; Serban et al. 2020; Esfahani & Malek 2010; Zhang et al. 2019, 2017). The source of uncertainty can either be the system itself or its execution environment. System uncertainty includes uncertainty about input parameters, structural and algorithmic uncertainty due to approximations, or experimental uncertainty caused by variable measured values. Environmental uncertainty can originate from incomplete information about the behaviour of external components, which are provided by third-party organisations, or input data provided by sensors or wireless networks. Furthermore, the root cause of uncertainty can either be the lack of knowledge about one of the aforementioned factors or some non-determinism within the system. In general, as uncertainty forces the developer to make decisions based on assumptions, one is not able to guarantee the optimality of those decisions, involving various trade-offs.
In summary, modelling with uncertainty denotes a way of efficiently encoding multiple alternatives into a single representation, from which at least one valid, i.e. consistent, configuration should be derivable. Tolerance, in contrast, means being able to perform operations on models in the presence of incon-

sistencies, while the ultimate goal is still to eventually reach a consistent state. Both concepts aim at facilitating the work flow of system designers and developers by aligning the principles of MDE to practical requirements. Likewise, both tolerance and uncertainty involve a combination of automated and usercentric resolution strategies to finally obtain an unambiguous and consistent model.

4. Examples and Application Domains
This section gives an overview of examples related to tolerance and uncertainty in different application fields. Although the underlying notion for consistency is essential for understanding the proposed approaches to tolerating inconsistencies (cf. Sect. 3), the presented examples and mentioned (dis-)advantages mostly refer to concepts of tolerance and uncertainty building up on it. Instead, we also found examples and arguments for flexibility as a general term subsuming tolerance and uncertainty, such that we devote a further subsection to it in the following.

Research Domain

#

Research Domain

#

Aspect-oriented modelling 3

Process Modelling

4

(Meta-)model Co-Evolution 4 Product Line Engineering

7

Cyber-Physical Systems

7 Requirements Engineering

9

Databases

5 Service-Oriented Computing 3

Distributed Systems

4 Smart & Adaptive Systems 10

Language Engineering

4

Software Architecture

4

Mobile & Cloud Computing 3 Software Engineering (Other) 5

Model-Based Testing

7

Software Verification

4

Model-Driven Engineering 74

TOTAL

157

Table 2 Number of relevant papers per research domain

In Tab. 2, the number of relevant sources per research domain is depicted. Most of the sources are related to MDE and similar fields, such as co-evolution, model-based testing, process modelling, and aspect-oriented modelling. Especially uncertainty appears to play an important role for requirements engineering and adaptive systems. The relatively large number of papers concerning other sub-domains of software engineering such as language engineering, product line engineering, software

6 Weidmann et al.

Figure 5 Modelling with Uncertainty

architecture and service-oriented computing underpins the importance of tolerance and uncertainty for the entire field of research. Cyber-physical and distributed systems, as well as mobile computing, can be identified as relevant application domains due to the substantial impact of environmental conditions involved. Several papers concern multiple research domains, such that a prioritisation was necessary in these cases: When MDE concepts were applied to a concrete use case, the paper was allocated to the application domain. For papers which can be matched to different software engineering domains, the main focus was taken as decisive factor.
From the set of relevant sources 36 examples could be extracted, which can be used to illustrate approaches to tolerance, uncertainty, flexibility, or consistency management in general. 23 examples focus on a conceptual approach, 6 are used for tool demonstrations, and 7 cover both purposes equally. In the following, examples for tolerance, uncertainty, and flexibility are briefly sketched; a complete list including examples for consistency management and further classifications can be found online8.
4.1. Tolerance
A frequently used example for tolerance is a simplified videoon-demand system modelled with Unified Modeling Language (UML) diagrams (Egyed et al. 2011; Egyed 2007a; Kretschmer et al. 2017; Egyed et al. 2008; Reder & Egyed 2012b; Egyed 2007b, 2011, 2006; Xiong et al. 2009; Khelladi et al. 2019). The system consists of a streamer retrieving and decoding the content, and a display showing the video and receiving user input. Each component is modelled with a state chart diagram, in addition to a common class and sequence diagram for both components. Design rules describe the semantic interrelations between state charts, class diagram, and sequence diagram, e.g. that a class method name be equal to the corresponding message name in the sequence diagram, or that a message sequence match the behaviour in the state chart. As a software tool cannot decide if the effects of fixing inconsistencies, probably introduced when changing one model, are desirable or not, a tolerant treatment is suggested.
Tolerating inconsistencies has been a long-term research topic for databases, which is illustrated by an example dealing
8 https://drive.google.com/file/d/1uSuOn3hX5BHpLhw3jaH2ZpVffgTxHOov

with a project management tool storing information about the utilisation of employees for projects, as well as how many hours per week they should work (Balzer 1991). Constraints ensure that the sum of hours an employee works in all projects is equal to their regular working hours. The time an employee is needed for a project is maintained by project managers, whereas the regular working hours can only be changed by the business office. It is, therefore, not possible to change project plans or working hours without temporarily introducing inconsistencies.
In the requirements engineering domain, requirements can be described with model fragments that conform to a core requirements metamodel (Perrouin et al. 2009). The complete specification for a library management system, in which books must be registered such that customers can borrow them, can be created by fusing all fragments into one model. As this procedure can clearly lead to inconsistencies and the loss of meta-model compliance, it is necessary to temporarily relax the metamodel regarding abstract classes, multiplicities, and containment relations. Metamodel conformance is later restored by fixing the remaining inconsistencies.
The DOPLER tool suite (Vierhauser et al. 2012) is used in software product line engineering for sales support systems for product configuration. Based on Eclipse, the tool is able to manage consistency between a variability model, a calculation model, and document templates. All models can be edited in parallel via suitable editor windows. Inconsistencies are tolerated in a way that their immediate resolution is not enforced, but occurring problems are listed in the Eclipse error viewer.
Adaptive systems have to cope with the impact of environmental conditions; this is also reflected in their software models. For flood warning systems, it is important to predict floods as early as possible to reduce damage (Goldsby & Cheng 2008). In a distributed system of sensors, water depth is calculated with pressure sensors, while flow speed is determined with camera sensors. The sensor nodes transmit the information to a gateway node, which forwards the predictions to an off-site server. The system needs to be fault-tolerant because signals can get lost, nodes can get disconnected, etc. Uncertainty is also involved regarding the execution environment and an appropriate tradeoff between functional behaviour (e.g. prediction accuracy) and non-functional characteristics (e.g. energy efficiency) for changing environmental conditions.

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 7

4.2. Uncertainty
Another use case for systems that dynamically adapt to uncertain environmental conditions is a smart phone app for shop reviews, which provides users with information about lower prices for a product (Ghezzi et al. 2013). The product's bar code is scanned with the camera to identify the product, and the user's position is determined to make suggestions for nearby shops, while an online search in web shops is performed simultaneously. However, the quality of the photo, the positioning system and the availability of mobile data represent sources of uncertainty that have to be taken into account when modelling the system.
Uncertainty in model-based testing is demonstrated by testing UML specifications for a video conference system (Ji et al. 2018). The models store information about the number of connected participants and the video quality. Changing environmental conditions, such as packet loss in the network, or joining and leaving participants, are the primary sources of uncertainty.
The use of type systems can be substantially influenced by the uncertainty of measured values. In an illustrative case study, a toy car drives along a straight track, which is partitioned into multiple sections. Within this set-up, the car's velocity and acceleration on each of the sections (Mayerhofer et al. 2016) should be computed. The system model involves uncertainty regarding the length of the sections (at design-time) and the time measurements (at run-time). Besides these absolute values, also relative values, such as the velocity and acceleration of the car, are uncertain.
Several small-scale but useful examples for modelling with uncertainty originate from MDE research itself. In an ecommerce application for selling books, data about books, authors, comments on the books, and details on books and authors is shown to the user (Brambilla et al. 2017). A user interaction model specifies how a user can navigate between the respective views with help of the Interaction Flow Modeling Language (IFML). Due to a combinatorial explosion, it is challenging to evaluate all possible alternative flows with usability tests. Integrating uncertainty in IFML models, however, can help to specify a compact encoding of all these alternatives.
Code refactorings can be expressed in software models in terms of transformation rules. This becomes especially challenging for models incorporating uncertainty (Famelis et al. 2012b). To explain transformation semantics on uncertain models, it is assumed that a modeller might not be sure whether an attribute should be added to the subclass or the superclass of an inheritance hierarchy. Furthermore, the model is to be refactored by adding get- and set-methods to both classes, which leads to an exponential growth of possible results, demonstrating the need for a compact encoding of uncertain values.
In a fictional automotive design project, modelling with uncertainty is motivated for UML class diagrams. The three involved classes represent controllers for engine, body, and security of the car (Salay, Chechik, & Gorzny 2012). Similarly, a perception system for autonomous driving is used to demonstrate uncertainty occurring during object detection and position determination in a scene (Serban et al. 2020). In a partial model (involving design uncertainty), each controller's attributes are modelled as attribute sets, which can be refined to discrete at-

tributes by partial model refinement. Besides attributes, this refinement step can affect the existence of an inheritance relation (e.g. between the classes car and vehicle) or the knowledge if car and vehicle are actually the same class (Salay, Famelis, & Chechik 2012).
Smart home systems provide solutions for intrusion detection with sensors, which are however exposed to uncertainty on several levels. Both imprecise measurements on sensors, the network infrastructure which connects the sensors and the interactions between physical units can be sources of uncertainty, leading to false positives and negatives when triggering alarm signals (Camilli & Russo 2020; Zhang et al. 2019).
The design of an automatic reasoning engine for logical expressions is taken as an example for design uncertainty (Famelis et al. 2013). When the reasoning engine reaches an error state, a solver exception should be thrown, whose concrete implementation has some points of uncertainty. The exception may be an inner class of the solver, or an attribute could possibly provide more information about the error type. A similar example for uncertainty resulting from incomplete requirements is presented via an UML state chart for a bank ATM. Depending on the required level of strictness, the ATM can either be restarted or set to be out of service in case of errors (Eramo et al. 2014).
Finally, a framework for model-based testing under uncertain conditions was presented in recent work (Zhang et al. 2019) to cope with the inherent uncertainty of CPS components. Connecting it to a test ready model evolution framework (Zhang et al. 2017), it is possible to generate further test cases for CPSs from evolved models.
4.3. Flexibility
Some of the considered examples illustrate the use of flexibility in software modelling, which can be seen as a generalisation of concepts including both tolerance and uncertainty. Motivating examples for flexibility with respect to metamodel conformance are proposed in co-evolution scenarios. When keeping class diagrams and relational databases consistent (Kusel et al. 2015), refactorings on the metamodel make it necessary to adapt the transformation definition and the models, which should comply to this modified metamodel. As common examples for refactorings, deleting or moving attributes to other classes, introducing inheritance relations, or renaming references are listed.
In a similar setting, a family register is to be kept consistent with a persons register (Sottet & Biri 2016), such that, for example, the first and last name of a family member should be consistent with the full name of the corresponding person. When the metamodel is adapted, e.g. by adding a nickname attribute to the family member or by fusing first and last name, it is useful to relax the conformance relation by (temporarily) deactivating type or cardinality checks.
Especially when working with EMF, co-evolving metamodels introduce problems and additional effort for the persons involved, which is illustrated by a small case study modelling the network infrastructure of an office, including all shared gadgets such as scanners, photocopiers and fax machines (Rose et al. 2009). As the EMF editor always enforces strict metamodel conformance, it is not possible to work with models conforming

8 Weidmann et al.

to older versions of the metamodel. A common workaround is the trial-and-error strategy of loading a model to get an error message from EMF, and then attempting to fix this error directly in the XMI document, obviously a tedious and error-prone task.
To model flexibility in software processes, the Eclipse Process Framework Composer (EPFC) was extended to ease the collaboration of the involved persons (Martinho et al. 2008). The process engineers propose a flexible work flow, which can be adapted by other participants in a second step.
5. Benefits and Challenges
To investigate the third research question, arguments were collected that support or question the use of tolerance or uncertainty. As benefits and drawbacks differ, the two concepts were analysed separately. More general arguments, which deal with more flexibility in software engineering, concern both concepts and are discussed afterwards.
5.1. Tolerance
A range of benefits resulting from tolerating inconsistencies to some extent was identified during the SLR. In some application scenarios, such as distributed software systems, fault-tolerance is required to achieve availability and partition-tolerance (Höllrigl et al. 2010; Hamid & Mosbah 2005; Decker 2011; Balzer 1991). Similarly, being able to handle inconsistencies is essential due to the modularity of applications and data sources in modern software systems; errors can easily occur when composing building blocks in a new way, even if each module is implemented correctly (Fan et al. 2009; Decker & Martinenghi 2008). A frequently mentioned point is that temporarily tolerating inconsistencies can ease the work flow for system designers and testers as a fault-tolerant Integrated Development Environment (IDE) does not enforce the restoration of consistency before further modelling steps can be performed (Vierhauser et al. 2012; Paradkar & Klinger 2004; Perrouin et al. 2009; Gabsi et al. 2016; Guerra & de Lara 2018; Jahanbanifar et al. 2016; Egyed 2011; Schoenboeck et al. 2014). Usually, atomic changes such as graph edits can lead to inconsistent states in between, which should be tolerated at least until the entire edit sequence is completed (Kretschmer et al. 2018; Stevens 2014; Decker 2011; Yu & Vahdat 2000; Gabsi et al. 2016; Vierhauser et al. 2010; Reder & Egyed 2012b; Vouk et al. 1990; Guerra & de Lara 2018; de Souza et al. 2003; Egyed 2011; Nuseibeh et al. 2000; Khelladi et al. 2019). From a practical point of view, improving consistency might be more helpful than enforcing it strictly. Often, the restoration process requires multiple changes that can each be regarded as an improving step towards consistency, while only the last one is able to finally restore consistency (Stevens 2014; Decker 2011). Furthermore, a detected error often reveals another problem, which might be the root cause of multiple other defects. Therefore, information about inconsistencies is often more helpful than an automated fix that achieves consistency (Egyed et al. 2008; Egyed 2007b; Khelladi et al. 2019). In fault-tolerant systems, the number of automated changes can be decreased, which can improve the tool's trustworthiness for the designer (Stevens 2014). Even if automated changes are the

preferred way of resolving conflicts, their application often relies on a central authority to define a policy for restoration steps. Especially when more than two models are involved, it is in general not possible to declare one of the models as the authoritative one, or prefer a certain type of changes over others due to, e.g., transitive consequences (Friedrich 2018; Stevens 2018b). It follows that, whenever a design decision is ambiguous, only the uncontroversial steps can be fully automated - leading to a possibly inconsistent state - before the user must participate in resolving the remaining inconsistencies (Stevens 2014; Egyed et al. 2011; Xiong et al. 2009). Another set of arguments refers to weaknesses of fixing-procedures. To maintain an acceptable level of efficiency, many approaches apply local fixes to restore consistency. This means that mechanisms don't have a global view on the modelled system, and local fixes can have sideeffects that are not monitored by the tool (Egyed et al. 2011; Egyed 2007a; Hegedüs et al. 2011). Consequently, these fixes might introduce new inconsistencies, which are often hard to detect, and which have to be fixed at a later point (Decker 2011; Egyed 2007a; Egyed et al. 2008; Küster & Ryndina 2007; Egyed 2011; Khelladi et al. 2019; Hegedüs et al. 2011). As multiple stakeholders are involved in the modelling of complex systems, their requirements can be contradictory. Without being able to tolerate these defects for a while, the modelling process gets stuck at this point and requires an instant resolution (DeVries & Cheng 2016; Egyed 2006). Last but not least, the consistency check itself can be erroneous, such that the respective tool finds false positives. While it is undisputed that the error has to be removed, tolerant behaviour could again ease the continuation of the modelling process (Reder 2011).
Despite this long list of advantages, many authors argue against involving tolerance in system design. It is questionable how long and to which extent inconsistencies should be tolerated, because a large number of factors have an influence on the value of fault-tolerance in a specific use case (Höllrigl et al. 2010; Perrouin et al. 2009; Blanc et al. 2008; Egyed 2007a; Kretschmer et al. 2017; Ebnenasir et al. 2006). Certainly, one should not lose track of the goal of eventually restoring consistency. Assuming that it is always possible to fix inconsistencies at a later point, this might still involve additional effort and thus a higher cost (Egyed 2007b, 2006; Reder & Egyed 2012a; Salay, Chechik, & Horkoff 2012; Hao et al. 1992; Khelladi et al. 2019). On the one hand, when consistency should eventually be restored, the developer might be confronted with so many errors at once that they are overwhelmed. On the other hand, errors might be caused by changes that occurred so long ago, that design decisions have to be completely revisited (Egyed 2006). As developers are usually willing to fix errors as soon as they are noticed, they will probably do the same when they detect inconsistencies that could actually be tolerated by the system. This means that such a tool's potential for supporting tolerance will probably be ignored by its users (Kolovos et al. 2008). Also, performing operations (e.g. model transformations) on inconsistent models likely introduces further errors (Khelladi et al. 2019). Finally, many tools for model management are based on formal methods, which are not yet compatible with tolerant concepts (Decker & Martinenghi 2008).

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 9

5.2. Uncertainty
An important argument for modelling with uncertainty is that it represents real-world scenarios more accurately. The input data and the behaviour of CPSs and adaptive systems is imprecise, e.g. their sensors and actuators provide the system with imprecise data, and this should be reflected in a model of the system (Kyrkou et al. 2015; Mayerhofer et al. 2016; Goldsby & Cheng 2008; Vallecillo et al. 2016; Camilli et al. 2018; Prasetya & Klomp 2019; Bamgboye et al. 2018; Ali & Yue 2015; Camilli et al. 2017; Esfahani & Malek 2010). Similarly, information might not be available in distributed systems, or not accessible due to security restrictions or authentication problems (Gao et al. 2011). In software and requirements engineering processes, uncertainty plays an important role, especially in early phases. When designing complex and widely heterogeneous systems, multiple stakeholders are involved, whose understanding of the final result may be incomplete (Honda et al. 2013a; Förster & Schneider 2010; Famelis et al. 2015; Famelis & Santosa 2013; Camilli et al. 2018; Famelis et al. 2012a; Ramirez et al. 2012; Jureta et al. 2010; Hansen & Thomsen 1999; Famelis et al. 2013; DeVries & Cheng 2017; Garlan 2010; Camilli & Russo 2020; Eramo et al. 2014). Additionally, this incomplete information makes it necessary to continuously adapt the development process and the requirements (Cheng et al. 2009; Mens et al. 2006; Salay, Chechik, & Horkoff 2012; Camilli et al. 2018; Ramirez et al. 2012; Garlan 2010; Famelis et al. 2012b; Salay, Chechik, & Gorzny 2012). Likewise, removing uncertainty too early can force the designer to commit to premature decisions that can increase cost and efforts to remove resulting errors later (Famelis et al. 2013; Eramo et al. 2014), while ignoring uncertainty completely decreases the overall quality of the software (Ibrahim et al. 2009; Esfahani & Malek 2010). An obvious alternative to model uncertainty is to list each alternative value explicitly, but this can quickly become infeasible. Uncertainty is an elegant way to encode alternatives and non-determinism, while still keeping models manageable (Brambilla et al. 2017; Bucaioni et al. 2016; Eramo et al. 2015; Reder & Egyed 2013). Indeed, uncertain values are probably easier to maintain than a large set of alternatives (Bucaioni et al. 2016; Ghezzi et al. 2013). In case some design choices are more likely to be applied than others, uncertainty is also useful to express these varying probabilities quantitatively (Ou et al. 2009). From a practical point of view, uncertainty is often indirectly added to models via informal annotations in case its direct expression is not supported. Therefore, enabling the designer to model uncertainty in the given formal notation improves the verification and validation of such models (Salay, Chechik, & Gorzny 2012).
Handling uncertainty, however, can also increase development cost as the encoded set of alternatives - which takes all possible combinations of values into account - can be much larger than the set of possible options in practice (Cheng et al. 2009; Hansen & Thomsen 1999; Ibrahim et al. 2009). Following the same argument, the model space grows exponentially with the degree of uncertainty, which can cause performance problems for larger model sizes (Ou et al. 2009; Famelis et al. 2012a; Esfahani & Malek 2010). Even though uncertainty is an appropriate way of expressing probabilities, it can be difficult

to realistically quantify uncertainty measures, as empirical tests for these measures are often missing or cannot be conducted at all (Ou et al. 2009; Esfahani & Malek 2010). Finally, operations on models are usually designed for single models, whereas uncertain models encode a whole set, restricting the applicability of standard tooling (Famelis et al. 2012a).
5.3. Flexibility
It is possible that multiple consistent solutions exist, which deviate in their quality. As it is hard to specify which solution should be taken, the system should provide the flexibility to let the user make this final decision (B. Wang et al. 2010). To keep the complexity of a system manageable, software is usually developed with an idealised environment in mind. However, the system is also expected to react robustly to environment changes and unforeseen circumstances at runtime (Fraj et al. 2017; Wolfe et al. 2009; Hansen & Thomsen 1999; He et al. 2015). In application domains such as product line engineering, "hard constraints" can reduce the potential of the modelling language and therefore restrict the scope of action for the designer (Barreiros & Moreira 2014; Aquino 2009). In the area of model-metamodel co-evolution, some flexibility is necessary for a modelling tool to be appropriate for practical use. The temporary loss of metamodel conformance should not lead to a situation where the model cannot be modified or even loaded in the respective editor (Rose et al. 2009; Hili & Sottet 2017; Hili 2016; Atkinson et al. 2015; Hebig et al. 2016; Zolotas et al. 2016; Sottet & Biri 2016). Finally, the result of a model transformation is often not unique, requiring a flexible encoding (Callow & Kalawsky 2013; Eramo et al. 2014).
A few arguments can also be found that question the benefits of flexibility. As tools are typically not built by the intended users, the developer might have a different understanding of flexibility, such that the user may ignore or even disregard any support for it (Honda et al. 2013b). The more flexibility is added to a system, the more complexity is involved as well, which can end up in a misinterpretation of functionality or a loss of overview while developing and maintaining the tool (Shan & Zhu 2004; Farias et al. 2012; Famelis & Santosa 2013) Finally, in case of errors and other inconsistencies, software developers are currently used to instant feedback from IDEs for general purpose languages, and will probably expect similar behaviour from modelling tools. Transitioning to tolerant tooling will therefore require a certain retraining of users to ensure acceptance, and it is still unclear how challenging this will be in practice (Egyed 2006).
6. Result Analysis
This section provides an overview of aggregated meta-data of the considered sources, before directions for future research are sketched, which can be motivated by this SLR.
The distribution of all sources in the database, i.e. all core papers and all sources cited by them, is depicted in Fig. 6, whereby ten sources published before 1975 are not captured in the diagram. In total, 268 core papers, 1146 other papers at SE venues and 2055 other sources were found in the initial

10 Weidmann et al.

search step. The median (mean) publication year is 2010.5 (2009.78) for core papers, 2007 (2005.87) for other papers at SE venues and 2006 (2004.35) for the remaining sources. It follows that filtering the additional sources was necessary to keep the amount of work manageable, and also that being published at a venue listed as research area 0803 (software engineering) is a useful indicator for increased relevance; at least one third of the additional sources was published at such a venue. The differences between core papers and other sources with respect to the average publication year can be explained by the applied snowballing technique, by which only sources released prior to the initial source can be found. Furthermore, the set of sources published at non-SE venues include standard references in form of books and journal articles, which is probably the reason why the papers from SE venues are slightly newer on average.
Figure 6 Number of sources per year
When taking only those sources into account that were later identified as being relevant for answering the research questions, the majority of sources originates from the set of core papers (cf. Fig. 7). Besides 114 of the core papers, 23 papers published at SE venues and 20 other sources were classified as relevant. Compared to the full corpus, the relevant papers are newer on average: The median (mean) publication year is 2011 (2011.05) for core papers, 2012 (2011.08) for publications at SE venues, and 2012 (2011.29) for the remaining relevant sources. An explanation can be that the search terms are used in a different meaning more frequently in older sources, according to our experience. Furthermore, as the research field MDE became popular along with the emergence of the UML in the late 1990s, sources published before can only be relevant for our purposes if they describe transferable concepts or examples from other domains.
Figure 7 Number of relevant sources per year

Table 3 gives an overview of the number of relevant papers per venue, listing those venues with at least four relevant papers. As this SLR deals with a subtopic of MDE, finding the MODELS conference at the top of the ranking is a result one would expect. Five papers published at co-located events were relevant for this SLR as well. ICSE and ASE as two top-ranked SE conferences in the list underpin the topic's relevance for a broader audience. The appearance of important conferences for more specialised research fields, such as requirements engineering (RE), software language design (SLE) and software testing (ICST), shows that fault-tolerance concerns the entire software development process. The remaining well-known SE venues COMPSAC, SEKE, APSEC and FASE complete the list of venues with 4 or more relevant papers.

Rank Acronym Venue

#

1

MODELS Model Driven Engineering: Languages and Systems 20

2

ICSE

International Conference on Software Engineering 15

3 COMPSAC Computer Software and Applications Conference

10

4

ASE

Automated Software Engineering

8

5

SEKE

Software Engineering and Knowledge Engineering 7

6

FASE

Fundamental Approaches to Software Engineering

6

7

APSEC Asia-Pacific Software Engineering Conference

5

7

RE

Intern. Conference on Requirements Engineering

5

7

-

MODELS Satellite Events

5

10

SLE

Software Language Engineering

4

10

ICST

International Conference on Software Testing

4

Table 3 Top 10 conferences by number of relevant papers

Although as a result of this SLR, many thorough definitions, useful examples and convincing arguments for tolerance in MDE could be extracted, a need for further research became apparent simultaneously. As tolerance was mostly defined intuitively, an extended formal framework (e.g. for softening domain constraints) would be helpful to prove properties of tolerant systems. This includes quantitative measures for (in)consistency, as well as quality criteria for the intermediate and final model states to assess the utility of proposed approaches. Up to now, it remains also unclear when exactly consistency shall be restored, up to which point errors can be tolerated, and how to deal with conflicting changes that were made in the meantime. Especially for more than two models, consistency restoration is a non-trivial problem because removing errors in one model can introduce other errors in different places. Further user studies could show to which extent user interaction is required to resolve such conflicts, and which restoration actions can be performed automatically. Several authors pointed out that some faults are too serious to be tolerated, but still strategies are needed to assess the severity of errors in a model, though. While model transformations in presence of uncertainty are already investigated, fault-tolerant consistency management is still an unsolved issue. Finally, although tolerance and uncertainty could be differentiated in spite of their common goal, it would be useful to specify which of the two concepts is more helpful in which particular scenarios.

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 11

7. Related Work
Studies that provide a structured overview of existing work on a particular topic are often conducted as SLRs (B. Kitchenham 2004) or as mapping studies (Petersen et al. 2008). SLRs are a secondary study that identifies, analyses and interprets all available information related to one or more research questions. SLRs follow a predefined review protocol, such that the process of retrieving results is transparent and the introduced bias is minimised. Mapping studies categorise existing work, often leading to a visual mapping of categories that supports the understanding of what is already addressed in a specific domain.
Several of these studies of either type have been conducted in the MDE domain and related fields. Modelling languages were investigated with a focus on the Systems Modeling Language (SysML) language (Wolny et al. 2020), the QVT Operational (QVTo) standard (Gerpheide et al. 2014, 2016), and the application of modelling in Industry 4.0 (Wortmann et al. 2020, 2017). Further MDE-related work investigates literature on models at runtime (Szvetits & Zdun 2016), software testing process models (Vukovic et al. 2018), articles that appeared in the Journal of Software and Systems Modelling (Gray & Rumpe 2016), and quality in MDE (Goulão et al. 2016). In the requirements engineering domain, studies on software tooling for requirement elicitation (Iqbal et al. 2019) and software testing in the context of agile software development (Coutinho et al. 2019) have been presented. For software product lines, existing work on the automated analysis of feature models (Galindo et al. 2019), variability management (Galster et al. 2014), and tool support (Bashroush et al. 2017) has been already investigated. Context modelling (Koç et al. 2014) and environment modelling (Siavashi & Truscan 2015) are further topics of existing SLRs.
Multiple studies on consistency in modelling languages have been already presented. Awadid et al. (Awadid & Nurcan 2019, 2016) composed an overview of consistency requirements of business process models by proposing a framework for the categorization of approaches and a road-map for future research on consistency requirements elicitation and management. The work of Muram et al. (Muram et al. 2017) takes consistency checking of software behavioural models into account. Seven main categories for consistency checking in this domain were identified, and suggestions for future research in this direction were proposed. Hoisl et al. (Hoisl & Sobernig 2015) conducted a literature review on consistency rules for UML-based language models, discussing frequently-named defects of such models and demanding more tool support for enforcing consistency rules in this setting. All of these studies focus on a sub-domain of MDE and do not take tolerance or uncertainty into account.
Only two studies on existing work relating fault-tolerance to software engineering problems could be found. Nascimento et al. (Nascimento et al. 2014) analysed literature on the design of fault-tolerant Service-Oriented Architecture (SOA) using design diversity, deriving guidelines for fault-tolerant SOA design and proposing a taxonomy for useful techniques in this respect. A mapping study for fault-tolerant Internet of Things (IoT) applications (Moghaddam & Muccini 2019) identifies key factors

for tolerant systems, including the use of micro-services and the distribution of IoT components. Both studies are neither directly related to MDE nor address the problem of maintaining consistency.
In a study combining an SLR, semi-structured interviews, and an empirical evaluation, Marinho et al. (M. Marinho et al. 2018; M. L. M. Marinho et al. 2015) propose and evaluate techniques to distinguish risks and uncertainties to reduce the latter in software projects. Salih et al. (Salih et al. 2017) provide an overview of existing work on uncertainty involved in requirements engineering via a categorisation of relevant sources, while several questions are left open. Measurement uncertainty was studied in depth by da Silva Hack et al. (da Silva Hack & ten Caten 2012), resulting in a classification of approaches and a list of methods for calculating uncertainty. However, these treatments focus solely on uncertainty, whereas tolerance and software modelling are not considered.
As previously mentioned, SLRs in computer science often lack adequate tool support; this issue has been identified and discussed by existing work. Götz proposes a tool for processing the findings of SLRs (Götz 2018), which enables the user to assign the relevant papers to formed categories, such that diagrams can be generated that visualize the characteristic values for one or two categories. The tool supports SLRs in a later phase, though, as the list of relevant sources is required as input data. The SLR-Tool by Fernández-Sáez et al. (Fernández-Sáez et al. 2010) supports the process of conducting SLRs in different phases. Relevant meta-data can be stored for each source, a classification scheme can be created, and diagrams for result visualisation can be exported. In contrast to our tool-chain, the sources have to be imported manually in the beginning, and support for automated snowballing is not provided.
8. Conclusion and Future Work
We presented the results of an SLR on tolerance in MDE, which took 157 relevant sources into account. The key terms consistency, tolerance, and uncertainty were defined and represented in feature models, such that salient differences and commonalities between tolerance and uncertainty could be pointed out. Typical use cases for tolerant and uncertain modelling were sketched, and benefits and challenges of the respective concepts were discussed. To ease the reproducibility of our results and to support future SLRs in computer science, we proposed a model-driven tool-chain based on open-source components under active development.
Although some relevant journal articles and workshop papers were identified by the snowballing step, the set of sources can be further extended by more sources published at other venues. Since the CORE2020 journal ranking was recently made available, we plan to extend the literature review towards journal papers following the search strategies presented in this paper. To the same end, other research databases could be considered as well. The review has shown that there are indeed useful examples for applying tolerant concepts in MDE; a systematic benchmark for comparing tolerant approaches is, however, still an open issue.

12 Weidmann et al.

Acknowledgements
We would like to thank all anonymous reviewers for their helpful feedback that improved the quality of this SLR.
References
Ali, S., & Yue, T. (2015, 05). Evolving, modelling and testing realistic uncertain behaviours of cyber-physical systems. In ICST 2015.
Aquino, N. (2009). Adding flexibility in the model-driven engineering of user interfaces. In EICS 2009 (pp. 329­332).
Atkinson, C., Gerbig, R., & Fritzsche, M. (2015, 01). A multi-level approach to modeling language extension in the enterprise systems domain. Information Systems, 54.
Awadid, A., & Nurcan, S. (2016). A systematic literature review of consistency among business process models. In R. Schmidt, W. Guédria, I. Bider, & S. Guerreiro (Eds.), BPMDS 2016 (Vol. 248, pp. 175­195). Springer.
Awadid, A., & Nurcan, S. (2019). Consistency requirements in business process modeling: a thorough overview. Software and Systems Modeling, 18(2), 1097­1115.
Babikian, A. A., Semeráth, O., & Varró, D. (2020). Automated generation of consistent graph models with first-order logic theorem provers. In FASE 2020 (pp. 441­461).
Bagheri, E., & Ghorbani, A. A. (2007). On the collaborative development of para-consistent conceptual models. In QSIC 2007 (pp. 336­341).
Balzer, R. (1991). Tolerating inconsistency. In ICSE 1991 (pp. 158­165).
Bamgboye, O., Liu, X., & Cruickshank, P. (2018). Towards modelling and reasoning about uncertain data of sensor measurements for decision support in smart spaces. In COMPSAC 2018 (pp. 744­749).
Barreiros, J., & Moreira, A. (2014). Flexible modeling and product derivation in software product lines. In SEKE 2013 (pp. 67­70).
Bashroush, R., Garba, M., Rabiser, R., Groher, I., & Botterweck, G. (2017). CASE tool support for variability management in software product lines. ACM Comput. Surv., 50(1), 14:1­ 14:45.
Blanc, X., Mounier, I., Mougenot, A., & Mens, T. (2008). Detecting model inconsistency through operation-based model construction. In ICSE 2008 (pp. 511­520).
Brambilla, M., Eramo, R., Pierantonio, A., Rosa, G., & Umuhoza, E. (2017). Enhancing flexibility in user interaction modeling by adding design uncertainty to IFML. In MODELS 2017, workshop proceedings (pp. 435­440).
Bucaioni, A., Cicchetti, A., Ciccozzi, F., Mubeen, S., Pierantonio, A., & Sjödin, M. (2016, Aug). Handling uncertainty in automatically generated implementation models in the automotive domain. In SEAA 2016 (p. 173-180).
Burdusel, A., Zschaler, S., & John, S. (2019). Automatic generation of atomic consistency preserving search operators for search-based model engineering. In MODELS 2019 (pp. 106­116).
Callow, G., & Kalawsky, R. (2013). A satisficing bi-directional model transformation engine using mixed integer linear pro-

gramming. J. Object Technol., 12(1), 1: 1­43. Camilli, M., Bellettini, C., Gargantini, A., & Scandurra, P.
(2018). Online model-based testing under uncertainty. In ISSRE 2018 (pp. 36­46). Camilli, M., Gargantini, A., Scandurra, P., & Bellettini, C. (2017). Towards inverse uncertainty quantification in software development (short paper). In A. Cimatti & M. Sirjani (Eds.), SEFM 2017 (Vol. 10469, pp. 375­381). Springer. Camilli, M., & Russo, B. (2020). Model-based testing under parametric variability of uncertain beliefs. In SEFM 2020 (pp. 175­192). Cheng, B. H. C., Sawyer, P., Bencomo, N., & Whittle, J. (2009). A goal-based modeling approach to develop requirements of an adaptive system with environmental uncertainty. In MODELS 2009 (pp. 468­483). Cicchetti, A., Ruscio, D. D., Eramo, R., & Pierantonio, A. (2010). JTL: A bidirectional and change propagating transformation language. In SLE 2010 (pp. 183­202). Ciraci, S., Sözer, H., & Tekinerdogan, B. (2012). An approach for detecting inconsistencies between behavioral models of the software architecture and the code. In COMPSAC 2012 (pp. 257­266). Coutinho, J. C. S., de L. Andrade, W., & Machado, P. D. L. (2019). Requirements engineering and software testing in agile methodologies: a systematic mapping. In I. do Carmo Machado, R. Souza, R. S. P. Maciel, & C. Sant'Anna (Eds.), SBES 2019 (pp. 322­331). ACM. da Silva Hack, P., & ten Caten, C. S. (2012). Measurement uncertainty: Literature review and research trends. IEEE Trans. Instrumentation and Measurement, 61(8), 2116­2124. Dávid, I., Meyers, B., Vanherpen, K., Tendeloo, Y. V., Berx, K., & Vangheluwe, H. (n.d.). Modeling and enactment support for early detection of inconsistencies in engineering processes. In (MODELS 2017, workshop proceedings (pp. 145­154). Decker, H. (2011). Data quality maintenance by integritypreserving repairs that tolerate inconsistency. In QSIC 2011 (pp. 192­197). Decker, H. (2017). Inconsistency-tolerant database repairs and simplified repair checking by measure-based integrity checking. Trans. Large Scale Data Knowl. Centered Syst., 34, 153­183. Decker, H., & Martinenghi, D. (2008). Classifying integrity checking methods with regard to inconsistency tolerance. In PPDP 2008 (pp. 195­204). Decker, H., & Martinenghi, D. (2011). Inconsistency-tolerant integrity checking. IEEE Trans. Knowl. Data Eng., 23(2), 218­234. Demuth, A., Kretschmer, R., Egyed, A., & Maes, D. (2016). Introducing traceability and consistency checking for change impact analysis across engineering tools in an automation solution company: An experience report. In ICSME 2016 (pp. 529­538). IEEE Computer Society. de Souza, C. R. B., Oliveira, H. L. R., da Rocha, C. R. P., Gonçalves, K. M., & Redmiles, D. F. (2003). Using critiquing systems for inconsistency detection in software engineering models. In SEKE 2003 (pp. 196­203).

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 13

DeVries, B., & Cheng, B. H. C. (2016). Automatic detection of incomplete requirements via symbolic analysis. In B. Baudry & B. Combemale (Eds.), MODELS 2016 (pp. 385­ 395). ACM.
DeVries, B., & Cheng, B. H. C. (2017). Using models at run time to detect incomplete and inconsistent requirements. In (MODELS 2017, workshop proceedings (pp. 201­209).
Ebnenasir, A., & Cheng, B. H. C. (2007). Pattern-based modeling and analysis of failsafe fault-tolerance in UML. In HASE 2007 (pp. 275­282).
Ebnenasir, A., Cheng, B. H. C., & Konrad, S. (2006). Use case-based modeling and analysis of failsafe fault-tolerance. In RE 2006 (pp. 336­337).
Egyed, A. (2006). Instant consistency checking for the UML. In L. J. Osterweil, H. D. Rombach, & M. L. Soffa (Eds.), ICSE 2006 (pp. 381­390). ACM.
Egyed, A. (2007a). Fixing inconsistencies in UML design models. In ICSE 2007 (pp. 292­301).
Egyed, A. (2007b). Uml/analyzer: A tool for the instant consistency checking of UML models. In ICSE 2007 (pp. 793­ 796).
Egyed, A. (2011). Automatically detecting and tracking inconsistencies in software design models. IEEE Trans. Software Eng., 37(2), 188­204.
Egyed, A., Demuth, A., Ghabi, A., Lopez-Herrejon, R. E., Mäder, P., Nöhrer, A., & Reder, A. (2011). Fine-tuning model transformation: Change propagation in context of consistency, completeness, and human guidance. In ICMT 2011, proceedings (pp. 1­14).
Egyed, A., Letier, E., & Finkelstein, A. (2008). Generating and evaluating choices for fixing inconsistencies in UML design models. In ASE 2008 (pp. 99­108).
Ehrig, H., Ehrig, K., Ermel, C., & Prange, U. (2008). Consistent integration of models based on views of visual languages. In FASE 2008 (pp. 62­76).
Eramo, R., Pierantonio, A., & Rosa, G. (2014). Uncertainty in bidirectional transformations. In MiSE 2014 (pp. 37­42).
Eramo, R., Pierantonio, A., & Rosa, G. (2015). Managing uncertainty in bidirectional model transformations. In SLE 2015 (pp. 49­58).
Esfahani, N., & Malek, S. (2010). Uncertainty in self-adaptive software systems. In Software engineering for self-adaptive systems II, 2010 revised selected and invited papers (pp. 214­ 238).
Famelis, M., Ben-David, N., Di Sandro, A., Salay, R., & Chechik, M. (2015). Mu-mmint: An ide for model uncertainty. In ICSE 2015 (pp. 697­700). IEEE Press.
Famelis, M., Salay, R., & Chechik, M. (2012a). Partial models: Towards modeling and reasoning with uncertainty. In ICSE 2012 (pp. 573­583).
Famelis, M., Salay, R., & Chechik, M. (2012b, 06). The semantics of partial model transformations. In MiSE 2012 (p. 64-69).
Famelis, M., Salay, R., Sandro, A. D., & Chechik, M. (2013). Transformation of models containing uncertainty. In MODELS 2013 (pp. 673­689).
Famelis, M., & Santosa, S. (2013, 05). Mav-vis: A notation

for model uncertainty. In ICSE 2013, workshop on software engineering for adaptive and self-managing systems (p. 712). Fan, G., Yu, H., Chen, L., & Liu, D. (2009). A method for modeling and analyzing fault-tolerant service composition. In APSEC 2009 (pp. 507­514). Farias, K., Garcia, A., & de Lucena, C. J. P. (2012). Evaluating the impact of aspects on inconsistency detection effort: A controlled experiment. In MODELS 2012 (pp. 219­234). Fernández-Sáez, A. M., Bocco, M. G., & Romero, F. P. (2010). Slr-tool - A tool for performing systematic literature reviews. In J. A. M. Cordeiro, M. Virvou, & B. Shishkov (Eds.), ICSOFT 2010 (pp. 157­166). SciTePress. Förster, M., & Schneider, D. (2010, 12). Flexible, any-time fault tree analysis with component logic models. In ISSRE 2010 (p. 51 - 60). Fraj, I. B., Hlaoui, Y. B., & Ayed, L. J. B. (2017). A modeling approach for flexible workflow applications of cloud services. In COMPSAC 2017 (pp. 175­180). Friedrich, J. (2018). Declarative project planning and controlling: a formal model to support the handling of unavoidable inconsistencies. In ICSSP 2018 (pp. 61­69). Gabsi, W., Zalila, B., & Jmaïel, M. (2016). EMA2AOP: from the AADL error model annex to aspect language towards fault tolerant systems. In SERA 2016 (pp. 155­162). Galindo, J. A., Benavides, D., Trinidad, P., Gutiérrez-Fernández, A. M., & Ruiz-Cortés, A. (2019). Automated analysis of feature models: Quo vadis? Computing, 101(5), 387­433. Galster, M., Weyns, D., Tofan, D., Michalik, B., & Avgeriou, P. (2014). Variability in software systems - A systematic literature review. IEEE Trans. Software Eng., 40(3), 282­ 306. Gao, X., Hu, W., Ye, W., & Zhang, S. (2011, 01). Data uncertainty model for mashup. In Seke 2011 (p. 503-508). Garlan, D. (2010). Software engineering in an uncertain world. In G. Roman & K. J. Sullivan (Eds.), FoSER 2010 (pp. 125­ 128). ACM. Gerpheide, C. M., Schiffelers, R. R. H., & Serebrenik, A. (2014). A bottom-up quality model for qvto. In QUATIC 2014 (pp. 85­94). IEEE Computer Society. Gerpheide, C. M., Schiffelers, R. R. H., & Serebrenik, A. (2016). Assessing and improving quality of qvto model transformations. Software Quality Journal, 24(3), 797­834. Ghezzi, C., Pinto, L. S., Spoletini, P., & Tamburrelli, G. (2013). Managing non-functional uncertainty via model-driven adaptivity. In D. Notkin, B. H. C. Cheng, & K. Pohl (Eds.), ICSE 2013 (pp. 33­42). IEEE Computer Society. Gogolla, M., Hamann, L., Hilken, F., & Sedlmeier, M. (2015). Checking UML and OCL model consistency: An experience report on a middle-sized case study. In TAP 2015 (pp. 129­ 136). Gogolla, M., Kuhlmann, M., & Hamann, L. (2009). Consistency, independence and consequences in UML and OCL models. In TAP 2009 (pp. 90­104). Goldsby, H., & Cheng, B. H. C. (2008). Automatically generating behavioral models of adaptive systems to address uncertainty. In MoDELS 2008 (pp. 568­583).

14 Weidmann et al.

Götz, S. (2018). Supporting systematic literature reviews in computer science: the systematic literature review toolkit. In Ö. Babur et al. (Eds.), MODELS 2018, companion proceedings (pp. 22­26). ACM.
Goulão, M., Amaral, V., & Mernik, M. (2016). Quality in model-driven engineering: a tertiary study. Software Quality Journal, 24(3), 601­633.
Gray, J., & Rumpe, B. (2016). How to write a successful sosym submission. Software and Systems Modeling, 15(4), 929­931.
Guerra, E., & de Lara, J. (2018). On the quest for flexible modelling. In MODELS 2018 (pp. 23­33).
Hamid, B., & Mosbah, M. (2005). A formal model for faulttolerance in distributed systems. In SAFECOMP 2005 (pp. 108­121).
Hamlaoui, M. E., Ebersold, S., Coulette, B., Nassar, M., & Anwar, A. (2014). Heterogeneous models matching for consistency management. In RCIS 2014 (pp. 1­12).
Hansen, K. M., & Thomsen, M. (1999). The "domain model concealer" and "application moderator" patterns: Addressing architectural uncertainty in interactive systems. In TOOLS 1999 (pp. 177­190). IEEE Computer Society.
Hao, J., Trousset, F., & Jacques, J. (1992). Prototyping an inconsistency checking tool for software process models. In SEKE 1992 (pp. 227­234).
He, X., Fu, Y., Sun, C., Ma, Z., & Shao, W. (2015). Towards model-driven variability-based flexible service compositions. In COMPSAC 2015 (pp. 298­303).
Hebig, R., Khelladi, D., & Bendraou, R. (2016, 09). Approaches to co-evolution of metamodels and models: A survey. IEEE Transactions on Software Engineering, PP, 1-1.
Hegedüs, Á., Horváth, Á., Ráth, I., Branco, M. C., & Varró, D. (2011). Quick fix generation for dsmls. In VL/HCC 2011 (pp. 17­24).
Hili, N. (2016). A metamodeling framework for promoting flexibility and creativity over strict model conformance. In FlexMDE@MoDELS 2016, workshop proceedings (pp. 2­ 11).
Hili, N., & Sottet, J. (2017). The conformance relation challenge: Building flexible modelling frameworks. In MODELS 2017, workshop proceedings (pp. 418­423).
Hoisl, B., & Sobernig, S. (2015). Consistency rules for umlbased domain-specific language models: A literature review. In I. Dragomir et al. (Eds.), MoDELS 2015, workshop proceedings (Vol. 1508, pp. 29­36). CEUR-WS.org.
Höllrigl, T., Dinger, J., & Hartenstein, H. (2010). A consistency model for identity information in distributed systems. In COMPSAC 2010 (pp. 252­261).
Honda, K., Washizaki, H., & Fukazawa, Y. (2013a). A generalized software reliability model considering uncertainty and dynamics in development. In J. Heidrich, M. Oivo, A. Jedlitschka, & M. T. Baldassarre (Eds.), PROFES 2013 (Vol. 7983, pp. 342­346). Springer.
Honda, K., Washizaki, H., & Fukazawa, Y. (2013b). A generalized software reliability model considering uncertainty and dynamics in development. In J. Heidrich, M. Oivo, A. Jedlitschka, & M. T. Baldassarre (Eds.), PROFES 2013 (Vol.

7983, pp. 342­346). Springer. Ibrahim, H., Far, B. H., Eberlein, A., & Daradkeh, Y. (2009). Un-
certainty management in software engineering: Past, present, and future. In CCECE 2009 (pp. 7­12). Iqbal, A., Khan, I. A., & Jan, S. (2019). A review and comparison of the traditional collaborative and online collaborative techniques for software requirement elicitation. In ICACS proceedings (pp. 1­8). IEEE. Jahanbanifar, A., Khendek, F., & Toeroe, M. (2016). Runtime adjustment of configuration models for consistency preservation. In HASE 2016 (pp. 102­109). Ji, R., Li, Z., Chen, S., Pan, M., Zhang, T., Ali, S., . . . Li, X. (2018). Uncovering unknown system behaviors in uncertain networks with model and search-based testing. In ICST 2018 (pp. 204­214). Jureta, I., Borgida, A., Ernst, N. A., & Mylopoulos, J. (2010). Techne: Towards a new generation of requirements modeling languages with goals, preferences, and inconsistency handling. In RE 2010 (pp. 115­124). Khelladi, D. E., Kretschmer, R., & Egyed, A. (2019). Detecting and exploring side effects when repairing model inconsistencies. In SLE 2019 (pp. 113­126). Kitchenham, B. (2004, 08). Procedures for performing systematic reviews. Keele, UK, Keele Univ., 33. Kitchenham, B. A., Brereton, P., Budgen, D., Turner, M., Bailey, J., & Linkman, S. G. (2009). Systematic literature reviews in software engineering - A systematic literature review. Inf. Softw. Technol., 51(1), 7­15. Koç, H., Hennig, E., Jastram, S., & Starke, C. (2014). State of the art in context modelling - A systematic literature review. In L. S. Iliadis, M. P. Papazoglou, & K. Pohl (Eds.), CAiSE 2014, workshop proceedings (Vol. 178, pp. 53­64). Springer. Kolovos, D. S., Paige, R. F., & Polack, F. (2008). Detecting and repairing inconsistencies across heterogeneous models. In ICST 2008 (pp. 356­364). Kretschmer, R., Khelladi, D. E., Demuth, A., Lopez-Herrejon, R. E., & Egyed, A. (2017). From abstract to concrete repairs of model inconsistencies: An automated approach. In APSEC 2017 (pp. 456­465). Kretschmer, R., Khelladi, D. E., & Egyed, A. (2018). An automated and instant discovery of concrete repairs for model inconsistencies. In ICSE 2018 (pp. 298­299). Krishna, A., Ghose, A. K., & Vilkomir, S. A. (2005). Looselycoupled consistency between agent-oriented conceptual models and Z specifications. In SEKE 2005 (pp. 455­460). Kusel, A., Etzlstorfer, J., Kapsammer, E., Retschitzegger, W., Schwinger, W., & Schönböck, J. (2015). Consistent coevolution of models and transformations. In MoDELS 2015 (pp. 116­125). Küster, J. M., & Ryndina, K. (2007). Improving inconsistency resolution with side-effect evaluation and costs. In MoDELS 2007 (pp. 136­150). Kyrkou, C., Christoforou, E., Theocharides, T., Panayiotou, C., & Polycarpou, M. M. (2015). A camera uncertainty model for collaborative visual sensor network applications. In R. Carmona-Galán & Á. Rodríguez-Vázquez (Eds.), ICDSC 2015 (pp. 86­91). ACM.

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 15

Leblebici, E., Anjorin, A., & Schürr, A. (2017). Inter-model consistency checking using triple graph grammars and linear optimization techniques. In FASE 2017 (pp. 191­207).
Link, S., Service, G., Nentwich, C., Capra, L., & Emmerich, W. (2001, 01). xlinkit: A consistency checking and smart link generation service. ACM Transactions on Internet Technology (TOIT), 2.
Lytra, I., Tran, H., & Zdun, U. (2012). Constraint-based consistency checking between design decisions and component models for supporting software architecture evolution. In CSMR 2012 (pp. 287­296).
Lytra, I., Tran, H., & Zdun, U. (2013). Supporting consistency between architectural design decisions and component models through reusable architectural knowledge transformations. In ECSA 2013 (pp. 224­239).
Macedo, N., & Cunha, A. (2013). Implementing QVT-R bidirectional model transformations using alloy. In FASE 2013 (pp. 297­311).
Marinho, M., Sampaio, S., & de Moura, H. P. (2018). Managing uncertainty in software projects. ISSE, 14(3), 157­181.
Marinho, M. L. M., de Barros Sampaio, S. C., de Andrade Lima, T. L., & de Moura, H. P. (2015). Uncertainty management in software projects. JSW, 10(3), 288­303.
Martinho, R., Varajão, J., & Domingos, D. (2008). A two-step approach for modelling flexibility in software processes. In ASE 2008 (pp. 427­430).
Mayerhofer, T., Wimmer, M., & Vallecillo, A. (2016). Adding uncertainty and units to quantity types in software models. In T. van der Storm, E. Balland, & D. Varró (Eds.), SLE 2016 (pp. 118­131). ACM.
Mens, T., Straeten, R. V. D., & D'Hondt, M. (2006). Detecting and resolving model inconsistencies using transformation dependency analysis. In MoDELS 2006 (pp. 200­214).
Moghaddam, M. T., & Muccini, H. (2019). Fault-tolerant iot - A systematic mapping study. In R. Calinescu & F. D. Giandomenico (Eds.), SERENE 2019 (Vol. 11732, pp. 67­84). Springer.
Morin, B., Klein, J., Kienzle, J., & Jézéquel, J. (2010). Flexible model element introduction policies for aspect-oriented modeling. In MODELS 2010 (pp. 63­77).
Muram, F. U., Tran, H., & Zdun, U. (2017). Systematic review of software behavioral model consistency checking. ACM Comput. Surv., 50(2), 17:1­17:39.
Nascimento, A. S., Rubira, C. M. F., Burrows, R., Castor, F., & Brito, P. H. S. (2014). Designing fault-tolerant SOA based on design diversity. J. Software Eng. R&D, 2, 13.
Nentwich, C., Emmerich, W., & Finkelstein, A. (2003). Consistency management with repair actions. In ICSE, 2003 (pp. 455­464).
Noyrit, F., Gérard, S., Terrier, F., & Selic, B. (2010). Consistent modeling using multiple UML profiles. In MODELS 2010 (pp. 392­406).
Nuseibeh, B., Easterbrook, S., & Russo, A. (2000, 01). Making inconsistency respectable in software development. Journal of Systems and Software, 58, 171-180.
Ou, X., Rajagopalan, S. R., & Sakthivelmurugan, S. (2009). An empirical approach to modeling uncertainty in intrusion

analysis. In ACSAC 2009 (pp. 494­503). IEEE Computer Society. Paradkar, A. M., & Klinger, T. (2004). Automated consistency and completeness checking of testing models for interactive systems. In COMPSAC 2004 (pp. 342­348). IEEE Computer Society. Perrouin, G., Brottier, E., Baudry, B., & Traon, Y. L. (2009). Composing models for detecting inconsistencies: A requirements engineering perspective. In REFSQ 2009 (pp. 89­ 103). Petersen, K., Feldt, R., Mujtaba, S., & Mattsson, M. (2008). Systematic mapping studies in software engineering. In G. Visaggio, M. T. Baldassarre, S. G. Linkman, & M. Turner (Eds.), EASE 2008. BCS. Petersen, K., Spreitzer, M., Terry, D. B., Theimer, M., & Demers, A. J. (1997). Flexible update propagation for weakly consistent replication. In SOSP 1997 (pp. 288­301). Prasetya, I. S. W. B., & Klomp, R. (2019). Test model coverage analysis under uncertainty. In SEFM 2019 (pp. 222­239). Ramirez, A. J., Cheng, B. H. C., Bencomo, N., & Sawyer, P. (2012). Relaxing claims: Coping with uncertainty while evaluating assumptions at run time. In R. B. France, J. Kazmeier, R. Breu, & C. Atkinson (Eds.), MODELS 2012 (Vol. 7590, pp. 53­69). Springer. Reder, A. (2011). Inconsistency management framework for model-based development. In ICSE 2011 (pp. 1098­1101). Reder, A., & Egyed, A. (2012a). Computing repair trees for resolving inconsistencies in design models. In ASE 2012 (pp. 220­229). Reder, A., & Egyed, A. (2012b). Incremental consistency checking for complex design rules and larger model changes. In MODELS 2012 (pp. 202­218). Reder, A., & Egyed, A. (2013). Determining the cause of a design model inconsistency. IEEE Trans. Software Eng., 39(11), 1531­1548. Riedl-Ehrenleitner, M., Demuth, A., & Egyed, A. (2014). Towards model-and-code consistency checking. In COMPSAC 2014 (pp. 85­90). Rose, L. M., Kolovos, D. S., Paige, R. F., & Polack, F. A. C. (2009). Enhanced automation for managing model and metamodel inconsistency. In ASE 2009 (pp. 545­549). Sabetzadeh, M., Nejati, S., Easterbrook, S. M., & Chechik, M. (2008). Global consistency checking of distributed models with tremer+. In ICSE 2008 (pp. 815­818). Sabetzadeh, M., Nejati, S., Liaskos, S., Easterbrook, S. M., & Chechik, M. (2007). Consistency checking of conceptual models via model merging. In RE 2007 (pp. 221­230). Salay, R., Chechik, M., & Gorzny, J. (2012). Towards a methodology for verifying partial model refinements. In G. Antoniol, A. Bertolino, & Y. Labiche (Eds.), ICST 2012 (pp. 938­945). IEEE Computer Society. Salay, R., Chechik, M., & Horkoff, J. (2012). Managing requirements uncertainty with partial models. In M. P. E. Heimdahl & P. Sawyer (Eds.), RE 2012 (pp. 1­10). IEEE Computer Society. Salay, R., Famelis, M., & Chechik, M. (2012). Language independent refinement using partial modeling. In J. de Lara

16 Weidmann et al.

& A. Zisman (Eds.), FASE 2012 (Vol. 7212, pp. 224­239). Springer. Salih, A. M., Omar, M., & Yasin, A. (2017). Understanding uncertainty of software requirements engineering: A systematic literature review protocol. In M. Kamalrudin, S. Ahmad, & N. Ikram (Eds.), APRES 2017 (Vol. 809, pp. 164­171). Springer. Schoenboeck, J., Kusel, A., Etzlstorfer, J., Kapsammer, E., Schwinger, W., Wimmer, M., & Wischenbart, M. (2014). CARE - A constraint-based approach for re-establishing conformance-relationships. In G. Grossmann & M. Saeki (Eds.), APCCM 2014 (Vol. 154, pp. 19­28). Australian Computer Society. Serban, A., Poll, E., & Visser, J. (2020). Towards using probabilistic models to design software systems with inherent uncertainty. In ECSA 2020 (pp. 89­97). Shan, L., & Zhu, H. (2004). Consistency check in modelling multi-agent systems. In (COMPSAC 2004 (pp. 114­119). Shan, L., & Zhu, H. (2006). Specifying consistency constraints for modelling languages. In SEKE 2006 (pp. 578­583). Siavashi, F., & Truscan, D. (2015). Environment modeling in model-based testing: concepts, prospects and research challenges: a systematic literature review. In J. Lv, H. J. Zhang, & M. A. Babar (Eds.), EASE 2015 (pp. 30:1­30:6). ACM. Sottet, J.-S., & Biri, N. (2016). Jsmf: a javascript flexible modelling framework. In Flexmde@models 2016 (Vol. 1694, pp. 42­51). CEUR-WS.org. Stevens, P. (2014). Bidirectionally tolerating inconsistency: Partial transformations. In FASE 2014 (pp. 32­46). Stevens, P. (2017). Bidirectional transformations in the large. In MODELS 2017 (pp. 1­11). IEEE Computer Society. Stevens, P. (2018a). Is bidirectionality important? In ECMFA 2018 (pp. 1­11). Stevens, P. (2018b). Towards sound, optimal, and flexible building from megamodels. In MODELS 2018 (pp. 301­ 311). Straeten, R. V. D., Mens, T., Simmonds, J., & Jonckers, V. (2003). Using description logic to maintain consistency between UML models. In P. Stevens, J. Whittle, & G. Booch (Eds.), UML 2003 (Vol. 2863, pp. 326­340). Springer. Szvetits, M., & Zdun, U. (2016). Systematic literature review of the objectives, techniques, kinds, and architectures of models at runtime. Software and Systems Modeling, 15(1), 31­69. Tang, J., Zhang, J., Yao, L., Li, J., Zhang, L., & Su, Z. (2008). Arnetminer: extraction and mining of academic social networks. In Y. Li, B. Liu, & S. Sarawagi (Eds.), KDD 2008 (pp. 990­998). ACM. Tran, L. M. S., & Massacci, F. (2014, 09). An approach for decision support on the uncertainty in feature model evolution. In RE 2014 (p. 93-102). Trollmann, F., Blumendorf, M., Schwartze, V., & Albayrak, S. (2011). Formalizing model consistency based on the abstract syntax. In EICS 2011 (pp. 79­84). Vallecillo, A., Morcillo, C., & Orue, P. (2016, Sep.). Expressing measurement uncertainty in software models. In QUATIC 2016 (p. 15-24). Vierhauser, M., Grünbacher, P., Egyed, A., Rabiser, R., & Hei-

der, W. (2010). Flexible and scalable consistency checking on product line variability models. In ASE 2010 (pp. 63­72). Vierhauser, M., Grünbacher, P., Heider, W., Holl, G., & Lettner, D. (2012). Applying a consistency checking framework for heterogeneous models and artifacts in industrial product lines. In MODELS 2012 (pp. 531­545). Vouk, M. A., Paradkar, A. M., & McAllister, D. F. (1990). Modeling execution time of multi-stage n-version fault-tolerant software. In Proceedings of the fourteenth annual international computer software and applications conference, COMPSAC 1990, chicago, il, usa, october 31 1990 - november 2, 1990 (pp. 505­511). Vukovic, V., Djurkovic, J., & Trninic, J. (2018). A business software testing process-based model design. International Journal of Software Engineering and Knowledge Engineering, 28(5), 701­750. Wang, B., Xiong, Y., Hu, Z., Zhao, H., Zhang, W., & Mei, H. (2010). A dynamic-priority based approach to fixing inconsistent feature models. In MODELS 2010 (pp. 181­ 195). Wang, C., & Cavarra, A. (2009). Checking model consistency using data-flow testing. In APSEC 2009 (pp. 414­421). Weidmann, N., Anjorin, A., Fritsche, L., Varró, G., Schürr, A., & Leblebici, E. (2019). Incremental bidirectional model transformation with emoflon: : Ibex. In J. Cheney & H. Ko (Eds.), Bx@PLW 2019 (Vol. 2355, pp. 45­55). CEUR-WS.org. Wolfe, C., Graham, T. C. N., & Phillips, W. G. (2009). An incremental algorithm for high-performance runtime model consistency. In MODELS 2009 (pp. 357­371). Wolny, S., Mazak, A., Carpella, C., Geist, V., & Wimmer, M. (2020). Thirteen years of sysml: a systematic mapping study. Software and Systems Modeling, 19(1), 111­169. Wortmann, A., Barais, O., Combemale, B., & Wimmer, M. (2020). Modeling languages in industry 4.0: an extended systematic mapping study. Software and Systems Modeling, 19(1), 67­94. Wortmann, A., Combemale, B., & Barais, O. (2017). A systematic mapping study on modeling for industry 4.0. In MODELS 2017 (pp. 281­291). IEEE Computer Society. Xiong, Y., Hu, Z., Zhao, H., Song, H., Takeichi, M., & Mei, H. (2009). Supporting automatic model inconsistency fixing. In H. van Vliet & V. Issarny (Eds.), ESEC/SIGSOFT FSE 2009 (pp. 315­324). ACM. Yu, H., & Vahdat, A. (2000). Design and evaluation of a continuous consistency model for replicated services. In OSDI 2000. USA: USENIX Association. Zhang, M., Ali, S., Yue, T., & Norgren, R. (2017). Uncertaintywise evolution of test ready models. Inf. Softw. Technol., 87, 140­159. Zhang, M., Ali, S., Yue, T., Norgren, R., & Okariz, O. (2019). Uncertainty-wise cyber-physical system test modeling. Softw. Syst. Model., 18(2), 1379­1418. Zolotas, A., Clarisó, R., Matragkas, N., Kolovos, D., & Paige, R. (2016, 12). Constraint programming for type inference in flexible model-driven engineering. Computer Languages, Systems & Structures, 49.

Tolerance in MDE: A Systematic Literature Review with Model-Driven Tool Support 17

