arXiv:2106.00714v1 [cs.CC] 1 Jun 2021

Parallel Polynomial Permanent Mod Powers of 2 and Shortest Disjoint Cycles
Samir Datta
Chennai Mathematical Institute, Chennai sdatta@cmi.ac.in
Kishlaya Jaiswal
Chennai Mathematical Institute, Chennai kishlaya@cmi.ac.in
Abstract
We present a parallel algorithm for permanent mod 2k of a matrix of univariate integer polynomials. It places the problem in L  NC2. This extends the techniques of Valiant [26], Braverman, Kulkarni and Roy [3] and Björklund and Husfeldt [2] and yields a (randomized) parallel algorithm for shortest 2-disjoint paths improving upon the recent (randomized) polynomial time algorithm [2].
We also recognize the disjoint paths problem as a special case of finding disjoint cycles, and present (randomized) parallel algorithms for finding a shortest cycle and shortest 2-disjoint cycles passing through any given fixed number of vertices or edges.
2012 ACM Subject Classification Theory of computation  Parallel algorithms
Keywords and phrases permanent mod powers of 2, parallel computation, graphs, shortest disjoint paths, shortest disjoint cycles
Digital Object Identifier 10.4230/LIPIcs.CVIT.2016.23
Funding Samir Datta: Partially funded by a grant from Infosys foundation and SERB-MATRICS grant MTR/2017/000480
Acknowledgements We would like to thank Eric Allender for a discussion regarding what was known about field operations in L. We would also like to thank Partha Mukhopadhyay for his comments on a preliminary version of the paper.
1 Introduction
The problem of computing the determinant of a matrix has been a very well studied problem in the past, and several fast (both sequential and parallel) algorithms are known. On the contrary, Valiant in his seminal paper [26] showed that computing permanent of a matrix, an algebraic analogue of determinant, is hard. However modulo 2, determinant and permanent are equal and so building up on this, he presented an algorithm for computing permanent of an integer matrix modulo small powers of 2. The algorithm uses Gaussian elimination which is known to be highly sequential and so it is desirable to have a parallel algorithm. This was resolved by [3] who presented a L  NC algorithm.
Moreover, NC algorithms for computing determinant of matrices over arbitrary commutative rings are also known, e.g. [17]. We would like to ask a similar question for the permanent. One natural extension would be to consider the ring of polynomials with integer coefficients. In this paper, we present a NC algorithm to compute permanent of matrices over integer polynomials modulo 2k for any fixed k.
 Theorem 1. Let k  1 be fixed and A be a n × n matrix of integer polynomials, such that the degree of each entry is atmost poly(n). We can compute perm(A) (mod 2k) in L  NC2
© Samir Datta and Kishlaya Jaiswal; licensed under Creative Commons License CC-BY 4.0 42nd Conference on Very Important Topics (CVIT 2016). Editors: John Q. Open and Joan R. Access; Article No. 23; pp. 23:1­23:21
Leibniz International Proceedings in Informatics Schloss Dagstuhl ­ Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

23:2 Parallel Polynomial Permanent
In the second half of the paper, we consider some applications of our parallel polynomial permanent algorithm. One direct consequence is that we are now able to parallelize the shortest 2-disjoint paths problem [2]. Furthermore, we generalize this problem by adding more constraints on the disjoint paths - that the paths should pass through any given set of edges. This can also be viewed as a problem of finding 2-disjoint cycles, for which we present a randomized parallel algorithm, using the techniques from [28] and [2].
 Theorem 2. Let k  1 be fixed and G be an undirected graph with k marked vertices. We can find shortest 2-disjoint cycles passing through the marked vertices in L/poly (and RNC)
Finally, we notice that a similar approach gives us an algorithm to compute Hafnians modulo 2k of symmetric matrices of integers. Unfortunately, unlike the case of the permanent, we weren't able to extend this to a parallel algorithm. But nevertheless it gives a direct proof of the fact that counting number of perfect matchings modulo 2k, in any general graph, is in P, as proved in [3].
1.1 Historical Survey
The problem of computing permanent of an integer matrix was first shown to be NPhard by Valiant, where he also presented a O(n4k-3) running time algorithm to compute permanent modulo 2k. It was also shown that computing permanent modulo any odd prime still remains hard. Zanko [29] gave a proof for hardness of permanent under many-one reductions strengthening the result from the weaker Turing reductions used by Valiant. Later, Braverman, Kulkarni and Roy [3] presented a parallel SPACE(k2 log n) algorithm for computing permanent modulo 2k. Björklund and Husfeldt [2] presented a d3nO(k) time algorithm to compute permanent modulo 2k of matrices over integer polynomials where the entries are of degree atmost d.
Finding k disjoint paths in a graph has been a well studied problem in the past: given a graph (undirected/directed) and k pairs of terminals (si, ti)1ik, find k pairwise vertexdisjoint paths Pi from si to ti, if they exist.
When k is not fixed (and is part of input) then the problem is known to be NP-hard even for undirected planar graphs [15]. Linear time algorithms are known when further restricting directed planar graphs to the case: when all terminals lie on outer face [25], or when all the si-terminals lie on one common face while all the ti-terminals lie on another common face [22]. If we further ask for paths with minimal total length in the latter problem, then [7] presented a O(kn log n) running time algorithm to achieve the same.
When k is fixed, the problem remains NP-hard for directed graphs, even for k = 2 [11], who had also given given a poly time algorithm for the restricted case of directed acyclic graphs. In the restriced setting of directed planar graphs, [24] presented a nO(k) running time algorithm, which was further improved to a fixed parameter tractable algorithm by [4].
Shifting our focus to undirected graphs, the celebrated work of Robertson and Seymour [23] gave a O(n3) algorithm for finding k disjoint paths in an undirected graph, for any fixed k. [6] gave a parallel algorithm for class of planar graphs where all the terminals lie either on one or two faces. All this while, the question of finding shortest disjoint paths in general undirected graphs, remained open for many years until recently, Björklund and Husfeldt [2] gave a polynomial time algorithm for finding the shortest 2-disjoint paths. For general k, this problem still remains open. Björklund and Husfeldt also gave a parallel algorithm to count shortest 2-disjoint paths but only for cubic planar graphs [1].

S. Datta and K. Jaiswal

23:3

1.2 Our Techniques
To compute permanent of a matrix A over integer polynomials, we closely follow the analysis of [3] but immediately hit an obstacle. They give a reduction from perm(A) (mod 4) to several computations of perm(.) (mod 2), which crucially uses the fact that Z2 is a field. More precisely, when mimicking the proof, firstly it is required to find a non-trivial solution of Av = 0 with the property that atleast one of the entries of this vector is invertible. This fails1 over Z2[x]. Moreover, their algorithm also uses the fact that a non-singular matrix admits a LU decomposition iff all the leading principal minors are non-zero, which is known to hold in general only for matrices over fields.
Therefore, replacing Z with Z[x] in their analysis doesn't work as Z2[x] isn't a field. Furthermore, any finite field F of characteristic 2 only corresponds to modulo 2 arithmetic. We need a way to extend the field structure so that it supports modulo 2k arithmetic as well. If F was realized as Z2[x]/(p(x)) where p(x) is irreducible over Z2 then a possible candidate is the ring Z[x]/(2k, p(x)). Therefore, the appropriate algebraic structure to consider would be the ring R = Z[x]/(p(x))
Now we see that replacing Z with R solves the above mentioned problems in the analysis, primarily because of the fact that R (mod 2) is a finite char 2 field. With a slight bit of modification in the proof, we achieve that: given a matrix A over R, we can find perm(A) (mod 2k) or in other words if A is a matrix over Z[x], we can compute perm(A) (mod 2k, p(x)).
We are still not done because our aim was to compute perm(A) (mod 2k) over Z[x]. To achieve that, we choose p(x) such that its degree is larger than the degree of polynomial perm(A). This requires doing computations over a large field. Alternatively, we develop a new way of interpolation over R, which allows us to choose p(x) such that its degree is of logarithmic order of degree perm(A), but with a tradeoff of computing several (polynomially many) more permanents. We present this technique for its novelty.
Wahlström [28] addressed the question of finding a cycle passing through given vertices. We ask if we can also find shortest such cycle. And furthermore, can we also find shortest 2-disjoint cycles passing through these vertices? We combine techniques of [28] and [2] to answer the above questions, by reducing them to computing permanents modulo 2 of 2k-1 and modulo 4 of 2k-1 + 2k-2 matrices respectively. These matrices are adjacency matrix of what we refer to as pattern graphs. Notice that for k = 2 finding shortest 2-disjoint cycles corresponds to finding shortest 2-disjoint paths (by connecting each pair of terminals with a common vertex), and in this case our pattern graphs are exactly those presented in [2].
1.3 Organization of the Paper
In section 2, we first introduce the preliminaries and the notation that we shall be using throughout this paper. In the next section 3, we present proof of our main theorem 1 about computing permanent modulo 2k, following which we also discuss the complexity of required computations over the ring R which shows that our algorithm is in L. We also present an alternative proof for our main theorem in section 4 which uses new techniques. Then we present applications of our result that is finding shortest disjoint cycles in section 5. Section 6 discusses how to apply the same techniques to hafnian and hence it gives an alternate proof of the already known result that counting perfect matchings modulo 2k is in P.

1 Let A =

x x

x+1 x+1

then there does not exist any null vector of the form

f 1

or

1 f

for any f  Z2[x]

CVIT 2016

23:4 Parallel Polynomial Permanent

2 Preliminaries

We begin by stating the definition of the complexity class L.

 Definition 3. L is the class of decision problems solvable by an NL machine such that If the answer is 'yes', then the number of accepting paths is odd. If the answer is 'no', then the number of accepting paths is even.

Given a n × n matrix A = (aij)i,j[n], determinant and permanent of A are defined as

n

det(A) =

sgn() ai(i)

Sn

i=1

n

perm(A) =

ai(i)

Sn i=1

The permanent of a matrix can be regarded as the weighted sum of cycle covers of an undirected graph. This gives a combinatorial interpretation to a seemingly pure algebraic quantity. We shall use this bridge to illustrate an application of our parallel polynomial permanent.
Let G be a weighted undirected graph (not necessarily loopless) with the associated weight function w.

 Definition 4. We say C  V (G) × V (G) is a cycle cover of G if (u, v)  C = {u, v}  E(G) C is a union of vertex-disjoint simple directed cycles in G every vertex is incident to some directed edge in C

Note: loops are allowed as simple cycles in the above definition.

 Definition 5. For any cycle cover C we denote the weight of C by w~(C) = eC w(e)
The above definition is well-defined because any directed edge (u, v) or (v, u) in our cycle cover correspond to the same edge {u, v} in our underlying undirected graph. And hence both these directed edges get the same weight, that is w((u, v)) = w((v, u)) = w({u, v}). In literature, such type of weight functions are commonly referred to as symmetric weight functions.

 Definition 6. Let V (G) = [n] then we say A = (aij)i,j[n] is the (n × n) adjacency matrix of G if

w(e) aij =
0

if e = {i, j}  E(G) otherwise

 Observation 7. perm(A) = w~(C) where the sum is taken over all cycle covers C of G

3 Permanent over R Mod 2k
To begin with, we fix some general notation. Let p(x) be an irreducible polynomial over Z2[x] such that deg(p(x)) is atmost poly(n). Denote by F the finite field of char 2, which is realized as Z2[x]/(p(x)) and by Rk = Z[x]/(2k, p(x)). In particular R1 = F. Now as already discussed, we essentially replace Z by R in the algorithm of [3]. We are ready to state the main theorem.
 Theorem 8. Let k  1 be fixed and A  Rn×n. We can compute perm(A) (mod 2k) in L

S. Datta and K. Jaiswal

23:5

Proof is by induction on k. We start with the base case k = 1. Note that perm(A)  det(A) (mod 2). Using corollary 15 we can find perm(A) (mod 2) in L. Now suppose k > 1, we shall reduce it to computing several such determinants modulo 2, all of which can be computed in parallel. In doing so, we first illustrate an algorithm which is sequential and then we shall see how to parallelize it.

3.1 Sequential algorithm for computing permanent modulo 2k

We present the algorithm from [3] for computing permanent but translated within our framework. Let A = (aij)i,j[n]  Rn×n be such that det(A)  0 (mod 2). Therefore we can find a non-zero vector v  Fn such that AT v = 0 over F. Assume without loss of generality
v1 = 1. Let ri denote the ith row of A and define A to be the matrix where the 1st row in matrix
A is replaced with i viri. Now if we expand the permanent along the first row then we get

n

n

perm(A) = viperm(A[1  i]) = perm(A) + viperm(A[1  i])

(1)

i=1

i=2

where A[i  j] is the matrix A but with ith row replaced with the jth row. For I, J  [n] denote by A[I, J] the matrix obtained from A by deleting rows indexed by I and columns indexed by J. With this equation, modulo 2k computation reduces to modulo 2k-1 computations of the minors as follows:

n

n

perm(A) =

viaij perm(A[{1}, {j}])

j=1 i=1

Since AT v = 0 (mod 2), we can write i viaij = 2bj (mod 2k) for some bj  Rk, therefore, we can re-write the above permanents as:





n

perm(A) (mod 2k) = 2  bjperm(A[{1}, {j}]) (mod 2k-1)

j=1

Similarly, expanding perm(A[1  i]) along the 1st and ith rows, we get the reduction:

perm(A[1  i]) = aijaikperm(A[{1, i}, {j, k}])

j=k





perm(A[1  i]) (mod 2k) = 2  aijaikperm(A[{1, i}, {j, k}]) (mod 2k-1)
j<k

Substituting these equations back in 1, we get





n

perm(A) (mod 2k) = 2  bjperm(A[{1}, {j}]) (mod 2k-1)

j=1





n

n

-2

vi

 

aijaikperm(A[{1, i}, {j, k}]) (mod 2k-1)





i=2

j,k=1

j<k

CVIT 2016

23:6 Parallel Polynomial Permanent
Since addition and multiplication over Rk is in L (see 20) we get that perm(A) (mod 2k) L-reduces to perm(.) (mod 2k-1). Hence by induction, we can compute perm(A) (mod 2k) in L, provided that perm(A)  0 (mod 2).
Let us see how to drop this assumption. We expand the permanent of A along the ith row, then
perm(A) = aijperm(A[{i}, {j}])
j
If perm(A)  0 (mod 2), then i, j such that perm(A[{i}, {j}])  0 (mod 2). Consider the matrix C where all entries are same as A except the (i, j)th entry which is replaced with aij + y. Then, we get perm(C) = perm(A) + yperm(A[{i}, {j}]). Notice that perm(A) + yperm(A[{i}, {j}])  0 (mod 2) is a linear equation in y over the field F and so there exists a unique y which satisfies this equation, which is y0 = perm(A)perm(A[{i}, {j}])-1. Setting y = y0 we get perm(C)  0 (mod 2), so we can compute perm(C) (mod 2k) and then compute perm(A[{i}, {j}]) recursively as A[{i}, {j}] is a smaller (n - 1) × (n - 1) size matrix. Hence we obtain perm(A) = perm(C) - y0perm(A[{i}, {j}]) (mod 2k). This yields a sequential algorithm for computing permanent modulo 2k over R.
3.2 Parallel algorithm for computing permanent modulo 2k
The bottleneck was finding i, j such that A[{i}, {j}] is non-singular over F. We fix this by again appealing to the fact that we are working over a field, and modifying A such that all leading principal minors are non-zero. This modification essentially derives from the following fact.
 Theorem 9. ([20] Corollary 1) Let A be an invertible matrix over a field F, then all leading principal minors are non-zero iff A admits an LU decomposition
Every invertible matrix admits a P LU factorization [20] so let A = P LU . Denote by Q = P -1, then QA = LU . Since Q is also a permutation matrix, we get that perm(QA) = perm(A) (because permanent is invariant under row swaps). Therefore, it suffices to give a L algorithm to find Q so that we can replace A by QA which is an invertible matrix such that all leading principal minors are non-zero. Thus computing perm(A) (mod 2k) reduces to the problem of computing (in parallel) permanent modulo 2k of n - 1 matrices with perm  0 (mod 2). This gives a L algorithm to compute permanent modulo 2k over R.
To find Q, we closely follow [9]. For each 1  i  n, let Ai be the matrix formed from A by only taking the first i columns. Let Aji matrix obtained from Ai by only taking the first j rows. We construct a set Si  [n] inductively as follows:
Base case: l  Si if rank(Ali) = 1 and rank(Aki ) = 0 for all k < l Include j  Si iff rank(Aji ) = 1 + rank(Aij-1)
Since rank(Ai) = i, we get |Si| = i. Furthermore note that Si  Si+1. So let S1 = {s1} and for each i  2, denote by si  Si \ Si-1. Consider the following permutation Q = (n, sn) . . . (2, s2)(1, s1). Thus Q is our desired permutation, such that QA has all leading principal minors non-zero.
As a corollary, we immediately get our desired result.
 Corollary 10. (Theorem 1 restated) Given a n × n matrix A = (aij)i,j[n] over Z[x] with deg(aij) atmost poly(n), we can compute perm(A) (mod 2k) in L for any fixed k  1

S. Datta and K. Jaiswal

23:7

Proof. Let N = n max{deg(aij)} + 1 and choose l = log3(N/2). Consider p(x) = x2.3l + x3l + 1 which is irreducible over Z2[x] (see [27] Theorem 1.1.28)

Since deg(p(x))  N > deg(perm(A)), using this p(x) in above theorem, we get

perm(A) (mod 2k) for any fixed k.



3.3 Complexity Analysis

We discuss the complexity results for arithmetic operations over the ring Rk and matrix operations over the field F, which were required in our above algorithm. To begin with, we state a well-known fact about integer polynomials matrix multiplication modulo 2. This shall form our basis for showing computations over F in L.
 Lemma 11. (Folklore [5]) Let A1, A2, . . . An  Z2[x]n×n then the product A1A2 . . . An can be computed in L

To obtain an analogous result over F we first perform multiplication over Z2[x] and then divide all entries by p(x), using the following polynomial division, as demonstrated by Hesse, Allender and Barrington in [12], to get that iterated matrix product over F is in L

 Lemma 12. ([12] Corollary 6.5) Given g(x), p(x)  Z[x] of degree atmost poly(n), we can compute g(x) (mod p(x)) in DLOGTIME - uniform TC0  L

In particular, it follows that given an irreducible polynomial p(x) (over Z2[x]), then for any g(x)  Z[x] of degree atmost poly(n) we can find g(x) (mod 2k, p(x)) in L, for any fixed k  1.
 Corollary 13. Let A1, A2, . . . An  Fn×n such that the degree of each entry is atmost poly(n) then the product A1A2 . . . An can be computed in L
Our algorithm also requires computing inverse of non-zero elements. To compute inverse over F we adopt the techniques from Fich and Tompa [8, 10]. Since F = Z2[x]/(p(x)) with N = deg(p(x)) which is atmost poly(n), then given a  F, we observe that a-1 = aq-2 where q = 2N = |F|.
We interpret this equation over Z2[x], that is we need to compute a(x)q-2 (mod p(x)) over Z2[x]. First we show how to compute a(x)2 (mod p(x)). Construct the N × N matrix Q whose ith row (Qi,0, Qi,1, . . . , Qi,N-1) is defined as:

N -1
Qi,jxj = x2i (mod p(x))
j=0
for each 0  i  N -1. Matrix Q can be computed in L using the divison lemma 12. Then the elements of the row vector (a0, a1, . . . , aN-1)Q are the coefficients of a(x)2 (mod p(x)) as explained in section 3 of [10]. Furthermore, the coefficients of a(x)2k (mod p(x)) are given by (a0, a1, . . . , aN-1)Qk. From lemma 11 we get that a(x)2k (mod p(x)) can be computed in L, for any k bounded by poly(n). Therefore. writing q - 2 = (c0, c1, . . . , cN-1) in binary,

N -1

a(x)q-2 (mod p(x)) =

a(x)ci2i (mod p(x))

i=0

can be computed in L, which gives us a-1. Mahajan and Vinay [17] describe a way to reduce the computation of a determinant
over a commutative ring to a semi-unbounded logarithmic depth circuit with addition and multiplication gates over the ring. In fact, the following is an easy consequence of their result:

CVIT 2016

23:8 Parallel Polynomial Permanent

 Lemma 14. (Mahajan-Vinay [17]) Let A  Rn×n be a matrix over a commutative ring. Then there exist M  R(2n2)×(2n2) and two vectors a, b  R2n2 such that det(A) = aT M nb.
Moreover, each entry of the matrix Mij and the vectors a, b is one of the entries Ai,j or a constant from {0, 1} and the mapping  where for every (i, j)  [2n2] × [2n2], (i, j) 
A[n]×[n]  {0, 1} is computable in Logspace.

Proof. (Sketch) In [17], given a matrix A they construct a graph HA whose vertex set is
{s, t+, t-}  Q where Q = {[p, h, u, i] : p  {0, 1}, h, u  [n], i  {0, . . . , n - 1}}. Moreover, the edges are one of the following forms (s, q), (q, q), (q, t+) and (q, t-) where q, q  Q and have weights w(q, q) that each depend on a single entry of A or are one of the constants

0, 1. Moreover the mapping is very simple to describe. Let us focus on the induced subgraph

HA[Q]. Notice that |Q| = 2n3 and each "layer" of HA[Q] is identical. In other words,

ei = [p, h, u, i], [p, h, u, i + 1] is an edge in HA[Q] iff ej = [p, h, u, j], [p, h, u, j + 1] is

an edge in HA[Q] and both have the same weights for every i, j  {0, . . . , n - 1}. Thus define

the matrix M by putting M[p,h,u],[p,h,u] as the weight of any of the edges ei.

Finally to define a, b: let a[n mod 2,1,1] = 1 and aq = 0 for all other q. b[1,h,u] = auh and

b[0,h,u] = -auh. The correctness of our Lemma then follows from the proof of Lemma 2 of

[17].



Using above lemma 14, we reduce determinant over F to matrix powering over F, which can be computed in L using corollary 13. Hence we get

 Corollary 15. Let A  Fn×n then det(A) can be computed in L

Now we demonstrate two results: computing rank and a null vector a matrix over F in

L. We use Mulmuley's algorithm [18], which requires finding determinant over the ring

F[y, t], which reduces to matrix powering over F[y, t] by the above result. We shall further

reduce this to matrix powering over F as follows: Let R be an arbitrary commutative ring.

We associate with each polynomial f (x) =

d-1 i=0

fixi



R[x]

a

d

×

d

lower-triangular

matrix

 f0



 f1 f0



 P (f ) = 

f2

f1

f0

   Rd×d

  

...

...

...

...

  

fd-1 fd-2 fd-3 . . . f0

Suppose we have two polynomials f (x) and g(x) of degree d1 and d2 respectively. We can interpret them as degree d1 + d2 polynomials (with higher exponent coefficients as 0). Then we have that P (f + g) = P (f ) + P (g) and P (f g) = P (f )P (g).

 Theorem 16. Let R be any commutative ring and A1, A2, . . . An be n × n matrices over R[x] such that the degree of each entry is atmost poly(n). Denote by A = Al. There exists poly(n) × poly(n) matrices B1, B2, . . . Bn over R such that the coefficient of xk in Aij is equal to B(i,j,k) where B = Bl and  is logspace computable.
In other words, iterated matrix multiplication over R[x] is logspace reducible to iterated
matrix multiplication over R.

Proof. Let N = n maxi,j,k[n]{deg((Ai)jk)} where (Ai)jk denotes the (j, k)th entry of Ai. By our assumption, N is atmost poly(n). Now for each 1  i  n, compute the matrix Bi  RnN×nN obtained from Ai by replacing each polynomial (Ai)jk with the N × N matrix P ((Ai)jk). These matrices Bi can be computed in log space. Now the coefficient of xk in

S. Datta and K. Jaiswal

23:9

Aij can be read from the entry B(i,j,k) where (i, j, k) = ((i - 1)N + k + 1, (j - 1)N + 1) is logspace computable. The correctness follows from our observation P (f g) = P (f )P (g). 

 Remark. This gives us an alternate proof of the fact that iterated matrix multiplication over Z2[x] is in L, as it follows immediately from the definition of L that iterated matrix multiplication over Z2 is in L.
 Lemma 17. [18] Let A  Fm×n then rank(A) can be computed in L

Proof. We can assume that A is a square (n × n) symmetric matrix because otherwise

0A replace A with AT 0 which has rank twice that of A. Let Y be a n × n diagonal

matrix with the (i, i)th entry as yi-1. And let m be the smallest number such that tm has a

non-zero coefficient in the characteristic polynomial of Y A, that is det(tI - Y A). Then rank

of A = n - m.

Suffices to show that det(tI - Y A) can be computed in L. Notice that (tI - Y A) 

F[y, t]n×n and so det(tI - Y A) is logspace reducible to matrix powering over F[y, t]. Using the canonical isomorphism F[y, t] = F[y][t], repeated application of theorem 16 logspace

reduces it to matrix powering over F.



 Observation 18. Let A  Fn×n be an invertible matrix then A-1 can be computed in L
This follows from the fact that computing A-1 involves computing the determinant of A and n2 cofactors, that is determinants of n2 matrices of size (n - 1) × (n - 1). Notice that this also requires inverting the determinant, an element of F, which has been explained above.

 Corollary 19. Let A  Fn×n then finding a non-trivial null vector (if it exists) is in L

Proof. Let rank(A) = m, then permute the rows and columns of A so that we can express

BC

x

A=

such that B is an invertible m × m matrix. Let

be a column vector

DE

y

where x  Fm and y  Fn-m, such that

x

BC x

A = 0 =

=0

y

DE y

This reduces to the set of equations: Bx + Cy = 0 and Dx + Ey = 0. But the later is a redundant set of equations because D E can be written in terms of B C . More precisely, there exists a matrix V  Fn-m×m such that D = V B and E = V C and so Dx + Ey = V Bx + V Cy = V (Bx + Cy) = 0. Therefore setting x = 1 and y = -B-1C1, gives us the desired null vector. So it suffices to give a L algorithm to transform A to the form as specified above, which follows from [9]. Let Ai be the matrix formed from first i rows of A. We construct a set S  [n] as follows:

Base case: i  S if rank(Ai) = 1 and rank(Aj) = 0 for all j < i Include k  S iff rank(Ak) = 1 + rank(Ak-1)

It follows that |S| = m and let S = {i1 < i2 < · · · < im} and Pr be the permutation

matrix described by (m, im) . . . (2, i2)(1, i1). Then PrA is the required matrix having first

m rows as linearly independent. Next, consider the matrix A = (PrA)T and apply the

above algorithm to get a permutation matrix Pc such that first m rows of PcA are linearly

independent. Then PrAPcT is the required matrix such that the leading principal m-minor

is non-singular.



CVIT 2016

23:10 Parallel Polynomial Permanent

Finally, to conclude our result, we discuss arithmetic over Rk

 Lemma 20. Let k  1 be fixed then the following operations can be done in L Multiplication : Given a, b  Rk compute ab Iterated Addition: Given c1, c2, . . . , cn  Rk compute i ci

Proof. We use the fact that the arithmetic operations mentioned in the statement of lemma, but over Z2k are in L (see for e.g. [12])

Let a(x), b(x)  Rk and write a(x) =

D i=0

aixi

and

b(x)

=

D i=0

bixi,

then

a(x)b(x)

=

D+D i=0

i j=0

aj

bi-j

xi. Finally, using lemma 12, divide a(x)b(x) by p(x) to obtain

ab  Rk

Similarly, let c1(x), c2(x), . . . , cn(x)  Rk and write ci(x) =

Di j=0

cij xj

for

each

i



[n],

then

n i=1

ci(x)

=

max{Di } j=0

(

n i=1

cij

)

xj

where

we

assume

cij

=

0

if

j

>

Di



3.4 Examples
1 x+1 x+2 Let A =  x x2 x2 + x, p(x) = x6 + x3 + 1 be the irreducible polynomial and we
x2 3 x2 + 3 want to evaluate perm(A) (mod 4) over the ring R = Z[x]/(p(x)). First of all, a direct computation gives us perm(A) = 2x5 + 6x4 + 2x3 + 12x2 + 12x. Now we demonstrate the steps taken by our algorithm.
Step 1: We start by evaluating perm(A) (mod 2). We directly notice here that last column is the sum of first two columns and so det(A) = 0 = perm(A)  0 (mod 2)

Step 2: Since det(A)  0 (mod 2), we solve the equation AT v = 0 over F by our method

1

x

x2  v1

as follows: x + 1 x2

1  v2 = 0

x x2 + x x2 + 1 v3

Since rank of the principal 2 × 2 submatrix is already 2, we set v3 = 1 and solve the

equation:

v1 v2

=- 1 x+1

x x2

-1

x2 1

1 to get v1 = x3 + 1 and v2 = x5 + x.

Step 3: For each j = 1, 2, 3, we find bj such that i viaij = 2bj (mod 4)

j=1: j=2: j=3:

(x3 + 1) + x(x5 + x) + x2 = 2x2 (x + 1)(x3 + 1) + x2(x5 + x) + 3 = 2x3 (x + 2)(x3 + 1) + (x2 + x)(x5 + x) + x2 + 3 = 2x3 + 2x2

Step 4: We have the formula





3

perm(A) (mod 4) = 2  bjperm(A[{3}, {j}]) (mod 2)

j=1





2

3

-2

vi

 

aijaikperm(A[{3, i}, {j, k}]) (mod 2)





i=1

j,k=1

j<k

S. Datta and K. Jaiswal

23:11

Step 4.1:

perm(A[{3}, {1}]) = perm

x+1 x2

x+2 x2 + x

= x (mod 2)

1 x+2 perm(A[{3}, {2}]) = perm x x2 + x = x (mod 2)

1 x+1

perm(A[{3}, {3}]) = perm x

x2

= x (mod 2)

3
= bjperm(A[{3}, {j}]) = ((x3) + (x4) + (x4 + x3)) = 0 (mod 2)
j=1

Step 4.2:

3
a1ja1kperm(A[{1, 3}, {j, k}])
j,k=1 j<k
= (x + 1)(x2 + x) + (x + 2)x2 + (x + 1)(x + 2)x = x3 + x2 + x (mod 2)
3
a2ja2kperm(A[{2, 3}, {j, k}])
j,k=1 j<k
= x3(x + 2) + x(x2 + x)(x + 1) + x2(x2 + x) = x4 + x3 + x2 (mod 2)





2

3

vi

 

aijaikperm(A[{3, i}, {j, k}]) (mod 2) = x5 + x4 + x3 (mod 4)





i=1

j,k=1

j<k

Therefore, perm(A) (mod 4) = 2x5 +2x4 +2x3 which matches with our direct computation.

Example 2

1 x x2

Consider A = x x2 1 , and so perm(A) = x5 + x4 + x2 + x. Therefore, we now have

1 x2 x

det(A)  0 (mod 2)

Step 1: Find Q such that QA has all leading principal minors are non-zero. In this case,

1 0 0

1 x x2

we will get Q = 0 0 1 = QA = 1 x2 x 

010

x x2 1

Step 2: Consider matrix C whose all entries are same as A except the last one 1 x x2 
which is incremented by y, that is C = 1 x2 x , then perm(C) = perm(A) + x x2 1 + y

yperm(A[{3}, {3}]). Again construct C same as A[{3}, {3}] but replace the last entry

incremented by y, that is C =

1x x x2 + y

= perm(C) = perm(A[{3}, {3}]) +

yperm(A[{2, 3}, {2, 3}]). Written as one equation, we get

perm(A) = perm(C) - y (perm(C) - ya11)

CVIT 2016

23:12 Parallel Polynomial Permanent

In this equation, both C, C are matrices with det  0 (mod 2) with the correct choice of y, y, which were:
y0 = perm(A)perm(A[{3}, {3}])-1 (mod 2) = (x5 + x4 + x2 + x)(x4 + x3 + x2) = x3 + 1 y0 = perm(A[{3}, {3}])perm(A[{2, 3}, {2, 3}])-1 (mod 2) = x2 + x
So we can compute perm(C) and perm(C) by above method and substitute it into previous equation to get perm(A) (mod 4)

4 Permanent via Interpolation

We now demonstrate another technique to compute permanent modulo 2k, which doesn't resort to computations over exponentially sized fields. This proceeds by choosing small degree polynomial p(x). The techniques developed in this section are new and hence interesting by themself.
First we mention a result from [14] used to interpolate the coefficients of a polynomial.
 Lemma 21. ([14] Lemma 3.1) Let F be a finite, characteristic 2, field of order q.

am = 0

aF

1

if q - 1  m otherwise

This dichotomy allows us to extract coefficients of any integer polynomial.

 Lemma 22. ([14] Corollary 3.2) Let f (x) =

d i=0

ci

xi

be

a

polynomial

with

integer

coefficients and q > d + 1, then for any 0  t  d,

aq-1-tf (a) = ct (mod 2)
aF
But this gives us the coefficients modulo 2 only. How do we get coefficients modulo 2k? The crucial observation here is that the above sum was computed over F. So instead we do so over R by identifying a copy of F - R, and then we have

am = 2m

aF

2m + 1

if q - 1  m otherwise

where m, m  R. Now we use repeated squaring method to obtain our desired modulo 2k result

 Lemma 23. m  0, k  1

(a1a2 · · · a2k-1 )m =
a1,...,a2k-1 F

am
aF

2k-1
=

0 (mod 2k) 1 (mod 2k)

if q - 1  m otherwise

Note: We remind the reader that the computation here is done over Rk

Proof. Fix any m  0. Clearly (2m)2k-1  0 (mod 2k). Suffices to show (2m + 1)2k-1  1 (mod 2k). This follows from induction on k. For k = 1
the result holds as stated above. Assume that for some k  1, the result holds. Then we have (2m + 1)2k-1 = 2km,k + 1 where m,k  R

(2m + 1)2k =

(2m + 1)2k-1

2
= (2km,k + 1)2 = 1 (mod 2k+1)



S. Datta and K. Jaiswal

23:13

Using this we can interpolate coefficients of an integer polynomial as follows:

(a1 . . . a2k-1 )q-1-tf (a1 . . . a2k-1 ) = ct (mod 2k)
a1,...,a2k-1 F
Finally let A(x) be a n × n matrix of integer polynomials and the permanent polynomial be
N
perm(A(x)) = cixi
i=0
From the above lemma it follows that

(a1a2 · · · )q-1-tperm(A(a1a2 · · · )) = ct (mod 2k)
a1 ,a2 ...F

provided that our field F is of order atleast N + 2.

For

this,

fix

l

=



log log N log 3



so

that

22.3l > N + 1. Hence the field obtained from the irreducible polynomial p(x) = x2.3l + x3l + 1

([27] Theorem 1.1.28) serves the purpose. It suffices to compute |F|2k-1 = O(N 2k-1 ) many

permanents over Rk to obtain all the coefficients ct modulo 2k, all of which can be computed

in parallel. Hence, we can compute the permanent of A modulo 2k in L.

5 Shortest Disjoint Cycles

Now that we have a L algorithm to compute permanent mod 2k, we are all set to demonstrate a parallel algorithm for shortest 2-disjoint paths. But we notice that we can place this problem in a more general framework of shortest disjoint cycles. Let us first formally define these problems.
SDP (k): Given a weighted undirected graph with k pairs of marked vertices {(si, ti) | 1  i  k}, find the minimum of sum of weight of paths between each pair si and ti such that all paths are pairwise disjoint.
SDC(l, k): Given a weighted undirected graph with k marked vertices, find the minimum of sum of weight of l cycles such that they pass through all the marked vertices and are pairwise disjoint and each cycle is incident to atleast one of the marked vertices.
 Note. We only consider non-trivial cycles that is we don't consider self-loops in the above problem.
Given an instance of the SDP (2) problem, join the pairs of vertices (s1, t1) and (s2, t2) with new vertices u1 and u2 respectively, as show in Figure 1. Notice that any two disjoint cycles passing through u1 and u2 give us two disjoint paths between (s1, t1) and (s2, t2).

t1 1
u1
1 s1

t2 1 u2 1
s2

Figure 1 Converting an instance of SDP (2) to SDC(2, 2)
Similarly, connecting the k-pairs of vertices via another new vertex and edges of weight x0 = 1, gives us a reduction from k-disjoint paths to k-disjoint cycles via k-vertices. Since

CVIT 2016

23:14 Parallel Polynomial Permanent
this reduction preserves the weight of the path/cycle, it is indeed a reduction from SDP (k) to SDC(k, k).
To apply the techniques of [2] to disjoint cycles problem, we instead consider the following variant SDCE(l, k): Given a weighted undirected graph with k marked edges, find the minimum of sum of weight of l cycles such that they pass through all the marked edges and are pairwise disjoint.
It can be easily seen that there is a logspace reduction from SDC(l, k) to SDCE(l, k) as follows: Let (G, {v1, v2, . . . , vk}) be an instance of SDC(l, k). Assume without loss of generality that the marked vertices form an independent set, or otherwise split the edge into two by introducing a new vertex in the middle. For each i, choose a vertex ui, a neighbour of vi, such that i = j = ui = uj, we solve (G, {e1, e2, . . . ek}) an instance of SDCE(l, k) where ei = {ui, vi} and output the smallest solution amongst all the instances of SDCE thus created. Since for each i, deg(vi) < n, number of instances of SDCE created are bounded by O(nk) all of which can be solved in parallel as k is fixed.
5.1 Pre-processing
Given a graph G = (V, E, w) and k marked edges {ei = {si, ti}}ik, assign weight xw(e) to the edge e of G and add self loops (weight 1) on all vertices except {si, ti}ik. Observe that all the non-zero terms appearing in the permanent of adjacency matrix correspond to a cycle cover in G. To force these k-edges in our cycle cover, we direct these edges in a certain way which we shall call as a pattern.
Formally, define a pattern P as an ordered pairing of terminals of given edges {si, ti | 1  i  k}. Furthermore, we view each undirected edge {u, v} in G as two directed edges (u, v) and (v, u) with the same weight. For any pattern P , define a pattern graph GP with the same vertex/edge set as of G but such that if (u, v)  P then all outgoing edges from u, except edge (u, v), are deleted. We denote by AP the adjacency matrix of GP .
Now we shall show how to solve the SDCE(1, k) problem for any k  1. This algorithm essentially follows from the work of [28]. Next, we also present how to solve the SDCE(2, k) problem for any k  2. As far as we know, no algorithm (better than brute force) was known apriori to our work for k  3.
5.2 Shortest Cycle
Let {ei = {si, ti}}ik be given k-edges. For each binary sequence b = (b1, b2, . . . , bk-1) of length k - 1, consider the following pattern Pb:
(s1, t1)  Pb 2  i  k, if bi-1 = 0 then (si, ti)  Pb else (ti, si)  Pb
So {Pb}b is the collection of patterns with the orientation of e1 fixed and all possible orientations of the other edges {ei}i2, as dictated by each binary sequence.
 Claim 24. Under the assumption that the shortest cycle is unique, the smallest exponent with non-zero coefficient in f1(x) (mod 2) is the weight of unique shortest cycle passing through the given edges, where
f1(x) = perm(APb )
b
Proof. Let C be any cycle cover which consists of atleast 2 non-trivial cycles. Consider the cycle in C which doesn't contain edge e1 - there are two ways of orienting this cycle, namely

S. Datta and K. Jaiswal

23:15

clockwise and counter-clockwise. So this cycle cover contributes to f1(x) for atleast two such b-sequences and so it vanishes modulo f1 (mod 2).
Thus the only terms that survive in f1 (mod 2) are the cycle covers which consist of one cycle passing through all the given edges and self-loops on the remaining vertices, and furthermore number of cycles of this weight must be odd.
Since the shortest weight cycle was unique by our assumption, we get the desired result. 

To drop the assumption that a unique minimum weight solution exists, we instead assign

modified weights 2nmw(e) + w(e) where n = |V (G)|, m = |E(G)|, w(e) is the given weight

of edge e and w(e)  {0, 2, . . . , 2m - 1} is choosen independently and uniformly at random

for

each

edge

e.

Then

isolation

lemma

[19]

tells

us

that,

with

probability

1 2

,

the

minimum

weight cycle is unique. Hence if the term xj survives as the smallest exponent with non-zero

coefficient term in f1(x) (mod 2) then we get the weight of shortest cycle as j/2nm.

5.3 Shortest 2-Disjoint Cycles
We shall first prove the following stronger result:
 Theorem 25. Given a set of k-edges {ei}ik, we can find weight of the shortest 2-disjoint cycles passing through these edges such that e1 and e2 appear in different cycles in L/poly (and RNC)
Let {Pb}b be the patterns as defined above. Furthermore, for each binary sequence c = (c1, c2, . . . , ck-2) of length k - 2, define pattern Qc as
(s1, s2)  Qc (t1, t2)  Qc 3  i  k, if ci-2 = 0 then (si, ti)  Qc else (ti, si)  Qc
With a combination of these patterns, we can get our desired cycle covers. We claim that the non-zero terms appearing in

f2(x) = perm(APb ) - perm(AQc )

b

c

correspond to cycle covers in GPb such that edges e1 and e2 appear in different cycles. To prove our claim, we need to argue that the cycle covers of GPb in which e1 and e2
appear in the same cycle are exactly the cycle covers of GQc Let

CQ = cycle covers of GQc
c
CP = cycle covers of GPb such that edges e1 and e2 appear in the same cycle
b
where each cycle cover is counted with repetitions in CP and CQ.
 Claim 26. There is a one-one correspondence between CP and CQ.
Proof. We define the mapping  : CP  CQ as follows. Given a cycle cover in CP , remove the edges e1 and e2 and add edges (s1, s2) and (t1, t2), refer to Figure 2 below.
To show that this a well-defined mapping and indeed a bijection, we partition CP into type 1 and type 2 cycle covers, depending upon the orientation of the edge e2. Consider the cycle in which e1 and e2 appear together. Then if the edge e2 is oriented as (s2, t2) then we call it type 1 cycle cover otherwise we call it a type 2 cycle cover.

CVIT 2016

23:16 Parallel Polynomial Permanent

Similarly, we partition CQ into type 1 and type 2 cycle covers. If the edges {s1, s2} and {t1, t2} appear in the same cycle then we call it a type 1 cycle cover otherwise we call it a type 2 cycle cover.
Fix a type 1 cycle cover of CP . Then it contains a cycle of the form
(s1 -e1 t1  P1  s2 -e2 t2  P2  s1)
Applying  to this cycle cover we get the cycle
(s1 -e1 s2  P1reverse  t1 -e2 t2  P2reverse  s1)
and the other cycles remain intact. This constitutes a type 1 cycle cover in CQ Similarly, consider a type 2 cycle cover of CP with the cycle
(s1 -e1 t1  P1  t2 -e2 s2  P2  s1)
Applying  to this cycle cover we get two cycles
(s1 -e1 s2  P2reverse  s1)
(t1 -e2 t2  P1reverse  t1) and the other cycles remain intact. This constitutes a type 2 cycle cover in CQ.
Therefore,  is a well-defined mapping and furthermore type i cycle covers of CP are mapped to type i cycle covers of CQ, i  {1, 2}. Now consider  : CQ  CP defined as follows. Given a cycle cover in CQ, remove the edges (s1, s2) and (t1, t2) in the cycle and insert edges e1 and e2 with the orientation decided by the type. By an similar argument as above, we get that  is well-defined and clearly  is inverse of .

t1

t2

t1

t2

s1

s2

s1

s2

Type 1 cycle cover in CP

Type 1 cycle cover in CQ

t1

t2

s1

s2

t1

t2

s1

s2

Type 2 cycle cover in CP

Type 2 cycle cover in CQ

Figure 2 Bijection between CP and CQ


Now suppose C is a cycle cover of G such that edges e1 and e2 appear in different cycles. We have two cases:
Case 1: number of non-trivial cycles in C is more than 2. Consider any two cycles in C such that e1 is not incident on them. We can orient these two cycles in both clockwise and

S. Datta and K. Jaiswal

23:17

anti-clockwise direction and so we get that C is a cycle cover in GPb for atleast 4 b-sequences. Hence, the term corresponding to C cancels out in f2 (mod 4)
Case 2: number of non-trivial cycles is exactly two. Then C is a cycle cover in GPb for exactly two b-sequences , that is the the cycle passing through e2 has two possible orientations whereas cycle passing through e1 has a fixed orientation (as orientation of e1 remains fixed in all GPb ). Hence, the term corresponding to C appears with a coefficient of two in f2 (mod 4). Therefore, the non-zero terms in f2 (mod 4) correspond to only the cycle covers in which edges e1 and e2 appear in different cycles and number of non-trivial cycles is exactly 2. Assuming a unique shortest 2-disjoint cycle exists, it's weight can be obtained from the
smallest exponent with a non-zero coefficient in f2 (mod 4). Finally, to drop this assumption, we again assign random weights as done previously to ensure that the minimum weight
solution is unique, with high probability. In the next section we discuss a common weighting scheme to obtain a L/poly algorithm. This shall complete the proof of Theorem 25.

 Corollary 27. (Theorem 2 restated) Given a set of k-edges {ei}ik, we can find weight of the shortest 2 cycles passing through these edges in L/poly (and RNC)

Proof. For each pair of edges ei and ej, we can find weight of the shortest cycles separating

them using the above algorithm. Hence taking the minimum over all pairs, we get our desired

result.



5.4 Common Weighting Scheme
We have only exhibited a randomized L algorithm (that is RNC algorithm). To further show that a common poly weight scheme exists for all graphs of size n, we use the well-known result of [21] as follows: Call a weighted undirected graph (G, w) (w is the given weight function on edges) min-k-unique, if for any k marked edges on G, there exists unique shortest l disjoint cycles passing through these k edges. Our goal is to show for each n > 0 there exists a set of n2 weight functions w1, . . . , wn2 such that given a graph G on n vertices, (G, wi) is min-k-unique for some i  [1, n2].
Given a graph G on n vertices and k marked edges e1, . . . , ek, let F (e1, . . . , ek) be the family of all l disjoint cycles passing through e1, . . . , ek. Using isolation lemma [19], if w is a random weight function, that is each edge is assigned a weight from [1, 4n2k+2] independently and uniformly at random, then probability that F (e1, . . . , ek) has a unique minimum weight element is atleast 1 - 1/4n2k. Therefore, probability that (G, w) is not min-k-unique for a random weight function w is atmost

Pr[e1, . . . , ek : F (e1, . . . , ek) doesn't have a minimum weight element]

1



4n2k  1/4

e1 ,...,ek

Now we claim that there exists a set of n2 weight functions W = (w1, . . . , wn2 ) such that for any given graph G on n vertices, (G, wi) is min-k-unique for some 1  i  n2. We say W is bad if it doesn't meet this criteria and in particular W is bad for G, if none of (G, wi) is min-k-unique. For a randomly choosen W , that is each wi is chosen independently and uniformly at random, then

1 n2 Pr[W is bad for G]  Pr[i : (G, wi) is not min-k-unique]  4

CVIT 2016

23:18 Parallel Polynomial Permanent

= Pr[W is bad]  Pr[G : W is bad for G]  2n2

1 n2 <1

4

Hence there exists some W = (w1, . . . , wn2 ) which satisfies the above property and so W is the required poly advice.
To complete the argument for SDCE(1, k), SDCE(2, k)  L/poly, we obtain the weight of shortest cycle(s), by replacing replace w, the random weight function, with each of the weight functions wi and output the minimum amongst them.

5.5 Constructing Cycles
We remark that under the assumption that the shortest cycle(s) are unique, we can recover these cycles C just from the knowledge of their weight w(C). This follows the standard strategy of solving search via isolation as in [19]. For each edge e  {e1, . . . , ek}, delete the edge e and call the resulting graph Ge. Running our algorithm on (Ge, {e1, . . . , ek}), if the shortest cycle(s) weight is more than w(C), then discard e otherwise add e to the set C, which gives us the required cycle(s).

6 Hafnians and counting perfect matchings modulo 2k

Similar to permanent and determinant, another pair of well-studied algebraic analogous functions on a matrix are hafnians and pfaffians. Let A = (aij) be a symmetric 2n × 2n matrix over integers, hafnian is defined as

1

n

hf(A) = 2nn!

a(2j-1),(2j)

(2)

S2n j=1

Note that the diagonal entries of A don't contribute in the calculation of hafnians and hence we can assume them to be 0. Let B = (bij) be a skew-symmetric 2n × 2n matrix, pfaffian is defined as

1

n

pf(B) = 2nn!

sgn() b(2j-1),(2j)

(3)

S2n

j=1

But notice that hf(A)  pf(A) (mod 2). [16] have shown that pf(A) can be computed in NC and hence as an immediate consequence we get that hf(A) (mod 2) can be computed in NC. We can reduce the computation of hafnian to several hafnians of smaller submatrices using the following lemma. Denote by A[i, j] the matrix obtained from A by deleting rows i and j, columns i and j.

 Lemma 28. ([13] Lemma 2.2)

hf(A) = aijhf(A[i, j])
j:j=i

hf(A) = aijhf(A[i, j]) +

(aipajq + aiqajp)hf(A[i, j, p, q])

pq:p,q{i,j},p=q

Assume pf(A)  0 (mod 2), then det(A)  0 (mod 2) and we can find a vector v  Z22n such that Av = AT v = 0 (mod 2). Assume without loss of generality v1 = 1.
Let ri, ci denote the ith row and ith column of A respectively.

S. Datta and K. Jaiswal

23:19

Construct A by replacing first row with viri and then replacing first column with vici
Construct Ai by replacing first row with ri and first column with ci.

Then we check that





hf(A) =  viaij hf(A[1, j])
j>1 i1





= vi  aijhf(A[1, j])

i1

j>1





= a1jhf(A[1, j]) + vi  aijhf(A[1, j])

j>1

i>1

j>1

= hf(A) + vihf(Ai)
i>1

Computing hf(A): since AT v = 0 (mod 2) = i1 viaij = 2bj (mod 2k) for some cj  Z and hence





hf(A) =  viaij hf(A[1, j])
j>1 i1

= 2bjhf(A[1, j])

j>1





= hf(A) (mod 2k) = 2  bjhf(A[1, j]) (mod 2k-1)
j>1

Computing hf(Ai):

hf(Ai) = aiihf(A[1, i]) +

2aipaiqhf(A[1, i, p, q])

pq:p,q{1,i},p=q





= hf(Ai) (mod 2k) = 2 

aipaiqhf(A[1, i, p, q]) (mod 2k-1)

pq:p,q{1,i},p=q

Thus, we can compute hf(A) (mod 2k) provided pf(A)  0 (mod 2).
Now if pf(A)  0 (mod 2), then we can find (i, j), i = j such that hf(A[i, j])  0 (mod 2).
Consider the matrix C where all entries are same as in A except aij is replaced with aij+1, then we get hf(C) = hf(A) + hf(A[i, j]). Since hf(C)  0 (mod 2), we can compute hf(C) (mod 2k)
as described above and since hf(A[i, j]) is a (n - 2) × (n - 2) matrix, we compute it's hafnian recursively modulo 2k. Therefore, we can compute hf(A) = hf(C) - hf(A[i, j]) (mod 2k).
This gives us a P algorithm for computing hafnians modulo 2k.

Counting perfect matchings modulo 2k
Let G be an undirected graph and AG denote the adjacency matrix of the graph G. If G has odd number of vertices, then clearly there aren't any perfect matchings. Otherwise it is straight-forward to see that number of perfect matchings in G is same as the value hf(AG). Hence the result follows.

CVIT 2016

23:20 Parallel Polynomial Permanent
7 Conclusion
We started by recognizing the appropriate algebraic structure R over which we can present a parallel algorithm to compute permanent modulo 2k. Then we saw two techniques to get permanent over Z[x] (mod 2k) from R (mod 2k). First method was to choose a large enough irreducible polynomial for our ring R. Another method was to interpolate over the ring R, which was an extension of the commonly known interpolation over finite fields.
Then we considered applications for parallel polynomial permanent. This includes a direct parallelization of the shortest 2-disjoint paths problem as given by [2]. Another direct application, although which required some modification, was finding shortest cycle passing through given vertices [28]. We further presented a common framework to view the above mentioned problems. This also aided us in further generalizing and obtaining a parallel algorithm to find shortest 2-disjoint cycles in any weighted undirected graph.
The more general question of computing permanent over arbitrary commutative rings of characteristic 2k for k  2 still remains open. On the other hand, using the framework we presented, we ask if it is possible to obtain shortest k disjoint cycles for k  3?
References
1 Andreas Björklund and Thore Husfeldt. Counting shortest two disjoint paths in cubic planar graphs with an NC algorithm. CoRR, abs/1806.07586, 2018. URL: http://arxiv.org/abs/ 1806.07586, arXiv:1806.07586.
2 Andreas Björklund and Thore Husfeldt. Shortest two disjoint paths in polynomial time. SIAM J. Comput., 48(6):1698­1710, 2019. doi:10.1137/18M1223034.
3 Mark Braverman, Raghav Kulkarni, and Sambuddha Roy. Space-efficient counting in graphs on surfaces. Comput. Complex., 18(4):601­649, 2009. doi:10.1007/s00037-009-0266-4.
4 Marek Cygan, Dániel Marx, Marcin Pilipczuk, and Michal Pilipczuk. The planar directed k-vertex-disjoint paths problem is fixed-parameter tractable. In 54th Annual IEEE Symposium on Foundations of Computer Science, FOCS 2013, 26-29 October, 2013, Berkeley, CA, USA, pages 197­206. IEEE Computer Society, 2013. doi:10.1109/FOCS.2013.29.
5 Carsten Damm. Problems complete for parityl. Information Processing Letters, 36(5):247­250, 1990. URL: https://www.sciencedirect.com/science/article/pii/002001909090150V, doi:https://doi.org/10.1016/0020-0190(90)90150-V.
6 Samir Datta, Siddharth Iyer, Raghav Kulkarni, and Anish Mukherjee. Shortest k-disjoint paths via determinants. In Sumit Ganguly and Paritosh K. Pandya, editors, 38th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2018, December 11-13, 2018, Ahmedabad, India, volume 122 of LIPIcs, pages 19:1­19:21. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018. doi:10.4230/LIPIcs.FSTTCS.2018.19.
7 Éric Colin de Verdière and Alexander Schrijver. Shortest vertex-disjoint two-face paths in planar graphs. ACM Trans. Algorithms, 7(2):19:1­19:12, 2011. doi:10.1145/1921659.1921665.
8 W. Eberly. Very fast parallel matrix and polynomial arithmetic. In 25th Annual Symposium onFoundations of Computer Science, 1984., pages 21­30, 1984. doi:10.1109/SFCS.1984. 715897.
9 W. Eberly. Efficient parallel independent subsets and matrix factorizations. In Proceedings of the Third IEEE Symposium on Parallel and Distributed Processing, pages 204­211, 1991. doi:10.1109/SPDP.1991.218278.
10 Faith E. Fich and Martin Tompa. The parallel complexity of exponentiating polynomials over finite fields. J. ACM, 35(3):651­667, June 1988. doi:10.1145/44483.44496.
11 Steven Fortune, John E. Hopcroft, and James Wyllie. The directed subgraph homeomorphism problem. Theor. Comput. Sci., 10:111­121, 1980. doi:10.1016/0304-3975(80)90009-2.

S. Datta and K. Jaiswal

23:21

12 William Hesse, Eric Allender, and David A. Mix Barrington. Uniform constant-depth threshold circuits for division and iterated multiplication. J. Comput. Syst. Sci., 65(4):695­716, 2002. doi:10.1016/S0022-0000(02)00025-9.
13 Hiroshi Hirai and Hiroyuki Namba. Shortest (a+b)-path packing via hafnian. Algorithmica, 80(8):2478­2491, 2018. doi:10.1007/s00453-017-0334-0.
14 Ce Jin, Nikhil Vyas, and Ryan Williams. Fast low-space algorithms for subset sum. CoRR, abs/2011.03819, 2020. URL: https://arxiv.org/abs/2011.03819, arXiv:2011.03819.
15 James F. Lynch. The equivalence of theorem proving and the interconnection problem. SIGDA Newsl., 5(3):31­36, September 1975. doi:10.1145/1061425.1061430.
16 Meena Mahajan, P. R. Subramanya, and V. Vinay. The combinatorial approach yields an nc algorithm for computing pfaffians. Discret. Appl. Math., 143(1-3):1­16, 2004. doi: 10.1016/j.dam.2003.12.001.
17 Meena Mahajan and V. Vinay. Determinant: Combinatorics, algorithms, and complexity. Chic. J. Theor. Comput. Sci., 1997, 1997. URL: http://cjtcs.cs.uchicago.edu/articles/ 1997/5/contents.html.
18 Ketan Mulmuley. A fast parallel algorithm to compute the rank of a matrix over an arbitrary field. Comb., 7(1):101­104, 1987. doi:10.1007/BF02579205.
19 Ketan Mulmuley, Umesh V. Vazirani, and Vijay V. Vazirani. Matching is as easy as matrix inversion. In Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing, STOC '87, page 345­354, New York, NY, USA, 1987. Association for Computing Machinery. doi:10.1145/28395.383347.
20 Pavel Okunev and Charles R. Johnson. Necessary And Sufficient Conditions For Existence of the LU Factorization of an Arbitrary Matrix. arXiv Mathematics e-prints, page math/0506382, June 2005. arXiv:math/0506382.
21 Klaus Reinhardt and Eric Allender. Making nondeterminism unambiguous. SIAM J. Comput., 29(4):1118­1131, 2000. doi:10.1137/S0097539798339041.
22 Heike Ripphausen-Lipa, Dorothea Wagner, and Karsten Weihe. Linear-time algorithms for disjoint two-face paths problems in planar graphs. Int. J. Found. Comput. Sci., 7(2):95­110, 1996. doi:10.1142/S0129054196000087.
23 N. Robertson and P.D. Seymour. Graph minors .xiii. the disjoint paths problem. Journal of Combinatorial Theory, Series B, 63(1):65­110, 1995. URL: https://www. sciencedirect.com/science/article/pii/S0095895685710064, doi:https://doi.org/10. 1006/jctb.1995.1006.
24 Alexander Schrijver. Finding k disjoint paths in a directed planar graph. SIAM J. Comput., 23(4):780­788, 1994. doi:10.1137/S0097539792224061.
25 Hitoshi Suzuki, Takehiro Akama, and Takao Nishizeki. Finding steiner forests in planar graphs. In David S. Johnson, editor, Proceedings of the First Annual ACM-SIAM Symposium on Discrete Algorithms, 22-24 January 1990, San Francisco, California, USA, pages 444­453. SIAM, 1990. URL: http://dl.acm.org/citation.cfm?id=320176.320230.
26 Leslie G. Valiant. The complexity of computing the permanent. Theor. Comput. Sci., 8:189­201, 1979. doi:10.1016/0304-3975(79)90044-6.
27 J.H. van Lint. Introduction to Coding Theory. Graduate Texts in Mathematics. Springer Berlin Heidelberg, 2013. URL: https://books.google.co.in/books?id=6dbqCAAAQBAJ.
28 Magnus Wahlström. Abusing the tutte matrix: An algebraic instance compression for the k-set-cycle problem. In STACS, pages 341­352, 2013.
29 VIKTÓRIA ZANKÓ. #p-completeness via many-one reductions. International Journal of Foundations of Computer Science, 02(01):77­82, 1991. arXiv:https://doi.org/10.1142/ S0129054191000066, doi:10.1142/S0129054191000066.

CVIT 2016

