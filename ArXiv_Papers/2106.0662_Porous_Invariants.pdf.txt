Porous Invariants

nalAEC

arXiv:2106.00662v1 [cs.LO] 1 Jun 2021 CAV

Engel Lefaucheux1, Jo¨el Ouaknine1, David Purser1, and James Worrell2

1 Max Planck Institute for Software Systems, Saarland Informatics Campus,
Saarbru¨cken, Germany 2 Department of Computer Science, Oxford University, UK

functio
Artifact

Abstract. We introduce the notion of porous invariants for multipath (or branching/nondeterministic) affine loops over the integers; these invariants are not necessarily convex, and can in fact contain infinitely many `holes'. Nevertheless, we show that in many cases such invariants can be automatically synthesised, and moreover can be used to settle (non-)reachability questions for various interesting classes of affine loops and target sets.

Evaluated

Keywords: Linear Dynamical Systems · Linear loops · Invariants · Reachability · Presburger arithmetic

1 Introduction
We consider the reachability problem for multipath (or branching) affine loops over the integers, or equivalently for nondeterministic integer linear dynamical systems. A (deterministic) integer linear dynamical system consists of an update matrix M  Zd×d together with an initial point x(0)  Zd. We associate to such a system its infinite orbit (x(i)) consisting of the sequence of reachable points defined by the rule x(i+1) = M x(i). The reachability question then asks, given a target set Y , whether the orbit ever meets Y , i.e., whether there exists some time i such that x(i)  Y . The nondeterministic reachability question allows the linear update map to be chosen at each step from a fixed finite collection of matrices.
When the orbit does eventually hit the target, one can easily substantiate this by exhibiting the relevant finite prefix. However, establishing non-reachability is intrinsically more difficult, since the orbit consists of an infinite sequence of points. One requires some sort of finitary certificate, which must be a relatively simple object that can be inspected and which provides a proof that the set Y is indeed unreachable. Typically, such a certificate will consist of an overapproximation I of the set R of reachable points, in such a manner that one can check both that Y  I =  and R  I; such a set I is called an invariant.
Formally we study the following problem for inductive invariants:
Meta Problem 1. Consider a system with update functions f1, . . . , fn. A set I is an inductive invariant if fi(I)  I for all i. Given a reachability query (x, Y ) we search for a separating inductive invariant I such that x  I and Y  I = .

2

E. Lefaucheux et al.

Meta Problem 1 is parametrised by the type of invariants and targets that are considered; that is, what are the classes of allowable invariant sets I and target sets Y , or equivalently how are such sets allowed to be expressed.
Fixing a particular invariant and target domain, a reachability query has three possible scenarios: (1) the instance is reachable, (2) the instance is unreachable and a separating invariant from the domain exists, or (3) the instance is unreachable but no separating invariant exists. Ideally, one would wish to provide a sufficiently expressive invariant domain so that the latter case does not occur, whilst keeping the resulting invariants as simple as possible and computable. For some classes of systems, it is known that distinguishing reachability (1) from unreachability (2,3) is undecidable; it can also happen that determining whether a separating invariant exists (i.e., distinguishing (2) from (3)) is undecidable.
We note that the existence of strongest inductive invariants3 is a desirable property for an invariant domain--when strongest invariants exist (and can be computed), separating (2) from (1,3) is easy: compute the strongest invariant, and check whether it excludes the target state or not; if so, then you are done, and if not, no other invariant (from that class) can possibly do the trick either. However, unless (3) is excluded, computing the strongest invariant does not necessarily imply that reachability is decidable. Unfortunately, strongest invariants are not always guaranteed to exist for a particular invariant domain, although some separating inductive invariant may still exist for every target (or indeed may not).
In prior work from the literature, typical classes of invariants are usually convex, or finite unions of convex sets. In this paper we consider certain classes of invariants that can have infinitely many `holes' (albeit in a structured and regular way); we call such sets porous invariants. These invariants can be represented via Presburger arithmetic4. We shall work instead with the equivalent formulation of semi-linear sets, generalising ultimately periodic sets to higher dimensions, as finite unions of linear sets of the form {b + p1N + · · · + pmN} (by which we mean {b + a1p1 + · · · + ampm | a1, . . . , am  N}, see Definition 2).
Let us first consider a motivating example:
Example 1 (Hofstadter's MU Puzzle [7]). Consider the following term-rewriting puzzle over alphabet {M, U, I}. Start with the word M I, and by applying the following grammar rules (where y and z stand for arbitrary words over our alphabet), we ask whether the word M U can ever be reached.
yI  yIU | My  Myy | yIIIz  yUz | yUUz  yz
The answer is no. One way to establish this is to keep track of the number of occurrences of the letter `I' in the words that can be produced, and observe
3 Given two invariants I and I , we say that I is stronger than I iff I  I ; thus strongest invariants correspond to smallest invariant sets.
4 Presburger arithmetic is a decidable theory over the natural numbers, comprising Boolean operations, first-order quantification, and addition (but not multiplication).

Porous Invariants

3

that this number (call it x) will always be congruent to either 1 or 2 modulo 3. In other words, it is not possible to reach the set {x | x  0 mod 3}. Indeed, Rules 2 and 3 are the only rules that affect the number of I's, and can be described by the system dynamics x  2x and x  x - 3. Hence the MU Puzzle can be viewed as a one-dimensional system with two affine updates,5 or a twodimensional system with two linear updates.6 The set {1 + 3Z}  {2 + 3Z} is an inductive invariant, and we wish to synthesise this. (The stability of this set under our two affine functions is easily checked: both components are invariant under x  x - 3, and {1 + 3Z}  {2 + 6Z}  {2 + 3Z} under x  2x, and similarly {2 + 3Z}  {4 + 6Z}  {1 + 3Z}.)
The problem can be rephrased as a safety property of the following multipath loop, verifying that the `bad' state x = 0 is never reached, or equivalently that the above loop can never halt, regardless of the nondeterministic choices made. x =1 while x = 0
x = 2 x || x = x-3 (where || represents nondeterministic branching)
The MU Puzzle was presented as a challenge for algorithmic verification in [4]; the tools considered in that paper (and elsewhere, to the best of our knowledge) rely upon the manual provision of an abstract invariant template. Our approach is to find the invariant fully automatically (although one must still abstract from the MU Puzzle the correct formulation as the program x  2x || x  x - 3).

Main Contributions. Our focus is on the automatic generation of porous invariants for multipath affine loops over the integers, or equivalently nondeterministic integer linear dynamical systems.

­ We first consider targets consisting of a single vector (or `point targets'), and present the classes of invariants and systems for which invariants can and cannot be automatically computed for the reachability question. A summary of the results for linear and semi-linear invariants for these targets is given in Table 1. For completeness we also consider R, R+-(semi)-linear sets, where we complete the picture from prior work by showing that strongest R-semilinear invariants are computable. · We establish the existence of strongest Z-linear invariants, and show that they can be found algorithmically (Theorem 2). These invariants may or may not separate the target under consideration. · If a Z-linear invariant is not separating, we may instead look for an Nsemi-linear invariant (which generalises both Z-semi-linear and N-linear invariants), and we show that such an invariant can always be found for any unreachable point target when dealing with deterministic integer linear dynamical systems (Theorem 4).

5 One-dimensional affine updates are functions of the form f (x) = ax + b.

6 ab 01

x 1

=

ax + b 1

models affine functions using a matrix representation, hold-

ing one of the entries fixed to 1.

4

E. Lefaucheux et al.

Dom D/N Linear

Semi-linear (SL)

Z det Strongest computable (Thm. 2)

No strongest (Sec. 4.1); subsumed by N-SL

Z non Strongest computable (Thm. 2)

No strongest (Sec. 4.1)

N det No strongest (Sec. 4.1); subsumed by N-SL No strongest (Sec. 4.1), but sufficient computable (Thm. 4)

N non No strongest (Sec. 4.1)

1d-affine decidable (Thm. 6); undecidable in general (Thm. 5)

R det Strongest: affine relations by Karr [17]

Strongest: affine closure on Zariski closure (Thm. 1)

R non Strongest: affine relations by Karr [17]

Strongest: affine closure on Zariski closure (Thm. 1)

R+ det No strongest (Sec. 4.1); subsumed by R+-SL No strongest, but sufficient computable [8]

R+ non No strongest (Sec. 4.1)

Undecidable [8]

Table 1. Results for integer linear dynamical systems for a point target. Det/Non refers to deterministic or nondeterministic LDS. "Subsumed by . . . " means that sufficient invariants can be generated, but of a more general type.

· However, for nondeterministic integer linear dynamical systems, computing an N-semi-linear invariants is an undecidable problem in arbitrary dimension (Theorem 5). Nevertheless we show how such invariants can be constructed in a low-dimensional setting, in particular for affine updates in one dimension (Theorem 6). As an immediate consequence, this establishes that the multipath loop associated with the MU Puzzle belongs to a class of programs for which we can automatically synthesise N-semi-linear invariants.
­ For full-dimensional 7 Z-linear targets we show that reachability is decidable, and, in the case of unreachability that a Z-semi-linear invariant can always be exhibited as a certificate (Theorem 3). If the target is not fulldimensional then the reachability problem is Skolem-hard and undecidable for deterministic and nondeterministic systems respectively.
­ In Section 6 we present our tool porous which handles one-dimensional affine systems for both point and Z-linear targets, solving both the reachability problem and producing invariants. Inter alia, this allows one to handle the multipath loop derived from the MU Puzzle in fully automated manner.
1.1 Related Work
The reachability problem (in arbitrary dimension) for loops with a single affine update, or equivalently for deterministic linear dynamical systems, is decidable in polynomial time for point targets (that is Y = {y}), as shown by Kannan and Lipton [16]. However for nondeterministic systems (where the update matrix is chosen nondeterministically from a finite set at each time step), reachability is undecidable, by reduction from the matrix semigroup membership problem [22].
In particular this entails that for unreachable nondeterministic instances we cannot hope always to be able to compute a separating invariant. In some cases we may compute the strongest invariant (which may suffice if this invariant happens to be separating for the given reachability query), or we may compute an invariant in sub-cases for which reachability is decidable (for example in low
7 The affine span covers the entire space.

Porous Invariants

5

dimensions). For some classes of invariants, it is also undecidable whether an invariant exists (e.g., polyhedral invariants [8]).
Various types of invariants have been studied for linear dynamical systems, including polyhedra [23,8], algebraic [15], and o-minimal [1] invariants. For certain classes of invariants (e.g., algebraic [15]), it is decidable whether a separating invariant exists, notwithstanding the reachability problem being undecidable. Other works (e.g., [5]) use heuristic approaches to generate invariants, without aiming for any sort of completeness.
Kincaid, Breck, Cyphert and Reps [18] study loops with linear updates, studying the closed forms for the variables to prove safety and termination properties. Such closed forms, when expressible in certain arithmetic theories, can be interpreted as another type of invariant and can be used to over-approximate the reachable sets. The work is restricted to a single update function (deterministic loops) and places additional constraints on the updates to bring the closed forms into appropriate theories.
Bozga, Iosif and Konecny´'s FLATA tool [2] considers affine functions in arbitrary dimension. However, it is restricted to affine functions with finite monoids; in our one-dimensional case this would correspond to limiting oneself to counterlike functions of the form f (x) = x + b.
Finkel, G¨oller and Haase [9], extending Fremont [10], show that reachability in a single dimension is PSPACE-complete for polynomial update functions (and allowing states can be used to control the sequences of updates which can be applied). The affine functions (and single-state restriction) we consider are a special case, but we focus on producing invariants to disprove reachability.
Other tools, e.g., AProVE [11] and Bu¨chi Automizer [14] may (dis-)prove termination/reachability on all branches, but may not be able to prove termination/reachability on some branch.
Inductive invariants specified in Presburger arithmetic have been used to disprove reachability in vector addition systems [20]. A generalisation, `almost semi-linear sets' [21] are also non-convex and can capture exactly the reachable points of vector addition systems. Our nondeterministic linear dynamical systems can be seen as vector addition systems over Z extended with affine updates (rather than only additive updates).

2 Preliminaries
We denote by Z the integers and N the non-negative integers. We say that x, y  Z are congruent modulo d  N, denoted x  y mod d, if d divides x - y. Given an integer x and natural d we write (x mod d) for the number in {0, . . . , d - 1} such that (x mod d)  x mod d.
Definition 1 (Integer Linear Dynamical Systems). A d-dimensional integer linear dynamical system (LDS) (x(0), {M1, . . . , Mk}) is defined by an initial point x(0)  Zd and a set of integer matrices M1, . . . , Mk  Zd×d. An LDS is deterministic if it comprises a single matrix (k = 1) and is otherwise nondeterministic.

6

E. Lefaucheux et al.

A point y is reachable if there exists m  N and B1, . . . , Bm such that B1 · · · Bmx(0) = y and Bi  {M1, . . . , Mk} for all 1  i  m.
The reachability set O  Zd of an LDS is the set of reachable points.

Definition 2 (K-(semi)-linear sets). A linear set L is defined by a base vector b  Zd and period vectors p1, . . . , pd  Zd such that
L = {b + a1p1 + · · · + adpd | a1, . . . , ad  K} .
For convenience we often write {b + p1K + · · · + pdK} for L. A set is semi-linear if it is the finite union of linear sets.

N-semi-linear sets are precisely those definable in Presburger arithmetic (FO(Z, +, )) [12]. However, we can also consider Z-semi-linear sets (corresponding to FO(Z, +) without order), and the real counterparts (R and R+). Note that even if K = N we still allow pi  Zd.
Definition 3. Given an integer linear dynamical system (x(0), {M1, . . . , Mk}), a set I is an inductive invariant if
­ x(0)  I, and ­ {Mix | x  I}  I for all i  {1, . . . , k}.

Note in particular that every inductive invariant contains the reachability set (O  I). We are interested in the following problem:
Definition 4 (Invariant Synthesis Problem). Given an invariant domain D, an integer linear dynamical system (x(0), {M1, . . . , Mk}), and a target Y , does there exist an inductive invariant I in D disjoint from Y ?
In our setting, we are interested in classes D of invariants that are linear, or semi-linear. When a separating inductive invariant I exists, we also wish to compute it. Since (semi)-linear invariants are enumerable, the decision problem is, in theory, sufficient--although all of our proofs are constructive.

3 R Invariants: R-linear and R-semi-linear
Before delving into porous invariants, let us consider invariants over the real numbers, i.e., described as R-(semi)-linear sets.
Strongest R-linear invariants are given precisely by the affine hull of the reachability set, and can be computed using Karr's algorithm [17]. Moreover, we will show that strongest R-semi-linear invariants also exist and can be computed by combining techniques for algebraic invariants [15] and R-linear invariants.

Porous Invariants

7

R-linear. Recall that a set L is R-linear if L = {v0 + v1R + · · · + vtR} for some v0, . . . , vt  Zd that can be assumed to be linearly-independent8 without loss of generality (and thus t  d). Given two distinct points of L, every point on the
infinite line connecting them must also be in L. Generalising this idea to higher dimensions, given a set S  Rd, let the affine hull be

k

k

Sa =

ixi | k  N, xi  S, i  R, i = 1 .

i=1

i=1

Fix Mim ·

an LDS · · Mi1 x(0)

(x(0), {M1, . . . , Mk}) | m  N, i1, . . . , im 

and {1, . .

consider its . , k} . Then

reachability set O = Oa is precisely the

strongest R-linear invariant. Karr's algorithm [17,26] can be used to compute

this strongest invariant in polynomial time. The next lemma follows from The-

orem 3.1 of [26].

Lemma 1. Given an LDS (x(0), {M1, . . . , Mk}) of dimension d, we can compute in time polynomial in d, k, and log µ (where µ > 0 is an upper bound on the absolute values of the integers appearing in x(0) and M1, . . . , Mk), a Q-affinely independent set of integer vectors R0  O such that:

1. 2.

x(0)  R0, the affine span

of

R0

and

the

affine

span

of

O

are

the

same

(R0a = Oa),

3. the entries of the vectors in R0 have absolute value at most µ0 := (dµ)d.

Let R0 = x(0), r1, . . . , rd be obtained as per Lemma 1, with d  d. The R-linear invariant of the LDS is the affine span R0a, which can be written as the R-linear set L0 = x(0) + (r1 - x(0))R + · · · + (rd - x(0))R .

R-semi-linear. Let us now generalise this approach to R-semi-linear sets. The

collection of R-semi-linear sets, {

m i=1

Li

|

m



N, L1, . . . , Lm

are

R-linear

sets},

is closed under finite unions and arbitrary intersections9. Thus for any given set

X, the smallest R-semi-linear set containing X is simply the intersection of all

R-semi-linear sets containing X. Let us denote by XR this smallest R-semi-linear set. We are interested in OR.

Theorem 1. The strongest R-semi-linear invariant OR of O is computable.

Algebraic sets are those that are definable by finite unions and intersections
of zeros of polynomials. For example, {(x, y) | xy = 0} describes the lines x = 0 and y = 0. The (real) Zariski closure Xz of a set X is the smallest algebraic subset of Rd containing the set X. The Zariski closure of the set of reachable points, Oz, can be computed algorithmically [15].

8 v0, . . . , vm are linearly independent if there does not exist a0, . . . , am  R, not all 0, such that a0v0 + · · · + amvm = 0.
9 When intersecting a linear set with a semi-linear set, either the latter does not
change, or one obtains a finite union of elements of smaller dimension. Thus, in an
infinite intersection, only a finite number of intersections affects the original set.

8

E. Lefaucheux et al.

An algebraic set A is irreducible if whenever A  B  C, where B and C are algebraic sets, then we have A  B or A  C. Any algebraic set (and in particular a Zariski closure) can be written effectively as a finite union of irreducible sets [3].

Proposition 1. Let Xz = A1  · · ·  Ak, with Ai's irreducible. Then XR = XzR = A1R  · · ·  AkR = A1a  · · ·  Aka.

Proof. Since Ai  XR = jLj, and Ai is irreducible, we have Ai  Lj for some j (as the Lj's are algebraic sets). Since Lj is R-linear, and Aia is the smallest R-linear set covering Ai, we have Aia  Lj. Taking XR = A1a  · · ·  Aka is thus
optimal.

Oz

Thus = A1

OR can be  · · ·  Ak.

obtained by computing Aia for each To complete the proof of Theorem 1

irreducible Ai, where it remains to confirm

that affine hulls of algebraic sets can be computed algorithmically. Let us fix

an algebraic set A, and let W denote a set variable. Proceed as follows. Start
a
with W  {x} for some point x  A, and repeatedly let W  W  {y} , where

y  A \ W . Such a point y can always be found using quantifier elimination in

the theory of the reals. Each step necessarily increases the dimension, which can occur at most d times, ensuring termination, at which point one has Aa = W .

4 Strongest Z-linear Invariants
Recall that a Z-linear set {q + p1Z + · · · + pnZ} is defined by a base vector q  Zd and period vectors p1, . . . , pn  Zd. Equivalently, a Z-linear set describes a lattice, i.e., {p1Z + · · · + pnZ}, in d-dimensional space, translated to start from q rather than 0.
Theorem 2. Given a d-dimensional dynamical system (x(0), {M1, . . . , Mk}), the strongest Z-linear inductive invariant containing the reachability set O exists and can be computed algorithmically.
The image of a Z-linear set L = {q + p1Z + · · · + pnZ} by a matrix M is the Z-linear set: M (L) = {M q + (M p1)Z + · · · + (M pn)Z}. The following lemma asserts that when two points are in a Z-linear set, the direction between these two points can be applied from any reachable point, and hence this direction can be included as a period without altering the set.
Proposition 2. Let L = {q + a1p1 + · · · + anpn | a1, . . . , an  Z} be a Z-linear set. If x, y  L then for all z  L and all a  Z we have z + (y - x)a  L. In particular, we have L = {q + a1p1 + · · · + anpn + a (y - x) | a1, . . . , an, a  Z}.
Proof. If x = q + a1p1 + · · · + anpn and y = q + b1p1 + · · · + bnpn then y - x = q + b1p1 + · · · + bnpn - (q + a1p1 + · · · + anpn) = (b1 - a1)p1 + · · · + (bn - an)pn.
Then for any z = q + c1p1 + · · · + cnpn, we have z + a (y - x) = q + c1p1 + · · · + cnpn + a ((b1 - a1)p1 + · · · + (bn - an)pn) = q + (c1 + a (b1 - a1))p1 + · · · + (cn + a (bn - an))pn) where (ci + a (bi - ai))  Z, so z + a (y - x)  L.

Porous Invariants

9

Proposition 3. Given two Z-linear sets L1 = {q + p1Z + · · · + pnZ} and L2 = {s + t1Z + · · · + tmZ}, there exists a smallest Z-linear set L containing L1  L2: the set L = {q + (s - q)Z + p1Z + · · · + pnZ + t1Z + · · · + tmZ}.
Proof. First we show L1  L2  L:
­ If x = q + a1p1 + · · · + anpn  L1, then x = q + (s - q)0 + a1p1 + · · · + anpn + 0t1 + · · · + 0tm  L.
­ If x = s + b1t1 + · · · + bmtm  L2, then x = q + (s - q)1 + 0p1 + · · · + 0pn + b1t1 + · · · + bmtm  L.
Next we show minimality as a straightforward consequence of Proposition 2. Clearly the vectors p1, . . . , pn can be added by Proposition 2 because any
two points of L1 differing by pi guarantees that adding pi does not alter the resulting set. Similarly, t1, . . . , tm can also be included. Finally, by Proposition 2, the vector s - q can be included because q and s both belong to L1  L2.
A d-dimensional lattice can always be defined by at most d vectors; and thus if d is the dimension of the matrices, no more than d period vectors are needed in total. However, Proposition 3 induces a representation which may over-specify the lattice by producing more than d vectors to define the lattice.
Example 2. Consider the lattice {(2, 2)Z + (0, 6)Z + (2, 6)Z}, specified with three vectors, which is equivalent to the lattice {(2, 0)Z + (0, 2)Z}. Note that one may not simply pick an independent subset of the periods, as none of the following sets are equal: {(2, 2)Z + (0, 6)Z}, {(2, 2)Z + (2, 6)Z}, {(0, 6)Z + (2, 6)Z}, and {(2, 2)Z + (0, 6)Z + (2, 6)Z}.
The Hermite normal form can be used to obtain a basis of the vectors that define the lattice. Consider a lattice Li = {p1Z + · · · + pdZ}. The lattice remains the same if pi is swapped with pj, if pi is replaced by -pi, or if pi is replaced by pi + pj where  is any fixed integer10.
These are the unimodular operations. The Hermite normal form of a matrix M is a matrix H such that M = U H, where U is a unimodular matrix (formed by unimodular column operations) and H is lower triangular, non-negative and each row has a unique maximum entry which is on the main diagonal. Such a form always exists, and the columns of H form a basis of the same lattice as the columns of M , because they differ up to unimodular (lattice-preserving) operations. There are many texts on the subject; we refer the reader to the lecture notes of Shmonin [25] for more detailed explanations.
The columns of a matrix in Hermite normal form constitute a unique basis for the lattice (up to additional redundant zero columns). Hence a basis of minimal dimension can be obtained by computing the Hermite normal form of the matrix formed by placing the period vectors into columns.
We now prove the main theorem:
10 The last replacement is valid, since if x = y +pi  L then x = y +(pi +pj)-pj is in the new lattice.

10

E. Lefaucheux et al.

Proof (Proof of Theorem 2). We claim that Algorithm 1 returns the strongest Z-linear invariant I.
Algorithm 1 proceeds in two phases:

­ First find a necessary subset L0  I of the invariant having already the same dimension as I.
­ Then compute a growing sequence L0 L1 · · · Lm-1 = Lm = I, where at each step the algorithm merely increases the density of the attendant sets in order to `fill in' missing points of the invariant.

Recall the set R0 = x(0), r1, . . . , rd  O, with d  d, from Lemma 1. The resulting Z-linear set L0 = x(0) + (r1 - x(0))Z + · · · + (rd - x(0))Z is then a

d -dimensional Oa). Applying

porous M1, . . .

subset of the , Mk can only

d -dimensional affine increase the density,

hull of the orbit (L0  but not the dimension.

As each ri and x(0) are in O, by Proposition 2 we can assume that each of the

directions (ri - x(0)) must be represented in any Z-linear set containing O, and

we therefore have that L0  I.

In the second phase, we `fill in' the lattice as required to cover the whole of

O. To do this we repeatedly apply the covering procedure of Proposition 3. That

is, Li+1 is the smallest Z-linear set covering Li  M1(Li)  · · ·  Mk(Li). To keep the number of vectors small, we keep the period vectors of the Z-linear set in

Hermite normal form.

The vectors p1 = (r1 - x(0)), . . . , pd = (rd - x(0)) form a parallelepiped

(hyper-parallelogram) that repeats regularly. There are a finite number of inte-

gral points inside this parallelepiped. If new points are added in some step, they

are added to every parallelepiped. Thus we can add new points finitely many

times before saturating or becoming fixed. The volume of the parallelepiped is

bounded above by |p1| · · · |pd |.

At each step, the volume of the parallelepiped must at least halve, thus the

volume at step t is volt  |p1| · · · |pd |/2t. The procedure must saturate at or

before the volume becomes 1, which occurs after at most log(|p1| · · · |pd |) =

i log(|pi|) steps. At each step, for efficiency considerations, we convert the Z-linear set into Hermite normal form to retain exactly d period vectors.

Claim (I is the strongest invariant). For every invariant J, we have I  J.

By induction, let us prove that every invariant J must contain Li. Clearly this is the case for L0 because all points of R0  O must be in J and every period vectors in L0 can be present, without loss of generality, thanks to Proposition 2. Assume Li  J. Then it must be the case that J contains every Mj(Li), as otherwise it would not be an invariant. It therefore follows that J must contain
Li+1, since the latter is the minimal Z-linear set containing Li and Mj(Li) for all j  k. Finally, since I is itself one of the Li's, we have I  J as required.

Remark 1. Note that a Z-linear set is not sufficient for the MU puzzle: both 1 and 2 are in the reachability set, thus {1 + 1Z} = Z is the strongest Z-linear invariant.

Porous Invariants

11

Algorithm 1: Strongest Z-linear invariant for LDS (x(0), M1, . . . , Mk)
Input: x(0),M1, . . . , Mk Compute R0 = x(0), r1, . . . , rd  O
Compute pi = ri - x(0) for i  {1, . . . , d } L0 = x(0) + p1Z + · · · + pd Z
while True do Li = Covering(Li-1  M1(Li-1)  · · ·  Mk(Li-1)) Hi = HermiteNormalForm(Li) Li = x(0) + h1Z + · · · + hd Z | hj column of Hi
if Li = Li-1 then return Li
end end

4.1 Extensions of Z-linear sets without strongest invariants

In this section we show that several generalisations of Z-linear domains fail to

admit strongest invariants.

Z-semi-linear sets are unions of Z-linear sets, and therefore can include sin-

gletons. Consider the deterministic dynamical system starting from point 1 and

doubling at each step M = (1, (x  2x)). This system has reachability set O = 2k | k  N , which is not even N-semi-linear (our most general class). For this LDS we can construct the invariant 2, 4, 8, ..., 2k  2k+1p1 | p1  Z for each k. For any proposed strongest Z-semi-linear invariant, one can find a k for

which the corresponding invariant is an improvement.

N-linear sets generalise Z-linear sets (observe that Z-linear sets are a proper

subclass, since {x + piZ} can be expressed as {x + (-pi)N + piN}, but {x + piN}

is

clearly

not

Z-linear).

Consider

the

LDS

((x1,

x2),

(

0 1

1 0

)),

with

a

reachability

set consisting of just two points x = (x1, x2) and y = (x2, x1). There are two

incomparable candidates for the minimal N-linear invariant: {x + (y - x)N} and

{y + (x - y)N}. Similarly for R+-linear invariants, the sets {y + (x - y)R+} and {x + (y - x)R+} are incomparable half-lines.

4.2 Z-linear targets
We have so far only considered invariants for point targets. We now turn to lattice-like targets, in particular targets specified as full-dimensional Z-linear sets.
Theorem 3. It is decidable whether a given LDS (x(0), {M1, . . . , Mk}) reaches a full-dimensional Z-linear target Y = {x + p1Z + · · · + pdZ}, with x, pi  Zd.
Furthermore, for unreachable instances, a Z-semi-linear inductive invariant can be provided.

12

E. Lefaucheux et al.

Theorem 3 requires the targets to be full-dimensional. For nondeterministic systems reachability is undecidable for non-full-dimensional targets (in particular point targets) [22]. However, even for deterministic systems, when Z-linear targets fail to be full-dimensional the reachability problem becomes as hard as the Skolem problem (see, e.g. [24]), for example by choosing as target the set {(0, x2, . . . , xd) | x2, . . . , xd  Z} = 0 + e2Z + · · · + edZ , where ei  {0, 1}d is
the standard basis vector, with (ei)i = 1 and (ei)j = 0 for i = j. Towards proving Theorem 3, we first show that full-dimensional linear sets
can be expressed as `square' hybrid-linear sets. Hybrid-linear sets are semi-linear sets in which all the components share the same period vectors, and thus differ only in starting position (whereas semi-linear sets allow each component to have distinct period vectors). By square, we mean that all period vectors are the same multiple of standard basis vectors.
Lemma 2. Let Y = {x + p1Z + · · · + pdZ} be a full-dimensional Z-linear set. Then there exists m  N and a finite set B  [0, m - 1]d such that Y =
bB {b + me1Z + · · · + medZ}.
p1
Proof. Suppose p1, . . . , pd span a d-dimensional vector space. Let P = ...
pd
be the matrix with rows p1, . . . , pd. Since P is full row rank it is invertible, hence there exists a rational matrix P -1 such that ei = Pi-,11p1 + · · · + Pi-,d1pd. In particular let mi be such that Pi-,j1mi is integral for all j. Then there is an integral combination of p1, . . . , pd such that miei is an admissible direction in Y.
Let m = lcm {m1, . . . , md}. Then mei is an admissible direction in Y . Hence by Proposition 2, Y is equivalent to {x + p1Z + · · · + pdZ + me1Z + · · · + medZ}. By the presence of me1Z + · · · + medZ we have that x  Y if and only x  Y where xi = (xi mod m).
And therefore Y can be written as bB {b + me1Z + · · · + medZ}, where B = [0, m - 1]d  Y .
We now prove Theorem 3.
Proof (Proof of Theorem 3). Choose m and B as in Lemma 2, so that Y is of the form bB {b + me1Z + · · · + medZ}. We build an invariant I of the form
bB {b + me1Z + · · · + medZ} for some B  [0, m - 1]d. We initialise the set I0 = {x + me1Z + · · · + medZ}, where x  [0, m - 1]d
such that xj = (x(j0) mod m). We then build the set I1 by adding to I0 the sets {y + me1Z + · · · + medZ} where for each choice of Mi, y  [0, m - 1]d is formed by yj = ((Mix)j mod m) for some x  I0. We iterate this construction until it stabilises in an inductive invariant I. Termination follows from the finiteness of [0, m - 1]d (noting in particular that if termination occurs with B = [0, m - 1]d, then I = Zd which is indeed an inductive invariant).
If there exists y  B  I then return Reachable. This is because the same sequence of matrices applied to x(0) to produce y  I would, thanks to the

Porous Invariants

13

modulo step, wind up inside the set {y + me1Z + · · · + medZ}, which is a part of the target.
Otherwise, return Unreachable and I as invariant. By construction, I is indeed an inductive invariant disjoint from the target set.
Remark 2. By the same argument, Theorem 3 extends to a restricted class of Z-semi-linear targets: the finite union of full-dimensional Z-linear sets.

5 N-semi-linear Invariants
We now consider N-semi-linear invariants, our most general class. N-semi-linear invariants gain expressivity thanks to the `directions' provided by the period vectors. For example, the only possible Z-semi-linear invariant for the LDS (0, (x  x + 1)) is Z, yet the reachability set, N, is captured exactly by an N-linear invariant. We show that a separating N-semi-linear invariant can always be found for unreachable instances of deterministic integer LDS, although the computed invariant will depend on the target. However, finding invariants is undecidable for nondeterministic systems, at least in high dimension. Nevertheless, we show decidability for the low-dimensional setting of the MU Puzzle--one dimension with affine updates.

5.1 Existence of sufficient (but non-minimal) N-semi-linear invariants for point reachability in deterministic LDS
Kannan and Lipton showed decidability of reachability of a point target for deterministic LDS [16]. In this subsection, we establish the following result to provide a separating invariant in unreachability instances.
Theorem 4. Given a deterministic LDS (x(0), M ) together with a point target y, if the target is unreachable then a separating N-semi-linear inductive invariant can be provided.
To do so, we will invoke the results from [8] to compute an R+-semi-linear inductive invariant, and then extract from it an N-semi-linear inductive invariant. More precisely, the authors of [8] show how to build polytopic inductive invariants for certain deterministic LDS. Such polytopes are either bounded or are R+-semi-linear sets. In the first case, the polytope contains only finitely many integral points, which can directly be represented via an N-semi-linear set. In the second case, we build an N-semi-linear set containing exactly the set of integral points included in the R+-semi-linear invariant, thanks to the following lemma.
Lemma 3. Given an R+-linear set S = {x + i piR+}, where the vectors pi have rational coefficients and x is an integer vector, one can build an N-semilinear set N comprising precisely all of the integral points of S.

14

E. Lefaucheux et al.

Proof (Proof of Theorem 4). We note that every invariant produced in [8] has rational period vectors, as the vectors are given by the difference of successive point in the orbit of the system, and thus Lemma 3 can be applied. The authors of [8] build an inductive invariant in all cases except those for which every eigenvalue of the matrix governing the evolution of the LDS is either 0 or of modulus 1 and at least one of the latter is not a root of unity. This situation however cannot occur in our setting. Indeed, the eigenvalues of an integer matrix are algebraic integers, and an old result of Kronecker [19] asserts that unless all of the eigenvalues are roots of unity, one of them must have modulus strictly greater than 1 (the case in which all eigenvalues are 0 being of course trivial).
This concludes the proof of Theorem 4.

5.2 Undecidability of N-semi-linear invariants for nondeterministic LDS
If the enhanced expressivity of N-semi-linear sets allows us always to find an invariant for deterministic LDS, it contributes in turn to making the invariantsynthesis problem undecidable when the LDS is not deterministic. We establish this through a reduction from the infinite Post correspondence problem (-PCP) that can be defined in the following way: given m pairs of non-empty words {(u1, v1), . . . , (um, vm)} over alphabet {0, 2}, does there exist an infinite word w = w1w2 . . . over alphabet {1, . . . , m} such that uw1 uw2 . . . = vw1 vw2 . . .. This problem is known to be undecidable when m is at least 8 [13,6].
Theorem 5. The invariant synthesis problem for N-semi-linear sets and linear dynamical systems with at least two matrices of size 91 is undecidable.
Proof (Sketch). We first establish the result in the case of several matrices in low dimension; this can then be transformed in a standard way to two larger matrices (of size 91).
The proof is by reduction from the infinite Post correspondence problem. Given an instance of this problem the pair of words corresponding to each sequence of tiles has an integer representation, using base-4 encoding. An important property of our encoding is that the operation of appending a new tile to an existing pair of words can be encoded by matrix multiplication.
Recall that if the instance of -PCP is negative, then every generated pair of words will differ at some point. Our encoding is such that this difference of letters creates a difference in their numerical encodings that can be identified with an N-semi-linear invariant. On the other hand, when there is a positive answer to the -PCP instance, there can be no N-semi-linear invariant.

5.3 Nondeterministic one-dimensional affine updates
The previous section shows that point reachability for nondeterministic LDS is undecidable once there sufficiently many dimensions, motivating an analysis at lower dimensions. The MU Puzzle requires a single dimension with affine updates

Porous Invariants

15

(or equivalently two dimensions in matrix representation, with the coordinate along the second dimension kept constant). We consider this one-dimensional affine-update case, and therefore, rather than taking matrices as input, we directly work with affine functions of the form fi(x) = aix + bi.
Theorem 6. Given x(0), y  Z, along with a finite set of functions {f1, . . . , fk} where fi(x) = aix + bi, ai, bi  Z for 1  i  k, it is decidable whether y is reachable from x(0).
Moreover, when y is unreachable, an N-semi-linear separating inductive invariant can be algorithmically computed.
We note that decidability of reachability is already known [9,10]. We refine this result by exhibiting an invariant which can be used to disprove reachability. In fact our procedure will produce an N-semi-linear set which can be used to decide reachability, and which, in instances of non-reachability, will be a separating inductive invariant. We have implemented this algorithm into our tool porous, enabling us to efficiently tackle the MU Puzzle as well as its generalisation to arbitrary collections of one-dimensional affine functions. We report on our experiments in Section 6.
We build a case distinction depending on the type of functions that appear:
Definition 5. A function f (x) = ax + b...
­ ... is redundant if f (x) = b, (including possibly b = 0), or if f (x) = x. ­ ... is counter-like if f (x) = x + b, b = 0. Two counter-like functions, f (x) =
x + b and g(x) = x + c are opposing if b > 0 and c < 0 (or vice-versa). ­ ... is growing if f (x) = ax + b and |a|  2. We say a growing function is
inverting if a  -2. ­ ... is pure inverting if f (x) = -x + b.

Simplifying assumptions
Lemma 4. Without loss of generality, redundant functions are redundant; more precisely, we can reduce the computation of an invariant for a system having redundant functions to finitely many invariant computations for systems devoid of such functions.
Proof. Clearly the identity function has no impact on the reachability set, and so can be removed outright. For any other redundant function, its impact on the reachability set does not depend on when the function is used, and we may therefore assume that it was used in the first step, or equivalently, using an alternative starting point. Hence the invariant-computation problem can be reduced to finitely many instances of the problem over different starting points, with redundant functions removed. Finally, taking the union of the resulting invariants yields an invariant for the original system.
Lemma 5. Without loss of generality, x(0)  0.

16

E. Lefaucheux et al.

Proof. We construct a new system, where each transition f (x) = ax + b is replaced by f (x) = ax - b. Then x(0) reaches y in the original system if and only if -x(0) reaches -y in the new system. To see this, observe that if f (x) = ax + b,
then f (-x) = -ax - b = -f (x).

Lemma 6. Suppose there are at least two distinct pure inverting functions (and possibly other types of functions). Then without loss of generality there are two opposing counters.

Proof. Consider f (x) = -x + b, and g(x) = -x + c. Then f (g(x)) = -(-x + c) + b = x + b - c and g(f (x)) = -(-x + b) + c = x + c - b. Since b - c = -(c - b) and b = c (as f = g) these two functions are opposing.

Two opposing counters. Let us first observe that when there are two opposing counters, we essentially move in either direction by some fixed amount. This will entail that only Z-(semi)-linear invariants can be produced, rather than proper N-(semi)-linear invariants.
Lemma 7. Suppose there are two opposing counters, f (x) = x + b, and g(x) = x - c. Then for any reachable x we have {x + dZ}  I for d = gcd(b, c).
Therefore, starting with x(0) + dZ  I we can `saturate' the invariant under construction using the following lemma:
Lemma 8. Let h(x) = x + d be chosen as a reference counter amongst the counters. If {x + dZ}  I, then {f (x) + dZ}  I for every function f .
Proof (Proof of Lemma 8). Consider the function f (x) = ax + b. If x = y + dk  I, then f (x) = ax + b = ay + adk + b = f (y) + adk  I.
Now thanks to the presence of counter h(x) = x + d, by choosing the initial k  Z appropriately and applying h(x) sufficiently many times (say m  N times), one can reach f (x) + adk + dm = f (x) + dn for any desired n  Z.
Without loss of generality if {x + dZ} is in the invariant, then 0  x < d. We then repeatedly use Lemma 8 to find the required elements of the invariant. Since there are only finitely many residue classes (modulo d), every reachable residue class {c1, . . . , cn} can be found by saturation (in at most d steps), yielding invariant {c1 + dZ}  · · ·  {cn + dZ}.
Thanks to Lemma 6, in all remaining cases there is without loss of generality at most one pure inverter.

Only pure inverters. If there is exactly one pure inverter f (x) = -x + b (and no other types of functions), then f (x(0)) = -x(0)+b and f (-x(0)+b) = x(0)-b+ b = x(0), thus the reachability set is finite, with exact invariant x(0), -x(0) + b .

Porous Invariants

17

No Counters. If we are not in the preceding case and there are no counters, then there must be growing functions and by Lemma 6, without loss of generality at most one pure inverter. We show that all growing functions increase the modulus outside of some bounded region.

Lemma 9. For every M  0 and every growing function f (x) = ax + b, |a|  2, there exists CfM  0 such that if |x|  CfM then |f (x)|  |x| + M .

Proof. By the triangle inequality we have: |f (x)| = |ax + b|  |a||x| - |b|. Thus

|x|



|b|+|M | |a|-1

=

|a||x| - |b|  |x| + |M |

=

|f (x)|  |x| + M .

This is the only situation in which the invariant is not exactly the reachability set, and requires us to take an overapproximation.
Let C = max Cf01 , . . . , Cf0k , |y| + 1 , for f1, . . . , fk growing functions. If there are no pure inverters then {-C - N}  {C + N} is invariant (although may not yet contain the whole of O). However, we can return the inductive invariant {-C - N}  {C + N}  (O  (-C, C)). The set O  (-C, C) is finite and can elicited by exhaustive search, noting that once an element of the orbit reaches absolute value at least C, the remainder of the corresponding trajectory remains forever outside of (-C, C).
If there is one pure inverter g(x) = -x + d then observe that -C is mapped to C + d and C + d is mapped to -C. Thus intuitively we want to use the interval (-C, C + d). However two problems may occur: (a) since d could be less than 0 then C + d may no longer be growing (under the application of the growing functions), and (b) an inverting growing function only ensures that -C is mapped to a value greater than or equal to C, rather than C+d. Hence, we choose C to ensure that C ± d is still growing by at least |d| (under the application of our growing functions). Let C = max Cf|d1|, . . . , Cf|dk|, |y| + 1 + |d|. Then the invariant is {-C - N}  {C + d + N}  (O  (-C , C + d)).

Non-opposing counters. The only remaining possibility (if there do not exist two opposing counters, and not all functions are growing or pure inverters), is that there are counter-like functions, but they are all counting in the same direction. There may also be a single pure inverter, and possibly some growing functions.
Pick a counter h(x) = x+d to be the reference counter; the choice is arbitrary, but it is convenient to pick a counter with minimal |d|. As a starting point, we have x(0) + dN  I.
Lemma 10. If there is an inverter g(x) = -ax + b, with a > 0, b  Z, and we have {x + dN}  I then {g(x) + dZ}  I.
The crucial difference with Lemma 8 is the observation that now an N-linear set has induced a Z-linear set.

18

E. Lefaucheux et al.

Proof. Let r = g(x) + dm for m  Z. We show r  I. Consider x + dn for n  N, then g(x + dn) = -a(x + dn) + b = -ax + b - adn = g(x) - adn. Hence g(x) - adn + dk, n, k  N, is reachable by applying k times the function h(x). Hence for any m  Z there exists k, n  N such that k - na = m, so that r is indeed reachable.
Similarly to the situation with two opposing counters, whenever the invariant contains some Z-linear set, Lemma 8 allows us to saturate amongst the finitely many reachable residue classes.
However, the invariant may contain subsets that are not Z-linear. Consider {x + dN}  I, which is not yet invariant. We repeatedly apply non-inverting functions to {x + dN} to obtain new N-linear sets (not Z-linear sets). When the function applied `moves' in the direction of the counters this will ultimately saturate (in particular when applying other counter functions). However, in the opposite direction, we may generate infinitely many such classes.
Example 3. Consider the reference counter h(x) = x+4, with initial point 5. This yields an initial set {5 + 4N}  O, where 5 is the initial point and 4N is derived from the counter increment. Now when applying x  2x + 6 to {5 + 4N} we obtain {10 + 6 + 8N + 4N} = {16 + 4N}, then {38 + 4N}, and then {82 + 4N}. However {82 + 4N}  {38 + 4N} and we can therefore stop with the invariant {5 + 4N}  {16 + 4N}  {38 + 4N}.
However, if the initial sequence is not moving in the direction of the reference counter, this saturation does not occur. Consider {5 + 4N} with the function x  2x - 6. Then {5 + 4N} maps to {10 - 6 + 8N + 4N} = {4 + 4N}, which maps to {2 + 4N}, {-2 + 4N}, {-10 + 4N}, {-26 + 4N}, and so on. However -2 and -10 are both 2 modulo 4 (and so is -26 as well). This means in the negative direction we can obtain arbitrarily large negative values congruent to 2 modulo 4 and then use the reference counter h(x) = x + 4 to obtain any value of {2 + 4Z}.
Clearly we can examine all reachable residue classes defined by our reference counter. Any residue class reachable after an inverting function induces a Z-linear set. So it remains to consider those N-linear sets reachable without inverting functions. The remaining case to handle occurs when we repeatedly induce Nlinear sets until they repeat a residue class in the direction opposite to that of the reference counter.
We consider the case for h(x) = x + d with d  0. The case with h(x) = x - d is symmetric. It remains to detect when a set {x + dN} leads to {y + dN} by a sequence of non-inverting functions with x  y mod d. Then by repeated application of these functions one can reach sets {z + dN} with z arbitrarily small, hence we can replace {x + dN} by {x + dZ}. We give further details in the appendix.

Reachability. The above procedure is sufficient to decide reachability. In all cases apart from that in which there are no counters, the invariants produced co-

Porous Invariants

19

incide precisely with the reachability sets. A reachability query therefore reduces to asking whether the target belongs to the invariant.
In the remaining case, the invariant obtained is parametrised by the target via the bound C . The target lies within the region (-C , C +d), within which we can compute all reachable points. Thus once again, the target is reachable precisely if it belongs to the invariant. However, for a new target of larger modulus, a different invariant would need to be built.

Complexity.
Lemma 11. Assume that all functions, starting point, and target point are given in unary. Then the invariant can be computed in polynomial time.
Without the unary assumption, the invariant could have exponential size, and hence require at least exponential time to compute. That is because the invariant we construct could include every value in an interval, for example, (-C, C), where C is of size polynomial in the largest value.
As shown in [10], the reachability problem is at least NP-hard in binary, because one can encode the integer Knapsack problem (which allows an object to be picked multiple times rather at most once). Moreover the Knapsack problem is efficiently solvable in pseudo-polynomial time via dynamic programming; that is, polynomial time assuming the input is in unary, matching the complexity of our procedure.

6 The POROUS Tool
Our invariant-synthesis tool porous11 computes N-semi-linear invariants for point and Z-linear targets on systems defined by one-dimensional affine functions. porous includes implementations of the procedures of Theorem 3 (restricted to one-dimensional affine systems) and Theorem 6. porous is built in Python and can be used by command-line file input, a web interface, or by directly invoking the Python packages.
porous takes as input an instance (a start point, a target, and a collection of functions) and returns the generated invariant. Additionally it provides a proof that this set is indeed an inductive invariant: the invariant is a union of N-linear sets, so for each linear set and each function, porous illustrates the application of that function to the linear set and shows for which other linear set in the invariant this is a subset. Using this invariant, porous can decide reachability; if the specific target is reachable the invariant is not in itself a proof of reachability (since the invariant will often be an overapproximation of the global reachability set). Rather, equipped with the guarantee of reachability, porous searches for a direct proof of reachability: a sequence of functions from start to target (a process which would not otherwise be guaranteed to terminate).
11 Tool: invariants.davidpurser.net Code: github.com/davidjpurser/porous-tool

20

E. Lefaucheux et al.

Size Invariant Unreachable Invariant Reachable Reachable Reachability

Build Time Instances Proof Time Instances with proofs Proof time

avg max

avg max

within 30s avg

8 0.001 0.009 100 (9.84%) 0.005 0.261 916 (90.2%) 911 (99.5%) 0.033

16 0.001 0.020 122 (12.0%) 0.010 0.788 894 (88.0%) 885 (99.0%) 0.053

32 0.003 0.068 134 (13.2%) 0.020 0.911 882 (86.8%) 843 (95.6%) 0.203

64 0.008 0.261 150 (14.8%) 0.052 2.969 866 (85.2%) 766 (88.5%) 0.294

128 0.021 0.557 153 (15.1%) 0.096 2.426 863 (84.9%) 719 (83.3%) 0.464

256 0.088 2.838 166 (16.3%) 0.316 43.587 850 (83.7%) 620 (72.9%) 0.998

512 0.428 9.312 162 (15.9%) 0.899 21.127 854 (84.1%) 570 (66.7%) 1.120

1024 1.121 20.252 173 (17.0%) 3.275 65.397 843 (83.0%) 514 (61.0%) 1.646

all 0.209 20.252 1160 (14.3%) 0.584 65.397 6968 (85.7%) 5828 (83.6%) 0.499

Table 2. Results varying by size parameter (last row includes all instances tested). Times are given in seconds, with the average and maximum shown (except reachability proof time, which are all approximately 30s due to instances that terminate just before the timeout).

Experimentation. porous was tested on all 27 - 1 possible combinations of the following function types, with a  2, b  1: positive counters (x  x + b), negative counters (x  x - b), growing (x  ax ± b), inverting and growing (x  -ax ± b), inverters with positive counters (x  -x + b), inverters with negative counters (x  -x - b) and the pure inverter (x  -x). For each such combination a random instance was generated, with a size parameter to control the maximum modulus of a and b, ranging between 8 and 1024. The starting point was between 1 and the size parameter and the target was between 1 and 4 times the size parameter. Ten instances were tested for each size parameter and each of the 27 - 1 combinations, with between 1 and 9 functions of each type (with a bias for one of each function type).
Our analysis, summarised in Table 2, illustrates the effect of the size parameter. The time to produce the proof of invariant is separated from the process of building the invariant, since producing the proof of invariant can become slower as |I| becomes larger; it requires finding Lk  I such that fi(Lj)  Lk for every linear set Lj  I and every affine function fi. In every case porous successfully built the invariant, and hence decided reachability very quickly (on average well below 1 second) and also produced the proof of invariance in around half a second on average. To demonstrate correctness in instances for which the target is reachable porous also attempts to produce a proof of reachability (a sequence of functions from start to target). Since our paper is focused on invariants as certificates of non-reachability, our proof-of-reachability procedure was implemented crudely as a simple breadth-first search without any heuristics, and hence a timeout of 30 seconds was used for this part of the experiment only.
Our experimental methodology was partially limited due to the high prevalence of reachable instances. A random instance will likely exhibit a large (often universal) reachability set. When two random counters are included, the chance

Porous Invariants

21

that gcd(b1, b2) = 1 (whence the whole space is covered) is around 60.8% and higher if more counters are chosen.
Overall around 86% of instances were reachable (of which 84% produced a proof within 30 seconds). Of the 14% of unreachable instances, all produced a proof, with the invariant taking around 0.2 seconds to build and 0.6 seconds to produce the proof. The 30-second timeout when demonstrating reachability directly is several orders of magnitudes longer than answering the reachability query via our invariant-building method.
A typical academic/consumer laptop was used to conduct the timing and analysis (a four-year-old, four-core MacBook Pro).

7 Conclusions and Open Directions
We introduced the notion of porous invariants, which are not necessarily convex and can in fact exhibit infinitely many `holes', and studied these in the context of multipath (or branching/nondeterministic) affine loops over the integers, or equivalently nondeterministic integer linear dynamical systems. We have in particular focused on reachability questions. Clearly, the potential applicability of porous invariants to larger classes of systems (such as programs involving nested loops) or more complex specifications remains largely unexplored.
Our focus is on the boundary between decidability and undecidability, leaving precise complexity questions open. Indeed, the complexity of synthesising invariants could conceivably be quite high, except where we have highlighted polynomial-time results. On the other hand, the invariants produced should be easy to understand and manipulate, from both a human and machine perspective.
On a more technical level, in our setting the most general class of invariants that we consider are N-semi-linear. There remains at present a large gap between decidability for one-dimensional affine functions, and undecidability for linear updates in dimension 91 and above. It would be interesting to investigate whether decidability can be extended further, for example to dimensions 2 and 3.

Acknowledgements This work was funded by DFG grant 389792660 as part of TRR 248 (see perspicuous-computing.science). Jo¨el Ouaknine was supported by ERC grant AVS-ISS (648701), and is also affiliated with Keble College, Oxford as emmy.network Fellow. James Worrell was supported by EPSRC Fellowship EP/N008197/1.

References
1. Almagor, S., Chistikov, D., Ouaknine, J., Worrell, J.: O-minimal invariants for discrete-time dynamical systems. preprint, submitted (2019), https://arxiv.org/ abs/1802.09263

22

E. Lefaucheux et al.

2. Bozga, M., Iosif, R., Konecny´, F.: Fast acceleration of ultimately periodic relations. In: Touili, T., Cook, B., Jackson, P.B. (eds.) Computer Aided Verification, 22nd International Conference, CAV 2010, Edinburgh, UK, July 15-19, 2010. Proceedings. Lecture Notes in Computer Science, vol. 6174, pp. 227­242. Springer (2010). https://doi.org/10.1007/978-3-642-14295-6 23, extended VERIMAG technical report, TR-2012-10, 2012: http://www-verimag.imag.fr/TR/TR-2012-10.pdf
3. Chistov, A.: Algorithm of polynomial complexity for factoring polynomials and finding the components of varieties in subexponential time. Journal of Soviet Mathematics 34(4), 1838­1882 (1986)
4. Clarke, E.M., Fehnker, A., Han, Z., Krogh, B.H., Ouaknine, J., Stursberg, O., Theobald, M.: Abstraction and counterexample-guided refinement in model checking of hybrid systems. Int. J. Found. Comput. Sci. 14(4), 583­604 (2003). https://doi.org/10.1142/S012905410300190X
5. Cousot, P., Halbwachs, N.: Automatic discovery of linear restraints among variables of a program. In: Aho, A.V., Zilles, S.N., Szymanski, T.G. (eds.) Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, Tucson, Arizona, USA, January 1978. pp. 84­96. ACM Press (1978). https://doi.org/10.1145/512760.512770
6. Dong, J., Liu, Q.: Undecidability of Infinite Post Correspondence Problem for instances of size 8. RAIRO Theor. Informatics Appl. 46(3), 451­457 (2012). https://doi.org/10.1051/ita/2012015
7. Douglas, R.H.: Go¨del, Escher, Bach: An eternal golden braid (1979) 8. Fijalkow, N., Lefaucheux, E., Ohlmann, P., Ouaknine, J., Pouly, A., Worrell, J.:
On the Monniaux Problem in Abstract Interpretation. In: Chang, B.E. (ed.) Static Analysis - 26th International Symposium, SAS 2019, Porto, Portugal, October 811, 2019, Proceedings. Lecture Notes in Computer Science, vol. 11822, pp. 162­180. Springer (2019). https://doi.org/10.1007/978-3-030-32304-2 9 9. Finkel, A., Go¨ller, S., Haase, C.: Reachability in register machines with polynomial updates. In: Chatterjee, K., Sgall, J. (eds.) Mathematical Foundations of Computer Science 2013 - 38th International Symposium, MFCS 2013, Klosterneuburg, Austria, August 26-30, 2013. Proceedings. Lecture Notes in Computer Science, vol. 8087, pp. 409­420. Springer (2013). https://doi.org/10.1007/978-3-642-403132 37 10. Fremont, D.: The reachability problem for affine functions on the integers. CoRR abs/1304.2639 (2013), http://arxiv.org/abs/1304.2639 11. Giesl, J., Aschermann, C., Brockschmidt, M., Emmes, F., Frohn, F., Fuhs, C., Hensel, J., Otto, C., Plu¨cker, M., Schneider-Kamp, P., Stro¨der, T., Swiderski, S., Thiemann, R.: Analyzing program termination and complexity automatically with AProVE. J. Autom. Reason. 58(1), 3­31 (2017). https://doi.org/10.1007/s10817016-9388-y 12. Ginsburg, S., Spanier, E.H.: Bounded algol-like languages. Transactions of the American Mathematical Society 113(2), 333­368 (1964). https://doi.org/10.1090/S0002-9947-1964-0181500-1 13. Halava, V., Harju, T.: Undecidability of Infinite Post Correspondence Problem for instances of Size 9. RAIRO Theor. Informatics Appl. 40(4), 551­557 (2006). https://doi.org/10.1051/ita:2006039 14. Heizmann, M., Hoenicke, J., Podelski, A.: Termination analysis by learning terminating programs. In: Biere, A., Bloem, R. (eds.) Computer Aided Verification - 26th International Conference, CAV 2014, Held as Part of the Vienna Summer of Logic, VSL 2014, Vienna, Austria, July 18-22, 2014. Proceedings.

Porous Invariants

23

Lecture Notes in Computer Science, vol. 8559, pp. 797­813. Springer (2014). https://doi.org/10.1007/978-3-319-08867-9 53 15. Hrushovski, E., Ouaknine, J., Pouly, A., Worrell, J.: Polynomial invariants for affine programs. In: Dawar, A., Gra¨del, E. (eds.) Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018. pp. 530­539. ACM (2018). https://doi.org/10.1145/3209108.3209142 16. Kannan, R., Lipton, R.J.: Polynomial-time algorithm for the orbit problem. J. ACM 33(4), 808­821 (1986). https://doi.org/10.1145/6490.6496 17. Karr, M.: Affine relationships among variables of a program. Acta Informatica 6, 133­151 (1976). https://doi.org/10.1007/BF00268497 18. Kincaid, Z., Breck, J., Cyphert, J., Reps, T.W.: Closed forms for numerical loops. Proc. ACM Program. Lang. 3(POPL), 55:1­55:29 (2019). https://doi.org/10.1145/3290368 19. Kronecker, L.: Zwei Sa¨tze u¨ber Gleichungen mit ganzzahligen Coefficienten. Journal fu¨r die reine und angewandte Mathematik 57(53), 173 ­ 175 (1857) 20. Leroux, J.: The general vector addition system reachability problem by presburger inductive invariants. Log. Methods Comput. Sci. 6(3) (2010). https://doi.org/10.2168/LMCS-6(3:22)2010 21. Leroux, J.: Vector addition system reachability problem: a short selfcontained proof. In: Ball, T., Sagiv, M. (eds.) Proceedings of the 38th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2011, Austin, TX, USA, January 26-28, 2011. pp. 307­316. ACM (2011). https://doi.org/10.1145/1926385.1926421 22. Markov, A.: On certain insoluble problems concerning matrices. In: Doklady Akad. Nauk SSSR. vol. 57, pp. 539­542 (1947) 23. Monniaux, D.: On the decidability of the existence of polyhedral invariants in transition systems. Acta Informatica 56(4), 385­389 (2019). https://doi.org/10.1007/s00236-018-0324-y 24. Ouaknine, J., Worrell, J.: Decision problems for linear recurrence sequences. In: Finkel, A., Leroux, J., Potapov, I. (eds.) Reachability Problems - 6th International Workshop, RP 2012, Bordeaux, France, September 17-19, 2012. Proceedings. Lecture Notes in Computer Science, vol. 7550, pp. 21­28. Springer (2012). https://doi.org/10.1007/978-3-642-33512-9 3 25. Shmonin, G.: Lattices and Hermite normal form (February 2009), lecture notes for the course Integer Points in Polyhedra at the Swiss Federal Institute of Technology Lausanne (EPFL) 26. Tzeng, W.: A polynomial-time algorithm for the equivalence of probabilistic automata. SIAM J. Comput. 21(2), 216­227 (1992). https://doi.org/10.1137/0221017

24

E. Lefaucheux et al.

A Proof of Lemma 1

Lemma 1. Given an LDS (x(0), {M1, . . . , Mk}) of dimension d, we can compute in time polynomial in d, k, and log µ (where µ > 0 is an upper bound on the absolute values of the integers appearing in x(0) and M1, . . . , Mk), a Q-affinely independent set of integer vectors R0  O such that:

1. 2.

x(0)  R0, the affine span

of

R0

and

the

affine

span

of

O

are

the

same

(R0a = Oa),

3. the entries of the vectors in R0 have absolute value at most µ0 := (dµ)d.

Proof. The result of [26, Theorem 3.1] proceeds by finding new points in the reachability set and adding them to a set of points if the new point is linearly independent of the current version this set. Whilst the result of [26] refers to linear independence, this can be converted to affine independence by increasing the dimension by one.
The procedure works via a pruned version breadth-first search, with nodes only expanded if its children are linearly independent of the current set. Hence, the first point found in the tree is the initial point x(0), and therefore this point is included. The maximum depth of the tree that needs to be explored is d, and so every point included is reached with at most d applications of matrices to x(0). Hence, if the largest absolute value of a point or matrix entry is µ, after d iterations, the largest absolute value is dd-1µd. This is by induction on the largest possible value µ for every entry:

µ . . . µ d0µ dµ2

Base case:  

...

 

...

= 

...

 

µ . . . µ d0µ

dµ2

µ . . . µ dk-1µk dµ(dk-1µk) dkµ(k+1)

Inductive case:  

...

 

...

= 

...

= 

...

 

µ . . . µ dk-1µk

dµ(dk-1 µk )

dk µ(k+1)

The result of [26] is in polynomial time in the number of arithmetic operations, we observe that this is also polynomial time in the bit-size. The independence checking in the algorithm involves checking linear independence of at most d vectors all having bit size at most log((dµ)d) = d log(d) + d log(µ), which can be done in polynomial time in the bit-size (for example by Bareiss algorithm for calculating the determinant).

B Proof of Lemma 3
Lemma 3. Given an R+-linear set S = {x + i piR+}, where the vectors pi have rational coefficients and x is an integer vector, one can build an N-semilinear set N comprising precisely all of the integral points of S.

Porous Invariants

25

Proof. Let S = {x + i piR+} be a R+-linear set where the vectors pi have rational coefficients and x is an integer vector. Let k  N so that the vectors kpi have integer coefficients. We denote by vi the integer vectors obtained as a convex combination of the vectors kpi. Then the set T = {x + i viN} contains exactly the integer vectors contained in S.
Indeed, first T only contains integer points as both x and the vectors vi are integer vectors. Secondly, all the vectors in T are included in S as the period
vectors of T lie in the convex hull of the vectors of S. Finally, given an integer
vector y in S, y can be rewritten as y = x + v + i mikpi where for all i, mi  N and v is an integer vector lying in the convex hull of the vectors kpi. Therefore there exists j such that vj = v and as for all i, kpi is a period vector of T , y  T.

C Proof of Theorem 5

Theorem 5. The invariant synthesis problem for N-semi-linear sets and linear dynamical systems with at least two matrices of size 91 is undecidable.

Proof. We will prove the result for m + 5 matrices of size 7. This can then be

transformed in a usual way to two matrices of size 7m + 35 (See Theorem 9 of [8]

for instance).

In order to simplify the main part of the proof, let us first show that one

can enforce an order between the matrices using affine transformations on one

dimension. Let us denote p this dimension, it is initially equal to 1 and its target

value is 0. Consider the three following affine transformation: f1(p) = 2p - 1, f2(p) = 2p - 2 and f3(p) = 2p, then the only sequences of transformation allowing to reach the target are of the form f3f2f1. Indeed, let I = {p | p  2  p  -1}, we have (1) if p  I, then for all i  {1, 2, 3}, fi(p)  I, (2) f1(1) = 1 and f1(0)  I, (3) f2(1) = 0 and f2(0)  I and (4) f3(1)  I and f3(0) = 0. As a consequence, the inductive invariant I ensure that any sequence of transformation that do not have the desired order cannot reach the target. In

the following, we will call type 1, 2 or 3 the transformations we define, depending

on whether they implictly contain the function f1, f2 or f3. We reduce an instance {(u1, v1), . . . , (um, vm)} of the -PCP problem to the

invariant synthesis problem. In order to simplify future notations, given a finite

or infinite word w, we denote by |w| the length of the word w and given an integer

i  |w|, we write wi for the i'th letter of w. Given a finite or infinite word w on alphabet {1, . . . , m} we denote by uw and vw the words on the alphabet {0, 2}

such that uw = uw1 uw2 . . . and vw = vw1 vw2 . . . . Given a (finite or infinite)

word w on the alphabet {0, 2}, denote by [w] =

|w| i=1

wi4|w|-i

the

quaternary

encoding of w. It is clear that it satisfies [ww ] = 4|w |[w] + [w ]. For all i  m,

we denote by ni = 4|ui|, mi = 4|vi| and maxi = max(ni, mi).

We work with 5 dimension, (s, c, d, n, k), and define the following transfor-

mations:

26

E. Lefaucheux et al.

­ For i  m, the type 1 transformation Simulatei on (s, c, d, n, k) encode the

action of reading the pair (ui, vi) and increases the counters n and k: it

simultaneously applies

maxi ni

d,

n



n

+

k

k



s k

 maxi + 1.

s

+

[ui]

maxi ni

-

[vi]

maxi ni

,

c



maxi ni

c,

d



­ The type 2 transformation Transfer on (s, c, d, n, k) gather some of the values

in order to compare them: s  s - c - d, c  -s - c - d.

­ The type 3 transformation Incs increments s: s  s + 1. ­ The type 3 transformation Incc increments u: c  c + 1. ­ The type 3 transformation Dec decreases k and n: n  n - k, k  k - 1.

­ The type 3 transformation Deck decrements k: k  k - 1.

These m+5 transformations need 7 dimensions in total: the five above, (s, c, d, n, k), the one used for ordering the transformations,p, and one dimension constantly equal to 1, required to use affine transformations.
We now show that there is a solution to the given instance of the -PCP problem iff there does not exist a N-semi-linear invariant for the system with initial point x = (0, 1, 1, 0, 0, 1, 1), target y = (0, 0, 0, 1, 0, 0, 1) and using the matrices inducing the transformations defined above.
Assume first that there is a solution w to the -PCP instance. Consider the sequence of points (xn) obtained as follows: for all j  N, denoting wj the prefix of w of length, xj = (sj, cj, 0, nj, kj, 0, 1) = Transfer Simulatewj x where Simulatewj represents the transformation Simulatewj . . . Simulatew2 Simulatew1 . We have that sj and cj are negative. Indeed, let (s, c, d) be the three first components of Simulatewj x, we have that s = c[uwi] - d[vwi]. As wj is a prefix of a solution to the -PCP instance, assuming |uwi|  |vwi| this implies that

|s| = |c[uwi] - d[vwi]|

|vw i|

=

|uwj i - vjwi|c4|uwi|-j

j=1

|vw i|

=

vjwi c4|uw i|-j

j =|uw i|+1

2c

3

Thus |s| - c - d is negative, thus sj = s - c - d and cj = -s - c - d are negative. Due to the above, by applying to the points xj a number of time the trans-
formations Incs and Incc, we obtain the sequence of points (yj) where yj = (0, 0, 0, nj, kj, 0, 1). We claim that any semi-linear invariant containing all the points yj also contains a point of the shape (0, 0, 0, 0, nj + d, kj, 0, 1) where d is a positive integer. This will imply the result as from such a point, one can reach the target by d - 1 applications of Deck and kj applications of Dec and thus there is no semi-linear invariant of the system that does not intersect the target.
Let us now prove the above claim. Let I be a semi-linear set containing every point (yj) (which we will see as two-dimensional objects by projecting on the

Porous Invariants

27

4th and 5th dimension). Then there exists a linear set I  I that contains infinitely many vectors of (yj). This set I is defined by an initial vector, and a set of period vectors. As I contains infinitely many vectors of (yj) where the ratios between the first and second component is increasing, one of the period vectors is of the form (d, 0) where d is a strictly positive integer. Let j be such that yj  I , then (nj + d, kj)  I which implies the claim.
As a consequence, every N-semi-linear set over-approximating the system intersects with the target.
Conversely, assume that there is no solution to the -PCP instance. There exists n0  N such that for every infinite word w on alphabet {0, . . . , m} there exists n  n0 such that uwn = vnw. Indeed, consider the tree which root is labelled by (, ) and, given a node (u, v) of the tree, if for all n  min(|u|, |v|) we have un = vn, then this node has m children: the nodes (uui, vvi) for i = 1 . . . m. This tree is finitely branching and does not contain any infinite path (which would induce a solution to the -PCP instance). Thus, according to K¨onig's lemma, it is finite. We can therefore choose the height of this tree as our n0.
We define the invariant I = I1  I2  I3 where
I1 = Simulatew(x) | w  {1, . . . , m}  |w|  n0 + 1 ,

I2 = z = (s, c, 0, n, k, 0, 1) | z = (Incs)(Incc)(Dec)(Deck)Transfer Simulatew(x)  w  {1, . . . , m}  |w|  n0 + 1  s, t, n, k  N
and

I3 = (s, c, d, n, k, p, 1) | (|s| - c - d  1  c  0  d  0  p = 1)  ((s  1  c  1  n  -1  k  -1)  p = 0)  p  -1  p  2}.

By definition, I is an N-semi-linear set, contains x and does not contain y. The difficulty is to show stability under the transformations. · Let z = Simulatew(x)  I1, for some w  {1, . . . , m} with |w|  n0 + 1. By ordering if we apply a transformation outside Transfer or a Simulatei for some i, we reach I3.

­ For i  m, if |w|  n0, then Simulateiz  I1. Else, Simulatewix = (s, c, d, n, k, p, 1) with |w| = n0 + 1. But then, there exists n1 n0 such that uwn1i = vnw1i. Let n2 be the smallest such number, then assume without loss of generality that
c  d, we have

s = c[uwi] - d[vwi]

max(|uw i|,|vw i|)

= (uwn2i - vnw2i)c4|uwi|-n2 +

(uwj i - vjwi)c4|uwi|-j

j =n2 +1

28

E. Lefaucheux et al.

since uwj i = vjwi for j < n2. Thus,

|s|

2c4|uw i|-n2

-

2 3

c4|uw

i|-n2

since |uwn2i - uwn2i| = 2 and for n  n2, |uwn i - uwn i|  2

c4|uwi |-n2

2 3

2c + 1

since n2 n0 and |uwi| n0 + 2.

As c  d, this shows that Simulatewiz  I3. ­ Transferz  I2.
· Let z  I2 and f be one of the transformations, then f (z)  I2 if f increased (resp. decreased) a negative (resp. positive) component. Otherwise f (z)  I3. · Let z = (s, c, d, n, k, p, 1)  I3, f be one of the transformations and f (z) = (s , c , d , n , k , p , 1).

­ if p = 0, then either p  -1 and f (z)  I3 or z satisfies (s  1  c  1  n  -1  k  -1) and then f (z) satisfies (s  1  c  1  n  -1  k  -1), thus f (z)  I3.
­ if p = 1, then |s| - c - d  1, c  0 and d  0. There is three possibilities (1) p = 2 and thus f (z)  I3, (2) f = Transfer then p = 0 and either s  1 or c  1 and thus f (z)  I3 or (3) f = Simulatei for i  m. In the latter case without loss of generality, assume that d c (this is completely symmetric in c and d ). We have that

|s | = | max(s) + c [ui] - d [vi]|
i

max |s| - d max([ui], [vi])
i

max(c + d + 1) - d max([ui], [vi])
i

max(c
i

+

d

+

1)

-

2 3

d

max
i

= max(c + d/3) + max

i

i

c +d +1

by applying Simulatei

by assumption on |s|

since

[ui]



[0,

2ni 3

]

since maxi c  c , maxi d/3  d (as mi  4) and maxi 4. This shows that f (z)  I3.
Therefore I is inductive and thus a N-semi-linear invariant of the system. This concludes the reduction.

D Additional proofs for Theorem 6
D.1 Proof of Lemma 7 Lemma 12. For , k coprime, the sequence an = (n mod k) for n  N cycles through every modulo class {0, . . . , k - 1}.

Porous Invariants

29

Proof. Any path longer than k visits some class twice, and if the shortest cycle

is k, then it visits every class.

Suppose there is a cycle of length less than k; then n = c+mk and (n+i) =

c + m k and hence i = (m - m)k, with i < k. Since is an integer i divides

(m

- m)k

then

i = pr

for

p, r

N

such

that

m -m p

is

integer

and

k r

is

integer.

Observe

that

since

r



i

<

k

we

have

k r

>

1.

But

this

implies

that

k r

divides

k

and , contradicting gcd(k, ) = 1.

Lemma 7. Suppose there are two opposing counters, f (x) = x + b, and g(x) = x - c. Then for any reachable x we have {x + dZ}  I for d = gcd(b, c).

Proof. Let b = kd, c = d, where k, are co-prime.

We show there exists m, n  0 such that mb - cn = d. We have mb - cn =

d



mkd - n d = d



mk - n

=

1.

Then

choose

m

=

1+n k

.

By

Lemma 12 there exists n such that n is in any modulo class modulo k, and thus

too for 1 + n and so k divides 1 + n for some n.

Hence the set {x + dN} is included in the reachability set: we obtain x + jd

by applying function f mj times and applying function g nj times. Similarly,

we can find m , n  0 such that m b - cn = -d and thus {x + dZ} is within

the reachability set.

D.2 Extended argument for non opposing counters
The following shows that if {x + dN} does lead to {y + dN}, with y < x and y  x mod d, then indeed we can reach {z + dN} for any z  x mod d by reapplying the same set of functions which lead from x to y.
Lemma 13. Assume the reference counter h(x) = x + d with d  0. Suppose all growing functions are growing outside of [-B, C]. Consider x(0)  I and a path x(0), fi1 , x(1), fi2 , . . . , fim , x(m) such that x(j) = fij (x(j-1)), x(j)  -B, x(m) < x(0) and x(0)  x(m) mod d.
Then x(0) + dZ  I.
Proof. The re-application of fim  · · ·  fi1 results in the same modulo class by modulo arithmetic. Further since x(j)  -B then any growing fij , is growing by at least as much as in the first application. Thus fim  · · ·  fi1 (x(m)) < x(m).
Hence for any M < -B, there exists c < M, n  N, such that (fim  · · ·  fi1 )n(x(0)) = c  x(0) mod d. Hence for any x(0) + kd  x(0) + dZ with k  Z then there exists n, such that (fim  · · ·  fi1 )n(x(0))  x(0) + kd and h  (fim  · · ·  fi1 )n(x(0)) = x(0) + kd.
Remark 3. By symmetry, Lemma 13 also holds for the opposite direction. That is when h(x) = x - d, d > 0, inequalities are inverted and C is used in place of -B.

30

E. Lefaucheux et al.

We now consider inductively applying non-inverting functions to sets {x + dN}  I. Then add {fi(x) + dN} provided it is not already a subset of some set already in I. If {fi(x) + dN} is new and a new modulo class we can again apply Lemma 10, from whence we may also need to apply Lemma 8.
However, when this procedure does not saturate there eventually exists be a sequence of actions in which {x + dN} leads to {y + dN} with x  y mod d according to a path in Lemma 13. In particular y < x < -B since if x < y then {y + dN}  {x + dN}, some modulo class must repeat after at most d steps, and eventually the procedure must stay < -B for at least d steps. Then, according to Lemma 13, a new Z-linear set can be added ({x + dZ}) (which again can be saturated using Lemma 8). We repeat this process until all N-linear sets are invariant. This process terminates, as each application of Lemma 13 adds a new Z-linear set with period d, of which there are at most d.

D.3 Proof of Lemma 11

Lemma 11. Assume that all functions, starting point, and target point are given in unary. Then the invariant can be computed in polynomial time.

Proof. In the no-counter case, by Lemma 9, there is an interval [-C, C] of size

approximately

|b|+|M |a|-1

|

,

where

|b|, |M |, |a|

are

all

numbers

represented

in

the

in-

put, and thus is of polynomial of size. This means the gap is of polynomial

size, and thus the saturation algorithm, which must in each step add a point or

terminate, is of polynomial time.

In each counter-case there is a reference counter period d arising directly from

the input as the counter part of some function, or in the case of two opposing

counters, possibly the sum of two counter parts. For this period d there are

at most 3d possible types of non-singleton invariant ({x + dN} or {x - dN} for some x and x + dZ for x  {0, . . . , d} ). Singletons only arise in the interval

[-C, C] if they exist. Hence, there are at most O(2C + 3d) steps which change

the invariant.

In the case of two opposing counters, immediately all invariants are of the

form x + dZ for x  {0, . . . , d}, and the reachable modulo classes can be found

in O(dk) (recall k is the number of functions), by breadth first search.

In the case of all counters in the same direction, there are two phases, each

has a bounded number of steps. First we consider updates which move in the

direction of the counters and secondly we consider updates which move against

the counters.

In the case of moving with the counters, outside of [-C, C] all functions

are growing. Hence, by conducting breadth first search on a priority queue that

always expands the minimal element we can find the sets of the form x + dN for x  {0, . . . , d} in polynomial time. Only inside [-C, C] does the search result in

smaller elements (which there are at most 2C such steps), and in the remaining

case we either expand to find an element already covered, or we find the smallest

element in that modulo class. Thus this step takes O(dk + 2C) time.

Porous Invariants

31

Secondly we search for cycles in the direction opposing the counters, to see if we can turn any x + dN sets into x + dZ sets, that is invariants induced by Lemma 13. There can be a path of length at most d steps outside of [-C, C] before a cycle is found, so the running time is O(2Cd).

E Tool

The tool's output, when, applied to the MU Puzzle can be seen to produce the invariant {1 + 3Z}  {2 + 3Z} of Example 1:

-----------------

Interpretation of input

start: 1 target: {0} functions: [f(x) = x - 3, f(x) = 2x]

-----------------

invariant: {1 +3Z}  {2 +3Z}

-----------------

reachability: unreachable

target {0} disjoint from invariant

-----------------

Proof of invariance

Set

under

gives

within

------- ------------ ------- -- --------

{1 +3Z} f(x) = x - 3 {1 +3Z}  {1 +3Z}

{1 +3Z} f(x) = 2x

{2 +6Z}  {2 +3Z}

{2 +3Z} f(x) = x - 3 {2 +3Z}  {2 +3Z}

{2 +3Z} f(x) = 2x

{4 +6Z}  {1 +3Z}

-----------------

time invariant 0.000556707

time proofOfInvariant 0.000496387

-----------------

The web-interface can be found at http://invariants.davidpurser.net.

