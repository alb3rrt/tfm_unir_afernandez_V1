arXiv:2106.00733v1 [math.RA] 1 Jun 2021

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS
ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO
Abstract. This paper presents new results on the identities satisfied by the sylvester and Baxter monoids. We show how to embed these monoids, of any rank strictly greater than 2, into a direct product of copies of the corresponding monoid of rank 2. This confirms that all monoids of the same family, of rank greater than or equal to 2, satisfy exactly the same identities. We then give a complete characterization of those identities, and prove that the varieties generated by the sylvester and the Baxter monoids have finite axiomatic rank, by giving a finite basis for them.
1. Introduction
When studying the identities satisfied by a given semigroup S, if S indeed satisfies a non-trivial identity, two natural questions arise: The first is the finite basis problem, that is, are the identities satisfied by S consequences of those in some finite subset (see [Sap14, Vol01]). There exist several powerful methods with which to approach the problem for finite semigroups, however, such is not the case for infinite semigroups. The second question is the computational complexity of the identity checking problem Check-Id(S) [KS95], that is, the decision problem whose instance is an arbitrary identity u  v, and the answer to such an instance is `YES' if S satisfies u  v, and `NO' if it does not. It is well-known that, for any finite semigroup S, the problem Check-Id(S) is decidable, since there are only finitely many substitutions of the variables occurring in the identity by elements of S. Furthermore, Check-Id(S) belongs in the complexity class co-NP. However, in the case of infinite semigroups, the brute-force approach used in the finite case does not work, and only recently there have been results on the computational complexity of identity checking for infinite semigroups, beyond undecidability and trivial or easy decidability in linear time (see [DJK18, CHK+20, KV20]).
The plactic monoid plac [LS78a], whose elements can be identified with Young tableaux, has long been considered an important monoid, due to its numerous applications in different areas of mathematics, such as algebraic combinatorics [Lot02],
2020 Mathematics Subject Classification. Primary 08B05; Secondary 05E99, 20M05, 20M07, 20M32.
Key words and phrases. Sylvester monoid, Baxter monoid, variety, identities, equational basis, axiomatic rank.
This work is funded by National Funds through the FCT ­ Fundação para a Ciência e a Tecnologia, I.P., under the scope of the project UIDB/00297/2020 (Center for Mathematics and Applications) and the project PTDC/MAT-PUR/31174/2017. The third author is funded by National Funds through the FCT ­ Fundação para a Ciência e a Tecnologia, I.P., under the scope of the studentship SFRH/BD/138949/2018.
1

2

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

representation theory [Ful96, Gre06], symmetric functions [Sch77, Mac98], KostkaFoulkes polynomials [LS78b], and crystal bases [BS17]. By its definition via Schensted's insertion algorithm [Sch61], the plactic monoid has decidable word problem. The question of identities satisfied by the plactic monoid is actively studied [KO15, Izh19], since it is an infinite monoid with a powerful combinatorial structure. Cain et al [CKK+17] showed that the plactic monoid of finite rank n does not satisfy any non-trivial identity of length less than or equal to n, thus showing that there is no single "global" identity satisfied by every plactic monoid of finite rank. On the other hand, Johnson and Kambites [JK21] gave a tropical representation of the plactic monoid of every finite rank, thus showing that they all satisfy non-trivial identities. Furthermore, in conjunction with results given in [DJK18] and [JT19], this shows that the identity checking problem in the plactic monoids of finite rank is in the complexity class P. Daviaud et al [DJK18] also show that the monoid of 2 × 2 upper-triangular tropical matrices (see, for example, [MS15]), the bicyclic monoid, and the plactic monoid of rank 2 satisfy exactly the same identities. Since the bicyclic monoid is not finitely based [Shn89], none of these monoids are.
In the context of combinatorial Hopf algebras, whose bases are indexed by combinatorial objects, the plactic monoid is used to construct the Hopf algebra of free symmetric functions FSym [PR95, DHT02], whose bases are indexed by standard Young tableaux. In this context, other monoids arise with similar combinatorial properties to the plactic monoid: the Hopf algebra Sym of non-commutative symmetric functions [GKL+94], whose bases are indexed by integer compositions, is obtained from the hypoplactic monoid hypo [KT97, Nov00], the monoid of quasiribbon tableaux; the Loday­Ronco Hopf algebra PBT [LR98, HNT05], whose bases are indexed by planar binary trees, is obtained from the sylvester monoid sylv [HNT05], the monoid of right strict binary search trees; the Baxter Hopf algebra Baxter [Rea05, Gir12], whose bases are indexed by Baxter permutations [Bax64], is obtained from the Baxter monoid baxt [Gir12], the monoid of pairs of twin binary search trees. These monoids satisfy identities, and the shortest identities have been characterized [CM18b]. Unlike in the case of the plactic monoid, these identities are independent of rank, except for the case of rank 1.
The identities satisfied by the hypoplactic monoid have been studied in depth by the present authors in [CMR20]. It was shown that the hypoplactic monoids of rank greater than or equal to 2 all satisfy exactly the same identities, which have been fully characterized. Furthermore, a finite basis was given for the variety generated by hypo, thus proving that it has finite axiomatic rank. Although not stated in the article, the characterization of the identities implies that Check-Id(hypo) is in the complexity class P. These results were obtained by extensively using an alternate characterization of the hypoplactic monoid using inversions, which arises as a consequence of [Nov00, Subsection 4.2].
This paper focuses on the sylvester and Baxter monoids, as well as the #sylvester monoid, whose elements are identified with left strict binary search trees and whose properties can be derived from those of the sylvester monoid by parallel reasoning. These monoids are closely related to each other (see [Gir12, Proposition 3.7]), as well as to the hypoplactic monoid (see [Pri13, CM18a]). The main goal of the paper is to present a systematic study of the identities satisfied by these monoids, in the same way as the one given for the hypoplactic monoid in [CMR20]. This paper also gives an alternate characterization of these monoids, by

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

3

introducing the concepts of right and left precedences, which serve the same purpose as inversions for the hypoplactic monoid. The authors of this paper remark that Theorem 4.16 has been proven independently in the upcoming paper [CJKM21].

2. Preliminaries and notation
This section gives the necessary background on universal algebra (see [BS81, Mal12, MMT18, Ber11]), in the context of monoids, followed by the definition and essential facts about the sylvester and Baxter monoids.
For the necessary background on semigroups and monoids, see [How95]; for presentations, see [Hig92]; for computational complexity, see [Pap94]; for a general background on the plactic monoid, see [Lot02, Chapter 5], and on the hypoplactic monoid, see [Nov00] and [CM17].
2.1. Varieties, identities and bases. The background given in this subsection is mostly identical to the one given in [CMR20, Subsection 2.1], of which this paper is a sequel. As such, we omit most of the subsection, with the following exceptions:
We define the content and support of a balanced identity as the content and support of both sides of the identity, respectively.
An equational theory  is left 1-hereditary if, for every identity u  v of  and any variable x  supp(u  v), the identity u  v is in , where u1 (respectively, v1) is the longest prefix of u (respectively, v) where x does not occur (see [Pas06, Vol01, Mas96]). We define right 1-hereditary equational theories in a dual way. The equational theory of the variety generated by the bicyclic monoid, which coincides with that of the variety generated by the plactic monoid of rank 2 (see [JK21]), is both left and right 1-hereditary (see [Shn89, Pas06]).
For a given semigroup S, its identity checking problem Check-Id(S) is the following combinatorial decision problem: the instance is an arbitrary identity u  v; the answer to such an instance is `YES', if S satisfies the identity, and `NO' otherwise. Notice that the semigroup itself is fixed, as such, it is only the identity u  v that serves as the input. Therefore, the time/space complexity of Check-Id(S) should be measured only in terms of the size of the identity. Naturally, the problem can also be considered for monoids.
2.2. The sylvester and #-sylvester monoids. This subsection gives a brief overview of the sylvester and #-sylvester monoids and their related combinatorial objects and insertion algorithms, as well as results from [CM18b]. We introduce an alternative characterization of these monoids, analogous to the one given in [Nov00] for the hypoplactic monoid, as well as some new notation. For more information on the sylvester monoid, see [HNT05] and [CM18a]; for more information on binary search trees, see [Knu70] and [AU92].
Let A = {1 < 2 < 3 < · · · } denote the set of positive integers, viewed as an infinite ordered alphabet, and let An = {1 < · · · < n} denote the set of the first n positive integers, viewed as a finite ordered alphabet. For brevity, we will write `the node a' instead of `the node labelled with a'.
A right strict binary search tree is a labelled rooted binary tree where the label of each node is greater than or equal to the label of every node in its left subtree, and strictly less than every node in its right subtree. A left strict binary search tree is a labelled rooted binary tree where the label of each node is strictly greater than the label of every node in its left subtree, and less than or equal to every node in

4

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

its right subtree. The following are examples of, respectively, right and left strict binary search trees:

4

2

5

(1)
1456

1

5

7

5

4

5

(2)

.

14

7

1

6

25

The (left-to-right) postfix (or postorder ) traversal of a labelled rooted binary search tree T is the sequence of nodes obtained by recursively performing the postfix traversal of the left subtree of the root of T , then recursively performing the postfix traversal of the right subtree of the root of T , and then adding the root of T to the sequence. The (left-to-right) postfix reading of a labelled rooted binary search tree T is the word Post(T ) obtained by listing the labels of the nodes visited during the postfix traversal. For example, the postfix reading of the tree given in Example 1 is 1142557654.
The (left-to-right) prefix (or preorder ) traversal of a labelled rooted binary search tree T is the sequence of nodes obtained by first adding the root of T to the sequence, then recursively performing the prefix traversal of the left subtree of the root of T , and then recursively performing the prefix traversal of the right subtree of the root of T . The (left-to-right) prefix reading of a labelled rooted binary search tree T is the word Pre(T ) obtained by listing the labels of the nodes visited during the prefix traversal. For example, the prefix reading of the tree given in Example 2 is 5411245765.
The infix (or inorder ) traversal of a labelled rooted binary search tree T is the sequence of nodes obtained by recursively performing the infix traversal of the left subtree of the root of T , then adding the root of T to the sequence, and then recursively performing the infix traversal of the right subtree of the root of T . The following result is immediate from the definitions of right and left strict binary search trees:
Proposition 2.1. For any right or left strict binary search tree T , if a node a is encountered before a node b in an infix traversal, then a  b.
In other words, the infix traversal visits nodes in weakly increasing order, in right or left strict binary search trees.
Let T be a right or left strict binary search tree, and let a  A be a symbol which labels a node of T . We say that a node a is topmost if all other nodes a are its descendants. The following lemma, and its consequences, will be used thoroughly in this section:
Lemma 2.2 ([CM19, Lemma 6.6]). Every node a appears on a single path descending from the root to a leaf; thus, there is a unique topmost node a.
Let T be a right or left strict binary search tree, and consider two nodes of T , respectively labelled with a and b, for some a, b  A. Consider the lowest common ancestor of nodes a and b, labelled with c, for some c  A. If the node a is in the left subtree of the node c or coincides with it, and the node b is in the right subtree of the node c or coincides with it, and the nodes a and b do not both coincide with

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

5

the node c, then we say that the node a is to the left of the node b, and the node b is to the right of the node a. It is immediate to see that a node a is to the left of a node b if and only if the infix traversal visits the node a before the node b, hence a is less than or equal to b. Furthermore, if we consider a subset of nodes of T , the definition of leftmost and rightmost nodes follows naturally.
The following algorithm allows us to insert a letter from A into an existing right strict binary search tree, as a leaf node in the unique place that maintains the property of being a right strict binary search tree:

Algorithm 1: Right strict leaf insertion. Input: A right strict binary search tree T and a symbol a  A. Output: A right strict binary search tree T  a.
1 if T is empty, then 2 create a node and label it a; 3 else 4 examine the label x of the root node; if a > x, recursively insert a into
the right subtree of the root node; otherwise recursively insert a into the left subtree of the root node;
5 return the resulting tree.

Let u  A. Using the insertion algorithm above, we can compute a unique right strict binary search tree Psylv(u) from u: we start with the empty tree and insert the letters of u, one-by-one from right-to-left. Notice that, for any right strict binary search tree T , we have that Psylv (Post(T )) = T , that is, the right strict insertion algorithm, with the postfix reading of T as input, gives back T . As such, any right strict binary search tree can be seen as an output of the right strict insertion algorithm.
We define the relation sylv on A as follows: For u, v  A,
u sylv v  Psylv(u) = Psylv(v).
This relation is a congruence on A, called the sylvester congruence. The factor monoid A/sylv is the infinite-rank sylvester monoid, denoted by sylv. The congruence sylv naturally restricts to a congruence on An, and the factor monoid An/sylv is the sylvester monoid of rank n, denoted by sylvn.
It follows from the definition of sylv that each element [u]sylv of sylv can be identified with the combinatorial object Psylv(u). As such, for each right strict binary search tree T , the set of words u  A such that Psylv(u) = T is called the sylvester class of T , and the postfix reading of T is called the canonical word of the sylvester class of T .
Recall that the content of u describes the number of occurrences of each letter of A in u. It is immediate from the definition of the sylvester monoid that if u sylv v, then c(u) = c(v). Thus, we can define the content of an element of sylv as the content of any word which represents it. Furthermore, since c(u) = c(v) implies that supp(u) = supp(v), we can also define the support of an element of sylv as the support of any word which represents it. We define the content and support of a right strict binary search tree as the content and support of its corresponding sylvester class.

6

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

Notice that sylvn is a submonoid of sylv, for each n  N, and, for n, m  N, if n  m, then sylvn is a submonoid of sylvm.
The sylvester monoid can also be defined by the presentation A | Rsylv , where
Rsylv = {(caub, acub) : a  b < c, u  A} .
These defining relations are known as the sylvester relations. A presentation for the sylvester monoid of rank n, for some n  N, can be obtained by restricting generators and relations of the above presentation to generators in An.
We now give an alternative characterization of the sylvester monoid, inspired by the characterization of the hypoplactic monoid using inversions (see [Nov00, CMR20]). Let u  A and let a, b  supp(u) be such that a < b. We say u has a b-a right precedence if, when reading u from right to left, b occurs before the first occurrence of a and, for any c  supp(u) such that a < c < b, c does not occur before the first occurrence of a. The number of occurrences of b before the first occurrence of a is the index of the right precedence.
Notice that, by the definition of a right precedence, for any given a  supp(u), there is at most one b  supp(u) such that u has a b-a right precedence (of index k, for some k  N). On the other hand, u can have several right precedences of the form b-x, for a fixed b.
Example 2.3. The word 3123 has a 2-1 and a 3-2 right precedence, both of index 1, however, it does not have a 3-1 right precedence, since 2 occurs before the first occurrence of 1; the word 2313 has a 3-1 right precedence of index 1 and a 3-2 right precedence of index 2; and the word 3132 has a 2-1 right precedence of index 1, and does not have a 3-1 right precedence.
In order to prove that the sylvester monoid can be characterized using only the content and right precedences of words, we require some lemmata:
Lemma 2.4. Let u  A, and let a, b  supp (u) be such that a < b and b occurs at least k times in u, for some k  N. Then, u has a b-a right precedence of index k if and only if the topmost node a in Psylv(u) has exactly k ancestor nodes labelled with b, and no ancestor nodes labelled with c, for any c  supp (Psylv(u)) such that a < c < b.
Proof. Suppose that u has a b-a right precedence of index k. It is clear that, as a consequence of the insertion algorithm 1, the topmost node a in Psylv(u) corresponds to the rightmost occurrence of a in u. Thus, there are exactly k symbols b inserted before a, when computing Psylv(u). Notice that, by Lemma 2.2, the corresponding nodes must be in a single path from the root to any leaf of Psylv(u). Furthermore, since no symbol c occurs before the rightmost symbol a, when reading u from rightto-left, for any a < c < b, we have that the rightmost symbol a must be inserted as a left child of a node b, in particular, the node corresponding to the k-th inserted symbol b. This is due to the fact that, during the "searching" step of the insertion algorithm, the symbol a will satisfy exactly the same criteria as the last inserted symbol b, except when checking the k-th node b. Thus, the topmost node a in Psylv(u) must have exactly k ancestor nodes labelled with b, and no ancestor nodes labelled with c.
On the other hand, suppose u is such that u sylv u. Suppose, in order to obtain a contradiction, that u does not have a b-a right precedence of index k. Then, by

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

7

the previous part of this proof, we have that Psylv(u) = Psylv(u), which contradicts our hypothesis.
It is clear, from the previous lemma, that all words in the same sylvester class must share exactly the same right precedences. However, it is not immediate that two words which share the same content and right precedences will produce exactly the same output, when considered as inputs for the insertion algorithm.
Lemma 2.5. Let T be a right strict binary search tree, and let a, b  supp(T ), with a strictly less than b, be such that the topmost node a is a left child of a node b. Then, all words in the sylvester class of T have a b-a right precedence of index k, where k is the number of ancestor nodes of the topmost node a labelled with b.
Proof. If the topmost node a had an ancestor node labelled with c, for some a < c < b, then the node a would be in the left subtree of a node c, but even more so, since the node a is a left child of the node b, then the node b would also be in the left subtree of a node c, which contradicts the hypothesis that c is strictly less than b. The result follows from Lemma 2.4.
More generally, we can also see that if a topmost node a is in the left subtree of some node b, then the words in the sylvester class of T will have a c-a right precedence, for some c  supp(T ) such that a < c  b.
Suppose u, v  A are words which share the same content, but Psylv(u) = Psylv(v). It is immediate that at least more than one different symbol must occur in u and v. Furthermore, if the roots are labelled differently, it is clear that the words in the sylvester class of the tree whose root label is higher will have a right precedence concerning the root of the other tree, while the words in the sylvester class of the tree whose root label is lower will not. Thus, we will consider that, up to a certain depth, the two trees Psylv(u) and Psylv(v) are identical.
Let Tu,v be the right strict binary search tree obtained by removing all nodes of decreasing depth in Psylv(u) and Psylv(v) until we obtain the same tree.
Lemma 2.6. Any node of Psylv(u) and Psylv(v), corresponding to a leaf of highest depth in Tu,v, has a left (respectively, right) child in Psylv(u) if and only if it has a left (respectively, right) child in Psylv(v).
Proof. Suppose, in order to obtain a contradiction, that there is a node in Psylv(u) and Psylv(v), corresponding to a leaf of highest depth in Tu,v and labelled with a, for some a  supp (Tu,v), which has a child node in Psylv(u) that does not occur in Psylv(v). Assume, without loss of generality, that it is a left child. Notice that the node a cannot be the only leaf of highest depth in Tu,v. Furthermore, this node cannot correspond to the leftmost leaf of highest depth in Tu,v, otherwise, this would imply that Psylv(u) has at least one node labelled with a symbol which either cannot occur in Psylv(v), or occurs more times in Psylv(u) than in Psylv(v), which contradicts our hypothesis that u and v share the same content.
Let b be the label of the left child of the node a, in Psylv(u); let c be the label of the node corresponding to the rightmost leaf of highest depth in Tu,v to the left of the node a; let d be the label of the lowest common ancestor of the nodes a and c. Notice that the nodes a and b are in the right subtree of the node d, hence c  d < b  a. On the other hand, the infix traversal, in Psylv(u), first visits the node c, then the node d, then the node b, and immediately afterwards the node a. Since u and v have the same content, the infix traversal, in Psylv(v), must also

8

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

first visit the node c, then all nodes labelled with b, and then the node a. As such, since in Psylv(v), the node a does not have a left child, and the node c corresponds to the rightmost leaf of highest depth in Tu,v to the left of the node a, all nodes labelled with b must be descendants of the node c. But this implies that, in Psylv(v), all nodes labelled with b are in the left subtree of the node d, hence b  d, which contradicts our hypothesis.

This lemma shows that two different right strict binary search trees are identical up to a certain depth, and the first difference between the trees, when searching in depth, is a difference between the labels of some nodes. Now, we are ready to prove the right precedence characterization of the sylvester monoid:
Proposition 2.7. For u, v  An, we have that u sylv v if and only if u and v share exactly the same content and right precedences.
Proof. We already know that if two words u and v are in the same sylvester class, then they share the same content and right precedences, by Lemma 2.4. Suppose now that u and v share the same content, but Psylv(u) = Psylv(v). Once again, consider the right strict binary search tree Tu,v, obtained by removing all nodes of decreasing depth in Psylv(u) and Psylv(v) until we obtain the same tree. By the previous lemma and our hypothesis, there must exist a node in Psylv(u) and Psylv(v), corresponding to a leaf of highest depth in Tu,v, which has a child node labelled differently in Psylv(u) than in Psylv(v).
Let a be the label of the child node in Psylv(u) and b be the label in Psylv(v). Assume, without loss of generality, that a < b. Notice that the node a in Psylv(u) must be topmost, otherwise, the node b in Psylv(v) would be in the left subtree of a node labelled with a. Let c be the label of the parent node of node a in Psylv(u) and node b in Psylv(v). Using an argument similar to the one used in the proof of Lemma 2.6, we can see that the topmost node a is also a descendant of the node c, in Psylv(v). Even more so, the topmost node a must be in the left subtree of the node b, in Psylv(v).
Suppose nodes a and b are left children. First of all, notice that a < b  c. Furthermore, by Lemma 2.5, we have that u has a c-a right precedence of index k, where k is the number of ancestor nodes of the node a labelled with c. If b is equal to c, then v either has a c-a right precedence of index strictly greater than k, or it does not have a c-a right precedence at all; otherwise, if b is strictly less than c, then v does not have a c-a right precedence.
Suppose nodes a and b are right children. If u has a d-a right precedence of index k, for some d  supp (Tu,v) and some k  N, then the node a is in the left subtree of a node d, in Psylv(u) as well as in Psylv(v), and the node b is in the left subtree of that node d in Psylv(v). If b is equal to d, then v either has a d-a right precedence of index greater than k, or it does not have a d-a right precedence at all; otherwise, if b is strictly less than d, then v does not have a d-a right precedence. On the other hand, if u does not have a d-a right precedence, for any d  supp (Tu,v), then v has a d-a right precedence, for some symbol d which is either equal to b or labels an ancestor node of the topmost node a in the left subtree of the node b, in Psylv(v).
Thus, we can conclude that if u and v share the same content, but Psylv(u) = Psylv(v), then u and v do not share the same right precedences.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

9

In light of the previous result, we say that an element [u]sylv of sylv has a b-a right precedence (of index k) if the word u itself, and hence any other word in [u]sylv, has a b-a right precedence (of index k).
The sylvester and hypoplactic monoids are closely related (see [Pri13, CM18a]). In fact, the hypoplactic monoid is a homomorphic image of the sylvester monoid. Notice that, for any right strict binary search tree with support {a1 < · · · < ak}, all words in its sylvester class have a ai+1-ai inversion if and only if a node ai+1 appears in a right subtree of a node ai. Hence, the map defined by
[u]sylv  [u]hypo,
for u  A, is a natural homomorphism of sylv into hypo, though not an embedding. Therefore, hypo is in the variety generated by sylv, and thus must satisfy all identities satisfied by sylv.
The insertion algorithm for left strict binary search trees is dual to Algorithm 1:

Algorithm 2: Input: A left strict binary search tree T and a symbol a  A. Output: A left strict binary search tree T  a.
1 if T is empty, then 2 create a node and label it a; 3 else 4 examine the label x of the root node; if a < x, recursively insert a into
the left subtree of the root node; otherwise recursively insert a into the right subtree of the root node;
5 return the resulting tree.

Let u  A. Using the insertion algorithm above, we can compute a unique left strict binary search tree Psylv# (u) from u: we start with the empty tree and insert the symbols of u, one-by-one from left-to-right. Notice that, for any left strict binary search tree T , we have that Psylv# (Pre(T )) = T , that is, the left strict insertion algorithm, with the prefix reading of T as input, gives back T . As such, any left strict binary search tree can be seen as an output of the left strict insertion algorithm.
We define the #-sylvester congruence sylv# , the infinite-rank #-sylvester monoid sylv#, the #-sylvester monoid of rank n sylv#n , and the content and support of a #-sylvester class in a similar fashion as before.
The #-sylvester monoid can also be defined by the presentation A | Rsylv# , where
Rsylv# = {(buac, buca) : a < b  c, u  A} .
These defining relations are known as the #-sylvester relations. The sylvester and #-sylvester monoids of finite rank n are anti-isomorphic: a
natural anti-isomorphism of sylvn into sylv#n arises by taking a right strict binary search tree, reflecting it about a vertical axis, and renumbering the label i of each node to n - i + 1, thus obtaining a left strict binary search tree. Similarly, we can define a natural anti-isomorphism of sylv#n into sylvn. These anti-isomorphisms allow us to easily deduce results for the #-sylvester monoid from results for the

10

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

sylvester monoids. However, notice that these natural anti-isomorphisms do not arise in the infinite rank case, as there is no natural way to renumber the labels of the nodes. In fact, we have the following:
Proposition 2.8. There is no anti-isomorphism of sylv into sylv#.
Proof. Suppose, in order to obtain a contradiction, that there exists such an antiisomorphism  : sylv  sylv#. Notice that, for any element of the form [a]sylv, where a  A, we have that | ([a]sylv)| = 1, since | ([a]sylv)| > 1 implies that
|[a]sylv| = -1 ( ([a]sylv)) > 1,
along with the fact that the identity of sylv is mapped to the identity of sylv#. Thus,  maps the sylv-classes of generators into sylv#-classes of generators.
Thus, we have that  ([1]sylv) = [x]sylv# , for some x  A. Since we are considering the infinite-rank case, there must exist b, y  A such that y > x and  ([b]sylv) = [y]sylv#. Notice that, since  maps 1 to x, then b > 1. As such, we have that b11 sylv 1b1, but on the other hand,
 ([b11]sylv) = [xxy]sylv# = [xyx]sylv# =  ([1b1]sylv) ,
which contradicts the hypothesis that  is an anti-isomorphism.
We now give an alternative characterization of the #-sylvester monoid, parallel to the one given for the sylvester monoid. Let u  A and let a, b  supp(u) be such that a < b. We say u has a a-b left precedence of index k if, when reading u from left to right, a occurs before the first occurrence of b and, for any c  supp(u) such that a < c < b, c does not occur before the first occurrence of b. The number of occurrences of a before the first occurrence of b is the index of the left precedence.
Notice that, by the definition of a left precedence, for any given b  supp(u), there is at most one a  supp(u) such that u has a a-b left precedence (of index k, for some k  N). On the other hand, u can have several left precedences of the form a-x, for a fixed a.
Example 2.9. The word 1231 has a 1-2 and a 2-3 left precedence, both of index 1, while 1312 has a 1-2 left precedence of index 2 and a 1-3 left precedence of index 1, and 3121 has a 1-2 left precedence of index 1.
The following proposition is parallel to Proposition 2.7:
Proposition 2.10. For u, v  An, we have that u sylv# v if and only if u and v share exactly the same content and left precedences.
In light of the previous result, we say that an element [u]sylv# of sylv# has a a-b left precedence (of index k) if the word u itself, and hence any other word in [u]sylv# , has a a-b left precedence (of index k).
The hypoplactic monoid is also a homomorphic image of the #-sylvester monoid. Hence, hypo is in the variety generated by sylv#, and thus must satisfy all identities satisfied by sylv#.
2.3. The Baxter monoid. This subsection gives a brief overview of the Baxter monoid and its related combinatorial object and insertion algorithm, as well as results from [CM18b]. Due to its connection with the sylvester and #-sylvester monoids, we also give an alternative characterization of this monoid, derived from

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

11

the characterization of sylv and sylv# given in the previous subsection. For more

information, see [Gir12] and [CM18a].

The canopy of a rooted binary tree T is the word over {0, 1} obtained by doing

an infix traversal of T , outputting 1 when an empty left subtree is encountered

and 0 when an empty right subtree is encountered, then omitting the first and last

symbols of the resulting word (which correspond, respectively, to the empty left

subtree of the leftmost node and the empty right subtree of the rightmost node).

A pair of twin binary search trees consist of a left strict binary search tree TL and a right strict binary search tree TR , such that TL and TR contain the same symbols, and the canopies of TL and TR are complementary, in the sense that the i-th symbol of the canopy of TL is 0 (respectively 1) if and only if the i-th symbol of the canopy of TR is 1 (respectively 0). The following is an example of a pair of twin binary search trees:





5


 4



1 4 

 

1

4




5

2

5



,



7

1 4 5 6



6

1

5

7

 

25

Let u  A. Due to [Gir12, Proposition 4.5], the pair of binary seach trees
(Psylv#(u), Psylv(u)) is a pair of twin binary search trees. As such, by defining Pbaxt(u) as this pair, we can use Algorithms 1 and 2 to compute a unique pair of twin binary search trees Pbaxt(u) from u.
We define the Baxter congruence baxt, the infinite-rank Baxter monoid baxt, the Baxter monoid of rank n baxtn, and the content and support of a Baxter class in a similar fashion as before.
The Baxter monoid can also be defined by the presentation A | Rbaxt , where

Rbaxt = {(cudavb, cuadvb) : a  b < c  d, u, v  A}  {(budavc, buadvc) : a < b  c < d, u, v  A} .

These defining relations are known as the Baxter relations.
The Baxter, sylvester and #-sylvester monoids are closely related, due to [Gir12, Proposition 3.7]: For u, v  A, we have that u baxt v if and only if u sylv v and u sylv# v. As a consequence of this, and Propositions 2.7 and 2.10, we have the following:

Corollary 2.11. For u, v  An, u baxt v if and only if u and v share exactly the same content and left and right precedences.

In light of the previous result, we say that an element [u]baxt of baxt has a b-a right (respectively, left) precedence of index k if the word u itself, and hence any other word in [u]baxt, has a b-a right (respectively, left) precedence of index k.
It is also easy to see that the maps defined by

[u]baxt  [u]sylv and [u]baxt  [u]sylv# ,
for u  A, are natural homomorphisms of baxt into sylv and sylv#, respectively (though not embeddings). Therefore, both sylv and sylv# are monoids in the variety generated by baxt, and thus must satisfy all identities satisfied by baxt.

12

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

3. Embeddings

In this section, we prove that the sylvester monoids of ranks greater than or equal to 2 satisfy exactly the same identities. We do this by constructing embeddings of sylvester monoids of any rank greater than 2 into direct products of copies of the sylvester monoid of rank 2, as it is not possible to embed one into another. Thus, they generate the same variety and, by Birkhoff's Theorem, satisfy exactly the same identities. We also show that the basis rank of the variety generated by sylv is 2.
By parallel reasoning, we prove the same results for the #-sylvester monoids of ranks greater than or equal to 2. Furthermore, as a consequence of [Gir12, Proposition 3.7], we also obtain the same results for the Baxter monoids of ranks greater than or equal to 2.

3.1. Non-existence of embedding into a monoid of lesser rank. It is not possible to embed a sylvester monoid of finite rank into a sylvester monoid of lesser rank:

Proposition 3.1. For all n > m  1, there is no embedding of sylvn into sylvm.

Proof. First of all, notice that sylv1 is isomorphic to the free monogenic monoid and sylvn is non-commutative, for any n  2. Thus, there is no embedding of sylvn into sylv1.
On the other hand, if there exists an embedding of sylvn into sylvm, for some n > m  2, then, since sylvm is a submonoid of sylvn-1, there must also exist an embedding of sylvn into sylvn-1. As such, we just need to prove that this second embedding cannot exist.
Suppose, in order to obtain a contradiction, that there exists n  3 such that we
have an embedding  : sylvn - sylvn-1. Without loss of generality, suppose n is the smallest positive integer in such conditions.

Observe that supp  [2 · · · n]sylvn = An-1, that is, the image of the product of all generators of sylvn, except for 1, has all the possible letters of An-1. Indeed, if

supp  [2 · · · n]sylvn

An-1, we would be able to construct an embedding from

the submonoid isomorphic to sylvn-1 of sylvn, generated by all generators of sylvn

except for 1, into a submonoid of sylvn-1 isomorphic to sylvn-2. This contradicts

the minimality of n.

Hence, since all letters of An-1 already occur in  [2 · · · n]sylvn , if we multiply this element by any other element of sylvn-1 to the left, we obtain an element with
the same right precedences as  [2 · · · n]sylvn . Thus, by Proposition 2.7, we have that
 [12]sylvn · [2 · · · n]sylvn =  [21]sylvn · [2 · · · n]sylvn .
On the other hand, we have that

[12]sylvn · [2 · · · n]sylvn = [21]sylvn · [2 · · · n]sylvn ,
since the left-hand side has a 2-1 right precedence of index 2, and the right-hand side has a 2-1 right precedence of index 1.
This contradicts our hypothesis that  is injective. Hence, for all n  2, there is no embedding of sylvn into sylvn-1. As such, there is no embedding of sylvn into sylvm, for n > m  2.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

13

Corollary 3.2. There is no embedding of sylv into sylvn, for any n  N.
Proof. If such an embedding existed, for some n  N, then, by restricting the embedding to the first n + 1 generators of sylv, we would obtain an embedding of sylvn+1 into sylvn, which contradicts the previous proposition.
If there existed an embedding of a #-sylvester monoid of finite rank into a #sylvester monoid of lesser rank, then we would be able to compose it with the natural anti-isomorphisms, thus obtaining an embedding for the sylvester case. Therefore, no such embedding exists, as well as no embedding of the infinite-rank #-sylvester monoid into a #-sylvester monoid of finite rank. We can also prove the corresponding result for the Baxter monoid:
Proposition 3.3. For all n > m  1, there is no embedding of baxtn into baxtm.
Proof. The proof follows the same reasoning as given in the proof of Proposition 3.1: Instead of considering the elements
[12]sylvn · [2 · · · n]sylvn and [21]sylvn · [2 · · · n]sylvn , we consider, respectively, the elements
[2 · · · n]baxtn · [12]baxtn · [2 · · · n]baxtn and [2 · · · n]baxtn · [21]baxtn · [2 · · · n]baxtn .

Corollary 3.4. There is no embedding of baxt into baxtn, for any n  N.

3.2. Embedding into a direct product of copies of monoids of rank 2. Although it is not possible to embed the sylvester, #-sylvester and Baxter monoids,
of rank greater than or equal to 2, into their corresponding monoids of rank 2, we
now show how to embed each of them into a direct product of copies of their corresponding monoid of rank 2, starting with the sylvester monoid. For simplicity, we shall denote by M k the direct product of k copies of a monoid M .
For any i, j  A, with i < j, define a map from A to sylv2 in the following way: For any a  A,

[1]sylv2  a - [2]sylv2 [21]sylv2  []sylv2

if a = i; if a = j; if i < a < j; otherwise;

and extend it to a homomorphism ij : A - sylv2, in the usual way. This homomorphism is analogous to the one given in [CMR20, Subsection 3.2]. The proofs of

the following lemmata and propositions make use of the new characterization using

right precedences for the sylvester monoid.

Notice that ij(w) is the sylvester class of the word obtained from w by replacing any occurrence of i by 1; any occurrence of j by 2; any occurrence of an a, with

i < a < j, by 21; and erasing any occurrence of any other element.

Lemma 3.5. ij factors to give a homomorphism ij : sylv - sylv2.
Proof. Since sylv is given by the presentation A | Rsylv , we just need to verify that both sides of the sylvester relations have the same image under ij .
Let a, b, c  A and u  A be such that a  b < c. If ij maps either a or c to []sylv2, then the images of caub and acub under ij coincide. Assume, without

14

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

loss of generality, that ij does not map any letter to []sylv2. Then, ij maps a to [1]sylv2 , b to either [21]sylv2 or [1]sylv2 , and c to [2]sylv2 . Notice that b is mapped to an element with no right precedences. As such, we have that
ij (caub) = ij (acub),
since both sides of the equality have no right precedences. Hence, Rsylv  ker ij.

Let w  An, for some n  3. Suppose supp (w) = {a1 < · · · < am}, for some m  N. Observe that, ranging 1  i < m, we can get from the maps aiai+1 the number of occurrences of ai and ai+1 in w, since, when reading any word in aiai+1 ([w]sylv), every occurrence of 1 corresponds exactly to an occurrence of ai in w, and every occurrence of 2 corresponds exactly to an occurrence of ai+1.
Recall that there is at most one index j, with i < j  m, such that w has a aj-ai right precedence. Ranging 1  i < j  m, we can also check if w has a aj-ai right precedence: If w does not have any b-ai right precedence, for b < aj, then no b occurs before ai, when reading w from right-to-left. As such, we have that, when reading any word in aiaj ([w]sylv) from right-to-left, the first occurrence of 1 corresponds to the first occurrence of ai, when reading w from right-to-left, and all occurrences of 2 before the first occurrence of 1 correspond to all occurrences of aj before the first occurrence of ai. Thus, aiaj ([w]sylv) has a 2-1 right precedence if and only if w has a aj-ai right precedence, and the indexes must coincide. Hence, we get the following lemma:
Lemma 3.6. Let u, v  An. Then, u sylv v if and only if ij ([u]sylv) = ij ([v]sylv), for all 1  i < j  n.
Proof. The proof of the implication is trivial, since ij is well-defined as a map, for all 1  i < j  n. The proof of the converse follows from the previous observations, as well as Proposition 2.7.
For each n  N, with n  3, let In be the index set
{(i, j) : 1  i < j  n} ,
and let I := nN In. Now, consider the map
n : sylvn - sylv2,
In
whose (i, j)-th component is given by ij ([w]sylv), for w  An and (i, j)  In.
Proposition 3.7. The map n is an embedding.
Proof. It is clear that n is a homomorphism. It follows from the definition of n and Lemma 3.6 that, for any u, v  An, we have u sylvn v if and only if n([u]sylv) = n([v]sylv), hence n is an embedding.
Thus, for each n  N, we can embed sylvn into a direct product of copies of sylv2. Similarly, we can embed sylv into a direct product of infinitely many copies of sylv2. Consider the map
 : sylv - sylv2,
I
whose (i, j)-th component is given by ij ([w]sylv), for w  A and (i, j)  I.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

15

Proposition 3.8. The map  is an embedding.
Proof. It is clear that  is a homomorphism. Notice that, for any word w  A, there must exist n  N such that w  An. Furthermore, for (i, j)  In, we have that the (i, j)-th component of ([w]sylv) is equal to the (i, j)-th component of n([w]sylv). Thus, for u, v  A, if ([u]sylv) = ([v]sylv), then n([u]sylv) = n([v]sylv), for some n  N such that u, v  An.
It follows from Lemma 3.6 that, for any u, v  A, we have u sylv v if and only if ([u]sylv) = ([v]sylv), hence  is an embedding.
As such, all sylvester monoids of rank higher than 2 are in the variety generated by sylv2. Since sylv2 is a submonoid of sylv and sylvn, for any n  3, they all generate the same variety, which we will denote by Vsylv. Thus, by Birkhoff's Theorem, we have the following result:
Theorem 3.9. For any n  2, sylv and sylvn satisfy exactly the same identities.
Another consequence of Vsylv being generated by sylv2 is the following:
Proposition 3.10. The basis rank of Vsylv is 2.
Proof. Since Vsylv is generated by sylv2, and sylv2 is defined by a presentation where the alphabet has two generators, then rb (Vsylv) is less than or equal to 2.
On the other hand, notice that any monoid generated by a single element is commutative. Since sylv is not commutative, Vsylv cannot be generated by any single monoid which is itself generated by a single element. As such, rb (Vsylv) is strictly greater than 1.
Hence, the basis rank of Vsylv is 2.
By parallel reasoning, we can also prove that the #-sylvester monoids of rank greater than or equal to 2 embed into a direct product of copies of sylv#2. For any i, j  A, with i < j, define the homomorphism #ij : A - sylv#2 in an identical fashion to ij , mapping a word to a #-sylvester class instead of a sylvester class.
As with the case of ij (see Lemma 3.5), we have that #ij factors to give a homomorphism #ij : sylv# - sylv#2. Furthermore, we can also deduce the number of occurrences of each symbol in a word w  An, for some n  3, and its left precedences, by looking at the images of [w]sylv# under #ij , ranging 1  i < j  n. Thus, for u, v  An, we have that u sylv# n v if and only if #ij ([u]sylv# ) = #ij ([v]sylv# ), for all 1  i < j  n.
For each n  N, we can embed sylv#n into a direct product of copies of sylv#2, using the embedding
#n : sylv#n - sylv#2,
In
whose (i, j)-th component is given by #ij ([w]sylv# ), for w  An and (i, j)  In. Similarly, we can embed sylv# into a direct product of infinitely many copies of sylv#2, using the embedding
# : sylv# - sylv#2,
I
whose (i, j)-th component is given by #ij ([w]sylv# ), for w  A and (i, j)  I.

16

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

As such, all #-sylvester monoids of rank higher than 2 are in the variety generated by sylv#2. Since sylv#2 is a submonoid of sylv# and sylv#n , for any n  3, they all generate the same variety, which we will denote by Vsylv# . Thus, by Birkhoff's Theorem, we have the following result:
Theorem 3.11. For any n  2, sylv# and sylv#n satisfy exactly the same identities.
The basis rank of Vsylv# is also 2. Notice that the embeddings of the #-sylvester monoids of finite rank greater than or equal to 2 into a direct product of copies of sylv#2 can also be obtained using the anti-isomorphisms between sylvester and #-sylvester monoids of finite rank, and the the previously obtained embeddings. However, we cannot use this argument for the infinite rank case, due to Proposition 2.8. On the other hand, since antiisomorphisms exist in the finite case, we can conclude that, due to Theorems 3.9 and 3.11, any monoid anti-isomorphic to sylv (respectively, sylv#) is in the variety generated by sylv# (respectively, sylv). Once again, we can also prove that the Baxter monoids of rank greater than or equal to 2 embed into a direct product of copies of baxt2. For any i, j  A, with i < j, define the homomorphism ij : A - baxt2 in an identical fashion to ij, mapping a word to a Baxter class instead of a sylvester class. As with the case of ij , we have that ij factors to give a homomorphism ij : baxt - baxt2. Furthermore, we can also deduce the number of occurrences of each symbol in a word w  An, for some n  3, and its left and right precedences, by looking at the images of [w]baxt under ij, ranging 1  i < j  n. Thus, for u, v  An, we have that u baxtn v if and only if ij([u]baxt) = ij ([v]baxt), for all 1  i < j  n. For each n  N, we can embed baxtn into a direct product of copies of baxt2, using the embedding
n : baxtn - baxt2,
In
whose (i, j)-th component is given by ij([w]baxt), for w  An and (i, j)  In. Similarly, we can embed baxt into a direct product of infinitely many copies of baxt2, using the embedding
 : baxt - baxt2,
I
whose (i, j)-th component is given by ij([w]baxt), for w  A and (i, j)  I. As such, all Baxter monoids of rank higher than 2 are in the variety generated by
baxt2. Since baxt2 is a submonoid of baxt and baxtn, for any n  3, they all generate the same variety, which we will denote by Vbaxt. Thus, by Birkhoff's Theorem, we have the following result:
Theorem 3.12. For any n  2, baxt and baxtn satisfy exactly the same identities.
The basis rank of Vbaxt is also 2.
4. Identities and bases
In this section, we obtain a complete characterization of the identities satisfied, respectively, by the sylvester, #-sylvester and Baxter monoids, finite bases for Vsylv, Vsylv# and Vbaxt, and also their axiomatic rank.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

17

4.1. Characterization of the identities satisfied by the sylvester, #-sylvester and Baxter monoids. The identities satisfied by the sylvester, #-sylvester and Baxter monoids and those satisfied by their respective monoids of rank 2 are exactly the same. As such, we shall use the monoids of rank 2 to obtain a characterization of those identities.
For a word u over an alphabet of variables X, and for variables x, y  supp(u), we denote the number of occurrences of y before the first occurrence of x in u, when reading u from right-to-left (respectively, from left-to-right), by oxy(u) (respectively, oyx(u)).
Theorem 4.1. The identities u  v satisfied by sylv are exactly the balanced identities such that, for any variables x, y  supp(u  v), oxy(u) = oxy(v).
Proof. We first prove by contradiction that an identity satisfied by sylv2 must satisfy the previously mentioned conditions. Suppose u  v is an identity satisfied by sylv2. Since sylv2 contains the free monogenic submonoid, we know that any identity satisfied by sylv2 must be a balanced identity. Thus, we assume u  v is a balanced identity.
Suppose, in order to obtain a contradiction, that there exist variables x, y  supp(u  v), such that oxy(u) = oxy(v). Then, if we consider the words u|x,y and v|x,y, obtained from u and v, respectively, by eliminating every occurrence of a variable other than x or y, we have that u|x,y admits the suffix xyoxy(u) and v|x,y admits the suffix xyoxy(v).
Taking the evaluation  of X in sylv2 such that (x) = [1]sylv2, (y) = [2]sylv2 and (z) = []sylv2, for all other variables z  X, we have
(u) =  (u|x,y) = [u]sylv2 · [12oxy(u)]sylv2 and
(v) =  (v|x,y) = [v]sylv2 · [12oxy(v)]sylv2 ,
for some words u, v  A2. Since oxy(u) = oxy(v), we have that (u) and (v) cannot share a 2-1 right precedence of the same index. Thus, by Proposition 2.7, we have that (u) = (v), which contradicts our hypothesis that u  v is an identity.
We now prove by contradiction that an identity which satisfies the previously mentioned conditions must also be satisfied by sylv2. Suppose that u  v is a balanced identity, such that, for any variables x, y  supp(u  v), oxy(u) = oxy(v). Suppose, in order to obtain a contradiction, that there is some evaluation  of X in sylv2 such that (u) = (v).
Notice that, since u  v is a balanced identity, then (u) and (v) have the same content. As such, we have that supp ((u)) = supp ((v)) = {1, 2}, and, by Proposition 2.7, either (u) and (v) have 2-1 right precedences, of different indexes, or one of them has a 2-1 right precedence and the other does not. Assume, without loss of generality, that words in (u) admit a suffix of the form 12a, and words in (v) admit a suffix of the form 12b, for some a, b  N0 such that a > b. Notice that this assumption covers both the case where (v) has a right precedence and the case where it has not. Furthermore, the assumption implies that (u) has a 2-1 right precedence of index a.
Observe that u must be of the form u = u1zu2, with z  X and u2  X, such that (u2) has support {2} and (z) has either support {1, 2} or support {1}. As such, (zu2) has a 2-1 right precedence of index a, the same as (u). Furthermore, notice that z cannot occur in u2. Thus, by our hypothesis, we have

18

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

that ozx(u) = ozx(v), for any variable x  supp(u2). Therefore, v must also be of the form v = v1zv2, where v2 has the same content as u2. But this implies that (v2) has support {2}, hence (zv2) also has a 2-1 right precedence of index a. Since (zv2) must also have the same right precedence as (v), we have reached a contradiction.
Thus, there is no evaluation  of X in sylv2 such that (u) = (v). Therefore, u  v is an identity satisfied by sylv2.
Since all identities satisfied by sylv must also be satisfied by sylv2, we obtain the stated result.
By parallel reasoning, we can obtain the characterization of the identities satisfied by the #-sylvester monoid:
Theorem 4.2. The identities u  v satisfied by sylv# are exactly the balanced identities such that, for any variables x, y  supp(u  v), oxy(u) = oxy(v).
From the previous two theorems, we can easily obtain the characterization of the identities satisfied by the Baxter monoid:
Theorem 4.3. The identities u  v satisfied by baxt are exactly the balanced identities such that, for any variables x, y  supp(u  v), oxy(u) = oxy(v) and oxy(u) = oxy(v).
Proof. Let u  v be an identity and let  be an evaluation of X in baxt. Let u, v  A be words such that (u) = [u]baxt and (v) = [v]baxt.
Notice that, by composing  with the natural homomorphisms of baxt into sylv and sylv#, we obtain evaluations 1 and 2 of X into sylv and sylv#, respectively. Furthermore, notice that 1(w) = [w]sylv and 2(w) = [w]sylv#, for w  {u, v}.
Hence, by [Gir12, Proposition 3.7], we have that (u) = (v) if and only if 1(u) = 1(v) and 2(u) = 2(v). As such, if u  v is satisfied by both sylv and sylv#, then it must also be satisfied by baxt.
On the other hand, any identity satisfied by baxt must be satisfied by both sylv and sylv#, since both these monoids are in the variety generated by baxt. Thus, the result follows as a consequence of Theorems 4.1 and 4.2.
Recall that two identities are equivalent if one can be obtained from the other by renaming variables or swapping both sides of the identities. With these characterizations, we recover the following corollaries:
Corollary 4.4 ([CM18b, Proposition 20]). The sylvester monoid satisfies the nontrivial identity xyxy  yxxy. Furthermore, up to equivalence, this is the shortest non-trivial identity satisfied by sylv.
Corollary 4.5 ([CM18b, Proposition 24]). The #-sylvester monoid satisfies the non-trivial identity yxyx  yxxy. Furthermore, up to equivalence, this is the shortest non-trivial identity satisfied by sylv#.
Corollary 4.6 ([CM18b, Proposition 26]). The Baxter monoid satisfies the nontrivial identities yxxyxy  yxyxxy and xyxyxy  xyyxxy. Furthermore, up to equivalence, these are the shortest non-trivial identities satisfied by baxt.
The following corollaries are useful alternative characterizations of the identities satisfied by sylv, sylv# and baxt. They state that, when reading both sides of an

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

19

identity satisfied by the sylvester, #-sylvester or Baxter monoid, the first occurrence of a variable is read at the same time in both words:
Corollary 4.7. The identities u  v satisfied by sylv (respectively, sylv#) are balanced identities such that, for any x  supp(u  v), the longest suffix (respectively, prefix) of u where x does not occur has the same content as the longest suffix (respectively, prefix) of v where x does not occur.
Proof. We give the proof for the sylv case. The reasoning for the sylv# case is parallel.
Let u = u1xu2 and v = v1xv2, where u2 and v2 are words where x does not occur. Notice that, due to Theorem 4.1, for any variable y which occurs in u2 or v2, we have that oxy(u) = oxy(v). The result follows immediately.

Corollary 4.8. The identities u  v satisfied by baxt are balanced identities such that, for any x  supp(u  v), the longest prefix of u where x does not occur has the same content as the longest prefix of v where x does not occur, and the longest suffix of u where x does not occur has the same content as the longest suffix of v where x does not occur.

Proof. The result follows from the previous corollary.

These alternate characterizations allow us to obtain algorithms which check if identities are satisfied by the sylvester, #-sylvester and Baxter monoids in polynomial time. For brevity's sake, we only show the algorithm for the sylvester case:

Proposition 4.9. Algorithm 3 is sound and complete, and has time complexity O(k2 log(k)), where k is the length of the word u, for input u  v.

Proof. Algorithm 3 first checks if u and v have the same length, in line 1. If they

do not, then u  v is not a balanced identity, and as such, is not satisfied by sylv.

This is done in 2k + 1 time, in the worst-case scenario where the length of v is

greater than the length of u.

The algorithm scans u and v, from right-to-left, in the `for' cycle in line 5. The

arrays C and D stand for, respectively, the content vectors of the suffixes of u and v read so far, while the word -s stands for the support of these suffixes. Notice

that, since u is of length k, then at most k variables occur in u. Hence, C and D

have length k.

In each loop of the cycle, the algorithm checks if the letter which is being read

in u is the same as the one being read in v. If they are the same, and they do not occur in -s , this means that this is the first occurrence of a variable x. The

algorithm checks if the arrays C and D are equal. If they are not, this implies that

the longest suffix of u where x does not occur does not have the same content as

the longest suffix of v where x does not occur. Hence, by Corollary 4.7, u  v is

not satisfied by sylv. If C and D are equal, then the algorithm registers the new

voaccriuarbslealirnea-dsyainnd-su,ptdhaeteaslgtohreitchomntseinmt pvleyctuoprdsaCtesanCd

D. and

On D.

the

other

hand,

if

x

If the letters which are being read in u and v are different, then the algorithm checks if they both occur in -s . If that does not happen, then that means at least

one of them is the first occurrence of a variable in one of the words, but not in the

other. Hence, by Corollary 4.7, u  v is not satisfied by sylv. Otherwise, if they both occur in -s , the algorithm simply updates C and D.

20

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

Algorithm 3: Identity checking algorithm for the sylvester monoid.
Input: An identity u  v. Output: True if sylv satisfies u  v, False otherwise.

1 if |u| = |v| then return False;

2 k  |u|;

3 C[1, . . . , k], D[1, . . . , k]  [0, . . . , 0]; 4 -s  ;

5 for 0  i  k - 1 do

6 7

if uikf-ui k=-ivk/-siutphpe(n-s ) then

8

if C = D then

9

return False;

10

else

11 12

ajppe|n-sd |u; k-i to -s ;

13

C[j]  C[j] + 1; D[j]  D[j] + 1;

14

else

15

j  index of uk-i in -s ;

16

C[j]  C[j] + 1; D[j]  D[j] + 1;

17 else

18 19 20

if

uk-i, j
l

ivinnkdd-eeixxoosffuvupkkp--i(i-siinn)-st-sh;;en

21

C[j]  C[j] + 1; D[l]  D[l] + 1;

22

else

23

return False;

24 if C = D then return False; 25 return True

It is clear that the algorithm is sound and complete, since it always detects when a new variable is read, if it is read at the same time in both u and v, and if the content of the suffixes is the same.
Taking into consideration that operations of addition and comparing numbers are logarithmic time in a Turing machine model, and that accessing coordinates of vectors is a linear-time operation, we have that comparing the content vectors C and D takes at most O (k log(k)) time, and updating them takes O (k log(k)) time as well. On the other hand, checking if a variable occurs -s takes O(k) time. As such, each loop of the for cycle has time complexity O (k log(k)). Since there are k loops of the cycle, and no other part of the algorithm takes as much time as the cycle, we can conclude that Algorithm 3 has time complexity O k2 log(k) .
Corollary 4.10. The decision problem Check-Id(sylv) belongs to the complexity class P.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

21

We can also construct an algorithm that checks if identities hold in sylv#, with time complexity O(k2 log(k)). From that algorithm and Algorithm 3, we can construct another algorithm for the Baxter case. As such, we also have the following corollary:
Corollary 4.11. The decision problems Check-Id(sylv#) and Check-Id(baxt) belong to the complexity class P.

We also easily obtain some examples of important non-trivial identities satisfied by these monoids:

Example 4.12. Consider the following non-trivial identities:

(L)

xyzxty  yxzxty;

(M)

xzxytx  xzyxtx;

(R)

xzytxy  xzytyx.

The sylvester monoid satisfies (L), but satisfies neither (M) nor (R), while the #-sylvester monoid satisfies (R), but satisfies neither (L) nor (M).
The Baxter monoid satisfies the following non-trivial identities:

(O)

xzyt xy rxsy  xzyt yx rxsy;

(E)

xzyt xy rysx  xzyt yx rysx.

The following corollaries will be important in the next subsection:

Corollary 4.13. The shortest non-trivial identities, with n variables, satisfied by sylv or by sylv#, are of length n + 2.

Proof. Since any identity satisfied by sylv must also be satisfied by hypo, and since we already know that the shortest non-trivial identity, with n variables, satisfied by hypo, is of length n + 2 (see [CMR20, Corollary 4.6]), then a non-trivial identity, with n variables, satisfied by sylv, must be of length at least n + 2.
On the other hand, by Theorem 4.1, it is immediate that
xya1 . . . an-2yx  yxa1 . . . an-2yx
is an identity satisfied by sylv, for variables x, y, a1, . . . , an-2. The reasoning for identities satisfied by sylv# is parallel to the one given previ-
ously.

Corollary 4.14. The shortest non-trivial identity, with n variables, satisfied by baxt, is of length n + 4.

Proof. It is immediate, by Theorem 4.3, that for variables x, y, a1 . . . an-2,
xy xy a1 . . . an-2yx  xy yx a1 . . . an-2yx
is an identity satisfied by baxt. On the other hand, let u  v be a non-trivial identity, with n variables, satisfied
by baxt, such that u = wxu and v = wyv, for some words w, u, v over the alphabet of variables X.
Observe that y must occur in w, otherwise, we would have oxy(u) > oxy(v). Furthermore, it must also occur in u, since u  v is a balanced identity, hence c(xu) = c(yv). Similarly, x must occur in both w and v. On the other hand, by Corollary 4.8, x must occur in u and y must occur in v, since |u| = |v|. Therefore,

22

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

x and y both occur at least three times each in u and v. Since u  v is an identity with n variables, it must be of length at least n + 4.

Finally, we can also clarify the relation between the Baxter monoids and the plactic monoids:

Corollary 4.15. The variety generated by baxt is strictly contained in the variety generated by plac2.
Proof. Let u  v be an identity satisfied by plac2. Thus, it must be a balanced identity. Let x, y  supp(u  v). Suppose, in order to obtain a contradiction, that oxy(u) > oxy(v). Let
u = u1 y u2 and v = v1 y v2,
where u1 (respectively, v1) is the longest prefix of u (respectively, v) where y does not occur. Since the equational theory of the variety generated by plac2 is left 1-hereditary, then u1  v1 must be satisfied by plac2. Hence, it must be a balanced identity. But |u1|x = oxy(u) > oxy(v) = |v1|x. We have reached a contradiction, hence, oxy(u) > oxy(v).
By this reasoning, we prove that oxy(u) = oxy(v) and oxy(u) = oxy(v). Hence, by Theorem 4.3, u  v must be satisfied by baxt.
On the other hand, it is well-known that the shortest non-trivial identity satisfied by the bicyclic monoid is Adjan's identity xyyxxyxyyx  xyyxyxxyyx (see [Adj67]). As such, plac2 does not satisfy any non-trivial identity of length less than 10. But baxt satisfies an identity of length 6, as seen in Corollary 4.6. Thus, not all identities satisfied by baxt are satisfied by plac2.
Therefore, as a consequence of Birkhoff's Theorem, the variety generated by baxt is strictly contained in the variety generated by plac2.
4.2. The axiomatic rank of the varieties generated by the sylvester, #sylvester and Baxter monoids. Now, we prove that that the varieties generated by the sylvester, #-sylvester and Baxter monoids have finite axiomatic rank and are finitely based. We give bases for Vsylv and Vsylv# with one identity each, of length 6, over a four-letter alphabet. Trivially, these bases are minimal with regards to the number of identities in the basis; they are also minimal with regards to the number of variables occurring in these identities, and the length of these identities. We also give a basis for Vbaxt, with two identities, of length 10, over a six-letter alphabet. This basis is also minimal with regards to the number of identities in the basis, the number of variables occurring in these identities, and the length of these identities.
Furthermore, we also prove that there exist no bases for Vsylv or Vsylv# with only identities over an alphabet with at most three variables, thus showing that the axiomatic rank of Vsylv and Vsylv# is 4. We also prove that there exists no basis for Vbaxt with only identities over an alphabet with at most five variables, thus showing that the axiomatic rank of Vbaxt is 6.
The following theorem has been proven by different means in the upcoming paper [CJKM21, Theorem 6.9].

Theorem 4.16. Vsylv admits a finite basis Bsylv, with the following identity:

(L)

xyzxty  yxzxty.

Proof. Let Bsylv be the set of identities which contains only the identity (L). Notice that this identity is given in Example 4.12.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

23

The following proof will be done by induction, in the following sense: We order identities by the length of the common suffix of both sides of the identity. The induction will be on the length of the prefix, that is, the length of the identity minus the length of the common suffix.
The base cases for the induction, for identities of length n (with n  4), are those identities of the form
xyw  yxw,
where w is a word of length n - 2 and x, y are variables. Observe that, since any identity u  v satisfied by sylv is a balanced identity, there are no non-trivial identities, of length n, with a common prefix of length greater than n - 2, satisfied by sylv. Furthermore, x and y must both occur in w, otherwise, we would have oxy(xyw) > oxy(yxw). Thus, w is of the form
w1xw2yw3 or w1yw2xw3,
for some words w1, w2, w3. Therefore, by replacing z with w1, and t by w2, and, if necessary, renaming x and y, we can immediately deduce this identity from the identity (L). Notice that, when n = 4, the base cases correspond to the identities given in Corollary 4.4.
The idea of the proof of the induction step is that, for any identity u  v, we can apply the identity (L), finitely many times, to deduce a new identity u  u from u  v, such that u is "closer" to v than u, in the sense that u and v have a common suffix which is strictly longer than the common suffix of u and v. Notice that u  v is a consequence of Bsylv, by the induction hypothesis. As such, we can conclude that u  v is a consequence of Bsylv.
The technical part of the proof allows us to show that there is always a way to shuffle some variables of u in such a way that we obtain u. We show that these variables must occur several times in u, thus allowing us to apply the identity (L) to shuffle u and obtain u.
By the induction hypothesis, we know that u  v is a consequence of Bsylv. Thus, we conclude that u  v is also a consequence of Bsylv.
Let u  v be a non-trivial identity satisfied by sylv and let X denote its support. Since u  v is a non-trivial identity, we must have u = uxw and v = vyw, for some words w, u, v  X  and variables x, y such that x = y. Notice that u and v cannot be the empty word, otherwise, we would have u = xw and v = yw, which contradicts the fact that c(u) = c(v).
On the other hand, since c(ux) = c(vy), we have that y occurs in u. Thus, to distinguish the rightmost y in u, we have that
ux = u1yau2,
for some variable a and words u1 and u2, such that y does not occur in u2 and a = y. Once again, since c(ux) = c(vy), we have that a occurs in v. Thus, to distinguish the rightmost a in v, we have that
v = v1av2,
for some words v1 and v2, such that a does not occur in v2. To sum up, we have that
u = u1yau2w and v = v1av2yw,
where y does not occur in u2 and a does not occur in v2.

24

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

Notice that, by Theorem 4.1, y must occur in w, otherwise, we would have oyx(u) > oyx(v). Thus, a must also occur in w, otherwise, we would have oay(u) < oay(v). As such, we can deduce the word u1ayu2w, by applying the identity (L), renaming x to a and replacing z and t by the appropriate words.
Observe that we can repeatedly apply this reasoning until we obtain a word of the form
u = uyw,
for some word u, since the only restriction imposed on the variable a was that a = y. Thus, we have proven that, for any non-trivial identity u  v satisfied by sylv, we can obtain a new word u from u such that the common suffix of u and v is strictly longer than the common suffix of u and v, by applying the identity (L) finitely many times. By the induction method, we conclude that u  v is a consequence of Bsylv, thus proving that Bsylv is a basis for Vsylv.

By the same reasoning, we can also prove the following result:

Theorem 4.17. Vsylv# admits a finite basis Bsylv# , with the following identity:

(R)

xzytxy  xzytyx.

Proof. The proof follows the same reasoning as the proof of Theorem 4.16, the main difference being that, within a set of identities of the same length, they are ordered on the length of the common prefix of both sides of the identity. Therefore, the induction is on the length of the suffix. The induction step resorts to Theorem 4.2.

We also use the same reasoning to prove the following theorem:

Theorem 4.18. Vbaxt admits a finite basis Bbaxt, with the following identities:

(O)

xzyt xy rxsy  xzyt yx rxsy;

(E)

xzyt xy rysx  xzyt yx rysx.

Proof. The proof follows the same reasoning as the proof of Theorem 4.16. As such, we only give the reasoning for the base cases and the induction step.
The base cases for the induction on the length of the prefix, for identities of length n (with n  6), are those identities of the form

xyxyw  xyyxw,

where w is a word of length n - 4 and x, y are variables. Notice that both sides of the identity must have a prefix of the form xy, due to Corollary 4.8. By the same reason, observe that, since any identity u  v satisfied by baxt is a balanced identity, there are no non-trivial identities, of length n, with a common prefix of length greater than n - 4, satisfied by baxt. Furthermore, x and y must both occur in w, otherwise, we would have oxy(xyw) > oxy(yxw). Thus, w is of the form
w1xw2yw3 or w1yw2xw3,
for some words w1, w2, w3. Therefore, by replacing z and t with the empty word, r with w1, and s by w2, and, if necessary, renaming x and y, we can immediately deduce this identity from the identity (O) or the identity (E), depending on the form of w. Notice that, when n = 6, the base cases correspond to the identities given in Corollary 4.6.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

25

Let u  v be a non-trivial identity satisfied by baxt and let X denote its support. Since u  v is a non-trivial identity, we must have u = uxw and v = vyw, for some words w, u, v  X  and variables x, y such that x = y. By Corollary 4.8, we have that x must occur at least once in u and w and at least twice in v, and y must occur at least twice in u and at least once in v and w. Thus, to distinguish the leftmost y in u, we have that
ux = u1yau2
for some variable a and words u1 and u2, such that y does not occur in u2 and a = y. Notice that y must occur in u1. Since c(ux) = c(vy), we have that a occurs in v. Thus, to distinguish the rightmost a in v, we have that
v = v1av2,
for some words v1 and v2, such that a does not occur in v2. To sum up, we have that
u = u1yau2w and v = v1av2yw, where y occurs in u1 but not in u2 and a does not occur in v2.
Suppose, in order to obtain a contradiction, that a does not occur in u1. This implies that |u|y = oya(u). But |u|y = |v|y + 1, hence
oya(v)  |v|y < |u|y = oya(u).
Thus, by Theorem 4.3, we obtain a contradiction. As such, a must occur in u1. By the same theorem, a must occur in w as well, otherwise, we would have oay(u) < oay(v). Therefore, y and a both occur at least once in u1 and w. As such, we can deduce the word u1ayu2w, by applying the identity (O) or the identity (E), depending on where y and a occur in u1 and w, renaming x to a and replacing the remaining variables by the appropriate words.
An immediate consequence of having a finite basis is the following:
Corollary 4.19. The varieties Vsylv, Vsylv# and Vbaxt have finite axiomatic rank.
By [CMR20, Proposition 4.10] and [CMR20, Proposition 4.11], we know that the identities (L) and (R) are not consequences of the set of non-trivial identities, satisfied by hypo, over an alphabet with four variables, excluding themselves and equivalent identities. Since the identities satisfied by sylv and sylv# must also be satisfied by hypo, we can conclude the following:
Corollary 4.20. The identity (L) is not a consequence of the set of non-trivial identities, satisfied by sylv, over an alphabet with four variables, excluding (L) itself and equivalent identities. Furthermore, any basis for Vsylv with only identities over an alphabet with four variables must contain the identity (L), or an equivalent identity.
Corollary 4.21. The identity (R) is not a consequence of the set of non-trivial identities, satisfied by sylv#, over an alphabet with four variables, excluding (R) itself and equivalent identities. Furthermore, any basis for Vsylv# with only identities over an alphabet with four variables must contain the identity (R), or an equivalent identity.
Hence, Vsylv and Vsylv# do not admit any bases with only identities over an alphabet with two or three variables. In other words, we have that:

26

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

Corollary 4.22. The axiomatic rank of Vsylv and Vsylv# is 4.
We now show that the identities (O) and (E) are required to be in any basis for Vbaxt which contains only identities over an alphabet with six variables:
Proposition 4.23. The identities (O) and (E) are not consequences of the set of non-trivial identities, satisfied by baxt, over an alphabet with six variables, excluding themselves (but not the other) and equivalent identities.
Proof. We prove the result for the identity (O). Parallel reasoning shows the analogous result for (E).
Let X := {x, y, z, t, r, s} and let S be the set of all non-trivial identities, satisfied by baxt, over an alphabet with six variables, excluding (O) and equivalent identities. Suppose, in order to obtain a contradiction, that (O) is a consequence of S. As such, there must exist a non-trivial identity u  v in S, and a substitution , such that
xzyt xy rxsy = w1(u)w2,
where w1, w2 are words over X, and (u) = (v). Notice that u  v must be balanced, and that there must be at least two variables occurring in u and v, otherwise, u  v would be a trivial identity.
By the same reasoning as in the proof of [CMR20, Proposition 4.10], we can assume, without loss of generality, that  does not map any variable to the empty word. Due to this, and since only x and y occur three times in xzyt xy rxsy, and all other variables each occur one time, we have that each variable occurring in u  v can occur at most three times, and only two variables can occur more than one time. Furthermore, by Corollary 4.14, which gives us a lower bound for the length of the identities, we have that u  v is of length at least 6. Notice that it is exactly of length 6 if only two variables occur in it. Thus, up to renaming of variables, x and y occur exactly thrice in u  v, and t, z, r and s can occur at most one time.
Suppose now, in order to obtain a contradiction, that w1 = . Then, since u  v is of length at least 6, we must have w1 of length at most 4, that is, w1 is either x, xz, xzy or xzyt. Therefore, x can occur only twice in (u). But x and y occur thrice in u, and  does not map any variable to the empty word, hence, there must be at least two variables which occur thrice in (u). However, only x and y occur thrice in xzyt xy rxsy. We have reached a contradiction, hence, w1 = . Using a similar argument, we can also conclude that w2 = . Therefore, we have that
xzyt xy rxsy = (u).
As such, we can immediately conclude that only up to five variables occur in u  v: If u  v were to be a six-variable identity, then it would be of length 10, and  would be simply renaming the variables, thus implying that u  v was equivalent to (O), which contradicts our hypothesis.
Notice that, regardless of the number of variables occurring in u  v, we have that both (x) and (y) are a single variable, otherwise, more than two variables would have to occur three times in xzyt xy rxsy, or one variable would have to occur six times. Furthermore, (x) and (y) can only be x or y, since these are the only variables occurring thrice in xzyt xy rxsy. Hence, if u  v is an identity where up to five variables occur, then u  v cannot be a two-variable identity, and, furthermore, there is at least one variable z occurring in u  v such that (z) is of

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

27

length at least 2, and neither x nor y can occur in (z). This is impossible, since x or y occur in every factor of xzyt xy rxsy of length 2.
As such, we can conclude that (O) is not a consequence of the set of non-trivial identities, satisfied by baxt, over an alphabet with six variables, excluding (O) itself and equivalent identities.
Therefore, we can conclude that Vbaxt does not admit any basis with only identities over an alphabet with up to five variables. In other words, we have that:
Corollary 4.24. The axiomatic rank of Vbaxt is 6. Furthermore, any basis for Vbaxt with only identities over an alphabet with six variables must contain the identities (O) and (E), or equivalent identities.

References
[Adj67] Sergei I. Adjan. 'Defining relations and algorithmic problems for groups and semigroups', Tr. Mat. Inst. Steklov 85. Am. Math. Soc.(translation), 152, 1967.
[AU92] Alfred V. Aho and Jeffrey D. Ullman. Foundations of Computer Science. Computer Science Press, Inc., USA, 1992.
[Bax64] Glen Baxter. On fixed points of the composite of commuting functions. Proc. Amer. Math. Soc., 15:851­855, 1964.
[Ber11] Clifford Bergman. Universal Algebra: Fundamentals and Selected Topics. Chapman & Hall Pure and Applied Mathematics. Taylor & Francis, 2011.
[BS81] S. Burris and H.P. Sankappanavar. A Course in Universal Algebra. Graduate Texts in Mathematics. Springer New York, 1981.
[BS17] Daniel Bump and Anne Schilling. Crystal Bases: Representations and Combinatorics. World Scientific Publishing Company Pte. Limited, 2017.
[CHK+20] Yuzhu Chen, Xun Hu, Nikita V. Kitov, Yanfeng Luo, and Mikhail V. Volkov. Identities of the kauffman monoid k3. Communications in Algebra, 48(5):1956­1968, 2020.
[CJKM21] Alan Cain, Marianne Johnson, Mark Kambites, and António Malheiro. Representations and identities of plactic-like monoids. unpublished, 2021.
[CKK+17] Alan J. Cain, Georg Klein, Lukasz Kubat, António Malheiro, and Jan. Okniski. A note on identities in plactic monoids and monoids of upper-triangular tropical matrices. ArXiv e-prints, 2017.
[CM17] Alan J. Cain and António Malheiro. Crystallizing the hypoplactic monoid: from quasiKashiwara operators to the Robinson­Schensted-type correspondence for quasi-ribbon tableaux. Journal of Algebraic Combinatorics, 45:475­524, 2017.
[CM18a] Alan J. Cain and António Malheiro. Crystals and trees: Quasi-kashiwara operators, monoids of binary trees, and robinson­schensted-type correspondences. Journal of Algebra, 502:347 ­ 381, 2018.
[CM18b] Alan J. Cain and António Malheiro. Identities in plactic, hypoplactic, sylvester, Baxter, and related monoids. Electronic Journal Of Combinatorics, 25(3), 8 2018.
[CM19] A.J. Cain and A. Malheiro. Combinatorics of cyclic shifts in plactic, hypoplactic, sylvester, baxter, and related monoids. Journal of Algebra, 535:159­224, 2019.
[CMR20] Alan J. Cain, António Malheiro, and Duarte Ribeiro. Identities and bases in the hypoplactic monoid. arXiv e-prints, page arXiv:2010.06953, October 2020.
[DHT02] Gérard Duchamp, Florent Hivert, and Jean-Yves Thibon. Noncommutative symmetric functions vi: free quasi-symmetric functions and related algebras. International Journal of Algebra and computation, 12(05):671­717, 2002.
[DJK18] Laure Daviaud, Marianne Johnson, and Mark Kambites. Identities in upper triangular tropical matrix semigroups and the bicyclic monoid. Journal of Algebra, 501:503 ­ 525, 2018.
[Ful96] William Fulton. Young Tableaux: With Applications to Representation Theory and Geometry. London Mathematical Society Student Texts. Cambridge University Press, 1996.
[Gir12] Samuele Giraudo. Algebraic and combinatorial structures on pairs of twin binary trees. Journal of Algebra, 360:115 ­ 157, 2012.

28

ALAN J. CAIN, ANTÓNIO MALHEIRO, AND DUARTE RIBEIRO

[GKL+94] Israel Gelfand, Daniel Krob, Alain Lascoux, Bernard Leclerc, Vladimir Retakh, and J. Thibon. Noncommutative symmetric functions. Adv. Math., 112, 08 1994.
[Gre06] James A. Green. Polynomial Representations of GL_n: With an Appendix on Schensted Correspondence and Littelmann Paths, volume 830. Springer, 2006.
[Hig92] Peter M. Higgins. Techniques of semigroup theory. Oxford University Press on Demand, 1992.
[HNT05] Florent Hivert, Jean-Christophe Novelli, and Jean-Yves Thibon. The algebra of binary search trees. Theoretical Computer Science, 339(1):129 ­ 165, 2005. Combinatorics on Words.
[How95] John M. Howie. Fundamentals of Semigroup Theory. LMS monographs. Clarendon Press, 1995.
[Izh19] Zur Izhakian. Tropical plactic algebra, the cloaktic monoid, and semigroup representations. Journal of Algebra, 524:290 ­ 366, 2019.
[JK21] Marianne Johnson and Mark Kambites. Tropical representations and identities of plactic monoids. Transactions of the American Mathematical Society, 374:4423­4447, 2021.
[JT19] Marianne Johnson and Ngoc Mai Tran. Geometry and algorithms for upper triangular tropical matrix identities. Journal of Algebra, 530:470­507, 2019.
[Knu70] Donald E. Knuth. Permutations, matrices, and generalized Young tableaux. Pacific J. Math., 34(3):709­727, 1970.
[KO15] Lukasz Kubat and Jan Okniski. Identities of the plactic monoid. Semigroup Forum, 90(1):100­112, February 2015.
[KS95] O. G. KHARLAMPOVICH and M. V. SAPIR. Algorithmic problems in varieties. International Journal of Algebra and Computation, 05(04n05):379­602, 1995.
[KT97] Daniel Krob and Jean-Yves Thibon. Noncommutative symmetric functions IV: Quantum linear groups and Hecke algebras at q = 0. Journal of Algebraic Combinatorics, 6(4):339­376, October 1997.
[KV20] Nikita V. Kitov and Mikhail V. Volkov. Identities of the kauffman monoid K4 and of the Jones Monoid J4, pages 156­178. Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). Springer Verlag, Germany, January 2020.
[Lot02] M. Lothaire. Algebraic Combinatorics on Words. Encyclopedia of Mathematics and its Applications. Cambridge University Press, 2002.
[LR98] Jean-Louis Loday and María O. Ronco. Hopf algebra of the planar binary trees. Advances in Mathematics, 139(2):293­309, 1998.
[LS78a] Alain Lascoux and Marcel-Paul Schützenberger. Le monoïde plaxique. Noncommutative Structures in Algebra and Geometric Combinatorics, Naples, Quad. Ricerca Sci., vol. 109:129­156, 1978.
[LS78b] Alain Lascoux and Marcel-Paul Schützenberger. Sur une conjecture de H. O. Foulkes. C. R. Acad. Sci. Paris Sér. A-B, 286(7):A323­A324, 1978.
[Mac98] Ian G. Macdonald. Symmetric Functions and Hall Polynomials. Oxford Classic Texts in the Physical Sciences. Clarendon Press, 1998.
[Mal12] Anatoly I. Mal'cev. Algebraic Systems. Grundlehren der mathematischen Wissenschaften. Springer Berlin Heidelberg, 2012.
[Mas96] G. I. Mashevitzky. On the finite basis problem for left hereditary systems of semigroup identities. In J. Almeida, P. V. Silva, and G. M. S. Gomes, editors, Semigroups, Automata and Languages, pages 167­181. World Scientific, March 1996.
[MMT18] Ralph N. McKenzie, George F. McNulty, and Walter F. Taylor. Algebras, Lattices, Varieties. AMS Chelsea Publishing. American Mathematical Society, 2018.
[MS15] Diane Maclagan and Bernd Sturmfels. Introduction to Tropical Geometry. Number 161 in Graduate Studies in Mathematics. American Mathematical Society, 2015.
[Nov00] Jean-Christophe Novelli. On the hypoplactic monoid. Discrete Mathematics, 217(1):315 ­ 336, 2000.
[Pap94] C.H. Papadimitriou. Computational Complexity. Theoretical computer science. Addison-Wesley, 1994.
[Pas06] Francis Pastijn. Polyhedral convex cones and the equational theory of the bicyclic semigroup. Journal of the Australian Mathematical Society, 81(1):63­96, 2006.

IDENTITIES AND BASES IN THE SYLVESTER AND BAXTER MONOIDS

29

[PR95] [Pri13]
[Rea05] [Sap14] [Sch61] [Sch77]
[Shn89] [Vol01]

Stéphane Poirier and Christophe Reutenauer. Algèbres de Hopf de tableaux. Ann. Sci. Math. Québec, 19(1):79­90, 1995. Jean-Baptiste Priez. Lattice of combinatorial Hopf algebras: binary trees with multiplicities. In Alain Goupil and Gilles Schaeffer, editors, 25th International Conference on Formal Power Series and Algebraic Combinatorics (FPSAC 2013), volume DMTCS Proceedings vol. AS, 25th International Conference on Formal Power Series and Algebraic Combinatorics (FPSAC 2013) of DMTCS Proceedings, pages 1137­1148, Paris, France, 2013. Discrete Mathematics and Theoretical Computer Science. Nathan Reading. Lattice congruences, fans and Hopf algebras. J. Combin. Theory Ser. A, 110(2):237­273, 2005. Mark V. Sapir. Combinatorial Algebra: Syntax and Semantics. Springer Monographs in Mathematics. Springer International Publishing, 2014. Craige Schensted. Longest increasing and decreasing subsequences. Canad. J. Math., 13:179­191, 1961. Marcel-Paul Schützenberger. La correspondance de Robinson. In Combinatoire et
représentation du groupe symétrique (Actes Table Ronde CNRS, Univ. Louis-Pasteur Strasbourg, Strasbourg, 1976), volume 579 of Lecture Notes in Math., pages 61­115. Springer-Verlag, 1977. Lev M. Shneerson. On the axiomatic rank of varieties generated by a semigroup or monoid with one defining relation. Semigroup Forum, 39(1):17­38, December 1989. Mikhail V. Volkov. The finite basis problem for finite semigroups. Sci. Math. Jpn, 53(1):171­199, January 2001.

Centro de Matemática e Aplicações, Faculdade de Ciências e Tecnologia, Universidade Nova de Lisboa, 2829­516 Caparica, Portugal
Email address: a.cain@fct.unl.pt
Departamento de Matemática & Centro de Matemática e Aplicações, Faculdade de Ciências e Tecnologia, Universidade Nova de Lisboa, 2829­516 Caparica, Portugal
Email address: ajm@fct.unl.pt
Departamento de Matemática & Centro de Matemática e Aplicações, Faculdade de Ciências e Tecnologia, Universidade Nova de Lisboa, 2829­516 Caparica, Portugal
Email address: dc.ribeiro@campus.fct.unl.pt

