arXiv:2106.00801v1 [math.NT] 1 Jun 2021

Insertion in constructed normal numbers
Verónica Becher Universidad de Buenos Aires
vbecher@dc.uba.ar
May 29, 2021
Abstract
Defined by Borel, a real number is normal to an integer base b, greater than or equal to 2, if in its base-b expansion every block of digits occurs with the same limiting frequency as every other block of the same length. We consider the problem of insertion in constructed base-b normal expansions to obtain normality to base (b + 1).
1 Problem description and statement of results
Defined by Émile Borel, a real number is normal to an integer base b, greater than or equal to 2, if in its base-b expansion every block of digits occurs with the same limiting frequency as every other block of the same length. Equivalently, a real number x is normal to base b if the fractional parts of x, bx, b2x, . . . are uniformly distributed modulo 1 in the unit interval.
There are many ways to modify normal numbers preserving normality to a given base. A major result is Wall's theorem [10] showing that the subsequences of a base-b expansion along arithmetic progressions preserve normality, crowned by Kamae and Weiss' [13] complete characterization of the subsequences that preserve normality. Other normality preserving operations are addition by some numbers [19, 1, 17], multiplication by a rational [10], transformations by some finite automata [8] and there are more.
Another form of modification transfers normality from base b to normality to base (b - 1): Vandehey [18, Theorem 1.2] proved that the subsequence of a base-b normal expansion formed by all the digits different from (b - 1) is normal to base (b - 1). This is, indeed, the removal from a normal base-b expansion of all the instances of the digit (b - 1).
Here we consider the dual, the problem of transferring normality from base b to base (b + 1).
Problem. How to insert digits along a normal base-b expansion so that the resulting expansion is normal to base (b + 1)?
There are two versions of the insertion problem:
­ when insertion liberally uses all the digits in base (b + 1),
­ when insertion is limited just to the new digit.
In the present work we tackle the two versions of the insertion problem on a class constructed normal numbers. For each version of the problem we give an effective construction that controls the distance between each occurrence of the new digit and the next. An effective construction is a prescription on how to perform the insertion while reading the input sequence from left to right.
Since we look at normality to just one base at a time, instead of fractional expansions of real numbers we deal with sequences of symbols in a given alphabet and we talk about normality to that alphabet. We state the results as transferring normality from an alphabet A to alphabet A = A  {} with  not in A.
1

For the liberal insertion problem the input is the concatenation of perfect necklaces over alphabet A of linearly increasing order and the resulting sequence is also a concatenation of perfect necklaces of linearly increasing order but over alphabet A. Perfect necklaces were introduced in [2]. They are a variant of the classical de Bruijn sequences. The concatenation of perfect necklaces of linearly increasing order is a normal sequence (this is proved in Proposition 4). We prove the following.
Theorem 1. Let alphabets A and A = A  {} with  not in A. Let v  A be a concatenation of perfect necklaces over alphabet A of linearly increasing order. Then, there is an effective construction of v  A normal to alphabet A such that v is the concatenation of perfect necklaces over A of linearly increasing order, and v is a subsequence of v. And for every integer N greater than |A|, in between the occurrences of the symbol  in v just before and just after position N there are at most 2|A| + log|A|(N ) symbols.
The one symbol insertion problem has already an adroit solution on arbitrary normal sequences, given by Zylber in [20]. However, this solution is not effective in general. It becomes effective when there is an effective upper bound for the difference between the expected --by the uniform probability distribution-- and the actual number of occurrences of any given word in any position of the input sequence.
Theorem 2 (Zylber [20, Theorem 1]). Let alphabets A and A = A  {} with  not in A. Let v  A be normal to alphabet A. Then, there exists v  A normal to alphabet A such that r(v) = v, where r is the retract that removes all the instances of the symbol .
We rework Zylber's solution on normal sequences that are concatenations of nested perfect necklaces of exponentially increasing order. One of these is the celebrated sequence defined by M. Levin [14, Theorem 2] by means of Pascal triangle matrix modulo 2, [5, Theorem 1]. If we denote with b the cardinality of alphabet A, these sequences are base-b expansions of normal numbers x for which the discrepancy of (bnx mod 1)n1 is the smallest known [14, 5]. Here we prove the following corollary of Theorem 2.
Corollary 1. Let alphabets A and A = A  {} with  not in A. Let v  A be the concatenation of nested perfect necklaces over alphabet A of order 2n, for n = 1, 2, . . .. Then, there is an effective construction of v  A normal to alphabet A such that r(v) = v, where r is the retract that removes all the instances of the symbol . And, for every N sufficiently large, in between the occurrences of the symbol  just before and just after position N there are at most |A| log|A| log|A|( N ) symbols.
The construction given in Corollary 1 can be adapted to any other input sequence equipped with an effective bound for the difference between the expected and the actual number of occurrences of any given word in any position. In the case of the concatenation of nested perfect necklaces this bound is easy to obtain and it is the smallest known.
This document is organized as follows: Section 2 presents the basics of perfect necklaces and nested perfect necklaces. Section 3 solves the liberal insertion problem on the concatenation of perfect necklaces. Section 4 solves the one-symbol insertion problem on the concatenation of nested perfect necklaces.
It remains to study how to compare the discrepancy of (bnx mod 1)n0 and the discrepancy of ((b + 1)ny mod 1)n0 where the base-(b + 1) expansion of y results from insertion in the base-b expansion of a normal number x. It may be possible to obtain metric results similar to those obtained by Fukuyama and Hiroshima [11] for subsequences of (bnx mod 1)n0.
2

2 Perfect necklaces and nested perfect necklaces
2.1 Perfect necklaces
This section is based on [2]. A word is a finite sequence of symbols in a given alphabet. For a finite alphabet A, we write |A| for its cardinality, An for the set of all words of length n, A for the set of all words and A for the set of all infinite sequences. The positions in words and in sequences are numbered starting at 1. We write v[i] for the symbol at position i and we write v[i, j] for the symbols of v from position i to position j. The length of a word v is |v.
Let  : A  A be the rotation operator, (v)[i] = v[(i+1) mod |v|]), position i between 1 and the length of v. We let n denote the application of the rotation n times. A circular word or necklace is the equivalence class of a word under rotations. To denote a necklace we write [w] where w is any of the words in the equivalence class. For instance, [000] contains a single word 000 because for every i, i(000) = 000 and [110] contains three words 0(110) = 110, 1(110) = 101 and 2(110) = 011.
Definition. A necklace is (n, k)-perfect if each word of length n occurs k many times at positions different modulo k, for any convention of the starting point.
Thus, each (n, k)-perfect necklace has length k|A|n. Perfect necklaces are a variant of de Bruijn sequences. Recall that a de Bruijn sequence of order n over alphabet A is a necklace of length |A|n and each word of length n occurs in it exactly once. Then, (n, 1)-perfect necklaces coincide with the de Bruijn sequences of order n.
For alphabet A = {0, 1} there are just two (2, 2)-perfect necklaces,
[00 01 10 11] and [00 10 01 11]
This is a (3, 3)-perfect necklace
[000 110 101 111 001 010 011 100].
The following are not (n, n)-perfect
[00 01 11 10] and [000 101 110 111 010 001 011 100].
Definition. For an alphabet A and a positive integer n, the n-ordered necklace is the concatenation of all words of length n in lexicographic order.
The following are the n-ordered necklaces over alphabet A = {0, 1} for n = 1, 2, 3,
[01], [00 01 10 11], [000 001 010 011 100 101 110 111]
Every n-ordered necklace is (n, n)-perfect. Inexplicably, this was not observed by Barbier [3, 4] nor by Champernowne [9].
Remark ([2, Theorem 5]). Identify words of length n over alphabet A with the integers 0 to |A|n - 1. Let r coprime with |A|. The concatenation of words corresponding to the arithmetic sequence 0, r, 2r, ..., (|A|n - 1)r yields a (n, n)-perfect necklace. By taking r = 1 we obtain that n-ordered necklaces are (n, n)-perfect.
Proposition 1. In the n-ordered necklace over alphabet A, for each symbol a  A, between one occurrence of  and the next there are at most n|A| - 1 symbols.
Proof. The n-ordered necklace is the concatenation of all words of length n in lexicographical order. Consider |A| + 1 many consecutive words, u1, . . . u|A|+1. Observe that the last symbol in u1 is necessarily the same as the last symbol in u|A|+1. Let a be that symbol. In between these two occurrences of a there are n|A| - 1symbols. For some choices of u1, . . . u|A|+1 these are the only two occurrences of a in these words. All the other cases yield a smaller number of symbols.
3

2.2 Perfect necklaces as Eulerian cycles in astute graphs

The (n, k)-perfect necklaces are characterized with Eulerian cycles in the so called astute graphs.

Definition. The astute graph GA(n, k) is a pair (V, E) where V = {(w, m) : w  An, m  {0, . . . k - 1}} and E = { (w, m), (w, m) : w[2..n] = w[1..n - 1], m = (m + 1) mod k}.

Thus, GA(n, k) has k|A|n vertices and k|A|n+1 edges. It is Eulerian because it is strongly regular (all vertices have in-degree and out-degree equal to |A|) and strongly connected (every
vertex is reachable from every other vertex). Notice that GA(n, 1) is the de Bruijn graph of words of length n over alphabet A.

Proposition 2 ([2, Corollary 14]). Each (n, k)-perfect necklace over alphabet A can be constructed as an Eulerian cycle in GA(n - 1, k).
In some cases several Eulerian cycles in GA(n - 1, k) yield the same (n, k)-perfect necklace, this happens when there is a period inside a cycle.

Remark ([2, Theorem 20]). The number of (n, k)-perfect necklaces over a b-symbol alphabet is

1

e(j)(k/j),

k

db,k |j |k

where - db,k = pi i, such that {pi} is the set of primes that divide both b and k, and i is the exponent of pi in the factorization of k,
- e(j) = (b!)jbn-1 b-n is the number of Eulerian cycles in GA(n - 1, j) where |A| = b,
-  is Euler's totient function, (m) counts the positive integers less than or equal to m that are relatively prime to m.

2.3 From perfect necklaces to normal sequences
For the number of occurrences of a word u in a word v at any position we write

|v|u = |{i : v[i, i + |u| - 1] = u}|.
For example |00010|00 = 3. If [v] is a (n, k)-perfect necklace over alphabet A then for every word u of length at most n,

k|A||v|-|u| - |u| + 1  |v|u  k|A||v|-|u|.

Next, we show that the concatenation of perfect necklaces of linearly increasing order is normal. To prove it we use Piatetski-Shapiro's theorem [16, 15, 7].

Proposition 3 (Piatetski-Shapiro theorem). The sequence v  A is normal to alphabet A if and

only if there is positive constant C such that for all words u,

lim sup
n

|v[1, n]|u n

< C|A|-|u|.

Proposition 4. The concatenation of (n, k)-perfect necklaces over alphabet A, for n = 1, 2, . . . and kn a linear function of n, is normal to alphabet A.

Proof. Consider the ratio between the lengths of successive of (n, kn)-perfect necklaces. Since (n, k)-perfect necklaces have length k|A|n and kn is linear function in n,

lim
n

kn+1 kn

|A|n+1 |A|n

= |A|.

4

m
Let M (m) = kn|A|n. And, for every n, let mn be such that M (mn) < n  M (mn + 1).
n=1
Then, for every u of length ,

lim sup
n

|v[1, n]|u n

<

|v[1, M (mn + 1)]|u M (mn)



|A||A|-.

Piatetski-Shapiro theorem (Proposition 3) holds with C = |A| and v is normal to alphabet A.

2.4 Nested perfect necklaces
Nested perfect necklaces were introduced in [5].
Definition. A (n, k)-perfect necklace over alphabet A is nested if n = 1 or if it is the concatenation of |A| nested (n - 1, k)-perfect necklaces.
For example, the following is a nested (2, 2)-perfect necklace over alphabet A = {0, 1},

[ 0011 0110 ]
(1,2)-perfect (1,2)-perfect
Each of these 8 are (1, 4)-perfect necklaces.

[00001111] [00111100] [00011110] [00101101]

[01011010] [01101001] [01001011] [01111000]

The concatenation in each row yields a (2, 4)-perfect necklace. The concatenation of the first two rows yields a nested (3, 4)-perfect necklace. The concatenation of the last two rows yields a nested (3, 4)-perfect necklace. The concatenation of all rows yields a nested (4, 4)-perfect necklace.
The n-ordered necklaces are perfect but not nested, for example for A = {0, 1, } and n = 2,

[ 00 01 0 10 11 1 0 1  ]
not (1,2)-perfect not (1,2)-perfect not (1,2)-perfect
Remark ([5, Theorem 2]). For each d = 0, 1, 2, . . . there are 22d+1-1 binary nested (2d, 2d)-perfect necklaces.

2.5 From nested perfect necklaces to normal sequences
By Wall's thesis [10], normal numbers are exactly those real numbers x for which (bnx mod 1)n1 is uniformly distributed, which means that the discrepancy of the first N terms

DN ((bnxn

mod 1)n0) = sup
 [0,1)

1 N

|{n



N

:

(bnx

mod 1)} < }| - 

goes to 0 as N goes to infinity. For sequences of the form (bnx mod 1)n1 the smallest known discrepancy of the first N terms is O((log N )2/N ), see [14, 7]. Expansions made of nested perfect necklaces of exponentially increasing order yield real numbers x with this property.

Proposition 5 ([5, Theorem 1]). Let b a prime number. The base-b expansion of the num-
ber defined by M.Levin using Pascal triangle matrix modulo 2 is the concatenation of nested (2d, 2d)-perfect necklaces for d = 0, 1, 2, . . .. And for every number x whose base-b expansion is the concatenation of nested (2d, 2d)-perfect necklaces for d = 0, 1, 2 . . ., DN ((bnx mod 1)n0) is O((log N )2/N ).

5

2.6 Aligned occurrences and discrete discrepancy
Given two words v and u, we write ||v||u for the number of occurrences of u at the positions of v congruent to 1 modulo the length of u, that we call aligned occurrences,

||v||u = {i : v[i, i + |u| - 1] = u and i  1 mod |u|} .
For example, ||00000||00 = 2 and ||1001||00 = 0. The relation between |v|u and ||v||u is as follows,

|u|-1

|v|u =

||v[1 + i, |v|]||u.

i=0

So, for any single symbol a,

|v|a = ||v||a.
The next proposition is immediate from the definition of nested (n, k)-perfect necklaces. The bound given in Point 3 is analog to the bound given in [14, Lemma 5].

Proposition 6. Let [v] be a (n, k)-perfect necklace over alphabet A. Then for each word u of length less than or equal to n,

1. (k/|u|)|A|n-|u| - 1  ||v||u  (k/|u|)|A|n-|u|,

2. for every i = 0, . . . |u| - 1, (k/|u|)|A|n-|u| - 2  ||v[1 + i, |v|]||u  (k/|u|)|A|n-|u|,

3. if [v] is a nested perfect and v = st where [s] and [t] are (n - 1, k)-perfect for every i = 0, . . . |u| - 1, (k/|u|)|A|n-1-|u| - 2  ||s[|s| - i + 1, |s|] t[1, |t| - i]||u  (k/|u|)|A|n-1-|u| + 1, (k/|u|)|A|n-1-|u| - 2  ||s[1 + i, |s|] t[1, i]||u  (k/|u|)|A|n-1-|u| + 1.
We define the discrete discrepancy of a word v for length , A,(v), by counting aligned occurrences.
Definition (Discrete discrepancy at aligned positions).

A,(v) = max
uA

||v||u |v|/

-

1 |A|

.

Remark. If [v] is a (n, k)-perfect necklace over alphabet A then for every length  such that   n,

A,(v)



2 |v|/

.

Proof. The length of v is k|A|n. By Point 1 of Proposition 6, for every word u of length  less than or equal to n,

A,(v) = max
uA

||v||u |v|/

-

1 |A|

 max

(k/)|A|n- k|A|n/

-

1 |A|

,

1 |A|

-

(k/)|A|n- k|A|n/

-

1



2 |v|/

.

6

Lemma 1. Let x be concatenation of nested (2d, 2d)-perfect necklaces over alphabet A for d = 0, 1, 2, . . .. Then, for every  there is N such that for every N  N,

A,(x[N, N ]) = O (log N )/N .

If   log log N then N = 1. Proof. We follow the idea in the proof of [14, Theorem 2]. We write b for the cardinality of A. Fix N and let m and M be such that 0  M < 2mb2m and

N=

m-1
2db2d
d=0

+ M.

So, N is the sum of the lengths of nested (2d, 2d)-perfect necklaces for d = 0, . . . , 2m - 1, plus M .

x[1, N ] = 20b20 | 21 b21 | . . . | 2m-1b2m-1 | M

| 2mb2m - M

N d
Let L-1 = 0 and for d = 0, .., m - 1, Ld = 2jb2j . Then, N = Lm-1 + M and for every word u,
j=0

m-1
||x[1, N ]||u = ||x[Ld-1 + 1, Ld]||u + ||x[Lm-1 + 1, N ]||u.
d=0

Since x[Lm-1 + 1, N ] is an incomplete nested perfect necklace, its discrete discrepancy determines the discrete discrepancy of x[1, N ]. Let M0 and n1, . . . n2m-1 be integers such that 0  M0 < 2m, each ni  {0, ..., b - 1} and

M = 2m

2m -1
nibi
i=0

+ M0.

So,M is the sum of the lengths of ni nested (i, 2m)-perfect necklaces for i = 0, . . . , 2m - 1 plus M0

x[Lm-1 + 1, N ] = n02mb0 | n12mb1| n22mb2| . . . | n2m-12mb2m-1 | M0

For any word u of length ,

m-1
||x[1, N ]||u = ||x[Li-1 + 1, Li]||u + ||x[Lm-1 + 1, N ]||u + , where  = 0 or  = 1
i=0
In the concatenation of nested (2d, 2d)-perfect necklaces, it is certain to find u when d  log2 . In the concatenation of nested (i, 2m)-perfect necklaces, it is certain to find u when i  . Point 1 of Proposition 6 ensures that the difference between the actual and the expected number of aligned occurrences of u in a perfect necklace of order at least  is at most 2. Then,

m-1

||x[1, N ]||u  b-/

2ib2i - O(1) + (M - M0)b-/ - O(2m)  b-N/ - O(2m)

i=

m-1

||x[1, N ]||u  Llog / + b-

2ib2i / + O(1) + M b-/ + O(2m)  b-N/ + O(2m).

i=

Since O(2m) = O(log N ) we conclude A,(x[Llog2 , N ]) = O (log N )/N . Finally notice that if   log log N then Llog2 / is O(b) = O(log N ), hence we can take N = 1.

7

3 Liberal insertion

3.1 Tools to prove Theorem 1
Consider alphabets A and A = A  {} for  not in A. Since the length and lexicographic order on words over alphabet A respects the length and lexicographic order on words over A, by inserting suitable symbols in suitable positions in each n-ordered necklace over A we obtain each n-ordered necklace over A. For example, for A = {0, 1} and A = {0, 1, },

0 1 00 01 10 11 000 001 010 011 100 101 110 111 0000 0001 ...

0 1  00 01 10 11 1 0 1  000 001 00 010 011 01 00 01 0 100 101 10 110 111 11 10 11 1 00 01 0 10 11 1 0 1  0000 0001...

Much more is true: for any (n, k)-perfect necklace over alphabet A there is an (n, k)-perfect
necklace over A such that the first is a subsequence of the second. This is immediate from the graph theoretical characterization (n, k)-perfect necklaces as Eulerian cycles on astute graphs: GA(k, n - 1) is a subgraph of GA(k, n - 1), and any cycle in an Eulerian graph can be embedded into a full Eulerian cycle. For instance, such an extension can be constructed with Hierholzer's algorithm for joining cycles together to create an Eulerian cycle of a graph. However this method does not guarantee that along the resulting (n, k)-perfect necklace, there will be a small gap between one occurrence of the symbol  and the next.
The next lemma gives method to insert symbols in a perfect necklace ensuring a small gap condition. It extends to perfect necklaces the work in [6, Theorem 1] for de Bruijn sequences.

Lemma 2 (Main lemma). Assume alphabets A and A = A  {} for  not in A. For every
(n, k)-perfect necklace [v] over alphabet A there is a (n, k)-perfect necklace [v] over alphabet A such that v is a subsequence of v. Moreover, for each such [v] there is [v] satisfying that in between one occurrence of the symbol  and the next there at most n + 2|A| - 2 other symbols.

Notice that n-ordered necklace over alphabet A fails the small gap condition required in Lemma 2. For instance, for A = {0, 1}, A = {0, 1, } and n = 2, there occurrences of  with more than n + 2|A| - 2 = 4 symbols in between:

[v] = [ 00 01 10 11 ]

[v] = [00 01 0 10 11 1 0 1 ]
5 symbols 5 symbols
However this other insertion satisfies the small gap condition:

[v] = [ 0  00 01  1 10  01  11 ].

4 symbols 3 symbols

2 symbols

2+1 symbols

Our main tool to prove the Main Lemma 2 is the factorization of the set of edges in the astute
graph GA(n, k) in convenient sets of pairwise disjoint cycles. We say that two cycles are disjoint if they have no common edges.

Proposition 7. The set of edges in GA(n, k) can be partitioned into a disjoint set of cycles identified by the necklaces of length n + 1.
Proof. Each edge in GA(n, k) is identified with a different word of length n + 1. The set of all rotations of a word of length n+1 identifies consecutive edges that form a simple cycle in GA(n, k). And each necklace of length n + 1 corresponds exactly to k disjoint simple cycles in GA(n, k), one associated to each congruence class. The partition of the set of words of length n + 1 in the equivalence classes given by their rotations determines a partition of the set of edges in GA(n, k) into disjoint simple cycles.

8

The fact that GA(n, k) is a subgraph of GA(n, k) motivates the following definition.
Definition (Augmenting graph). The augmenting graph XA(n, k) is the directed graph (V, E) where V is the set of length-n words over A and E is the set of pairs ((v, m), (w, m + 1 mod k)) such that v = au, w = ub for some word u of length n - 1 and symbols a, b in A, and either v or w have at least one occurrence of symbol .
The definition above ensures that each of the vertices in XA(n, k) that is also a vertex in GA(n, k) has exactly one incoming edge and exactly one outgoing edge. This outcoming edge is associated to new symbol . To prove the Main Lemma 2 we plan to construct an Eulerian cycle in GA(n, k) by joining the given Eulerian cycle in GA(n, k) with disjoint cycles of the augmenting graph XA(n, k) that we call petals. These petals must exhaust the augmenting graph XA(n, k). And we must insert the petals in a way that ensures the small gap condition for the symbol 
Definition (Necklaces for pairs (v, m)). We now consider necklaces consisting a word and a number that represents a congruence class. Recall that  is the rotation operation on words that shifts one position to the right. For alphabet A, words of length n and k congruence classes, if v  An and m is between 0 and k - 1,
[v, m] = (v, m), ((v), (m + 1) mod k), (2(v), (m + 2) mod k), . . . , (n(v), (m + n) mod k) ,
Definition (Graph of necklaces). We define CA(n, k) as the graph (V, E) where
V = {[v, m] : v  An, m = 0, . . . , k - 1}
E = {(x, y) : there is (au, m)  x and there is (uc, (m + 1) mod k)  y, for a, c  A}

We also define the graph CA(n, k) as the subgraph of CA(n, k) whose vertices contain at least one occurrence of the symbol .

We define a petal for each vertex in GA(n, k). A petal is a union of disjoint cycles in XA(n, k) which are identified by the necklaces of length (n+1) that have at least one occurrence of symbol .

For this identification we consider the graph CA(n + 1, k). The petal for vertex (v, m) in GA(n, k) starts at the necklace [v] in CA(n + 1, k).

Definition (Petal for vertex in GA(n, k)). A petal for vertex (v, m) in GA(n, k) is a cycle in XA(n, k) induced by a subgraph CA(n + 1, k) that contains the necklace [v, m].

To tree is

eaxhdairuesctteXdAa(cny,ckli)c

we partition graph with

it in petals. exactly one

For path

this we define from the root

a Petals to each

tree. Recall vertex. The

that a Petals

tree has

kis|Aa|nromoatntyhabtrabnrcahnecsh,eesaochutbirnanachsuibs garaPpehtaolffoCrAa(nve+rt1ex)

including (u, m) in

all its GA(n,

vertices. The k) that starts

root with

the necklace [u, m]. The Petals tree has has height n + 1, the vertices at distance d to the root

have exactly d occurrences of the new symbol , for d = 0, . . . , n + 1.

Definition (Petals tree). A Petals tree consists of all the vertices [v] in CA(n+1, k) and a root [r], which is a necklace that corresponds to an Eulerian cycle in GA(n, k). Each vertex [v], where v has exactly one occurrence of the symbol  (there are k|A|n many of them), is a child of [r]. And for t = 2, . . . , n + 1, each vertex [v], where v has exactly t occurrences of the symbol , is a child of some vertex [w] if w has exactly t - 1 occurrences of the symbol  and there is an edge
between [w] and [v] in CA(n + 1, k).
There are many Petals trees, any one is good for our purpose. A Petals tree can be obtained by any algorithm that finds a spanning tree of a graph, as Kruskal's greedy algorithm for the minimal spanning tree, or constructing one based on the classical Breath First search on CA(n + 1, k).
We now focus on how to insert the petals in the given Eulerian cycle in GA(n, k), which is a pointed cycle, this is a cycle with a specified starting edge. We need to define the sections of an Eulerian cycle in G(n, k).

9

Definition (Section of a cycle). For a pointed Eulerian cycle in GA(n, k) given by the sequence of edges e1, . . . , ek|A|n+1 and an integer j such that 0  j < k|A|n, the j-th section of the cycle is the sequence of the |A| vertices that are heads of ej|A|, . . . , ej|A|+|A|-1 .
The astute GA(n, k) has k|A|n vertices and k|A|n+1 edges. An Eulerian cycle in GA(n, k) has k|A|n sections with |A| vertices each section. Since there are the same number of vertices as sections we would like to choose one vertex from each section to place a petal. The problem is each vertex occurs |A| times in the Eulerian cycle but not necessarily at |A| different sections. We pose it as a matching problem.

Definition (Distribution graph). Given pointed Eulerian cycle in GA(n, k) the Distribution graph DA(n, k) is a |A|-regular bipartite graph, one part consists of the vertices in GA(n, k), the other part consists of the sections of the Eulerian cycle. There is an edge from a vertex v in GA(n, k) to a section j if v belongs to the section j.

A matching in a Distribution graph is a set of edges such that no two edges share a common vertex. A vertex is matched if it is an endpoint of one of the edges in the matching. A perfect matching is a matching that matches all vertices in the graph.

Proposition 8. For every Distribution graph DA(n, k) there is a perfect matching.
Proof. Let D be a finite bipartite graph consisting of two disjoint sets of vertices X and Y with edges that connect a vertex in X to a vertex in Y . For a subset W of X, let N (W ) be the set of all vertices in Y adjacent to some element in W . Hall's marriage theorem [12] states that there is a matching that entirely covers X if and only if for every subset W in X, |W |  |N (W )|. Consider a Distribution graph DA(n, k) and call X to the set of vertices GA(n, k) and Y to the set of sections. For any W  X such that |W | = r, the sum of the out-degree of these r vertices is r|A|. Given that the in-degree for any vertex in Y is |A|, we have that |N (W )|  r. Then, there is a matching that entirely covers X. Furthermore, since the number of vertices is equal to the number of sections, |X| = |Y |, the matching is perfect.

To obtain a perfect matching in a Distribution graph we can use any method to compute the maximum flow in a network. We define the flow network by adding two vertices to the Distribution graph, the source and the sink. Add an edge from the source to each vertex in X and add an edge from each vertex in Y to the sink. Assign capacity 1 to each of the edges of the flow network. The maximum flow of the network is |X|. This flow has the edges of a perfect match.
We have the needed tools for the awaiting proof.

Proof of the Main Lemma 2. To simplify the notation, assume that v is a (n + 1, k)-perfect

necklace over alphabet A. We construct a (n + 1, k)-perfect necklace v over alphabet A. Based on

Proposition 2, we cycle in GA(n, k)

need for v

to construct an Eulerian cycle in and divide it in k|A|n sections.

GA(n, k). Consider a pointed Eulerian From Proposition 8 we know that we

can choose one vertex in each section according to a perfect matching. Fix a Petals tree. The

construction considers all the sections, one after the other, starting at section 0. The construction

starts at the vertex that is the head of the first edge of section 0. Let (u, m) be the current vertex.

Case (u, m) is a vertex in GA(n, k): If (u, m) is the chosen vertex in the current section and the petal for (u, m), which starts with [u, m], has not been inserted yet then insert it now: traverse

the edge that adds the symbol  and continue traversing the petal for (u, m). If the petal for

(u, m) has already been inserted or (u, m) is not a chosen vertex then continue with the traversal

of edges in the current section.

Case (u, m) is not a vertex in GA(n, k): If the necklace [u, m] is a child of the current vertex in the Petals tree and it has not been traversed yet, then traverse it. Otherwise continue with the

traversal of the petal that (u, m) was already part of.

Finally, we prove that the construction of satisfies the minimal gap condition. Since we

assumed [v] is a (n + 1, k)-perfect necklace and we must prove that in between any occurrence of 

and the next in [v] there are at most (n + 1) + 2|A| - 2 = n + 2|A| - 1 symbols.

10

Consider the petals for the vertices in GA(k, n). Before the insertion of petals in sections, each section has no occurrence of the symbol . Since each section has |A| edges, if we place one petal in each section then two consecutive petals are at most 2|A| - 1 edges away. A petal for a vertex (u, m) in GA(n, k) starts with the edge that adds the symbol  right after u. In case the petal is just the single vertex [u, m] in CA(n + 1, k), then it is a cycle of exactly n + 1 edges. So, in between the occurrence of  in the first petal and the occurrence of  in the second there are at most n + 2|A| - 1 other symbols. In case the petal traverses more than one vertex in CA(n + 1, k) then, before completing the traversal of the (n + 1) edges in [u, m], the path branches out to another vertex in CA(n + 1, k). This is possible only by adding the symbol . In the traversal to other vertices in CA(n + 1, k) it also happens that before traversing n + 1 consecutive edges there is necessarily one edge that adds the symbol . We conclude that in between any occurrence of  and the next there are at most n + 2|A| - 1 other symbols.
Example. Consider A = {0, 1} and A = {0, 1, }. Let [v] the n-ordered necklace for n = 2
[v] = [00 01 10 11]
Fix an Eulerian cycle for [v] in GA(1, 2). Since GA(1, 2) has 4 vertices, divide it in 4 sections: Section 0 contains the vertices (0, 0) and (0, 1) Section 1 contains the vertices (0, 0) and (1, 1). Section 2 contains the vertices (1, 0) and (0, 1). Section 3 contains the vertices (1, 0) and (1, 1).
The following choice gives a perfect match: Section 0 : (0, 0), Section 1 : (1, 1), Section 2 : (0, 1), Section 4 : (1, 0).
Consider the following Petals tree with root [r] = [00011011],
[r]

[0, 0]

[0, 1]

[1, 0]

[1, 1]

[, 0]

[, 1]

The Petals tree has 4 branches, each one is a petal for a vertex in GA(1, 2):
1. The first branch is a petal for (0, 0), It results in the sequence 0 to be inserted (right after the 0 that appears at an even position).
2. The second branch is a petal for (0, 1). It is the join of two vertices in the tree, which results in the sequence 0 to be inserted (right after the 0 that appears at an odd position).
3. The third branch is a petal for (1, 0). It results in the sequence 1 to be inserted (right after the 1 that appears at an even position).
4. The fourth branch is a petal for (1, 1). It results in the sequence 1 to be inserted (right after the 1 that appears at an odd position).
The construction traverses the Eulerian cycle for [v] in GA(n, k) and, in each section it inserts the petal for the chosen vertex, immediately after it. The result is (3, 2)-perfect necklace [v] over alphabet A. It satisfies the small gap condition, because between any occurrence of  and the next there are at most 4 other symbols, which is less that the allowed n + 2|A| - 1 = 2 + 4 - 1 = 5 symbols. The inserted symbols apear in red:
[v] = [0 00 01 1 10  01  11].

11

3.2 Proof of Theorem 1
Suppose v  A is the concatenation of (n, kn)-perfect necklaces over alphabet A, for n = 1, 2, . . . and kn linear in n. Apply the Main Lemma 2 to each of these (n, kn)-perfect necklaces over alphabet A and obtain (n, kn)-perfect necklaces over alphabet A. By Proposition 4, their concatenation is normal to alphabet A.
Recall that the length of a (n, kn)-perfect necklace over alphabet A is kn|A|n, Fix an positive integer N . Let m be the largest integer such that

m-1

m

ki|A|i < N  ki|A|i.

i=1

i=1

Therefore, |A|m < N, hence, m  log|A| N. Consider the possibilities for the occurrences of  in v just before and just after position N .
We need to analyze two cases. Case they are both inside the same (m, km)-perfect necklace. The Main Lemma 2 proved that
the number of symbols in between is less than m + 2|A|. Case they are not in same perfect necklace. Notice that in the proof of the Main Lemma 2
the Eulerian cycle over alphabet A is divided in sections of size |A|, independently of the value
of n and k. Assume that N is in the (m, k)-perfect necklace over A|. First suppose that the occurrence before position N is in the (m - 1, km-1)-perfect necklace. Then, necessarily,  occurs
in the last |A| + m symbols of the (m - 1, km-1)-perfect necklace over A and the next occurrence
of  is in the fist |A| + 1 symbols of the (m, km)-perfect necklace over A. Thus, in between these two occurrences of  there are at most 2|A| + m - 1 symbols. Now suppose that the occurrence after position N is in the (m + 1, km+1)-perfect necklace. Then, there is an occurrence of  in the
last |A| + m + 1 symbols of (m, k)-perfect necklace over A and the next occurrence of  is in the
first |A| + 1 symbols of the (m + 1, km+1)-perfect necklace over A. Therefore, in between the two occurrences of  are at most 2|A| + m symbols.
Since m  logA N , we conclude that for every N the number of symbols in between these occurrences of  before an after position N is at most log|A| N + 2|A. This concludes the proof of Theorem 1.

4 One symbol insertion

4.1 Tools to prove Corollary 1
Consider alphabets A and A = A  {} with  not in A. Given a normal sequence v over alphabet A that is the concatenation of nested perfect necklaces of exponentially increasing order we use Zylber's method to transform it into a normal sequence v over alphabet A. The method inserts the symbol  in the positions prescribed by a reference sequence over alphabet A, made of a concatenation of n-ordered perfect necklaces, for n non-decreasing.
We follow the presentation in [20] deviating only when there are differences. The construction could have been be tuned for other input sequences and for other prescription sequences.
Definition (wildcard morhpism). The wildcard function  : A  {, } is such that for a  A,

(a) =

, ,

if a =  otherwise

Abusing notation we also define  : (A)  {, } and  : (A)  {, } to denote the morphism that replaces in a given word in A all the symbols different from  with a wildcard .

12

For example, for A = {0, 1} and A = {0, 1, },

(n, n)-perfect 00 01 0 10 11

1

0 1 

wildcards

        

arbitrary insertion

a1a2 a3a4 a5a6 a7a8 a9a10 a11a12 a1a2 a3a4 a5 a6a7 a8a9 a10  a11 a12 

Definition (expansion en of order n). For n  1 let n be the n-orderered necklace over alphabet A. Let n = |n| and n = ||(n)||. The expansion of order n is the map en : An  An such that for v  An ,

(en(v))[i] =

, v[m(n, i)],

if (n)[i] =  otherwise

where m(n, i) = ||(n)[1, i]|| is the number of wildcards up to the i-th symbol in (n). We define the expansion on words in (An ) by concatenation of application of expansion en.
Observe that en : An  An is an injective map. A subsequence of a word v is a word v[i1]v[i2] . . . v[ik] for some indices i1, i2, . . . , ik with i1 < i2 < . . . < ik  |v|. Clearly, v is a subsequence of en(v) and the only digits that are not part of that subsequence are all 's.
Proposition 9. For every n, n = n(|A|)n and n = n|A||A|n-1.
Proof. Since there are (|A|)n different words of length n over alphabet A then n = n|A|n. Since each symbol appears the same number of times in n then ||n|| = n|A|n-1. Thus,
n = |n| - ||n|| = n|A|n - n|A|n-1 = n|A||A|n-1.

We define the retraction as the map that removes the symbol .
Definition (retraction). We write  for the empty word. Let r : A  A  {} be the map such that if a  A then r(a) = a and r() = . The function r extends to A and A as the morphism that removes the symbol  from a given word.
For example, r(01110) = 01110. Clearly, for all n, r  en = id.
We write ½ for the indicator function of the diagonal elements of  × ,

½(x = y) =

1, 0,

if x = y otherwise

Proposition 10 ([20, Lemma 12]). For v  An,

||en(u)||v = |A|n .

uAn

Proof. This is the proof given in [20, Lemma 12]. It is included here to help the refereeing process,
it is not meant to appear in the final version of this paper. By definition of aligned occurrences, for any u  An and v  An,

|u|/n-1

||en(u)||v =

½ en(u)[in + 1, in + n] = v

i=0

13

Given x, y  A, x = y if and only if (x) = (y) and r(x) = r(y). Then, ||en(u)||v is equal to

|u|/n-1
½ (en(u)[in + 1, in + n]) = (v) ½ r(en(u)[in + 1, in + n]) = r(v) .
i=0
From the definition of (.) we have

(4.1)

(en(u)[in + 1, in + n]) = (en(u))[in + 1, in + n] = (n)[in + 1, in + n]. Since for any x  {, }n, ||(n)||x = |A|||x|| we have
||(n)||(v) = |A|||(v)|| = |A||v|-||v|| . This means that there are exactly |A||v|-||v|| terms of the sum in which

½ (en(u)[in + 1, in + n]) = (v) = 1.

Let I be the set of indexes where the first term of the product of equation (4.1) does not vanish,
I = 0  i < n/n : ½ (n)[in + 1, in + n] = (v) = 1 .
Notice that I does not depend on u. Analyzing the second term of the product of equation (4.1), we observe that
½ r(en(u)[in + 1, in + n]) = r(v) = ½ u[m(n, in) + 1, m(n, in + n)] = r(v) .

Applying this we simplify (4.1) to

||en(u)||v = ½ u[m(n, in) + 1, m(n, in + n)] = r(v) .
iI

(4.2)

Let m(n, i) = ||(n)[1, i]||. For i  I we have that (en(u)[in + 1, in + n]) = (v), which implies that

|u[m(n, in) + 1, m(n, in + n)]| = |r(en(u)[in + 1, in + n])| = |r(v)|. Summing (4.2) over all u  An we get

||en(u)||v =

½(u[m(n, in) + 1, m(n, in + n)] = r(v)).

uAn

uAn iI

Clearly, if x  n, m > n and 0  i  m - n, then

½ y[i + 1, i + n] = x = ||m-n.
ym
Then,

||en(u)||v =

|A|n-|r(v)| = |A||v|-||v|| |A|n-|r(v)|.

uAn

iI

By definition of r, |r(v)| = |v| - ||v||, which gives us the desired result

||en(u)||v = |A|n .

uAn

14

4.1.1 On discrete discrepancies at aligned positions
Consider the discrete discrepancy for words for a given length introduced in Section 2.6. We are interested in bounding the discrete discrepancy of the words after an expansion in terms of their discrete discrepancy before the expansion.
Lemma 3 (Main Lemma, [20, Lemma 14]). For every positive integer n for every positive  and for every word v  (An ),

if A,n (v) <  then A,n(en(v)) < cn,

where

cn

=

|A|n |A|n

.

Proof of Lemma 3. This is the proof given in [20, Lemma 14]. It is included here to help the
refereeing process, it is not meant to appear in the final version of this paper. Let z  An be any word, then

||en(v)||z =

||en (v)||u ||u||z .

uAn

By the definition of en, the blocks of length n of en(v) are of the form en(vi) for some vi  An . Then, the only non-zero terms of the sum can be the ones where u is in the image of en, and since en is injective we can change the sum to iterate over the en(u) for u  An . It follows that

||en(v)||z =

||en (v)||en (u) ||en (u)||z .

uAn

Observe that if y  An and x  (An ) then ||x||y = ||en(x)||en(y). Then,

||en(v)||z =

||v||u ||en (u)||z .

uAn

Assume A,n(v) < . Then

||en(v)||z <

|v| |u|

uAn

1 |A||u|

+



||en(u)||z

=

|v| n

1 |A|n

+







||en(u)||z .

uAn

Using Proposition 10 we get

||en(v)||z

<

|v| n

1 bn

+

|A|n = |v| n

1 + |A|n  .

Multiplying by |z| = n on both sides we obtain |en(v)| |en(v)|

|z| |en(v)|

||en

(v)||z

<

n|v| n|en(v)|

1 + |A|n 

.

Since v  (An ) we can write v as

(4.3)

v = v1v2 . . . vt where each vi satisfies |vi| = n. Then |v| = tn and
en(v) = en(v1)en(v2) . . . en(vt)

15

where |en(vi)| = n for all 1  i  t. So, |en(v)| = tn. Using this on (4.3) we get

|z| |en(v)|

||en

(v)||z

<

ntn ntn

1 + |A|n 

using Proposition 9 we can replace the value of n and get

|z| |en(v)|

||en

(v)||z

<

n n|A|n

1 + |A|n 

= 1 + |A|n . |A|n |A|n

By a similar argument we get the inequality

|z| |en(v)|

||en

(v)||z

>

1 |A|n

-

|A|n |A|n

.

These two inequalities imply that

A,n(en(v))

<

|A|n |A|n

.

The

desired

result

follows

taking

cn

=

|A|n |A|n

.

To prove Corollary 1 we shall drop the comfortable aligned condition and we shall count occurrences of words word at arbitrary positions. The next two propositions consider any word v over an alphabet  (not necessarily related to a nested perfect necklace).

Proposition 11. Let  be an alphabet and let m, n be positive integers. For each word v  (mn) and a positive ,

if ,mn(v) <  then,n(v) < ||(m-1)n. Proof. Let w  n. We have that

||v||w =

||v||u ||u||w .

umn

Assume ,mn(v) < . Then,

||v||w <

|v| |u|

1 ||mn

+

||u||w .

umn

|y|/n-1

Using that for x  (n) and y  n, ||x||y =

½ x[in + 1, in + n] = y

i=0
where ½(x = y) is the indicator that x is equal to y,

||v||w

<

|v| mn

1 ||mn

+



m
½(u[in + 1, in + n] = v).

umn i=0

By elementary combinatorics,

||v||w

<

|v| mn

1 ||mn

+



m

||mn-n =

|v| n

1 ||n

+ ||(m-1)n

.

i=0

16

Proposition 12. Let  be an alphabet, let n, m be positive integers with m < n, let u  (n) and let v  m.

If ,n(u) <  then |u|v < |u|

m- n

1

+

1 ||m

+

||n

- (m - 1).

Proof. For every pair of consecutive blocks of length n in u there are exactly m - 1 words of length m that are not fully contained in one of these blocks. Since there are |u|/n blocks of length n in u, there are (|u|/n - 1)(m - 1) words of length m not fully contained in one of the blocks. This gives us the following bound on the number of occurrences of v in u:

|u|/n-1

|u|v  (|u|/n - 1)(m - 1) +

|u[in + 1, in + n]|v

i=0

= (|u|/n - 1)(m - 1) +

||u||w |w|v .

wn

Assume ,n(u) < . Then,

|u|v < (|u|/n - 1)(m - 1) +

|u| |v|

1 ||n

+



|w|v .

wn

|x|-|y|

Writing ½(x = y) for the indicator that x is equal to y, and using that |x|y =

½(x[i, i+|y|] = y)

we get,

i=1

|u|v

<

(|u|/n

-

1)(m

-

1)

+

|u| |v|

1 ||n

+

n-m
½(w[i, i + |v|] = v).

wn i=1

By elementary combinatorics

|u|v

<

(|u|/n

-

1)(m

-

1)

+

|u| |v|

which is equivalent to

1 ||n

+

n-m
||n-mm

i=1

|u|v

<

(|u|/n

-

1)(m

-

1)

+

|u| n

1 ||m

+ ||n-m

(n - m).

Since m < n we obtain

|u|v < |u|

m-1 n

+

1 ||m

+ ||n

- (m - 1),

as desired.

4.2 Proof of Corollay 1
Let v  A be the concatenation of nested perfect necklaces over alphabet A of exponentially increasing order. By Lemma 5 v is normal to alphabet A. We adapt the proof of [20, Theorem 1] to the estimates that arise from nested perfect necklaces.

17

First, we define v  A. We first split v in words v1, v2, . . . such that for every k, the

concatenation v1v2 . . . vk is a prefix of v. Recall that n is the n-ordered necklace over alphabet A,

and n =

||n||a.

aA,a=
By Proposition 9, n = n|A||A|n-1. Define L0 = 0 and for n  1,

tn = |A|2n+1 |A|2n+1 Ln = Ln-1 + tn2n vn = v[Ln-1 + 1, Ln]

So, v1v2 . . . vn = v[1, Ln], |vn| = tn2n and

2n+1  log |vn|. Define v  A as

v = e21 (v1)e22 (v2) . . . e2i (vi) . . . Since each vi has length ti2i which is multiple of 2i, v is well defined. It follows that
r(v) = r(e21 (v1))r(e22 (v2)) . . . r(e2i (vi)) . . . = v. Second, we prove that v is normal to alphabet A. We can write each vn as

vn = vn,1vn,2 . . . vn,tn where each vn,i satisfies |vn,i| = 2n. Fix n and j with 0  j  tn+1 and define vn +1 as the prefix of vn+1 that consists of the first j blocks of length 2n+1,

vn +1 = vn+1,1vn+1,2 . . . vn+1,j

Since v is the concatenation of nested (2d, 2d)-perfect necklaces, for d = 0, 1, 2, . . ., by the proof of Lemma 1, for every s and for every N large enough we have A,(v[Ns, N ]) = O(s(log N )/N ), where Ns is the sum of the lengths of the nested (2d, 2d)-perfect necklaces for d < s. Then, for

n

=

1 , tn

there is n0 such that for every n  n0 and for every s  2n+1,

A,s(vn) < n,

(4.4)

because

A,s(vn) = O

s log(|vn|) |vn|

=O

2n+1 log2(tn2n ) tn 2n

<O

2|A|2n log2(tn2n ) tn

<

1 tn

=

n.

Using that v is nested perfect,

A,2n+1 (vn +1) < n,
applying the Main Lemma 3 to (4.4) and (4.5) we obtain, for cs = |A|s /|A|s,
A,2n (e2n (vn)) < c2n n A,2n+1 (e2n+1 (vn +1)) < c2n+1 n,

(4.5)
(4.6) (4.7)

18

By Proposition 11 applied to (4.7),

A,2n (e2n+1 (vn +1)) < |A|2n c2n+1 n.

Since

1 c2n n < |A|2n+n

and

|A|2n c2n+1 n

<

1 |A|2n+n

we join (4.6) and (4.8) and obtain,

A,2n (e2n (vn)e2n+1 (vn +1))

<

1 .
|A|2n+n

(4.8) (4.9)

Now, fix a word u over alphabet A. For n and j such that 0  j  tn define

Ln,j = |v1v2 . . . vnvn+1,1vn+1,2 . . . vn+1,j |.

Notice that Ln,tn = Ln+1,0. We define L0,0 = 0. Consider a position N with N > L1,0. Then, there exists n, j, with n > 1, such that

Ln,j-1  N  Ln,j.

We bound the number of occurrences of u in v[1, N ],

|v[1, N ]|u  |v[1, Ln,j]|u 

n-1
|e2i (vi)|u
i=1

+ |e2n (vn)e2n+1(vn+1,1) . . . e2n+1(vn+1,j )|u + (n - 1)(|u| - 1).

Using (4.9) for each term of the sum and applying Proposition 12 ,

(4.10) (4.11)

n-1

n-1

|e2i (vi)|u  |e2i (vi)|

i=1

i=1

|u| - 2i

1

+

1 |A||u|

+

|A|2i |A|2i +i

Noticing

that

|u| - 1 2i

+

1 i

tends

to

0

as

i

goes

to



there

exists

i0

such

that

for

all

i

> i0

|u| - 2i

1

+

1 i



1. |A||u|

Let

i0
 = |e2i (vi)|
i=1

|u| - 2i

1

+

1 |A||u|

+

1 i

and notice that  does not depend on N . If N is sufficiently large then n > i0 and

n-1
|e2i (vi)|u
i=1





+

n-1 i=i0 +1

|e2i

(vi

)|

1 |A||u|+i





+

2 |A||u|

n-1
|e2i (vi)|
i=i0 +1

2   + (Ln-1,0 - Li0,0) |A||u|

the last inequality uses |e2i (vi)| = Li,0 - Li-1,0. From (4.9) and using Proposition 12,

|u| - 1 1

|A|2n

|e2n (vn)e2n+1 (vn+1,1) . . . e2n+1 (vn+1,j )|u  (Ln,j - Ln-1,0)

2n

+

+

|A||u| |A|2n+n

.

19

Then, using n > i0 we have,

|v[1,

N ]|u





+

(Ln,j

-

Li0

,0

)

2 |A||u|

.

By (4.10), Ln,j - N  Ln,j - Ln,j-1 = 2n+1. By construction, 2n+1  |vn|, so 2n+1  |e2n (vn)|  N . Thus, Ln,j  2N . We obtain,

|v[1, N ]|u N



 N

+

2N

- Li0,0 N

2 |A||u|

<

 N

+

4. |A||u|

Since  does not depend on N ,

lim sup
N 

|v[1, N ]|u N



4. |A||u|

This bound is valid for all u  A. Therefore, using Piatetski-Shapiro theorem (Proposition 3) with C = 4 follows that v is normal.

Finally, we bound the distance between the occurrences of  just before and just after position N . The positions of  in v coincide with the positions of  in the 2i-ordered perfect necklaces used to define v as a sequence of expansions e21(v1)e22 (v2)e23(v3) . . . Proposition 1 proves that in the n-
ordered necklace over alphabet A the number of symbols in between one occurrence of the symbol  and the next is less than |A|n. Consider a position N . Observe that for M = log2 log|A| log|A| N , we have

M

M

N < |e2i (vi)| = ti2i

i=1

i=1

where ti = |A|2i+1 |A|2i+1 and 2i = 2i|A||A|2i-1. This means that at position N of v the

construction has put expansion e2m with m strictly smaller than M . There are two possibilities:

either both occurrences of  occur in the same expansion e2m; or they occur in consecutive

expansions. In less than |A|2M

both cases the number of symbols between an occurrence of  = |A| log|A| log|A| N . This completes the proof of Corollary 1.

and

the

next

is

References
[1] C. Aistleitner. On modifying normal numbers. Uniform Distribution Theory, 6(2):49­58, 2011.
[2] N. Álvarez, V. Becher, P. Ferrari, and S. Yuhjtman. Perfect necklaces. Advances in Applied Mathematics, 80:48 ­ 61, 2016.
[3] É. Barbier. On suppose écrite la suite naturelle des nombres; quel est le (1010000)ième chiffre écrit?'. Comptes Rendus des Séances de l'Académie des Sciences Paris, 105:1238­1239, 1887.
[4] É. Barbier. On suppose écrite la suite naturelle des nombres; quel est le (101000)ième chiffre écrit? Comptes Rendus des Séances de l'Académie des Sciences Paris, 105:795­798, 1887.
[5] V. Becher and O. Carton. Normal numbers and nested perfect necklaces. Journal of Complexity, 54:101403, 2019.
[6] V. Becher and L. Cortés. Extending de Bruijn sequences to larger alphabets. Information Processing Letters, 168:106085, 2021.

20

[7] Y. Bugeaud. Distribution modulo one and Diophantine approximation, volume 193 of Cambridge Tracts in Mathematics. Cambridge University Press, Cambridge, 2012.
[8] O. Carton and E. Orduna. Preservation of normality by transducers. Information and Computation, 104650, 2020.
[9] D. Champernowne. The construction of decimals normal in the scale of ten. Journal of London Mathematical Society, s1-8(4):254­260, 1933.
[10] D.D.Wall. Normal numbers. PhD thesis, University of California Berkeley, 1949. Ph.D.Thesis. [11] K. Fukuyama. The law of the iterated logarithm for discrepancies of {nx}. Acta Mathematica
Hungarica, 118(1):155­170, 2008. [12] Ph. Hall. On representatives of subsets. Journal of the London Mathematical Society, 10,
1935. [13] T. Kamae and B. Weiss. Normal numbers and selection rules. Israel Journal of Mathematics,
21(2):101­110, 1975. [14] M. B. Levin. On the discrepancy estimate of normal numbers. Acta Arithmetica, 88(2):99­111,
1999. [15] N. G. Moshchevitin and I. D. Shkredov. On the pyatetskii-shapiro criterion of normality.
Mathematical Notes, 73(3):539­550, 2003. [16] I. I. Piatetski-Shapiro. On the law of distribution of the fractional parts of the exponential
function. Izv. Akad. Nauk SSSR Ser. Mat. [Math. USSR-Izv.], 15(1):47­52, 1951. [17] G. Rauzy. Nombres normaux et processus déterministes. Acta Arithmetica, 29(3):211­225,
1976. [18] J. Vandehey. Uncanny subsequence selections that generate normal numbers. Uniform
Distribution Theory, 12(2):65­75, 2017. [19] B. Volkmann. On modifying constructed normal numbers. Annales de la Faculté des sciences
de Toulouse: Mathématique, 1(3):269­285, 1979. [20] A. Zylber. From randomness with two symbols to randomness with three symbols. Submitted
to this volume of Uniform Distribution. Also Tesis de Licenciatura en Ciencias de la Computación. Facultad de Ciencias Exactas y Naturales, Universidad de Buenos Aires. November 2017, 2021.
Verónica Becher Departmento de Computación, Facultad de Ciencias Exactas y Naturales Universidad de Buenos Aires & ICC CONICET Pabellón I, Ciudad Universitaria, 1428 Buenos Aires, Argentina vbecher@dc.uba.ar
21

Insertion in constructed normal numbers
Verónica Becher May 29, 2021

Contents

1 Problem description and statement of results

1

2 Perfect necklaces and nested perfect necklaces

3

2.1 Perfect necklaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

2.2 Perfect necklaces as Eulerian cycles in astute graphs . . . . . . . . . . . . . . . . . 4

2.3 From perfect necklaces to normal sequences . . . . . . . . . . . . . . . . . . . . . . 4

2.4 Nested perfect necklaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.5 From nested perfect necklaces to normal sequences . . . . . . . . . . . . . . . . . . 5

2.6 Aligned occurrences and discrete discrepancy . . . . . . . . . . . . . . . . . . . . . 6

3 Liberal insertion

8

3.1 Tools to prove Theorem 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

3.2 Proof of Theorem 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

4 One symbol insertion

12

4.1 Tools to prove Corollary 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

4.1.1 On discrete discrepancies at aligned positions . . . . . . . . . . . . . . . . . 15

4.2 Proof of Corollay 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

22

