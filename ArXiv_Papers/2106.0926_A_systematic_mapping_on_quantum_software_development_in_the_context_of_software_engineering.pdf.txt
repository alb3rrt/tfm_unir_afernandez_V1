arXiv:2106.00926v1 [cs.SE] 2 Jun 2021

A systematic mapping on quantum software development in the context of software engineering
Paulo Eduardo Zanni Junior Graduating at UFSCar ­ Universidade Federal de São Carlos, São Carlos - SP;
zanni97@hotmail.com
Prof. Dr. Valter Vieira de Camargo Professor at UFSCar ­ Universidade Federal de São Carlos, São Carlos - SP;
valtervcamargo@gmail.com
Abstract Quantum Computing is a new paradigm that enables several advances which are impossible using classical technology. With the rise of quantum computers, the software is also invited to change so that it can better fit this new computation way. However, although a lot of research is being conducted in the quantum computing field, it is still scarce studies about the differences of the software and software engineering in this new context. Therefore, this article presents a systematic mapping study to present a wide review on the particularities and characteristics of software that are developed for quantum computers. A total of 24 papers were selected using digital libraries with the objective of answering three research questions elaborated in the conduct of this research.
Keywords: software engineering, quantum computing, quantum software, quantum software development, systematic mapping study
1 Introduction
Quantum computing presented to the world a complete revolution in the processing power of computers. Problems that would take years to be solved can now be solved in seconds. This is possible because quantum computers are not an evolution of classical ones, but they are built based on new concepts such as superposition and entanglement [1­3].
An important point here is that the technical differences of quantum computers impacts the way software is developed. We have observed that although quantum computing

is becoming very spread across communities and companies, few research is being conducted from the software engineering point of view, particularly related to languages and software development phases [4]. In particular, we are interested in knowing the impact of quantum computing in software development.
Therefore, in this paper we present a systematic mapping focused on revealing: i) the main existing programming infrastructure for developing quantum software; ii) the differences of developing conventional and quantum software regarding the development phases and iii) which are the domain in which quantum software is more aligned to.
To achieve these goals, three research questions were elaborated: i) What are the main 'programming infrastructures' for developing quantum software? ii) What is the difference between developing conventional software and quantum software? iii) Is quantum software more suited to a particular application domain?
The remainder of this paper is organized as follows. In section 2, we present a brief overview of software engineering and quantum computing. In section 3, we present the research method, describing research questions, sources of studies, search strategy, and inclusion/exclusion criteria. In section 4, we present the results of this systematic mapping study, the data extraction and the synthesis of findings answering the research questions. In section 5, we outline our conclusions and limitations of this work.
2 Background
2.1 Software Engineering and Programming Languages
Software engineering aims at providing tools, methodologies, methods, languages, infrastructure in order to makes the software development and maintenance a more systematic and controlled activity, raising better quality levels [5].
In the context of this work, the main points we would like to check against the quantum world are the steps of the software development life cycle and programming languages. Depending on the languages and other technical tools used for developing a system, the phases of the life cycle are different. For example, when a Object-Oriented Language is employed, several artifacts that are developed before the implementation must consider this paradigm. Therefore, when we are considering the use of quantum computing, it is clear that there will be modifications in the traditional phases of the Software Development Life Cycle [5, 6].
Software Development Life Cycle involves, most of the times, the following steps: 1) Requirements Analysis, 2) Design, 3) Implementation, 4) Testing and 5) Maintenance.
2

In the requirements analysis phase, the goal is to elicit the functional and nonfunctional requirements, so that the team knows exactly what must be developed and also the necessary constraints. Requirements are elicited/discovered using several techniques, ranging from interviews with stakeholders to building of diagrams, like use cases. Usually the output of this phase is a requirement document listing the functional and non-functional requirements. Performance for example is an important non-functional requirement in the context of this work since the main advantage of quantum computing is power processing.
In the analysis phase, the requirements are analyzed and processed. At this point, some diagrams are build for initiating the construction of the computational solution. Therefore, class diagrams, sequence diagrams and others are built, but still without design details. At this point some non-functional requirements, like performance, are more difficult to be represented and most of the time are neglected.
In the design phase, the goal is to deep into computational details and build more elaborated diagrams, making evident components, classes, methods, relationships, etc. At this point software engineers can use extensions of the UML for representing more specialized details. Therefore, when quantum details show up in the design phase, they can be make evident in models by using UML profiles, applying stereotypes.
Besides the impact quantum computing poses over the software lifecycle, another important field that is impacted by the emergence of quantum computing is the programming languages. Programming a classical computer is different from programming a quantum one. However, programming languages and toolkit for the quantum context must consider some differences, such as quantum phenomena stemming from quantum mechanics and the quantum capabilities for different programming models that arise from quantum computing, providing an innovative programming paradigm with news resources to be explored.
2.2 Quantum Computing
The first ideas about quantum computing emerged in the early 1980s [7­9]. Some years later the first quantum algorithms, such as the Deutsch's algorithm in 1985 [10], the Shor's algorithm in 1994 [11] and Grover's algorithm in 1996 [12] were developed. Thus, with the quantum algorithms established, the first quantum programming languages were created and currently there are a lot of quantum languages, frameworks and libraries [13]. Currently, quantum computers are a reality and certain computational tasks might be executed exponentially faster on a quantum processor than on a classical processor [1]. In the past five years, the use of quantum computers has become available to everyone
3

through cloud systems [14]. It is known that computers are information processing machines that manipulate data.
A basic unit of data in classical computing is a binary digit called bit, which can assume the values "1" or "0", always representing a definite state. A quantum computer is a processing machine that obeys the laws of quantum mechanics, and the basic unit of data in quantum computing is a quantum bit called qubit [15]. A qubit is a two-level systems (such as spin-1/2 particles or two level atoms), represented mathematically by vectors in the form of a matrix (as bellow), in which data can be stored [16].

1 |0 =
0

e

0 |1 =

1

The two possible states for one qubit are the states |0 and |1 , which as you might guess correspond to the states 0 and 1 for a classical bit. The difference between bits and qubits is that a qubit can be in a state other than |0 and |1 . It is also possible to form a linear combinations of states, | =  |0 +  |1 , often called superposition [17]. Superposition is a concept of physics, more specifically, is a counter-intuitive principle from quantum mechanics widely used in quantum computing. Superposition is the capacity of a physical system (like a qubit) exists partially in all theoretically possible states simultaneously before being measured [18, 19]. After a measurement, the physical system in superposition collapse and goes to one definite state among all possible states.
In addition to the superposition, another counter-intuitive principle from quantum mechanics commonly used in quantum computing is entanglement. Entanglement is a quantum phenomenon that allows two or more objects to be deeply connected without any direct physical interaction [18,19]. In the context of quantum computing, this property is used to link two or more qubits, and this is done by quantum gates.
Regarding the operations that can be applied over qubits, a quantum operation is performed on a qubit by a quantum gate (in analogy with those in classical logic circuits). There are two basic types of gates in quantum computing: rotations, which modify an individual qubit's state, and entangling gates, which link multiple qubits into an entangled state [20]. A sequence of quantum gates operating on a set of qubits is traditionally called a quantum circuit. There are a lot of quantum gates, and in general, a quantum gate is a unitary operator and is described by unitary matrices. The main two are the Hadamard gate which is used to put a qubit in superposition, and the CNOT gate which is used to entangle two qubits.

4

H = 1 1 1 2 1 -1





1000

e

C N OT

=

0 

1

0

0 

0 0 0 1





0010

It is important to say that in classical computing the bits are physically implemented by the transistors, and this physical implementation is the so-called hardware. Currently, hardware for quantum computing is still in the early stages of development, meaning current quantum computers have limited qubits. Quantum computers can be based on different physical qubit realizations (superconducting [21], trapped ion [22], electron spins [23], etc.) and despite rapid progress, a lot of advances still are necessary to be made.
There are different quantum computing models (gate, adiabatic, topological, etc.) all equivalent to each other and to implement them physically it is necessary the qubit. Due to hardware limitations, currently, we are in the so-called Noisy Intermediate-Scale Quantum (NISQ) era [24], in which quantum computers have several errors associated (connectivity, gate errors, coherence times, etc.) at the hardware level.
Despite hardware limitations, quantum algorithms and quantum programming languages are well established and well-founded, and it is now possible to program and implement algorithms on real quantum computers through cloud systems. Therefore, the attention that the quantum software field is receiving grows up with the advent of quantum computer technologies, and in this way, there is a lot of changes that have significant and direct impacts on programming languages and software development.

3 Research Method
The goal of this systematic mapping is to reveal the main characteristics and differences of developing/programming software in quantum context when compared to the traditional development. The research method described here followed the proposal of Kitchenham [25] where she says that the mapping protocol specifies the methods that will be used to undertake a specific systematic review.
In this paper some necessary adaptations were made according to the specificity of this research. Yet according to Kitchenham, a systematic map is a method that can be conducted to get an overview of a particular research area.
Therefore, we have elaborated three research questions:
1. What are the main 'programming infrastructures' for developing quantum software? In this research question, we aim at finding out what are the
5

languages, frameworks, and libraries that are being currently used in software development. (Section 4.1)
2. What is the difference between developing conventional software and quantum software? In this research question we aim at investigating how quantum characteristics affect the conventional steps of the software life cycle, as it was presented in the Background Section. (Section 4.2)
3. Is quantum software more suited to a particular application domain? In this research question, knowing that a quantum computer can offer processing advantages, we seek to find out if a quantum software is more suitable to be applied to certain domains. (Section 4.3)
The digital libraries we have used in our systematic mapping are the following: IEEEXplore Digital Library, ACM Digital Library, Elsevier ScienceDirect, Scopus and Wiley Online Library. These digital libraries were selected because they are the most important repositories for research in computer science.
Another important part of a systematic mapping is the search string. In this paper we elaborated the search string shown in Table 1.
Table 1. The search string ("quantum software" OR "quantum software engineering" OR "quantum programming"
OR "quantum programming language" OR "quantum programming languages" OR "quantum computer software" OR "quantum application" OR "quantum applications")
The definition of the criteria for including and excluding papers is also another important step. These criteria are used to exclude studies that are not relevant to answer the research questions. They intend to select the suitable primary studies from literature.
The inclusion criteria we have considered are the following:
· Only studies written in English.
· Studies dealing and referencing any of the subjects related to quantum software in their title, abstract or keywords.
· Studies with restricted publication date only after 2010.
Besides, the exclusion criteria are:
· Repeated studies found in different search engines. In this case, just one study was considered.
6

· Duplicate studies reporting similar results. In this case, only the most complete study was considered.
· Secondary studies, as like surveys and state-of-art, and inaccessible papers and books.
4 Results
In order to find relevant studies, we have run the search string in the five digital libraries previously mentioned. We did our Initial Search seeking out the terms of the search string only in the title, keywords and abstract. After, with returned items, we use the following Steps to filter and to select the relevant articles. Figure 1 summarizes the selection process and presents the number of papers identified at each step.
Figure 1: The selection process to identify relevant papers.
In the Initial Search, the digital libraries provided a total of 937 papers. In the Step 1, since we used several repositories, many papers were duplicates, and after removing all duplicates, our list was reduced to 721 papers. In the Step2, we analyze every paper, one by one, and all papers not related to the quantum computing field were removed, and again our list was reduced, this time to 395 papers. In the Step3, we analyze these papers by reading just the title, keywords, and abstract, and at the end of this step, our list was reduced, here to a total of 67 papers. In the Step4, we read these 67 relevant articles in full, and using the inclusion and exclusion criteria, as like in previous steps, we reached a total of 24 papers.
Therefore, we reached 24 relevant articles selected for this systematic mapping study in order to answer our research questions. In the Appendix, we present the complete list of selected papers numbered from S1 to S24. These numbering will serve to reference the selected papers used to answer the research questions.
Figure 2 illustrates the year-wise distribution of selected papers, it is possible to notice an increase in the number of papers in the last three years. This suggests a growing
7

Figure 2: Year-wise distribution.
interest by the community in the field. Moreover, it indicates this topic is relatively recent in publications. As the search was done at the beginning of 2021, in the graph we have only one paper in 2021, but it is expected from now on more relevant publications to emerge.
We emphasize that papers like [2,3] are not in the selected studies due to the fact that they do not focus specifically on programming/development of software quantum. Instead, these papers primarily address a growing in the research field of quantum software.
Following, we present the three research questions and the answers.
4.1 What are the main 'programming infrastructures' for developing quantum software?
Here, we use the term "programming infrastructures" involving the most used programming languages as well as existing frameworks and libraries for developing quantum software.
Table 2 shows the languages and toolkits (frameworks and libraries) we have considered the most important currently for the context of quantum software. In the second column of the table, it is also possible to see the number of mentions. The third column is informing the host language, which means, the classical language on which the quantum programming infrastructure is based or extended. And the fourth column is saying the paradigm of the language or the type of the toolkit. Below the table, there is a short description of each programming infrastructure.
8

Our criteria for considering these programming infrastructures the main ones were, for languages, the number of times they were mentioned in different papers and the different paradigms, and for toolkits, the number of times they were mentioned in different papers and the different types.
Based on the selected papers, we noticed that there are 8 programming infrastructures that can be considered as the main ones. Languages, as can be seen, regarding the paradigm are classified into: imperative, functional and object-oriented. Toolkits are quantum software development kits that provide collections of tools to create and manipulate quantum programs.

Table 2. The main programming infrastructures

Languages Quipper Scaffold Q#
FJQuantum Toolkits Qiskit
OpenFermion ProjectQ PyQuil

Mentions 8 6 11 1
Mentions 11 3 2 4

Paradigm Functional Imperative Functional and Imperative Object-Oriented
Types Framework
Library Framework
Library

Quipper is a functional Domain-Specific Language (DSL) embedded in Haskell. It is scalable in terms of the number of gates, i.e., it can generate representations with trillions of gates and is independent of the backend gate model of the quantum hardware.
Scaffold/ScaffCC is an imperative DSL embedded in C/C++. It extends the language C with data types for quantum and classical bits, as well as functions that act as primitive quantum gates. Scaffold programs are composed of a hierarchical set of quantum modules (sub-circuits) and classical control constructs such as loops and conditionals. The compiler used is the ScaffCC for compiling Scaffold code.
Q# in contrast to the embedded quantum DSLs, Q# is a genuine stand-alone language. This means that functions provided by a large host language are not available, however, it has the key advantage that limitations of the host language do not apply to Q# itself.
FJQuantum (S8) is an object-oriented language based on Featherweight Java. It was created to develop programs that are able to handle quantum data and operations. This

9

language was developed due the lack of languages based on the object-oriented paradigm, which is among the most used paradigms today in software development.
Qiskit [26] is an open-source framework for quantum computing. It allows users to create, compile, and execute quantum programs in an online mannger, either in a simulator or a real quantum processor. Qiskit [27] is available in Python, JavaScript, and Swift. For beginners, Python is a very good starter programming language because of its easy and intuitive syntax. The source is hosted on https://github.com/Qiskit.
OpenFermion [28] is an open-source software library written largely in Python under Apache 2.0 license. It is aimed at enabling the simulation of fermionic and bosonic models and quantum chemistry problems on quantum hardware. Beginning with an interface to common electronic structure packages, it simplifies the translation between a molecular specification and a quantum circuit for solving or studying the electronic structure problem on a quantum computer, minimizing the amount of domain expertise required to enter the field. The package is designed to be extensible and robust, maintaining high software standards in documentation and testing. The source is hosted on https://github.com/ quantumlib/OpenFermion.
ProjectQ [29] is an extensible open-source software framework for quantum computing, providing clean interfaces for extending and improving its components. ProjectQ is built on four core principles: open & free, simple learning curve, easily extensible, and high code quality. This quantum language is implemented as a domain-specific language embedded in Python. The source is hosted on https://github.com/ProjectQ-Framework/ ProjectQ.
PyQuil [30] is an open-source Python library which allows the construction of Quil (Quantum Instruction Language) programs by treating them as first-class objects. Pyquil [31] allows us to work using a user-friendly syntax. The source is hosted on https: //github.com/rigetti/pyquil.
4.2 What is the difference between developing conventional software and quantum software?
The conventional way for developing software is presented in Figure 3 with five steps: 1) Requirements Analysis, 2) Design, 3) Implementation, 4) Testing and 5) Maintenance. In the next paragraphs, we elaborate on how quantum characteristics affect these conventional steps.
10

Figure 3: Conventional software development life cycle (adapted from xbsoftware.com)
1. In the Requirements Analysis, it is expected (S17) to have moderated changes. Although we have not found any paper related to this stage, we expect as long as the field grows up and tools begin to emerge, work on this topic will grow significantly. The main point here is that along the requirement analysis, the requirement engineer must identify in which application domain and also which non-functional requirements can benefit using quantum capabilities.
2. In the Design phase, there will be drastic changes because it will be necessary to represent the quantum capabilities. We found some papers (S14, S15, S16, and S20) related to this stage. Here, the software engineers use dedicated diagrams for specifying details of how the quantum software will be implemented. In conventional software, UML is the most used modeling language. In the case of quantum software, there are different approaches. Some trying to extend the classical languages like UML, BPMN, and TOSCA to create versions of these languages (Q-UML, Quantum4BPMN, and TOSCA4QC) that will include specifications of the quantum capabilities. Some trying to create a Domain-Specific Language independent of any classical language, considering all quantum differences, to model quantum software.
3. In the Implementation, one must take into consideration the requirements analysis and design, which will support all the implementation steps of the quantum software. Thus, based on the details of the design, one must use some implemen-
11

tation infrastructure (languages, frameworks, etc) to create quantum circuits. As previously discussed in the research question 1 (Sec. 4.1), there are a some quantum programming strategies that can be adopted, even in different paradigms.
To implement a quantum system, a software developer must known some patterns that are recurrent when implementing quantum algorithms (S1, S3 and S13). These patterns, in general, are basic structures related to putting a quantum state in superposition, create an entangled quantum state, doing the initialization of the circuit in a data preparation step, the expansion of the oracles that can be used in the circuit, among others.
4. In the Testing phase, due to intrinsic complexity of quantum algorithms, design and implementation are doomed to the appearance of multiple bugs and errors (S17). We found some papers (11, 12, 13, 21, and 22) focusing on this stage.
It is discussed in (S12) that the verification step has an important role to play in checking the correctness of quantum programs. Although there is some progress in this direction, by means of tools like QWIRE and QHL, it is not enough and it is necessary a new approach for revealing errors in the verification step. Furthermore, the paper (S21) states that approaches for performing verification and validation of quantum programs are essentially lacking and largely unexplored, which means that, in the context of testing, techniques of V&V are still in their infancy.
Also, in (S11) it is discussed that quantum tests can take advantages of some techniques of the known classical tests, such as: functional testing, white box testing and model-based testing. As an additional alternative, the authors of paper (S13) propose the use of statistical assertions for validating patterns and finding bugs in quantum programs. This work presents a strategy for deploying and checking quantum program assertions based on statistical tests.
The paper (S22) says that when compared to classical computing, quantum program testing and debugging are still at a very early stage. Even the basic testing and debugging approaches (e.g., assertions) are not yet available or well-developed for quantum programs.
5. In the Maintenance, the paper (S17) says that quantum programs are no different from other software in terms of the quality and maintainability of the applications and their code. Currently, there are no papers on this topic yet, probably because the development of quantum software is not yet being produced on a large scale. As this is a recent research area, tools for creating such systems are still recent and
12

they are constantly being improved. However, after reading the 24 selected papers, we perceived there are many possibilities of introducing errors at hardware (gates, qubits, etc) and software levels. Therefore, the strategies for maintaining a quantum software in order to preserve their quality attributes are still a challenge.
Furthermore, in order to make the quantum software development easier, the selected paper (S24) proposes a quantum software life cycle involving new steps. In this new cycle it is taken into account ­ among other things ­ the selection of suitable quantum hardware, determination of the error model, optimizations based on hardware characteristics, and so many other important factors.
4.3 Is quantum software more suited to a particular application domain?
The answer is Yes. The use of a quantum algorithm is necessary when there is no classical counterpart capable of performing a specific task efficiently. The quantum supremacy power over a classical computer becomes evident when an algorithm performs a task in a reduced number of steps taking less time. This capacity of quantum algorithms to outperform classical algorithms is known as speedup.
It is expected (S1, S4, S5, S6, S7, S12, S13, S15, S17, S18, S21 and S23) that quantum software provides substantial speedups over conventional software in several application domains, such as quantum chemistry, optimization problems (logistics, financial modeling and risk management), machine learning, materials science, cryptography, and many others. The authors of the paper (S12) claim that in a near term, it will become clearer what are the specific problems in which quantum applications must be employed so that we can obtain a great benefit in terms of processing time and volume.
The paper (S18) provides a brief explanation about some application domains mentioned above. For example, in quantum chemistry some exact calculations of molecular properties are currently intractable because their computational cost grows exponentially with the number of atoms. However, the power of quantum computer can make it a tractable problem. In optimization problems like complex mathematical processes behind finance such as Monte Carlo or Bayesian Inference could be lightened to provide real-time solutions. In machine learning, techniques that are applied today in multiple facets of our lives will increase their precision and speed so they can be used in problems that today are out of reach. Also, according to paper (S6), recent work has produced quantum algorithms that could act as the building blocks of machine learning programs; And says that currently is explored how to devise and implement quantum software that could enable
13

machine learning faster. To sum up, the authors of paper (S19) reinforce that quantumfy every business process
does not make sense because of the high cost that it requires. Therefore, the decision of applying quantum software for solving a determined task, requires a lot of considerations, such as: i) the level of difficulty for implementation; ii) what is the testing strategy that will be necessary due to many sources of errors; iii) lack of adequate maintenance methodologies for this new type of software, among other factors.
5 Conclusion
In this paper, we presented a systematic review whose focus was to evidence the impacts caused in the software engineering field due to the advent and improvement of quantum computing practical applications. Therefore, this study highlights the role which quantum technologies can play in the process of software engineering. Emphasizing the changes caused by quantum phenomena in the software development life cycle.
We exhibit the main findings of this work was:
1. Identifying and presenting the main existing programming infrastructures for quantum computing.
2. Identifying and presenting some differences that quantum computing can bring to software development.
3. Identifying and presenting some application domains to which quantum computing is more suited.
We can also observe that the research on quantum computing focused on quantum software has grown in the last years, as was shown in Figure 2. Besides, the quantum software field is recent because new quantum technologies for computing are emerging day by day, and the ones well-established are continuously improving. Therefore, we envisage that there still great opportunities for research in this field.
References
[1] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando G. S. L. Brandao, David A. Buell, and et al. Quantum supremacy using a programmable superconducting processor. Nature, 574(7779):505­510, Oct 2019.
14

[2] Mario Piattini, Guido Peterssen, Ricardo Pérez-Castillo, Jose Luis Hevia, Manuel A. Serrano, Guillermo Hernández, Ignacio García Rodríguez de Guzmán, Claudio Andrés Paradela, Macario Polo, Ezequiel Murina, Luis Jiménez, Juan Carlos Marqueño, Ramsés Gallego, Jordi Tura, Frank Phillipson, Juan Manuel Murillo, Alfonso Niño, and Moisés Rodríguez. The talavera manifesto for quantum software engineering and programming. volume 2561 of CEUR Workshop Proceedings, pages 1­5. CEURWS.org, 2020.
[3] Mario Piattini, Guido Peterssen, and Ricardo Pérez-Castillo. Quantum computing: A new software engineering golden age. SIGSOFT Softw. Eng. Notes, 45(3):12­14, July 2020.
[4] Guido Peterssen Nodarse. Quantum technology impact: the necessary workforce for developing quantum software. pages http://ceur­ws.org/Vol, 04 2020.
[5] Ian Sommerville. Software Engineering. Addison-Wesley, Harlow, England, 9 edition, 2010.
[6] J.M.A. Shari Lawrence Pfleeger. Software Engineering: Theory and Practice: Fourth Edition. Pearson Education India.
[7] Paul Benioff. The computer as a physical system: A microscopic quantum mechanical hamiltonian model of computers as represented by turing machines. Journal of Statistical Physics, 22:563­591, 1980.
[8] Yuri Manin. Computable and uncomputable (in russian). Sovetskoye Radio, Moscow, 1980.
[9] Richard Feynman. Simulating physics with computers. International Journal of Theoretical Physics, 21(6/7):467­488, 1982.
[10] Deutsch David. Quantum theory, the church­turing principle and the universal quantum computer. Proc. R. Soc. Lond. A40097­117, 1985.
[11] P. W. Shor. Algorithms for quantum computation: Discrete logarithms and factoring. Proceedings, 35th Annual Symposium on Foundations of Computer Science, pages 124­134, 1994.
[12] Lov K. Grover. A fast quantum mechanical algorithm for database search. Proceedings STOC, pages 212­219, 1996.
15

[13] S. Garhwal, M. Ghorani, and A. Ahmad. Quantum programming language: A systematic review of research topic and top cited languages. Arch Computat Methods Eng, 28:289­310, 2021.

[14] Haryono Soeparno and Anzaludin Samsinga Perbangsa. Cloud quantum computing concept and development: A systematic literature review. Procedia Computer Science, 179:944­954, 2021. 5th International Conference on Computer Science and Computational Intelligence 2020.

[15] Aleksandar Radovanovic. Quantum Programming Illustrated. Astoria Books, 2020.

[16] Mikio Nakahara and Tetsuo Ohmi. Quantum Computing - From Linear Algebra to Physical Realizations. CRC Press, 2008.

[17] Chuang I. L. Nielsen M. A. Quantum Computation and Quantum Information. Cambridge University Press, 10th edition, 2011.

[18] David J. GRIFFITHS. Introduction to Quantum Mechanics. Cambridge University Press, 4th edition, 2017.

[19] Claude Cohen-Tannoudji, Bernard Diu, and Franck Lalöe. Quantum Mechanics, volume 1. John Wiley & Sons, 1ª edition, 1981.

[20] https://ionq.com/technology. Creating entanglement. technology, Accessed: 2021-03-22.

https://ionq.com/

[21] Morten Kjaergaard, Mollie E. Schwartz, Jochen Braumüller, Philip Krantz, Joel I.-J. Wang, Simon Gustavsson, and William D. Oliver. Superconducting qubits: Current state of play. Annual Review of Condensed Matter Physics, 11(1):369­395, Mar 2020.

[22] Colin D. Bruzewicz, John Chiaverini, Robert McConnell, and Jeremy M. Sage. Trapped-ion quantum computing: Progress and challenges. Applied Physics Reviews, 6(2):021314, Jun 2019.

[23] Jarryd J. Pla, Kuan Y. Tan, Juan P. Dehollain, Wee H. Lim, John J. L. Morton, David N. Jamieson, Andrew S. Dzurak, and Andrea Morello. A single-atom electron spin qubit in silicon. Nature, 489(7417):541­545, Sep 2012.

[24] John Preskill. Quantum Computing in the NISQ era and beyond. Quantum, 2:79, August 2018.

[25] Barbara Kitchenham. Procedures for performing systematic reviews. Keele, UK, Keele Univ., 33, 08 2004.

16

[26] David C. McKay, Thomas Alexander, Luciano Bello, Michael J. Biercuk, Lev Bishop, Jiayin Chen, Jerry M. Chow, Antonio D. Córcoles, Daniel Egger, Stefan Filipp, Juan Gomez, Michael Hush, Ali Javadi-Abhari, Diego Moreda, Paul Nation, Brent Paulovicks, Erick Winston, Christopher J. Wood, James Wootton, and Jay M. Gambetta. Qiskit backend specifications for openqasm and openpulse experiments, 2018.
[27] Ryan LaRose. Overview and comparison of gate level quantum software platforms. Quantum, 3:130, Mar 2019.
[28] Jarrod R. McClean, Kevin J. Sung, Ian D. Kivlichan, Yudong Cao, Chengyu Dai, E. Schuyler Fried, Craig Gidney, Brendan Gimby, Pranav Gokhale, Thomas Häner, Tarini Hardikar, Vojtch Havlícek, Oscar Higgott, Cupjin Huang, Josh Izaac, Zhang Jiang, Xinle Liu, Sam McArdle, Matthew Neeley, Thomas O'Brien, Bryan O'Gorman, Isil Ozfidan, Maxwell D. Radin, Jhonathan Romero, Nicholas Rubin, Nicolas P. D. Sawaya, Kanav Setia, Sukin Sim, Damian S. Steiger, Mark Steudtner, Qiming Sun, Wei Sun, Daochen Wang, Fang Zhang, and Ryan Babbush. Openfermion: The electronic structure package for quantum computers, 2019.
[29] Damian S. Steiger, Thomas Häner, and Matthias Troyer. Projectq: an open source software framework for quantum computing. Quantum, 2:49, Jan 2018.
[30] Robert S. Smith, Michael J. Curtis, and William J. Zeng. A practical quantum instruction set architecture, 2017.
[31] Daniel Koch, Laura Wessing, and Paul M. Alsing. Introduction to coding quantum algorithms: A tutorial series using pyquil, 2019.
17

Appendix: The selected studies

ID

Reference

Svore, Krysta and Geller, Alan and Troyer, Matthias and Azariah, John

and Granade, Christopher and Heim, Bettina and Kliuchnikov, Vadym

S1 and Mykhailova, Mariia and Paz, Andres and Roetteler, Martin

Q#: Enabling Scalable Quantum Computing and Development with

a High-Level DSL In: ACM Digital Library (2018)

Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and

S2 Selinger, Peter and Valiron, Benoît Quipper: A Scalable Quantum

Programming Language In: ACM Digital Library (2013)

Lapets, Andrei and da Silva, Marcus P. and Thome, Mike and Adler,

S3 Aaron and Beal, Jacob and Roetteler, Martin QuaFL: A Typed DSL

for Quantum Programming In: ACM Digital Library (2013)

Mintz, Tiffany M. and McCaskey, Alexander J. and Dumitrescu, Eugene

F. and Moore, Shirley V. and Powers, Sarah and Lougovski, Pavel S4
QCOR: A Language Extension Specification for the Heterogeneous

Quantum-Classical Model of Computation In: ACM Digital Library (2020)

A.J. McCaskey and E.F. Dumitrescu and D. Liakh and M. Chen and

S5 W. Feng and T.S. Humble A language and hardware independent

approach to quantum­classical computing In: Elsevier ScienceDirect (2018)

Biamonte, J. and Wittek, P. and Pancotti, N. and Rebentrost, P. and S6
Wiebe, N. and Lloyd, S. Quantum machine learning In: Scopus (2017)

Wille, R. and Van Meter, R. and Naveh, Y. IBM's Qiskit Tool Chain:

S7 Working with and Developing for Real Quantum Computers In: Scopus

(2019)

Feitosa, S.D.S. and Vizzotto, J.K. and Piveta, E.K. and Du Bois, A.R.

S8 A monadic semantics for quantum computing in an object oriented

language In: Scopus (2018)

Boji, A. An approach to source code conversion of classical programming

S9 languages into source code of quantum programming languages In: Scopus

(2014)

McCaskey, A.J. and Lyakh, D.I. and Dumitrescu, E.F. and Powers, S.S.

S10 and Humble, T.S. XACC: A system-level software infrastructure for

heterogeneous quantum-classical computing In: Scopus (2019)

18

S11 Usaola, M.P. Quantum Software Testing In: Scopus (2020) Rand, R. and Hietala, K. and Hicks, M. Formal verification vs. quantum
S12 uncertainty In: Scopus (2019) Huang, Y. and Martonosi, M. Statistical assertions for validating patterns
S13 and finding bugs in quantum programs In: Scopus (2019) Pérez-Delgado, Carlos A. and Perez-Gonzalez, Hector G. Quantum Software
S14 Modeling Language In: ACM Digital Library (2020) B. Weder and U. Breitenbücher and F. Leymann and K. Wild Integrating
S15 Quantum Computing into Workflow Modeling and Execution In: IEEEXplore Digital Library (2020) K. Wild and U. Breitenbücher and L. Harzenetter and F. Leymann and D. Vietz and M. Zimmermann TOSCA4QC: Two Modeling Styles for TOSCA to
S16 Automate the Deployment and Orchestration of Quantum Applications In: IEEEXplore Digital Library (2020) M. Piattini and M. Serrano and R. Perez-Castillo and G. Petersen and
S17 J. L. Hevia Toward a Quantum Software Engineering In: IEEEXplore Digital Library (2021) Moguel, E. and Berrocal, J. and García-Alonso, J. and Murillo, J.M. A Roadmap
S18 for Quantum Software Engineering: applying the lessons learned from the classics In: Scopus (2020) Jiménez-Navajas, L. and Pérez-Del Castillo, R. and Piattinia, M. A Tool for
S19 Quantum Software Evolution In: Scopus (2020) Ali, S. and Yue, T. Modeling Quantum Programs: Challenges, Initial
S20 Results, and Research Directions In: Scopus (2020) Gomes, C. and Fortunato, D. and Fernandes, J.P. and Abreu, R. Off-the-shelf
S21 Components for Quantum Programming and Testing In: Scopus (2020) Li, G. and Zhou, L. and Yu, N. and Ding, Y. and Ying, M. and Xie, Y.
S22 Projection-Based Runtime Assertions for Testing and Debugging Quantum Programs In: Scopus (2020) Pérez-Castillo, R. and Serrano, M.A. and Piattini, M. Software modernization
S23 to embrace quantum technology In: Scopus (2020) Weder, B. and Barzen, J. and Leymann, F. and Salm, M. and Vietz, D. The
S24 Quantum Software Lifecycle In: Scopus (2020)
19

