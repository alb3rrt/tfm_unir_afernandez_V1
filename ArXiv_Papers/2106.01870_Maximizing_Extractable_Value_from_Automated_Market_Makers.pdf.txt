Maximizing Extractable Value from Automated Market Makers

arXiv:2106.01870v1 [cs.CR] 2 Jun 2021

Massimo Bartoletti
Università degli Studi di Cagliari Cagliari, Italy

James Hsin-yu Chiang
Technical University of Denmark Lyngby, Denmark

Alberto Lluch-Lafuente
Technical University of Denmark Lyngby, Denmark

ABSTRACT
Automated Market Makers (AMMs) are decentralized applications that allow users to exchange crypto-tokens without the need to find a matching exchange order. AMMs are one of the most successful DeFi use case so far, as the main AMM platforms UniSwap and Balancer process a daily volume of transactions worth billions of dollars. Despite this success story, AMMs are well-known to suffer from transaction-ordering issues: indeed, adversaries can frontrun user transactions to increase their gain to the detriment of honest users. Being specifically designated to arrange user transactions into blocks, miners can easily play the role of adversary, by suitably selecting and ordering transactions -- and possibly inserting their own -- to increase their gain. In this paper we formally characterize rational miners as players which follow an optimal strategy in the mining game. We identify relevant variants of the game, corresponding to specific real-world constraints that a miner might have. We devise effective procedures to construct solutions to mining game, both in its most general form and in some relevant variants. Most notably, miners can exploit these solutions to maximize the value extracted from user transactions.
KEYWORDS
maximum-extractable value, front-running, decentralized finance
1 INTRODUCTION
Decentralized finance (DeFi) is emerging as an alternative to the traditional finance, boosted by blockchain-based crypto-tokens and smart contracts [22]. One of the main DeFi applications are Automated Market Makers (AMMs), which allow users to exchange crypto-tokens of any types without the need to find another party wanting to participate in the exchange. As of May 2021, the two AMM platforms leading by user activity, Uniswap [10] and Curve Finance [2], alone hold $5.45B and $7.5B worth of tokens, and process $860M and $290M worth of transactions daily [1, 9].
Although AMMs generally only expose a handful of callable functions, they are sensitive to transaction ordering dependencies [17­19, 25]: namely, actors with the power to influence the insertion, removal or reordering of transactions in the blockchain may be incentivized to do so for profit -- or just to harm specific users. A well-known example of value extraction is the so-called transaction sandwich attack [25], where an actor can front- and back-run another actor's transactions to extract value.
We illustrate this attack through a minimal example. Assume a Uniswap-like AMM holding 100 units of ETH and 100 units of WETH, and assume that the price of both crypto-tokens in the reference currency is the same (say $1,000). Now, suppose that Alice wants to swap 20 units of ETH in her wallet for at least 15 units of WETH. This requires to perform a transaction of the form:
A : swap0 (20 : ETH, 15 : WETH)

where the prefix A indicates the wallet involved in the transaction, swap is the called AMM function, and the superscript 0 indicates the direction of the swap, i.e. deposit 20 ETH to receive back at least 15 WETH (a superscript 1 would indicate the opposite direction).
If A's transaction is processed immediately, A will get 16.7 units of WETH (so, more than the minimum request of 15 units). The actual amount of WETH transferred to A is determined by a swap invariant, which is specific to the AMM platform. Uniswap, as well as other main platforms like Balance, implements a constant product invariant [11]: this requires that the product between the AMM reserves remains constant before and after every exchange. In our example: 100 · 100  (100 + 20) · (100 - 16.7).
Now suppose that a miner M observes A's transaction in the transaction pool. The miner can extract value by "sandwiching" A's transaction between two swaps:
M : swap0 (5.9 : ETH, 5.5 : WETH) A : swap0 (20 : ETH, 15 : WETH) M : swap1 (25.9 : ETH, 20.6 : WETH)
where the last transaction is in the opposite direction: 20.6 WETH are transferred to the AMM in exchange of at least 25.9 ETH.
As a result, M is able to reduce the amount of WETH that A will receive by 1.7, thereby extracting as much value from A into M's own wallet. A will indeed receive 15 WETH for the 20 ETH, and M will gain 1.7 WETH, worth $1.7K.
Although some efforts have recently been done to study this and other attacks to AMMs [17, 19, 24, 25], the existing approaches are preeminently empirical, as they focus on finding heuristics that adversaries can use to extract value from AMMs, and on quantifying the effect of these heuristics in the wild. A general, systematic and precise understanding of attacks to AMMs, which would be instrumental to devise appropriate countermeasures, is still missing.
To illustrate our point, consider a variant of the previous example, where A wants to perform a different swap:
A : swap0 (40 : ETH, 35 : WETH)
This transaction would be rejected by the AMM: indeed, the constant product invariant dictates that for a 40 ETH deposit, one receives exactly 16.7 WETH, which is less than the required 35 units. The classical sandwich approach requires that M's front-run swap and A's swap have the same direction (i.e., offering ETH to obtain WETH): so, the sandwich would not be profitable, since A's transaction would not be enabled. However, M could extract value by performing a slightly different sandwich, where the first transaction is a swap in the opposite direction (i.e., offering WETH

to obtain ETH): M : swap1 (11 : ETH, 13 : WETH) A : swap0 (40 : ETH, 35 : WETH) M : swap1 (29 : ETH, 22 : WETH)

T  R+ represents A's token holdings. We denote with dom ()
0
the domain of . An AMM is a pair of the form (0 : 0, 1 : 1),
representing the fact that the AMM is holding, respectively, 0 and 1 units of token types 0 and 1. We denote by res0,1 () the reserves of 0 and 1 in , i.e. res0,1 () = (0, 1) if (0 : 0, 1 : 1)  .

By doing so, M will extract 5 WETH from A, thereby gaining $5K. We will provide a detailed account on this example in Section 3.2.
There are several other cases where the known approaches, e.g. [19, 25], are not able to extract the maximum possible value, and where there is a need to find how this value can be extracted. This is the case e.g. of user transactions to deposit or redeem tokens on AMMs, multiple AMMs, and bounds on the funds of the actors. It is worth to note that for most cases, an exhaustive exploration of the space of potential solutions to extract maximum value is not feasible since such as space is infinite due to the number of actions and parameters that an actor can choose.
Contributions. We address the above raised questions by providing theoretical foundations to rational miners aiming at maximizing extractable value from AMMs. More specifically:
· we introduce a general definition of a rational miner in the form of a mining game. We also introduce some relevant variants of the general game, based on specific real-world constraints that a miner may have (Section 3).
· we construct solutions to the general mining game and several relevant variants, which include well-known approaches such as sandwiches and arbitrage, in a wider range of cases as the ones illustrated above (Section 4).
At the best of our knowledge, this work is the first formalization of maximal-extractable value for the general mining game in AMMs, and the first to construct effective, optimal strategies for the miner.
2 AUTOMATED MARKET MAKERS
We formally describe the behaviour of AMMs by exploiting the general framework introduced in [13]. The main idea is to model the evolution of the blockchain state through a set of rewriting rules. We focus here on AMMs that implement the so-called constant product model [23]. Roughly, this requires that swaps (i.e., token exchange actions) preserve the product between the amounts of the tokens in the AMM. This is one of the most commonly used models in AMMs implementations, e.g. in Uniswap [5] and Mooniswap [3].
2.1 States and transactions
We assume a set of atomic token types T0, ranged over by ,  , . . .. We denote by T1 = T0 × T0 the set of minted token types, and with T = T0  T1 the universe of all token types. Intuitively, atomic tokens represent native cryptocurrencies and application-specific tokens, while minted tokens represent shares in AMMs. Tokens (both atomic and minted) are fungible, i.e. individual units of the same token type are interchangeable. In particular, amounts of tokens of the same type can be split into smaller parts, and two amounts of tokens of the same type can be joined. We use ,  , ,   to range over nonnegative real numbers (R+), and we write  :  to
0
denote  units of token type  (either atomic or minted). We assume a set of users A, ranged over by A, A, . . .. We model
the wallet of a user A as a term A [], where the partial map  

States. The state of a blockchain is a composition of wallets

and AMMs. We represent states as terms of the form:

A1 [1]

|

···

|

A []

|

(1

:

1,



 1

:

 )
1

|

···

|

(

:





,




:

)


where

we

require

that:

(i)

all

A

are

distinct,

(ii)

for

all





,








(i.e., the token types in an AMM are distinct), and (iii) for all   ,

(

=












 )




(

=














)

(i.e., distinct AMMs

cannot hold exactly the same token types). Two AMMs can have

a

common

token

type

,

e.g.

in

state

(1

:

1, 

:

)

|

( 

:


, 
2

:

 ),
2

thus enabling indirect trades between token pairs not directly pro-
vided by any AMM. We use , , . . . to range over states. For a base term  (either wallet or AMM), we write    when  =  | , for some , where we assume that two states are equivalent when

they contain the same base terms.

Token supply. We define the supply of a token type  in a state  as the sum of the balances of  in all the wallets and the AMMs occurring in . Formally:

 

(

)



sply (

|

)

=

sply ()

+

 

 0 



if  = A [] and   dom () if  = (0 : 0, 1 : 1) and  =  otherwise

2.2 Semantics of transactions

We formalise the interaction between users and AMMs as a tran-
sition system between blockchain states. Intuitively, a transition  --T  represents the evolution of the state  into  upon the execution of the transaction T. The possible transactions are: Deposit by firing the transaction:

A : dep(0 : 0, 1 : 1)

A deposits 0 : 0 and 1 : 1 to an AMM, receiving in return some units of the minted token (0, 1); Swap by firing the transaction:

A : swap (0 : 0, 1 : 1)
A tranfers  :  to an AMM (where   {0, 1}), receiving in return at least 1- units of 1- ; Redeem by firing the transaction:

A : rdm( : )

A redeems  units of minted token  = (0, 1) from an AMM,

receiving in return units of 0 and 1.

We now formalise the one-step relation --T through rewriting rules. We use the standard notation  {/ } to update a partial map

 at point : namely,  {/ }() = , while  {/ }() =  () for

  . Given a partial map   T  R+, a token type   T and

0

a partial operation   R+ × R+  R+, we define the partial map

00

0

   :  as follows:

 { ()  / } if   dom  and  ()    R+

  : =

0

 {/ }

if   dom 

2

Deposit. Any user can create an AMM for a token pair (0, 1) provided that such an AMM is not already present in the state. This is achieved by the transaction A : dep(0 : 0, 1 : 1), through which A transfers 0 : 0 and 1 : 1 to the new AMM. In return for the deposit, A receives a certain positive amount of units of a new token type (0, 1), which is minted by the AMM. The exact
amount of units received is irrelevant (we choose 0 as in [13]). We
formalise this behaviour by the rule:

 ( )   > 0 (  {0, 1})

0  1 0, 1  T0 (_ : 0, _ : 1), (_ : 1, _ : 0)  

A [ ] |  --A-:d-e-p-(--0-:-0-,--1:--1)

[Dep0]

A [ - 0 : 0 - 1 : 1 + 0 : (0, 1) ] | (0 : 0, 1 : 1) | 

Once an AMM is created, any user can deposit tokens into it,

A [70 : 0, 70 : 1 ] | B [30 : 0, 10 : 1 ]

--A-:d-e-p-(-7-0-:-0-,-70-:--1) A [70 : (0, 1) ] | B [ · · ·] | (70 : 0, 70 : 1)

(1)

--B-:s-w--ap-0-(-3-0-:-0-,-20-:--1) A [ · · ·] | B [0 : 0, 31 : 1 ] | (100 : 0, 49 : 1) (2)

--B-:s-w--ap-1-(-2-9-:-0-,-21-:--1) A [ · · ·] | B [30 : 0, 10 : 1 ] | (70 : 0, 70 : 1) (3)

-B--:r-d-m-(-3-0-:(--0-,-1-)) A [30 : 0, 30 : 1, 40 : (0, 1) ] | B [ · · ·] |

(4)

(40 : 0, 40 : 1)

--B-:s-w--ap-0-(-3-0-:-0-,-16-:--1) A [ · · ·] | B [0 : 0, 27 : 1 ] | (70 : 0, 23 : 1)

(5)

-A--:r-d-m-(-3-0-:(--0-,-1-)) A [82 : 0, 47 : 1, 10 : (0, 1) ] | B [ · · ·] |

(6)

(18 : 0, 6 : 1)

Figure 1: Interactions between two users and an AMM.

as long as doing so preserves the ratio of the token holdings in

the AMM. When a user deposits 0 : 0 and 1 : 1 to an existing
AMM, it receives in return an amount of minted tokens of type (0, 1). This amount is the ratio between the deposited amount 0 and the redeem rate of (0, 1) in the current state , i.e. the ratio between the amount 0 of 0 stored in the AMM, and the total supply sply (0,1) () of the minted token in the state.

 ( )   > 0 (  {0, 1})

10 = 01



=

0 0

· sply (0,1) ()

[Dep]

 = A [ ] | (0 : 0, 1 : 1) |  --A-:d-e-p-(--0-:-0-,--1:--1)

A [ - 0 : 0 - 1 : 1 +  : (0, 1) ] | (0 + 0 : 0, 1 + 1 : 1) | 

The premise 10 = 01 ensures that the ratio between the holdings of 0 and 1 in the AMM is preserved, i.e.:
1 + 1 = 1 0 + 0 0

Swap. Given an AMM (0 : 0, 1 : 1), any user A can swap units of 0 in her wallet for units of 1 in the AMM, or vice versa swap
units of 1 in the wallet for units of 0 in the AMM. This is achieved by the transaction A : swap (0 : 0, 1 : 1), where   {0, 1} is the swap direction. If  = 0 ("left" swap), then 0 is the amount of 0 transferred from A's wallet to the AMM, while 1 is a lower bound on the amount of 1 that A will receive in return. Conversely, if  = 1 ("right" swap), then 1 is the amount of 1 transferred from A's wallet, and 0 is a lower bound on the received amount of
0. The actual amount  of received units of 1- must satisfy the constant-product invariant, i.e.:

0 · 1 = ( +  ) · (1- -  )

Formally, for   {0, 1} we define:

 ( )   > 0



=

1- ·  +

0 < 1-  

A [ ] | (0 : 0, 1 : 1) |  -A--:s-w-a-p---(-0-:-0-,--1-:-1)

[Swap]

A [ -  :  +  : 1- ] | (0 : 0, 1 : 1) +  :  -  : 1- | 

where, for   {+, -}, we use the following auxiliary operation:

(0 : 0, 1 : 1)   :  =

(0   : 0, 1 : 1) (0 : 0, 1   : 1)

if  = 0 if  = 1

Redeem. Users can redeem units of a minted token (0, 1) for units of the underlying tokens 0 and 1. Each unit of (0, 1) can be

redeemed for equal fractions of 0 and 1 remaining in the AMM:

 (0, 1)   > 0

0

=



0 sply (0,1 )

()

1

=



1 sply (0,1 )

()

 = A [ ] | (0 : 0, 1 : 1) |  --A-:r-d-m--(-:-(--0-,-1-))

[Rdm]

A [ + 0 : 0 + 1 : 1 -  : (0, 1) ] | (0 - 0 : 0, 1 - 1 : 1) | 

The theory in [13] establishes some fundamental structural proper-

ties of AMMs. Among others, Lemma 1 of [13] ensures that the LTS
is deterministic, i.e. if  --T  and  --T , then the two states  and  are equivalent. This is a key property to ensure that our

notion of rational miners is well-defined, as we shall see.
We denote with type(T) the type of T, with AMM (T) the AMM pair affected by T, and with usr (T) the user issuing T, i.e.:

T0 = A : dep(0 : 0, 1 : 1)

 type(T0) = dep

T1 = A : swap (0 : 0, 1 : 1)  type(T1) = swap

T2 = A : rdm( : (0, 1))

 type(T2) = rdm

and AMM (T ) = (0, 1) and usr (T ) = A for   0..2. For a sequence of transactions  = T1 · · · T, we write  --  whenever there exist intermediate states 1, . . . -1 such that:
 --T1 1 --T2 · · · --T---1 -1 -T- 

When this happens, we say that  is enabled in , or just  --. We say that a state  is reachable if there exist some 0 only containing wallets with atomic tokens and some  such that 0 -- . We denote by tx() the multiset of all transactions occurring in the sequence , and with txA () the sub-multiset of transactions of user A (i.e., each T  txA () has the form A : , for some ). Hereafter, we denote with  the empty sequence, [] the empty multiset, with
[T1, . . . , T] the multiset containing T1, . . . , T, with mset () the multiset of the elements in a sequence . and with  +  and  - 

the sum and the difference between multisets, respectively.

2.3 A basic example
Figure 1 displays a sequence of transitions. In step (1), A creates a new AMM, depositing 70 : 0 and 70 : 1; in return, she receives 70 units of the minted token (0, 1). In step (2), B swaps 30 of his

3

units of 0 for at least 20 units of 1. The actual amount of units of 1 received by B is 21: indeed, (70 + 30) · (70 - 21) = 70 · 70, hence 21 satisfies the constant product swap invariant. In step (3), B reverses his prior action by swapping 21 of his units of 1 for at least 29 units of 0. Here, the actual amount of units of 1 received by B is 30, which also satisfies the constant product swap invariant. In step (4), B redeems 30 units of the minted token (0, 1), accordingly reducing the funds in the AMM. Note that the received tokens
exhibit the same 1-to-1 ratio as in the initial deposit at step (1). In step (5), B swaps 30 of his units of 0 for at least 16 units of 1. Unlike in the previous swap at step (2), now the actual amount of 1 received by B is 17. Note that the implied swap rate between received 1 units and sent 0 units has deteriorated w.r.t. step (2), even if the pair (0, 1) had the same 1-to-1 ratio of funds. Finally, in step (6) A performs another redeem of 30 units of the minted token (0, 1), thereby extracting 52 units of 0 and 17 units of 1 from the AMM. Note that the ratio of redeemed tokens is no longer
1-to-1 as in the previous redeem action (4), as the prior left swap
has changed the ratio between the funds of 0 and 1 in the AMM.

More formally, any move (, ) from the initial state (, X) must satisfy the following conditions:

mset () - txM ()  X dom ()  T0  : M [] |  -- 

( contains actions in X or by M) (M starts with atomic tokens) ( is enabled)

A solution to the game is a move that maximizes M's gain, i.e. the change in M's net worth after performing the block X from . Intuitively, the net worth of a user is the overall value of tokens in her wallet. To define this value, we first need to associate a price to each token. We provide the needed definitions below.

Token prices. We assume that the prices of atomic tokens are

given

by

an

oracle

P



T0



R+,
0

and

that

they

remain

constant

during the game. We then define the price P(0, 1) of a minted

token (0, 1) in a state  as follows:

P(0, 1)

=

0

·

P (0) + 1 · P (1) sply (0,1) ()

if res0,1 () = (0, 1)

(7)

The ratio behind this definition is that minted tokens are priced

3 RATIONAL MINERS
The model in the previous section defines how the blockchain state evolves upon a sequence of transactions, but it does not specify how this sequence is formed. What happens in practice is that users

such that the net worth of a user is preserved when the she redeems minted tokens in her wallet (see Lemma 6 in [13]).
Net worth and gain. We define the net worth of a user A in state  as follows:

broadcast their transactions to the blockchain network. Special nodes of this network -- called miners -- order users' transactions, group them into blocks, and append these blocks to the blockchain. The other nodes of the blockchain network follow the order chosen by miners to execute transactions, and accordingly update their local view of the blockchain state.
Miners are incentivized to perform their task by block rewards and by fees paid by users for each transaction included in a block. Besides this, miners can exploit knowledge of the upcoming transactions to further increase their gain. To this purpose, miners can filter and sort users' transactions however they want, and possibly insert their own transactions in a block. We can then interpret mining as a game, where a miner competes against users to maximize its short term gain. We formalise below the mining game and the notion of rational miner, which are pivotal to our main results, i.e. algorithms to compute rational strategies for miners.

  A () = 

 dom ()  () · P()

if A []  

(8)

0

otherwise



We denote by GA (, ) the gain of user A upon performing a

sequence of transactions  from state . Formally:

GA (, ) = A () - A () if  -- 

(9)

0

otherwise

Rational miners. From the definition of the mining game above, we characterise rational miners as those which, for all initial states (, X) of the game, always choose a move (, ) that maximizes the function (on balance  and sequence of transactions ):
GM (M [] | , )
We define the maximum extractable value in (, X) as the gain obtained by a rational miner by applying any solution (, ):

3.1 The mining game

MEV (, X) = GM (M [] | , )

We model mining as a single-player, single-round game. The only player is the miner, denoted by M (with M  A). The initial state of the game is given by a reachable blockchain state  (not including M's wallet) and by a finite multiset X of user transactions, representing the pool of pending transactions (also called txpool). The moves of M are pairs (, ), where  is the initial miner balance, and  is a block formed by (part of) the transactions in X, and by any number of M's transactions. The initial balance  may include any amount of atomic tokens: this reflects the fact that miners can trade their assets for atomic tokens through crypto-exchanges. We
assume instead that  does not include minted tokens, as the miner
can always obtain any amount of minted tokens by performing
suitable deposits actions. We further require that the sequence of transactions  in a move is enabled in state .

3.2 An example: sandwich attacks
We illustrate how miners can extract value from user transactions,
by consolidating the intuitions given by the example in Section 1. Recall that we are assuming an AMM holding 100 units of ETH and 100 units of WETH, hereby abbreviated by 0 and 1, respectively, with price set to 1,000 by the oracle. Figure 2 shows the initial state , which includes the AMM together with the wallets of A and M. The txpool contains the transaction T = A : swap0 (40 : 0, 35 : 1), only. If performed, T would allow A to swap 40 units of 0 in her wallet for at least 35 units of 1. However, T is not enabled in , since the required swap values would violate the swap invariant. One option for the miner is to drop T, but doing so would not increase its gain, i.e. GM (, ) = 0. A better alternative is to sandwich T as

4

 = A [40 : 0 ] | M [35 : 1 ] | (100 : 0, 100 : 1) | · · · --M-:-s-w-a-p-1-(-11-.-2-:-0-,1-2-.-7:--1) A [ · · ·] | M [11 : 0, 22.3 : 1 ] | (89 : 0, 112.7 : 1) | · · ·
--A-:s-w--ap-0-(-4-0-:-0-,-35-:--1) A [0 : 0, 35 : 1 ] | M [ · · ·] | (128.8 : 0, 77.7 : 1) | · · · --M-:-s-w-a-p-1-(-28-.-7-:-0-,2-2-.-3:--1) A [ · · ·] | M [40 : 0, 0 : 1 ] | (100 : 0, 100 : 1) | · · ·

a generalization of the so-called arbitrage problem, which has been studied before in [11, 12] in the restricted setting where players can only perform swap actions, and in [13] under an abstract notion of swap invariant. The 1-txpool case is the basis for greedy approaches trying to solve the mining game transaction-by-transaction. We show an instance of this approach in Section 4.5.

Figure 2: A miner sandwich against a user swap action.

Number of transactions in a block. In the general game, the sequence  in the solution can contain an arbitrary number of

in Figure 2. This results in the transaction sequence  indicated in
the figure. In this case the the gain for the miner is:
GM (, ) = (11.2 + 28.7) · P (T0) - (12.7 + 22.3)P (T1)  5, 000 As a matter of fact, any balance  such that  (1)  35 and  (0, 1) = 0 makes (, ) a solution to the mining game in (, [T]), and 5, 000 is indeed the maximum extractable value, i.e. MEV (, [T]) = 5, 000. Example 4.10 in Section 4.4 will provide a detailed explana-
tion of how such solution is constructed.

transactions. In practice, blockchain platforms usually impose a limit to the size of blocks. We can model this constraint by bounding the size of  to a given constant . Although this variant makes finding exact solutions to the game more complex, it is still possible to use the solution of the unbounded-block game as a sub-optimal solution of the bounded-block variant, i.e. the bounded sequence  increases M's gain, but not in an optimal way (see Lemma 3.3).
3.4 Basic properties
We now state some general properties on the mining game which

3.3 Variants of the mining game
The version of the mining game presented above is quite general, as it does not constrain the number of miner and user transactions, the number of AMMs in the state, and the amount of tokens in wallets. By adding constraints on the initial state and on the solution, we can obtain several meaningful variants of the game. We systematize below these variants, by providing a taxonomy of mining games

give key insight on the solutions constructed in Section 4. The following Lemma establishes that performing transactions
preserves the global net worth, i.e. the gains of some users are balanced by equal overall losses of other users.
Lemma 3.1 (Wealth conservation). Let  --T . Then: A GA (, T) = 0

along four features.
Miner balance. In the general mining game, the solution includes an initial miner balance , which is one of the two parame-
ters against which the solution maximizes the MEV. In practice, this
means that we assume miners to have an unbounded availability
of atomic tokens. This assumption is not completely unrealistic, as
the miner can exchange its assets for atomic tokens, and deposit
these tokens to obtain minted tokens by the AMMs. Further, miners can temporarily increase their balance by flash loans [20, 21], which are incorporated in main AMM platforms like Uniswap [4]. We call balance-bounded the variants of the game where we assume that the miner balance is fixed a priori. Formally, the initial blockchain state  now contains a given miner wallet M [], and the move of the game is just a block . In this variant, the solution to the game must maximize the one-variable function GM (, ), and the maximum extractable value in (, X) is defined accordingly as MEV (, X) = GM (, ), where  is a solution to the game.
Number of AMMs. In the general game, the initial blockchain state  may contain an arbitrary number of AMMs. We call 1-AMM the variant of the mining game where all the actions in the solution
 target a single AMM. This variant is still worth of study, because it
may allow to solve the general problem in two phases: first, compute
the solution for each individual AMM, and then greedily apply the

By using a simple inductive argument, we can extend Lemma 3.1 to sequences of transactions: if  -- , then the summation of the gains GA (, ) over all users (including the miner) equals to 0. Hence, the mining game is a zero-sum game.
The solution of a mining game singles out a specific balance
 of the miner for which the  is the optimal move. The follow-
ing Lemma extends the set of balances for which  is optimal:
any balance with more atomic tokens than in  is still a solution, provided that it holds no minted tokens. Below, we write     whenever the following conditions hold:
  dom ()  T0 :  ()   ()   dom ()  T1 :  () =  ()
Lemma 3.2. Let (, ) be a solution to the mining game in (, X). For all   such that    , ( , ) is a solution to the game in (, X).

The following Lemma allows miners to re-use a solution  of the general mining game in case blocks have a bounded length. If  exceeds the maximum length  of the block, any subsequence of length   is a sub-optimal solution to the bounded-block game.

Lemma 3.3. Let (, ) be a solution to the mining game in (, X).

Then,

any

prefix




of



of

length

bounded

by



is

a

sub-optimal

solution to the bounded-block variant of the game.

locally-optimal move to each AMM. We show an instance of this approach in Section 4.3.
Size of txpool. In the general game, the txpool X can contain an arbitrary (finite) multiset of user transactions. Two relevant subcases are when the X is empty (called 0-txpool), and when it contains exactly one transaction (1-txpool). The 0-txpool variant is

The following Lemma allows miners to restrict the type of trans-
actions to consider in a 0-txpool game: a solution can contain only swap actions, while dep and rdm actions can be neglected. More specifically, the Lemma states that if a sequence of transactions  (possibly including dep and rdm) yields a certain gain, there exists a sequence  containing only swaps and yielding the same gain.

5

Lemma 3.4. Let  be such that  -- and usr () = {M}. Then, there exists some  such that usr () = {M}, type() = {swap} and GM (, ) = GM (, ).
The idea of the proof of Lemma 3.4 is to rearrange the transac-
tions in . Indeed, transactions operating on different AMMs can be
reordered without affecting the semantics of the sequence. Trailing occurrences of dep and rdm transactions (i.e., without subsequent swap transactions on the same AMM) can be removed, since they do not affect the gain. The crucial point of the proof is the elimination of non-trailing occurrences of dep and rdm transactions. A subsequence containing a dep transaction immediately followed by a swap transaction on the same AMM can be replaced by a single swap transaction, with the same swap direction and adjusted swap values. The same can be done for the subsequences containing a rdm transaction immediately followed by a swap transaction. For a more detailed proof of this point, see Lemma A.1 in Appendix A.
4 SOLVING THE MINING GAME

Solving the mining game through an exhaustive search of the optimal move is not possible: indeed, even assuming that the number of transactions in  is bounded, the state space is unbounded, since the actual parameters of M's transactions are chosen from an infinite set. In this Section we construct solutions to the mining game, both in its general form and in some relevant variants. Figure 3 provides an overview of the games we consider.

4.1 1-AMM, 0-txpool game

We recall that in this variant of the game, the miner can operate on
a single AMM, and there are no transactions in the txpool. In order
to construct a solution to this game (Theorem 4.5), we need some auxiliary definitions. Let 0, 1 be atomic token types, and let  be a state with res0,1 () = (0, 1). For each swap direction   {0, 1}, we define the canonical swap values as:







(0, 1,

)

=

P (1- ) P ( )

· 0

· 1

- 


1-

(0, 1,

)

=

1-

· 


(0, 1,

)



+  (0, 1,


)

Intuitively, these values define the amount of tokens to be ex-

changed when the solution to the game is indeed a swap of tokens.
The value  is the amount of tokens deposited in a swap of direc-

tion : it is defined in such a way that, after the swap, the AMM

reaches an equilibrium, where the ratio of the AMM reserves is

equal

to

the

(inverse)

ratio

of

the

token

prices.

The

value



 1-

is

the amount of tokens received back after the swap, and it is com-

puted as a function of  : it is the unique value for which the swap

invariant is satisfied. If a swap direction  satisfies:

and we denote this transaction by X (0, 1, ). When we want to remark that  is the swap direction, we write X (0, 1, ).

Lemma 4.1. If the canonical swap transaction X (0, 1, ) is de-

fined,

then

it

is

enabled

in

M []

|



whenever

 ( )



 (0, 1,


).

Proof.

Let 

=





(0,

1,

)

let 1-

=


1-

(0,

1,

),

and

let

0 = M [] | . The assumption  ( )   guarantees that M has

enough balance of  to deposit to the AMM. So, we just need show

that the swap values respect the premise of rule [Swap] , i.e.:

1-



1- ·   + 

This

follows

directly

by

the

definition

of



 1-

(0,

1,

).



Example 4.2. Let  = (18 : 0, 6 : 1), and let the prices of the atomic tokens be P (0) = 5 and P (1) = 9. We have that:



1

1

(0,

1,

)

=

5 · 18 · 6 - 6  1.75
9

1

0

(0,

1,

)

=

18 · 1.75 6 + 1.75



4

The canonical swap transaction is T = M : swap1 (4 : 0, 1.75 : 1).
We anticipate that, by Theorem 4.5, the solution of the mining game
is (, T), for any  such that  (1)  1.75 and  (0, 1) = 0. Since  has enough units of 1 to perform the right swap, M can fire T from M [] | , reaching the state:

M [ - 1.75 : 1 + 4 : 0] | (14 : 0, 7.75 : 1)

In this state, the AMM has reached an equilibrium, where the ratio of the reserves equals to the (inverse) ratio of the token prices:

14 = 1.8 = P (1)

7.75

P (0)

The gain of M after this step is:

(4 · 5 - 1.75 · 9) · 1 -  (0, 1) sply (0,1) ()
Note that requiring  (0, 1) = 0 ensures that this gain is maximized (to 4.57). Any other choice would result in a lower gain for M. 

The following Lemma establishes that swap directions are mu-

tually exclusive: if the deposited canonical value for direction 

is

positive

(i.e.,




(0,

1,

)

>

0),

then

the

value

for

the

opposite

direction

is

negative

(i.e.,

 1-


(0,

1,

)

<

0),

and

vice

versa.

Further,

the deposited and redeemed canonical values for the same direction

have the same sign. Hence, if a swap transaction with the canonical

values is enabled in a given direction , then the transaction in the

opposite direction is not enabled, because its values are negative.

The Lemma also states that if a swap value in a given direction is

zero, then also the values in the other direction are zero.





(0, 1,

)

>

0

Lemma 4.3. For   {=, >}:

then we define the canonical swap transaction (a potential solution to the game, as we shall see) as:

M

:

swap

(
0

(0,

1,

)

:

0,



1

(0, 1,

)

:

1)





(0,

1,

)



0




1-

(0,

1,

)



0

and

0





1- 1-

(0,

1,

)

The following Lemma quantifies the gain of M upon firing a swap transaction (not necessarily the canonical one).

6

k-AMM, 0-txpool, -balance § 4.3

k-AMM, 1-txpool, -balance § 4.4

k-AMM, n-txpool, -balance (general mining game) § 4.5

k-AMM, 0-txpool, bounded-balance

k-AMM, 1-txpool, bounded-balance

k-AMM, n-txpool, bounded-balance

1-AMM, 0-txpool, -balance § 4.1

1-AMM, 1-txpool, -balance

1-AMM, n-txpool, -balance

1-AMM, 0-txpool, bounded-balance § 4.2

1-AMM, 1-txpool, bounded-balance

1-AMM, n-txpool, bounded-balance

Figure 3: Variants of the mining game: "-AMM, -txpool, " indicates a game with  AMMs, a txpool of size , and where the miner wallet is  (bounded or unbounded). Some variants are labelled with the subsection where their solution is provided. Arrows relate games by their relative restrictions (the target game has more constraints than the source game).

Lemma 4.4 (Swap gain). For all 0 = M [] |  such that the transaction T = M : swap (0 : 0, 1 : 1) is enabled in 0:

GM (0, T) = 1- P (1- ) -  P ( )

1 -  (0, 1) sply (0,1) (0)

canonical swap T = X (0, 1, ) = M : swap (0 : 0, 1 : 1) is defined or not. If T is defined, then the swap direction  satisfies:



=





(0,

1,

)

>

0

By definition of the canonical swap values, this implies:

Proof. Let 0 = M [] | , let T = M : swap (0 : 0, 1 : 1)

and

let


0

be

such

that

0

--T

.
0

Let

res0,1

()

=

(0, 1).

By

(9):

GM (M [] | , T) = M (0) - M (0)

By definition of net worth (8), we have that:

M (0) =  ( ) · P ( ) +  (1- ) · P (1- )

+

 (0, 1)

·



·

P ( ) + 1- · P (1- ) sply (0,1) (0)

+ {0,1,(0,1) }  () · P0 () M (0) = ( ( ) -  ) · P ( ) + ( (1- ) + 1- ) · P (1- )

+

 (0, 1)

·

(

+

 )

·

P ( ) + (1- - 1- ) sply (0,1) (0)

·

P (1- )

+

  {0,1, (0,1 )

}

 ()

·

P 0

( )

Since

P0

( )

=

P () 0

for

all





{0, 1,

(0, 1)},

it

follows

that:

M (0) - M (0)

=

1-

·

P (1- )

- 

·

P ( )

+



·

P ( ) - 1- · P (1- ) sply (0,1) (0)

1

= 1- · P (1- ) -  · P ( )

1- sply (0,1) (0)



We are now ready to construct the solution to the 1-AMM, 0-txpool game. Intuitively, the optimal move is the canonical swap transaction when defined, or otherwise it is just "do nothing".

Theorem 4.5. Let  = (0 : 0, 1 : 1) |  , where  only contains user wallets, and let X = []. If the canonical swap is undefined, then (, ) is a solution to the game, for all . Otherwise, (, X (0, 1, )) is a solution to the game, for all  such that  ( )   (0, 1, ) and  (0, 1) = 0.


Proof. Let 0 = M [] | , where  respect the hypotheses in the statement. For all  > 0, let:

Y0 () = M : swap0 ( : 0, 0 : 1) Y1 () = M : swap1 (1 : 0,  : 1)



=

1- ·   + 

Note that Y () is enabled in 0 for all  such that  ( )  , since   1- for all . There are two cases, depending on whether the

  1- P (1- ) -  P ( ) > 0

(10)

and, by Lemma 4.3, it also follows that:

1-

=


1-

(0,

1,

)

>

0

1-
1-

(0,

1,

)

<

0

We first show that Y1- () decreases M's gain, for all . Let  be

any balance be such that

without minted 0 --Y-1----(--) .

tokens, let 0 = We have that:

M []

|

,

and

let



GM (0, Y1- ()) = M () - M (0)

= 1- P ( ) - P (1- )

=

 ·  1- + 

P ( )

-

P (1- )

=   P ( ) -  (1- + )P (1- ) 1- + 

=   P ( ) - 1- P (1- ) + 2P (1- ) 1- + 

= - - 2P (1- ) 1- + 

By (11) we have  > 0: therefore, G0 (M, Y1- ()) < 0, i.e. Y1- () decreases M's gain, for all . We then show that the gain for M
with the canonical swap transaction T is greater than any swap

transaction with direction , i.e. for all  > 0:

GM (0, T)  GM (0, Y ()) By Lemma 4.4, and using the assumption that  (0, 1):

GM (0, Y ()) =  P (1- ) -  P ( )

=

1- ·   + 

P (1- ) - 

P ( )

=

1-

·



P (1- )

-  P ( )

-

2


P ( )

 + 

=  - 2 P ( )  + 

To find the maximum of GM (0, Y1- ()), we find the point  for

which the derivative is 0. We have that:

 

GM (0, Y ())

=





- P ( )  (2 ( + )2



+ )

7

This derivative equals to zero if and only of:

4.3 0-txpool game



=



·

( +  P ( )) P ( )

- 

By expanding the definition of  in (11):



=

P (1- ) P ( )

· 

· 1-

-



=





(0,

1,

)

By Lemma 3.4, we can restrict to sequences of swap transactions. Then, the canonical swap transaction maximizes M's gain.

Otherwise,

if

T

is

undefined,

it

must

be




(0,

1,

)

=

0

for 



{0, 1}. By definition of the canonical swap values, this implies:

  1- P (1- ) -  P ( ) = 0

(11)

For all   0, we have that:

GM (0, Y1- ())

=

- - 2P (1- ) 1- + 

=

-2P (1- ) 1- + 

0

Therefore, the empty move is a solution to the game.



4.2 Balance-bounded 1-AMM, 0-txpool game

The solution of the balance-bounded variant of the game is similar

to that of Theorem 4.5, except that now the canonical swap values

depend also on the initial miner's balance . Formally, let 0, 1 be atomic token types, let  be a balance, let  be a state with res0,1 () = (0, 1) and with M []  . For each swap direction   {0, 1}, we define the bounded canonical swap values as:







(0,

1,

,

)

=

min

 ( ),

P (1- ) P ( )

· 0

· 1

- 


1-

(0,

1,

, )

=

1-

·




(0, 1,

,

)



+  (0, 1,


, )

If a swap direction  satisfies the inequality:





(0, 1,

,

)

>

0

then we define the bounded canonical swap transaction as:

M

:

swap

(
0

(0,

1,

, )

:

0,



 1

(0,

1,

, )

:

1)

and we denote this transaction by X (0, 1, , ). When we want to remark that  is the swap direction, we write X (0, 1, , ).

Example 4.6. Recall the state  = (18 : 0, 6 : 1) from Example 4.2, and now assume that the miner M has an initial balance  = {1 : 0}.
The bounded canonical swap transaction is:

We now generalise the solution constructed in Section 4.1 to the

case where the miner can operate on multiple AMMs, still assuming

that the txpool is empty. We construct the solution to this game

by greedily solving the 1-AMM game for each AMM in the state,

and then composing the obtained solutions. Below, we indicate

with




the

concatenation

of

two

sequences,

and

with



+



the

composition of two balances, i.e. ( +  ) () is the summation of

the balance of  in  and in  .

Theorem 4.8. Let  =    (,0 : ,0, ,1 : ,1) |  be such that  only contains user wallets. For all    , let ( ,  ) be a solution to the 1-AMM game in (, []) such that M only operates on the AMM pair (,0, ,1). Then, (1 + · · · + , 1 · · · ) is a solution to the 0-txpool game in (, []).

4.4 1-txpool game
In this variant of the mining game, we assume that the miner can perform actions on multiple AMMs, and that X contains exactly one transaction. Here, it is helpful to consider the wealth of A as wealth components from both minted and atomic token balances:





A () =

 () · P () +

 () · P() (12)

 dom ()T0

 dom ()T1

In the 0-txpool game, the net worth of users is only affected by changes in the prices of minted tokens, since no user actions are performed which exchange units of tokens: thus, if for all users the net worth either stays constant or is reduced, the miner gain must be positive (Lemma 3.1). Further, if the minted token prices are minimized, the miner's gain must be maximized.
In the 1-txpool game, only a single user will experience a change in its balance if the miner includes the user transaction in the solution. Further, atomic token prices are fixed whilst minted token prices are minimized by the miner, since they reduce the net worth of users holding such tokens, thereby implying a gain for the miner.
The strategy of the miner is to first consider whether to include the user action, and then to subsequently perform the canonical swap on all pairs, which can be interpreted as a 0-txpool game. Importantly, the following lemma states that the 0-txpool game played in two states, where one is reachable from the other, will always result in the same minted token prices.

Lemma 4.9. Let M [] | 0  M [_] | 1, where 0 =    (,0 : ,0, ,1 : ,1) |  be such that  only contains user wallets, and AMM reserves of all pairs    are non-zero in the execution. Let:

M : swap1 (2.57 : 0, 1 : 1) The gain of M after firing this transaction is:

2.57 · P (T0) - 1.75 · P (T0) = 2.57 · 5 - 1.75 · 9 = 3.86

Note that this gain is lower than 4.57, i.e. the gain obtained in the

unbounded-balance case.



Theorem 4.7. Let  = M [] | (0 : 0, 1 : 1) |  , where  only contains user wallets, and let X = []. If the bounded canonical swap is undefined, then  is a solution to the game. Otherwise, X (0, 1, , ) is a solution to the game.

M [0] | 0 --0 M [_] | 0 M [1] | 1 --1 M [_] | 1 (13)

where (0, 0) and (1, 1) are solutions in (0, []) and (1, []), re-

spectively. Then, P (,0, ,1) = P (,0, ,1) for all    .

0

1

A practical consequence of Lemma 4.9 is that user actions do not affect the price minimization performed by the miner to maximize its gain: the decision to include or drop a user transaction does not affect the minted token prices resulting from a subsequent 0-txpool game. Thus, if including the user transaction increases the miner gain, it will always be included in the 1-txpool game solution.

8

For a user swap action, the exchanged value of atomic tokens determines whether it is profitable for the miner. The miner therefore executes the user swap, if the value of atomic tokens sent

M [35 : 1 ] | A [40 : 0 ] | (100 : 0, 100 : 1) | · · · --S-FX--(--0-,-1-,-,-T) M [11.2 : 0, 22.3 : 1 ] | (88.8 : 0, 112.7 : 1) | · · ·

by the user is higher than value of atomic tokens received. In the subsequent state, the miner executes the 0-txpool game solution, thereby minimizing all minted token prices. The swapping user has its wealth reduced: both from the swap and the reduced price of minted tokens it holds. All other users have their weath reduced

--T-=-A-:-sw--a-p-0-(4-0-:-0-,-3-5:--1) A [0 : 0, 35 : 1 ] | (128.8 : 0, 77.7 : 1) | · · · --X-(--0-,-1-,-- ) M [40 : 0, 0 : 1 ] | (100 : 0, 100 : 1) | · · ·
Figure 4: 1-txpool game solution with a user swap.

by the minimization of minted token prices. Thus, by Lemma 3.1,

the miner must experience a positive gain. In some cases, maximizing the gain resulting from the user swap requires a front-run

We define the canonical swap front-run values as

transaction by the miner. A user dep action does not affect the user's net worth during
the execution step: however, by increasing the balance of the user's minted tokens, any subsequent reduction of minted tokens caused by M can increase the reduction of the user's net worth, thereby motivating its inclusion. By contrast, a user rdm action is not included in the solution of the 1-txpool game, as a rdm step does not change the net worth of the user and the prices of redeemed tokens

SFdM (0, 1, , T) =

SFdA (0, 1, , T) - dA dA - SFdA (0, 1, , T)

if dM = dA if dM = 1 - dA

SF1-dM (0, 1, , T) =

1-dM - SF1-dM (0, 1, , T) SF1-dM (0, 1, , T) - 1-dM

if dM =  if dM = 1 - dM

Finally, the canonical swap front-run transaction is given by:

cannot be negatively affected by subsequent miner actions. We proceed by providing an overview of the 1-txpool game
solutions by user action type, each followed by specific examples.

SFX (0, 1, , T)

(16)

= M : swapdM (SF0 (0, 1, , T) : 0, SF1 (0, 1, , T) : 1)

We conclude the section by formalizing auxiliary definitions and

the general solution to the 1-txpool game in Theorem 4.13.
User swap. The solution to the 1-txpool game solution includes the user swap action if it can be enabled such that (1) the user gain is minimized and (2) the user gain is negative. For A : swap (0 : 0, 1 : 1) condition (1) holds if the user receives 1- : 1- in the swap execution and condition (2) holds if 1- ·P (1-1)- ·P ( ) < 0. Here, it may be necessary for the miner to front-run the user
swap action, in order to enable the user swap such that condition (1) holds. We denote this the swap front-run transaction performed by the miner (16). Following the execution of the canonical swap
front-run and user swap (if unprofitable for the user), the miner has minimized M's wealth derived from its atomic token balance (12). In the subsequent state, no further user action is considered, such that
the miner can only further reduce each users wealth by minimizing
the price of minted tokens: this is equivalent to the 0-txpool game.
We now define the canonical swap front-run transaction. For  = (0 : 0, 1 : 1) | · · · and T = A : swapdA (0 : 0, 1 : 1), let the canonical swap front-run reserves be

Example 4.10. Recall the example in Section 1 and in Section 3.2, where A emits a transaction T = A : swap0 (40 : 0, 35 : 1) in state  = (100 : 0, 100 : 1) | , where  only contains user wallets, A [40 : 0]   and P (0) = P (1) = 1, 000. The execution of the game solution (, ) is shown in Figure 4, which recasts Figure 2

with the notation of this section. The user action must be included

in the game solution since 35 · P (1) - 40 · P (1) = 35, 000 - 40, 000 = -5, 000 is negative. In order to realize this gain, a canonical swap

front-run transaction is needed: we compute the canonical swap

front-run reserves for the 1-txpool game (, [T]):



402 · 352 + 4 · 40 · 35 · 1002 - 40 · 35

SF0 (T, ) =

2 · 35

 88.8

1002

SF1 (T, ) =

 112.7

89

Since SF (T, )  100 for   {0, 1} and thus differs from the
reserves in the initial game state, the miner must first fire a user front-run transaction M [] |  --S-F-X--(-T-,-) M [ ] |  such that



2
0

·

2
1

+

4

·

0

·

1

·

0

·

1

SFdA (0, 1, , T) =

2 · 1-dA

SF1-dA

(0, 1,

, T)

=

0 · 1 SFdA (0, 1,

, T)

- 0 · 1

These reserve values define a state  which is reachable from M [] |  with a canonical swap front-run transaction by the miner.

 = (SFdA (0, 1, , T) : dA , SF1-dA (0, 1, , T) | · · · (14)

Further, let the canonical swap front-run direction be:

dM =

dA 1 - dA

if SFdA (0, 1, , T) > dA if SF1-dA (0, 1, , T) > 1-dA

(15)

 = A [40 : 0] | (SFdA (0, 1, , T) : dA , SF1-dA (0, 1, , T) | · · ·
By definition, firing T in M [ ] |  results in the minimized user step gain GA (M [ ] | , T) = -5, 000. Since SF1 (0, 1, , T) > 1, the direction (15) of the front-running swap is dM = 1. Thus, we can compute the canonical swap front-run values and canonical swap front-run transaction as:
SF0 (0, 1, , T) = 100 - 88.8  11.2 SF1 (0, 1, , T) = 112.7 - 100  12.7
SFX (0, 1, , T) = M : swap1 (11.2 : 0, 12.7 : 1)
Here, M can perform SFX (0, 1, , T) with  (1)  12.7. After firing the canonical swap front-run and the user swap, we derive the 0-txpool solution in  = (128.8 : 0, 77.7 : 1) | · · · , shown

9

in Figure 4. For , the canonical swap values and transaction are:



 1 (0, 1, ) =

1 · 128.8 · 77.7 - 77.7  22.3
1

 0 (0, 1, )

=

128.8 · 22.3 77.7 + 22.3



28.7

X (0, 1, ) = M : swap1 (28.7 : 0, 22.3 : 1)

Considering the entire run from M [] | , we determine M's gain as

GM (M [] | , ) = (11.2-12.7) ·1, 000+(28.7-22.3) ·1, 000  5, 000, which is the loss of the user A. We can construct the miner balance

 greedily as the sum of all input amounts in the solution trace. Thus, our solution to the 1-txpool game (, [T]) is:

 = {1 : 35}  = SFX (0, 1, , T) T X (0, 1, )



User deposit. The solution to the 1-txpool game will include a user deposit action if it deposits funds in the AMM in a state,
from which the minted token price can further be reduced by miner actions. For a deposit A : dep(0 : 0, 1 : 1) in the 1-txpool game (, [T]), this is the case when
0  P (1) 1 P (0) holds, since in a reachable state  = (0 : 0, 1 : 1) | · · · where the deposit T is enabled, 0 = 0  P (1) 1 1 P (0)

and the values of the pair reserves are such, that a canonical swap
is defined (Section 4.1). Thus, although the deposit action step maintains the net wealth of A, the price of minted tokens (0, 1) received by the user in the deposit can subsequently be reduced by
a canonical swap performed by the miner.
Here too, it may be necessary for the miner to front-run the
user deposit in order enable its execution. We provide auxiliary definitions to formalize the canonical deposit front-run transaction.
For  = (0 : 0, 1 : 1) | · · · and T = A : dep(0 : 0, 1 : 1), let us denote the canonical deposit front-run reserves as



DF0 (0, 1, , T) =

0 1

· 0

· 1

(17)



DF1 (0, 1, , T) =

1 0

· 0

· 1

which satisfy: DF0 (0, 1, , T) = 0 DF1 (0, 1, , T) 1
Further, we define the canonical deposit front-run values as:

DFdM (0, 1, , T) = DFdM (0, 1, , T) - dM (18)
DF1-dM (0, 1, , T) = 1-dM - DF1-dM (0, 1, , T) if a swap direction dM satisfies both:
DFdM (0, 1, , T) > 0 DF1-dM (0, 1, , T) > 0 then we define the canonical deposit front-run transaction as:

DFX (0, 1, , T)

(19)

= M : swapdM (DF0 (0, 1, , T) : 0, DF1 (0, 1, , T) : 1)

The following example show how the miner can front-run a user deposit with a canonical deposit front-run transaction.

M [11.2 : 0, 18.2 : 1 ] | A [60 : 0, 40 : 1 ] | (50 : 0, 50 : 1) | · · · -D--F-X-(--0-,-1-,-,-T) M [0 : 0, 27.4 : 1 ] | (61.2 : 0, 40.8 : 1) | · · · --T-=-A-:-d-ep--(6-0-:-0-,-4-0:--1) A [0 : 0, 0 : 1, 49.0 : (0, 1) ] | (121.2 : 0, 80.8 : 1) | · · ·
--X-(--0-,-1-,-- ) M [22.2 : 0, 9.2 : 1 ] | (99.0 : 0, 99.0 : 1) | · · ·
Figure 5: 1-txpool game solution with a user deposit.

Example 4.11. Let T = A : dep(60 : 0, 40 : 1), and let  = (50 : 0, 50 : 1) | , where  only contains user wallets, A [60 : 0, 40 : 1]   , and P (0) = P (1) = 1. The execution of the solution is shown in Figure 5. By rule [Dep], T cannot be fired in , since the deposit ratio 60/40 does not equal the reserve ratio 50/50 of the (0, 1) pair: however, this also implies that the miner
can profit from executing the user deposit in the game solution.
In order to execute T, M must produce a front-running transaction. We first compute the canonical deposit front-run pair reserves:



60

DF0 (0, 1, , T) =

· 502  61.2

40

40 · 61.2

DF1 (0, 1, , T) =

 40.8

60

This gives the following canonical deposit front-run values:

DF0 (0, 1, , T) = 61.2 - 50  11.2 DF1 (0, 1, , T) = 50 - 40.8  9.2 and the canonical deposit front-run transaction is:

DFX (0, 1, , T) = M : swap0 (11.2 : 0, 9.2 : 1)

Following the canonical deposit front-run by the miner, the
user's deposit T can now be executed. For T in Figure 5, note that we assume that the supply of (0, 1) is 50 in the initial state . Thus, the minted amount A receives for the deposit is:



=

0 0

· sply0,1 ()

=

60 · 50
61.2



49

To determine the required miner balance, we simply aggregate the
transaction input amounts from all miner actions. Thus, a solution to our 1-txpool game with a user deposit is given by (, ) where:

 = {11.2 : 0, 18.1 : 1} and  is determined by:

 = DFX (0, 1, T) T X (0, 1, )

M [] |  -D--F-X-(--0-,-1-,-,-T) M [ ] |  -T M [ ] | 

Finally, we compute the gain of A and of M as follows:

49.0

49.0

GA (, ) =

· 99.9 - 60 +

· 99.9 - 40 = -2.0

99.0

99.0

GM (, ) = -GA (, ) = 2



User redeem. Unlike user deposits, user redeems will reduce the MEV for the miner. If a redeem of (0, 1) occurs in a state where the price of (0, 1) is not minimized, A will experience a reduced
depreciation of her minted tokens.

Example 4.12. Let T = A : rdm(20 : (0, 1)) and  = (100 : 0, 100 : 1) |  where  contains only wallets, A [20 : (0, 1)]   and P (0) = 1.3 and P (1) = 1. We show an execution of game

10

solution, where  = X (0, 1, ) = M : swap1 (12.3 : 0, 14.0 : 1):

A [20 : (0, 1) ] | M [14.0 : 1 ] | (100 : 0, 100 : 1)
--M-:-s-w-a-p-1-(-12-.-3-:-0-,1-4-.-0:--1) A [ · · ·] | M [12.3 : 0, 0 : 1 ] | (87.7 : 0, 114 : 1)
where the miner gain GM (, ) = 12.3 · 1.3 - 14.0 · 1  2.0. We show a non-optimal, alternative trace, which includes A's
redeem, to illustate how M's gain is reduced by A's redeem.

A [20 : (0, 1) ] | M [11.2 : 1 ] | (100 : 0, 100 : 1) | · · ·

-A--:r-d-m-(-2-0-:(--0-,-1-)) A [20 : 0, 20 : 1 ] | (80 : 0, 80 : 1) | · · ·

-M--:-sw--a-p-1-(9-.-8-:-0-,1-1-.-2-:-1) A [ · · ·] | M [9.8 : 0, 0 : 1 ] | (70.2 : 0, 91.2 : 1) | · · ·

Here the miner gain is GM (, ) = 9.8 · 1.3 - 11.2 · 1  1.6. Note that reduction in gain results from the reduced swap amounts per-

formed in the 0-txpool game following the user redeem: this is due

to the deposit reduction resuling from the user's redeem.



Solution to the 1-txpool game. Having provided canonical definitions for action-specific scenarios of the 1-txpool game solution, we can now state the general 1-txpool game solution.

Theorem 4.13. Let  =    (,0 : ,0, ,1 : ,1) |  , where  contains only wallets, including A [A ], and let X = [T]. Then:

Case 1. If T = A : swapdA (0 : ,0, 1 : ,1),    and

A ,dA   ,dA

dA · P (,dA ) > 1-dA · P (,1-dA )

hold true, let

 = {SFdM (0, 1, , T) : ,dM }

 = SFX (0, 1, , T) T if SFX (0, 1, , T) is defined

T

otherwise

M []

|




-

M [_]

|



(


,

)

be

a

solution

to

the

game

in

(




,

[])

Then, ( +  , ) is a solution to the game in (, X).

Case 2. If T = A : dep(0 : ,0, 1 : ,1),    and

(A,0, A,1)  (0, 1)

0  P (,1) 1 P (,0)

hold true, let

 = {DFdM (0, 1, , T) : ,dM }

 = DFX (0, 1, , T) T if DFX (0, 1, , T) is defined

T

otherwise

M []

|




-

M [_]

|



( , ) be a solution to the game in (, [])

Then, ( +  , ) is a solution to the game in (, X).

Case 3. Otherwise, a solution of the 0-tx pool game in (, []) is a solution to the 1-txpool game in (, X).

4.5 The general game
We construct a solution for the general game in (, X), by greedily composing 1-txpool game solutions for each action in X. Because the solution is constructed by evaluating each T  X greedily,
we must ensure that each user has a sufficient balance of atomic

tokens to enable all its transactions in X in any order: we define the minimum input balance in the general game (, X) for A as:

in (A, X) =

in (A, T) + in (A, X) in (A, T)

if X = X - [T]  [] if X = [T]

  

{

:

 }



in (A, T)

=

 {0

:

0, 1

:

1}

{} 



T = A : swap (0 : 0, 1 : 1) T = A : dep(0 : 0, 1 : 1) T = A : rdm( : (0, 1))

A user must have a balance greater than its minimum input

balance for its transactions to be considered in the general game.

Such minimum balance is defined inductively by only aggregating

token amounts transferred away from the user in its transactions.

For redeems, no input token amounts are accounted for, as user

redeem actions are not part of the 1-txpool and n-txpool solutions.

Notably, this constraint results in a less general solution for the

general game: still, we believe it is not unrealistic: users are likely

to only broadcast transactions to the network, such that their token

balance is sufficient to enable all pending transactions in any order.

Theorem 4.14. Let  =    (,0 : ,0, ,1 : ,1) |  , where  contains user wallets only, and let X be a set of user transactions. Furthermore, for all A such that A [A ]   , A  in (A, X).
case 1. If X is empty, the solution to the n-txpool game is the 0-txpool game solution to (, []).
case 2. Otherwise, let X = [T] + X and (, ) be the 1-txpool game solution in (, [T]). Furthermore, let M [] |  -- M [_] |  and ( , ) be the n-txpool game solution to (, X). Then the game solution to (, X) is ( +  , ).

Here the solution is defined inductively: individual 1-txpool game solutions are aggregated for one user transaction at a time in any order. The minimum user input balance constraint ensures that each user balance enables its transactions in any sequence. The main proof idea is that each user transaction does not impact the miner gain contribution of any other transaction in the game: it is easily shown that the effect of each transaction on the user's token balance does not depend on the order of their execution. Further, Lemma 4.9 states that the minted token prices will always be equal after the 0-txpool game is played. Therefore, both token balance and token prices do not depend on the transaction order and can be optimized for maximimum miner gain in a greedy fashion.

5 RELATED WORK
Daian et al. [17] study the effect of transaction reordering obtained through priority gas auctions. These are games between users who compete to include a bundle of transactions in the next block, bidding on transaction fees to incentivize miners to include their own bundle. Notably, [17] finds empirical evidence of the fact that the gain derived from transaction reorderings in decentralized exchanges (DEX) exceeds the gain given by block reward and transaction fees in Ethereum. The same work also proposes a game model of priority gas auctions, showing a Nash equilibrium for players to take turns bidding, compatibly with behavior observed in the wild on Ethereum. Our mining game differs from that in [17],

11

since we assume a greedy miner wanting to maximize its gain at the expense of all the other users, exploiting arbitrages on AMMs.
Zhou et al. [25] provide a theoretical framework to study the front-running on AMMs. Here, two sandwich heuristics are provided: the front-run & back-run swap sandwich, and the novel frontrun redeem & back-run swap and deposit. This work uses a simplified swap semantics, where no minimum amount of received tokens is enforced by the AMM, users only perform swaps and hold no minted token balances (depositing and swapping agents are decoupled). Further, extractable value from arbitrage is considered separately. In comparison, we emphasize that our proposed model features all main user actions offered by leading AMMs. We include minimum swap amounts, user deposit and redeem actions as well as minted token balances. Thus, our game solution extracts the maximum value in a more complete setting, considering the victim transactions of both aforementioned sandwich attacks in [25], and leaving no arbitrage opportunities unexploited.
More general ordering and injection of transactions by a rational agent is generally referred to as front-running: Eskandari et al. [18] provide a taxonomy for various front-running attacks in blockchain applications and networks. This taxonomy is expanded in [19] with liquidations, sandwich attacks and arbitrage actions between DEX.
Some works investigate the problem of detecting front-running attacks on public blockchains. For example, in [19], Qin et al. introduce front-running detection heuristics which are deployed to empirically study the presence of such attacks on public DeFi applications. On the other hand, various fair ordering schemes have been proposed to mitigate front-running or exploitation of minerextractable value. However, simple commit-and-reveal schemes still leak information such as account balances. Breidenbach et al. [15] propose "submarine commitments", which rely on k-anonymity to prevent any leaks from user commitments. Baum et al. [14] introduce a order-book based DEX which delegates the matching of orders to an out-sourced, off-chain multi-party computation committee. Private user orders are not revealed to other participants, such that no front-running can occur in each privately-computed order matching round. Ciampi et al. [16] introduce a market maker protocol in which the strictly sequential trade history between an off-chain market maker and traders are verifiable as a hash-chain. Any subsequent reordering by the AMM is publicly provable: here, collateral from the market maker incentivizes honest, fair-ordering behaviour. Such work aims to provide alternative, front-running resistant designs with similar functionality to AMMs. In contrast, we note that our work is intended to formalize the behaviour of current, mainstream AMMs in the presence of a rational miner.
The DeFi community is developing tools to enable agents to extract value from smart contracts: e.g., mev-geth [6] is an Ethereum client implementation which supports transaction bundles. Rather than front-running individual transactions by adjusting their fees, an agent can communicate a sandwich of transactions to the miner, asking its inclusion in the next block. In practice, our game solutions can be implemented to solve for such transaction bundles.
6 CONCLUSIONS
We have addressed the problem of maximizing the value that miners can extract from users-AMMs interactions. Our mining games

provide the theoretical foundations for the notion of economicallyrational actors. We have constructed solutions to the mining game, providing efficient strategies that maximize value extraction. Even if we have focused on miners, our results apply to other kind of actors with the power to reorder, drop or insert transactions, e.g. roll-up aggregators like Optimism and StarkWare [7, 8]. Notably, our work shows that it is possible to extract value from all types of AMM transactions (swaps, deposits and redeems), while previous works focusses on swaps, only.
The main result of the paper, Theorem 4.14, solves the mining game in its general form, where we do not bound the block size and the miner's balance. The assumption that the miner has always sufficient balance to perform sandwiches is quite common [19, 24], and it reflects the fact that the miners have various options to obtain the needed tokens (e.g., buying, borrowing, or bribing). Also the assumption that blocks are unbounded is realistic. Indeed, a typical block will include other transactions besides those directed to AMMs, and so the miner can find enough space for its sandwiches by dropping non-AMM transactions.
To keep the presentation simple, we have abstracted from a few features found in some AMM platforms, namely transaction and swap fees, and lower bounds on deposit and redeem values. Fees affect the gain of miners, so they should be taken into account when constructing the miner strategy: for instance, fees may make convenient for a miner to include user redeem transactions, which are never used in our sandwiches. Besides fees, we abstract from the intervals that users can express to constrain the amount of tokens received upon deposits and redeems (we only model these constraints for swaps). Modelling this feature would give further opportunities to extract value. We leave a precise treatment of fees and on intervals as future work.
In this paper we have considered AMMs which implement the constant-product swap invariant, like e.g. Uniswap, Balance and Mooniswap. A relevant research question is how to solve the mining game under different swap invariants, e.g. those used by Curve Finance and Bancor. A uniform way to address this problem would be to follow the approach in [13], where swap invariants are abstracted as functions are subject to a given set of constraints.
REFERENCES
[1] 2020. Curve statistics. (2020). https://www.curve.fi/dailystats. [2] 2020. Curve website. (2020). https://www.curve.fi [3] 2020. Mooniswap implementation. (2020). https://github.com/1inch-
exchange/mooniswap/blob/02dccfab2ddbb8a409400288cb13441763370350/ contracts/Mooniswap.sol. [4] 2020. Uniswap flash loan implementation. (2020). https://github.com/ Uniswap/uniswap- v2- core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/ contracts/UniswapV2Pair.sol#L172. [5] 2020. Uniswap token pair implementation. (2020). https://github.com/ Uniswap/uniswap- v2- core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/ contracts/UniswapV2Pair.sol. [6] 2021. MEV Geth. (2021). https://github.com/flashbots/mev-geth. [7] 2021. Optimism website. (2021). https://optimism.io/. [8] 2021. StarkWare website. (2021). https://starkware.co/. [9] 2021. Uniswap V2 statistics. (2021). https://v2.info.uniswap.org/. [10] 2021. Uniswap website. (2021). https://www.uniswap.org. [11] Guillermo Angeris and Tarun Chitra. 2020. Improved Price Oracles: Constant Function Market Makers. In ACM Conference on Advances in Financial Technologies (AFT). ACM, 80­91. https://doi.org/10.1145/3419614.3423251 https: //arxiv.org/abs/2003.10001. [12] Guillermo Angeris, Hsien-Tang Kao, Rei Chiang, Charlie Noyes, and Tarun Chitra. 2019. An analysis of Uniswap markets. Cryptoeconomic Systems Journal (2019). https://ssrn.com/abstract=3602203.

12

[13] Massimo Bartoletti, James Hsin-yu Chiang, and Alberto Lluch-Lafuente. 2021. A theory of Automated Market Makers in DeFi. In COORDINATION. (to appear) https://arxiv.org/abs/2102.11350.
[14] Carsten Baum, Bernardo David, and Tore Frederiksen. 2021. P2DEX: PrivacyPreserving Decentralized Cryptocurrency Exchange. Cryptology ePrint Archive, Report 2021/283. (2021). https://eprint.iacr.org/2021/283.
[15] Lorenz Breidenbach, Philip Daian, Florian Tramèr, and Ari Juels. 2017. Enter the Hydra: Towards Principled Bug Bounties and Exploit-Resistant Smart Contracts. Cryptology ePrint Archive, Report 2017/1090. (2017). https://eprint.iacr.org/2017/ 1090.
[16] Michele Ciampi, Muhammad Ishaq, Malik Magdon-Ismail, Rafail Ostrovsky, and Vassilis Zikas. 2021. FairMM: A Fast and Frontrunning-Resistant Crypto MarketMaker. Cryptology ePrint Archive, Report 2021/609. (2021). https://eprint.iacr. org/2021/609.
[17] P. Daian, S. Goldfeder, T. Kell, Y. Li, X. Zhao, I. Bentov, L. Breidenbach, and A. Juels. 2020. Flash Boys 2.0: Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability. In IEEE Symp. on Security and Privacy. IEEE, 910­927. https://doi.org/10.1109/SP40000.2020.00040
[18] Shayan Eskandari, Seyedehmahsa Moosavi, and Jeremy Clark. 2020. SoK: Transparent Dishonesty: Front-Running Attacks on Blockchain. In Financial Cryptography. Springer International Publishing, Cham, 170­189. https://doi.org/10. 1007/978- 3- 030- 43725- 1_13
[19] Kaihua Qin, Liyi Zhou, and Arthur Gervais. 2021. Quantifying Blockchain Extractable Value: How dark is the forest? (2021). arXiv:2101.05511 https: //arxiv.org/abs/2101.05511
[20] Kaihua Qin, Liyi Zhou, Benjamin Livshits, and Gervais. 2021. Attacking the DeFi Ecosystem with Flash Loans for Fun and Profit. In Financial Cryptography. (to appear) https://arxiv.org/abs/2003.03810.
[21] Dabao Wang, Siwei Wu, Ziling Lin, Lei Wu, Xingliang Yuan, Yajin Zhou, Haoyu Wang, and Kui Ren. 2020. Towards understanding flash loan and its applications in defi ecosystem. arXiv preprint arXiv:2010.12252 (2020). https://arxiv.org/abs/ 2010.12252.
[22] Sam M. Werner, Daniel Perez, Lewis Gudgeon, Ariah Klages-Mundt, Dominik Harz, and William J. Knottenbelt. 2021. SoK: Decentralized Finance (DeFi). (2021). arXiv:cs.CR/2101.08778
[23] Yi Zhang, Xiaohong Chen, and Daejun Park. 2018. Formal Specification of Constant Product Market Maker Model & Implementation. (2018). https://github.com/runtimeverification/verified-smart-contracts/blob/ uniswap/uniswap/x- y- k.pdf .
[24] Liyi Zhou, Kaihua Qin, Antoine Cully, Benjamin Livshits, and Arthur Gervais. 2021. On the Just-In-Time Discovery of Profit-Generating Transactions in DeFi Protocols. (2021).
[25] Liyi Zhou, Kaihua Qin, Christof Ferreira Torres, Duc V Le, and Arthur Gervais. 2021. High-Frequency Trading on Decentralized On-Chain Exchanges. (2021). https://arxiv.org/abs/2009.14021.
13

A PROOFS
Proof. (Lemma 3.1) Direct consequence of Lemma 3 in [13]. 

Lemma A.1. Let  --T-0-T-1 , where:

type(T0)  {dep, rdm} AMM (T0) = (0, 1) usr (T0) = M

type(T1) = swap

AMM (T1) = (0, 1) usr (T1) = M

Then, there exists T such that type(T) = swap, AMM (T) = (0, 1), usr (T) = M and GM (, T0T1) = GM (, T).

Proof. Let  = (0 : 0, 1 : 1) | . We show that the maximum gain of T is greater than or equal to the gain of T0T1. The thesis then follows by continuity of the gain function. Let  be the swap direction of T1. We parameterize the swap transaction T over the deposited amount :

the state reached after performing T0. The deposited swap value after T0 is:




~



~ - (

+)

where


~



P (1- ) P ( )

· ( + ) ·

1-

+

1- 



Note that:



~ =

P (1- ) P ( )

· 1-

·

1 + 2 + 2
  2





=

P (1- ) P ( )

· 1-

·

1+ 


= ~ · 1 + 


by (22)

We now show that (~) = (~ ), i.e. the maximum gains of T0T1 and T are the same. First, note that:

T () = M : swap0 ( : 0, () : 1) if  = 0

(20)

M : swap1 (() : 0,  : 1) if  = 1

where the amount of received tokens of type 1- is given by:  () = 1- ·   + 
We can then compute the gain of T in  as a function of the deposited swap amount :

() = () · P (1- ) -  · P ( )

(21)

Now, choose T as the canonical swap transaction in . The deposited

swap value is:



~  ~ - 

where ~ 

P (1- ) P ( )

· 

· 1-

(22)

We consider now the case type(T0) = dep. The deposit transaction T0 must preserve the ratio between the reserved in the AMM. Then, given one of the values in T0, the other value is obtained as a function of the first. We can then write T0 as:

T0 =

M : dep( : 0,  () : 1) M : dep( () : 0,  : 1)

if  = 0 if  = 1

where the other value is computed as:

 () = 1-  

since this satisfies the condition   () = 1- required by the [Dep]. We can then relate the amount of deposited tokens in the swap T1

with the amount of received tokens as follows:

() =

1-

+

1- 



·

 +  + 

Similarly to (21), we estimate the gain of T0T1 as a function of the

deposited swap amount :




(

)

=

() · P (1- ) -  · P ( )

·   + 

where the rightmost factor is needed to take into account the minted
tokens received after the deposit T0. Now, note that the gain of T0T1 in  is bounded by the gain that
would be obtained when T1 is the canonical swap transaction in

(~ ) = =

1-

+

1- 



· (~ - ( + ))

 + (~ - ( + )) + 

1-

+

1- 



· (~ - ( + ))

~ 

=

1-  +1-  

· ~ -

1-

+

1- 



· ( + )

~ 

= 1- ( + ) - 

1-

+

1- 



~ 

· ( + )

Therefore:




(~

)

=

(~ ) · P (1- ) - ~  · P ( )

·   + 

=

1-

·

P (1- )

-

1- ( ~ 

+ )

·

P (1- )

-

~ 

·  

· P ( ) +

+ 

·

P ( )

and by expanding ~ in the equation:

= 1- · P (1- ) +  · P ( )
- 1- ( + ) · P (1- ) ~ · 1 + 


~ · 1 + 

-



·  · P ( )

 + 

= 1- · P (1- ) +  · P ( ) - 1- · P (1- ) - ~ · P ( ) ~

= 1- · (~ -  ) P (1- ) - (~ -  ) · P ( ) ~

=

1- · ~  + ~

P (1- )

-

~

·

P ( )

= (~)

which gives the thesis for the case type(T0) = dep. The case where

type(T0) = rdm is similar.



Proof. (Lemma 4.3) Straightforward arithmetic on the definition

of canonical swap values.



14

Lemma A.2. Let M [0] | 0  M [1] | 1, where 0 =    (,0 :

,0, ,1 : ,1) |  be such that  only contains user wallets, and

AMM reserves of pairs ,0, ,1 are non-zero in the execution.

case 1. Let

M [ ]
0

|

0

0

M [_]

|


0

where 0 consists of miner swaps 1 consisting of miner swaps or 

or  and

an1d0 1su0ch. Tthheant

there

exists

M

[ ]
1

|

1

1

M [_]

|


1

and P (,0, ,1) = P (,0, ,1) for    .

0

1

case 2. Let

M [ ]
1

|

1

1

M [_]

|


1

where 1 consists of miner swaps 0 consisting of miner swaps or 

or  and

an0d1 0su1ch. Tthheant

there

exists

M [ ] |  0 M [_] | 

0

0

and P (,0, ,1) = P (,0, ,1) for    .

0

1

Proof. (Lemma A.2) We prove by the lemma by induction.
Base case. For M [0] | 0 = M [1] | 1], the lemma holds trivially, for 0 = 1 and 0 = 1. Inductive Step: deposit / redeem. Let M [] |  T M [+1] | +1, where type(T)  {dep, rdm} and AMM (T) = (,0, ,1). By
definition of [Dep] and [Rdm]

 · sply (,0, ,1) = sply+1 (,0, ,1)

(

·

 ,
,0



·

 )
,1

=

(+1, +1)
,0 ,1

(23)

where res,0,,1 ()

=

( 


,

),

,0 ,1

res,0,,1 (+1)

=

(

+1
,



+1).

,0 ,1

Here,  > 1 for a deposit step and 1 >  > 0 for a redeem

step (lemma hypothesis: reserves are non-zero).

Let M [] |   M [_] |  where  consists of miner swaps or . Then for    the price of (,0, ,1), in  is given by

 

 

P (,0, ,1)

=

,0
sply (,0, ,1)

· P (,0)

+

,1
sply (,0, ,1)

· P (,1)

where

res

=

( 


,





).

,0 ,1

The

minted

token

supply

remains

con-

stant for a swap step by definition of [Swap]. Further, since the reserve product  · =   ·  invariant is preserved for swap actions,
,0 ,1 ,0 ,1

we can write

P (,0, ,1)

=

sply




0
(,0,

,1)

·P

(,0

)+

sply



 · 
,0 ,1
(,0, ,1

)

·   ·P (,1)
0

(24)

such that (24) gives us the the minted token price in  for a given

 .
,0

We

note

that

must

exist 

which

enables



in

M []

|

 :

a  can be constructed by aggregating all input token amounts

from actions in .
Then, let M [+1] | +1 +1 M [_] | +1 where +1 consists of miner swaps or . Substituting terms from (23), the price of (,0, ,1) in +1 is given by

+1 



P +1 (,0, ,1)

= 

,0
· sply (,0, ,1)

· P (,0)

(25)

2 ·  · 

+ 

,0 ,1
· sply (,0, ,1)

· +1 
,0

· P (,1)

15

Case 1 in Lemma A.2: for    and given   in (24), if +1 =

,0

,0



·

 
,0

in

(25),

then

P (,0, ,1)

=

P +1 (,0, ,1).

Thus,

for

any

 and , there exists +1 and +1 such that this holds.

Case 2 in Lemma A.2: for    and given +1 in (25), if

,0

 
,0

=

 +1
,0

/

,

then

P +1 (,0, ,1)

=

P (,0, ,1).

Thus,

for

any

+1 and +1, there exists  and  such that this holds.

Inductive Step: swap. Let M [] |  T M [+1] | +1, where type(T) = swap and AMM (T) = (,0, ,1). Then by defini-

tion of Swap

sply (,0, ,1) = sply+1 (,0, ,1)




·

= +1 ·+1

(26)

,0 ,1 ,0 ,1

Let M [] |   M [_] |  where  consists of miner swaps or . Then the price of (,0, ,1) in  is given by

 

 · 

P (,0, ,1)

=

sply



,0
(,0,

,1

)

·P

(,0

)+

sply



,0
(,0,

,1
,1)

·   ·P (,0)
,1

(27)

Then, let M [+1] | of miner swaps or .

+1 Then

+1 M the price

[o_f](| ,0,+1,1w) hinere+1+is1

consists given by

+1 



P +1 (,0, ,1)

=

,0

sply (,0, 1)

· P (,0)

+1 · +1

+

,0 ,1

sply (,0, ,1)

· +1 
,0

·

P (,1)

+1 

(28)

=

,0

sply (,0, ,1)

· P (,0)

 · 

+

,0 ,1

sply (,0, ,1)

· +1 
,0

·

P (,1)

Case 1 in Lemma A.2: for    and given   in (27), if   = +1

,0

,0 ,0

in (28), then P (,0, ,1) = P+1 (,0, ,1). Thus, for any  and

, there exists +1 and +1 such that this holds. Likewise for

case 2 of Lemma A.2.



Proof. (Lemma 4.9) The idea of the proof of Lemma 4.9 is to first

establish

that

for

any

state


0

reachable

from

0

with

swap

actions

only,

there

must

exist

a

state


1

reachable

from

1

with

swaps

such

that minted token prices in  and  are equal. Conversely, for

any state 
1
exist a state in  and 

0

1

reachable from 1 with swap actions only, there must


0

reachable

from

0

such

that

minted

token

prices

are equal. This is formally stated in Lemma A.2 and

0

1

proven in Appendix A. We show that if Lemma 4.9 does not hold,

Lemma A.2 is contradicted. Let M [] | 0  M [_] | 1, where 0 =    (,0 : ,0, ,1 :
,1) |  be such that  only contains user wallets, and AMM reserves of all pairs    are non-zero in the execution. The lemma

further assumes

M [0]

|

0

0

M [_]

|


0

(29)

M [1]

|

1

1

M [_]

|


1

where (0, 0) and (1, 1) are the 0-txpool game solutions of (0, )

and

(1, )

respectively.

We

prove

P

()
0

(,0,

,1

)

=

P

(

)
1

(,0,

,1)

for all    by contradiction.

By definition of the 0-txpool game, users token balance does

not change: instead, the game solution reduces users wealth with

miner swap actions, which minimize the price of minted tokens: no

further miner actions following the execution of the game solution

can result in lower prices, or lower gain of all non-miner users

(definition of game solution).

Let

us

assume

P

()
0

(,0,

,1)

<

P

(

)
1

(,0,

,1):

if

(1, 1)

is

a

game

solution

to

(1, ),

per

assumption

there

cannot

exist


1

consisting of swaps such that M [_]

|

1

1

M [_]

|

 and
1

P

()
0

(,0,

,1

)

=

P

(

 )
1

(,0,

,1)

for 





(otherwise

(1, 1)

is

not a 0-txpool game solution to (1, )). However, this assumption

contradicts

Lemma

A.2,

which

states

that

(1,

)
1

must

exist.

The

contradiction

for

P

(

)
0

(,0,

,1

)

>

P

()
1

(,0,

,1)

follows

similarly.

Thus,

P

()
0

(,0,

,1)

=

P

(

)
1

(,0,

,1)

must

hold.



Proof. (Theorem 4.13) We prove that the theorem produces a
game solution for (, [T]) where  =    (,0 : ,0, ,1 : ,1) |  ,  contains only wallets, including A [A ] where A = usr (T).
We refer to wealth components derived from minted and atomic

token balances implied from the definition of user net worth in Eq. (8).



A () =

 () · P () +  dom ( )/Tf  () · P () (30)

 dom ( ) Tf

For the 1-txpool game, only A = usr (T) experiences a change in

token balance, where as all other users do not. If the miner executes

the 0-txpool game in any state, prices of minted tokens are min-

imized, and thus, will affect the net worth of users holding these

tokens. By Lemma 3.1, if we can illustrate that all users experi-

ence a negative gain, this implies a positive gain for the miner: by

definition, a solution must maximize the gain for the miner.

case 1. For T = A : swapdA (0 : 0, , 1 : 1, ), where    , the wealth of A can be negatively affected in two ways. Firstly, the execution of T changes the users token balance, such that the

wealth component from atomic tokens may be reduced. Secondly,

all users will experience a reduced net worth if minted token prices
are reduced by actions performed by M. By conservation of wealth (Lemma 3.1) M will maximize its positive gain if all users experience

a minimized, negative gain. To ensure the minimized, negative step gain from T for A, there

must exist  and , where  consist of miner actions or , such that

M [] |   M [ ] |  T M [_] | 

(31)

and

GM (M [ ] | , T) = 1-dA · P (1) - 0 · P (0)

(32)

is negative. Assuming this is true and  consist of miner swaps or 

the following ,1)  

must

hold

for

(0

:

,0, 1

:

  ,1 )





and

( 
0

:





,0,



 1

:

0

× 1

=



0

×
1

=

(

 dA

+ dA )

×

(

 1-dA

-

dA )

(33)

which

holds

by

definition

of

[Swap].

Solving

for



 dA

0

× 1

=

(

 dA

+ dA )

×

(

0 

·


1

- dA )

dA

0

=

-

 dA

· 1-dA

+

dA

· 0 

· 1

- dA

· 1-dA

dA

0

=

-1-dA

·



 dA

2

- dA

· 1-dA

·


dA

+ dA

· 0

· 1

(34)
16

Here,

we

only

consider

the

positive

solution

of


dA

:



0 · 1 -


dA

=

2
0

·

2
1

+

4

·

0

·

1

·



-2 · 1-dA

(35)

Which coincides with the definition of SFdA (,0, ,1, , T). SF1-dA (,0, ,1, , T) follows similarly, implying SFX (,0, ,1, , T) defined (16). Thus, (32) holds for  = SFX (,0, ,1, , T), the canon-
ical swap front-run transaction for the 1-txpool game. We consider

the cases

1 M [1] |  SFX (,0,,1,,T) T M [_] | 1 1 M [_] | 1 2 M [2] |  T M [_] | 2 2 M [_] | 2

2 M [3] |  3 M [_] | 3

where 1, 2 and 3 are member of solutions to 0-txpool games in (1, []), (2, []) and (, []) respectively. In case (1) the step gain for the user when executing T is equal to (32) by definition. In case (2), we assume this is the case and that SFX (,0, ,1, , T) is undefined. Further, from Lemma 4.9, it follows that for all    :

P (,0, ,1) = P (,0, ,1) = P(,0, ,1)

1

2

If 1-dA · P (1) - 0 · P (0) < 0, then the game solution includes the action sequence of 1 if SFX (,0, ,1, , T) is defined, otherwise
sequence 2 . The gain for the miner in cases 1 and 2 is equal: user
A has the same change in token balance and the balances of all

other users is constant. Since, the minted token price is equal and

minimized at the end of both sequences, the total gain of all users

is negative, minimized and equal in 1 and 2 . By Lemma 3.1 the

miner's gain must therefore be maximized. It is easily shown that the miner gain in 3 is less than in 1 or 2 : here, the user A does not

experience the negative gain from the exchange of atomic tokens
in the swap step: A's gain in 3 is therefore higher than in 1 or 2 , implying a lower miner gain. If 1-dA · P (1) - 0 · P (0)  0, it is easily shown that 3 is the solution, since executing T in 1 or 2 increases A's gain.
Constructing the game solution (, ) for case (1) follows from

the prior discussion of sequences, and by aggregating the required

token amounts for the miner to execute the solution steps.

case 2. For T = A : dep(0 : ,0, 1 : ,1), where    . Here, the net worth of A can be negatively affected from increasing A's balance of (,0, ,1) when performing a deposit: the deposit step does not change A's net wealth, but a subsequent reduction in P (,0, ,1), where  is a state in which the miner has executed the 0-txpool game solution must result in a greater loss for A than if the deposit had not been performed.
Again, we consider:
1 M [1] |  DFX (,0,,1,,T) T M [_] | 1 1 M [_] | 1 2 M [2] |  T M [_] | 2 2 M [_] | 2
2 M [3] |  3 M [_] | 3

where 1, 2 and 3 are member of solutions to 0-txpool games in (1, []), (2, []) and (, []) respectively. Further, for all   

P (,0, ,1) = P (,0, ,1) = P(,0, ,1)

1

2

In 1 , the canonical deposit front-run transaction is required to enable T, whereas in 2 it is not. If

0  P (,1)

(36)

1 P (,0)

holds, it can easily be seen that then the canonical swap transaction

in Section 4.1 is defined. Thus, the price of this pair will be reduced

by the miner in the subsequent 0-txpool game, resulting in a loss

for the depositing user.

Thus, for deposits, sequence 1 is the solution if condition (36) holds and DFX (,0, ,1, , T) is defined. Case 2 is the solution if

(36) holds and the canonical swap is undefined and not required. Finally, 3 is a solution if (36) does not hold: here the price of the token will no longer be reduced, therefore not contributing to the miner's gain.

case 3. For T = A : rdm( : (0, 1)), it is never profitable for

the miner to include the transaction in the solution. The redeem

action does not change user A's net worth, but reduces its balance of minted tokens, which will lose value its prices are reduced by

miner actions. Thus redeems do not contribute to the miner's gain

in the 1-txpool game solution.



17

